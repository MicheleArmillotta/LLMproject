[
  {
    "function_name": "trace_events_synth_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "2224-2244",
    "snippet": "static __init int trace_events_synth_init(void)\n{\n\tstruct dentry *entry = NULL;\n\tint err = 0;\n\terr = tracing_init_dentry();\n\tif (err)\n\t\tgoto err;\n\n\tentry = tracefs_create_file(\"synthetic_events\", TRACE_MODE_WRITE,\n\t\t\t\t    NULL, NULL, &synth_events_fops);\n\tif (!entry) {\n\t\terr = -ENODEV;\n\t\tgoto err;\n\t}\n\n\treturn err;\n err:\n\tpr_warn(\"Could not create tracefs 'synthetic_events' entry\\n\");\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations synth_events_fops = {\n\t.open           = synth_events_open,\n\t.write\t\t= synth_events_write,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'synthetic_events' entry\\n\""
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"synthetic_events\"",
            "TRACE_MODE_WRITE",
            "NULL",
            "NULL",
            "&synth_events_fops"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9527-9553",
          "snippet": "int tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nint tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const struct file_operations synth_events_fops = {\n\t.open           = synth_events_open,\n\t.write\t\t= synth_events_write,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n};\n\nstatic __init int trace_events_synth_init(void)\n{\n\tstruct dentry *entry = NULL;\n\tint err = 0;\n\terr = tracing_init_dentry();\n\tif (err)\n\t\tgoto err;\n\n\tentry = tracefs_create_file(\"synthetic_events\", TRACE_MODE_WRITE,\n\t\t\t\t    NULL, NULL, &synth_events_fops);\n\tif (!entry) {\n\t\terr = -ENODEV;\n\t\tgoto err;\n\t}\n\n\treturn err;\n err:\n\tpr_warn(\"Could not create tracefs 'synthetic_events' entry\\n\");\n\n\treturn err;\n}"
  },
  {
    "function_name": "trace_events_synth_init_early",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "2212-2221",
    "snippet": "static __init int trace_events_synth_init_early(void)\n{\n\tint err = 0;\n\n\terr = dyn_event_register(&synth_event_ops);\n\tif (err)\n\t\tpr_warn(\"Could not register synth_event_ops\\n\");\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dyn_event_operations synth_event_ops = {\n\t.create = create_synth_event,\n\t.show = synth_event_show,\n\t.is_busy = synth_event_is_busy,\n\t.free = synth_event_release,\n\t.match = synth_event_match,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not register synth_event_ops\\n\""
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dyn_event_register",
          "args": [
            "&synth_event_ops"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "59-70",
          "snippet": "int dyn_event_register(struct dyn_event_operations *ops)\n{\n\tif (!ops || !ops->create || !ops->show || !ops->is_busy ||\n\t    !ops->free || !ops->match)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ops->list);\n\tmutex_lock(&dyn_event_ops_mutex);\n\tlist_add_tail(&ops->list, &dyn_event_ops_list);\n\tmutex_unlock(&dyn_event_ops_mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(dyn_event_ops_mutex);",
            "static LIST_HEAD(dyn_event_ops_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nstatic DEFINE_MUTEX(dyn_event_ops_mutex);\nstatic LIST_HEAD(dyn_event_ops_list);\n\nint dyn_event_register(struct dyn_event_operations *ops)\n{\n\tif (!ops || !ops->create || !ops->show || !ops->is_busy ||\n\t    !ops->free || !ops->match)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ops->list);\n\tmutex_lock(&dyn_event_ops_mutex);\n\tlist_add_tail(&ops->list, &dyn_event_ops_list);\n\tmutex_unlock(&dyn_event_ops_mutex);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct dyn_event_operations synth_event_ops = {\n\t.create = create_synth_event,\n\t.show = synth_event_show,\n\t.is_busy = synth_event_is_busy,\n\t.free = synth_event_release,\n\t.match = synth_event_match,\n};\n\nstatic __init int trace_events_synth_init_early(void)\n{\n\tint err = 0;\n\n\terr = dyn_event_register(&synth_event_ops);\n\tif (err)\n\t\tpr_warn(\"Could not register synth_event_ops\\n\");\n\n\treturn err;\n}"
  },
  {
    "function_name": "synth_events_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "2192-2198",
    "snippet": "static ssize_t synth_events_write(struct file *file,\n\t\t\t\t  const char __user *buffer,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos,\n\t\t\t\t       create_or_delete_synth_event);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_parse_run_command",
          "args": [
            "file",
            "buffer",
            "count",
            "ppos",
            "create_or_delete_synth_event"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parse_run_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9922-9985",
          "snippet": "ssize_t trace_parse_run_command(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\tint (*createfn)(const char *))\n{\n\tchar *kbuf, *buf, *tmp;\n\tint ret = 0;\n\tsize_t done = 0;\n\tsize_t size;\n\n\tkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (done < count) {\n\t\tsize = count - done;\n\n\t\tif (size >= WRITE_BUFSIZE)\n\t\t\tsize = WRITE_BUFSIZE - 1;\n\n\t\tif (copy_from_user(kbuf, buffer + done, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkbuf[size] = '\\0';\n\t\tbuf = kbuf;\n\t\tdo {\n\t\t\ttmp = strchr(buf, '\\n');\n\t\t\tif (tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tsize = tmp - buf + 1;\n\t\t\t} else {\n\t\t\t\tsize = strlen(buf);\n\t\t\t\tif (done + size < count) {\n\t\t\t\t\tif (buf != kbuf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/* This can accept WRITE_BUFSIZE - 2 ('\\n' + '\\0') */\n\t\t\t\t\tpr_warn(\"Line length is too long: Should be less than %d\\n\",\n\t\t\t\t\t\tWRITE_BUFSIZE - 2);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone += size;\n\n\t\t\t/* Remove comments */\n\t\t\ttmp = strchr(buf, '#');\n\n\t\t\tif (tmp)\n\t\t\t\t*tmp = '\\0';\n\n\t\t\tret = createfn(buf);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbuf += size;\n\n\t\t} while (done < count);\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define WRITE_BUFSIZE  4096"
          ],
          "globals_used": [
            "int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define WRITE_BUFSIZE  4096\n\nint tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic __always_inline struct;\n\nssize_t trace_parse_run_command(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\tint (*createfn)(const char *))\n{\n\tchar *kbuf, *buf, *tmp;\n\tint ret = 0;\n\tsize_t done = 0;\n\tsize_t size;\n\n\tkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (done < count) {\n\t\tsize = count - done;\n\n\t\tif (size >= WRITE_BUFSIZE)\n\t\t\tsize = WRITE_BUFSIZE - 1;\n\n\t\tif (copy_from_user(kbuf, buffer + done, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkbuf[size] = '\\0';\n\t\tbuf = kbuf;\n\t\tdo {\n\t\t\ttmp = strchr(buf, '\\n');\n\t\t\tif (tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tsize = tmp - buf + 1;\n\t\t\t} else {\n\t\t\t\tsize = strlen(buf);\n\t\t\t\tif (done + size < count) {\n\t\t\t\t\tif (buf != kbuf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/* This can accept WRITE_BUFSIZE - 2 ('\\n' + '\\0') */\n\t\t\t\t\tpr_warn(\"Line length is too long: Should be less than %d\\n\",\n\t\t\t\t\t\tWRITE_BUFSIZE - 2);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone += size;\n\n\t\t\t/* Remove comments */\n\t\t\ttmp = strchr(buf, '#');\n\n\t\t\tif (tmp)\n\t\t\t\t*tmp = '\\0';\n\n\t\t\tret = createfn(buf);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbuf += size;\n\n\t\t} while (done < count);\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic ssize_t synth_events_write(struct file *file,\n\t\t\t\t  const char __user *buffer,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos,\n\t\t\t\t       create_or_delete_synth_event);\n}"
  },
  {
    "function_name": "synth_events_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "2175-2190",
    "snippet": "static int synth_events_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = dyn_events_release_all(&synth_event_ops);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &synth_events_seq_op);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dyn_event_operations synth_event_ops = {\n\t.create = create_synth_event,\n\t.show = synth_event_show,\n\t.is_busy = synth_event_is_busy,\n\t.free = synth_event_release,\n\t.match = synth_event_match,\n};",
      "static const struct seq_operations synth_events_seq_op = {\n\t.start\t= dyn_event_seq_start,\n\t.next\t= dyn_event_seq_next,\n\t.stop\t= dyn_event_seq_stop,\n\t.show\t= synth_events_seq_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&synth_events_seq_op"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_events_release_all",
          "args": [
            "&synth_event_ops"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_events_release_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "195-220",
          "snippet": "int dyn_events_release_all(struct dyn_event_operations *type)\n{\n\tstruct dyn_event *ev, *tmp;\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event(ev) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tif (ev->ops->is_busy(ev)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor_each_dyn_event_safe(ev, tmp) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tret = ev->ops->free(ev);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dyn_events_release_all(struct dyn_event_operations *type)\n{\n\tstruct dyn_event *ev, *tmp;\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event(ev) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tif (ev->ops->is_busy(ev)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor_each_dyn_event_safe(ev, tmp) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tret = ev->ops->free(ev);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_TRACEFS"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct dyn_event_operations synth_event_ops = {\n\t.create = create_synth_event,\n\t.show = synth_event_show,\n\t.is_busy = synth_event_is_busy,\n\t.free = synth_event_release,\n\t.match = synth_event_match,\n};\nstatic const struct seq_operations synth_events_seq_op = {\n\t.start\t= dyn_event_seq_start,\n\t.next\t= dyn_event_seq_next,\n\t.stop\t= dyn_event_seq_stop,\n\t.show\t= synth_events_seq_show,\n};\n\nstatic int synth_events_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = dyn_events_release_all(&synth_event_ops);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &synth_events_seq_op);\n}"
  },
  {
    "function_name": "synth_events_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "2158-2166",
    "snippet": "static int synth_events_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dyn_event *ev = v;\n\n\tif (!is_synth_event(ev))\n\t\treturn 0;\n\n\treturn __synth_event_show(m, to_synth_event(ev));\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int synth_event_show(struct seq_file *m, struct dyn_event *ev);",
      "static int synth_event_release(struct dyn_event *ev);",
      "static bool synth_event_is_busy(struct dyn_event *ev);",
      "static bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__synth_event_show",
          "args": [
            "m",
            "to_synth_event(ev)"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "__synth_event_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "2121-2147",
          "snippet": "static int __synth_event_show(struct seq_file *m, struct synth_event *event)\n{\n\tstruct synth_field *field;\n\tunsigned int i;\n\tchar *type, *t;\n\n\tseq_printf(m, \"%s\\t\", event->name);\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfield = event->fields[i];\n\n\t\ttype = field->type;\n\t\tt = strstr(type, \"__data_loc\");\n\t\tif (t) { /* __data_loc belongs in format but not event desc */\n\t\t\tt += sizeof(\"__data_loc\");\n\t\t\ttype = t;\n\t\t}\n\n\t\t/* parameter values */\n\t\tseq_printf(m, \"%s %s%s\", type, field->name,\n\t\t\t   i == event->n_fields - 1 ? \"\" : \"; \");\n\t}\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int __synth_event_show(struct seq_file *m, struct synth_event *event)\n{\n\tstruct synth_field *field;\n\tunsigned int i;\n\tchar *type, *t;\n\n\tseq_printf(m, \"%s\\t\", event->name);\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfield = event->fields[i];\n\n\t\ttype = field->type;\n\t\tt = strstr(type, \"__data_loc\");\n\t\tif (t) { /* __data_loc belongs in format but not event desc */\n\t\t\tt += sizeof(\"__data_loc\");\n\t\t\ttype = t;\n\t\t}\n\n\t\t/* parameter values */\n\t\tseq_printf(m, \"%s %s%s\", type, field->name,\n\t\t\t   i == event->n_fields - 1 ? \"\" : \"; \");\n\t}\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_synth_event",
          "args": [
            "ev"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "to_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "86-89",
          "snippet": "static struct synth_event *to_synth_event(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct synth_event, devent);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int synth_event_show(struct seq_file *m, struct dyn_event *ev);",
            "static int synth_event_release(struct dyn_event *ev);",
            "static bool synth_event_is_busy(struct dyn_event *ev);",
            "static bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev);\nstatic int synth_event_release(struct dyn_event *ev);\nstatic bool synth_event_is_busy(struct dyn_event *ev);\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\n\nstatic struct synth_event *to_synth_event(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct synth_event, devent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_synth_event",
          "args": [
            "ev"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "is_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "81-84",
          "snippet": "static bool is_synth_event(struct dyn_event *ev)\n{\n\treturn ev->ops == &synth_event_ops;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int synth_event_show(struct seq_file *m, struct dyn_event *ev);",
            "static int synth_event_release(struct dyn_event *ev);",
            "static bool synth_event_is_busy(struct dyn_event *ev);",
            "static bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static struct dyn_event_operations synth_event_ops = {\n\t.create = create_synth_event,\n\t.show = synth_event_show,\n\t.is_busy = synth_event_is_busy,\n\t.free = synth_event_release,\n\t.match = synth_event_match,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev);\nstatic int synth_event_release(struct dyn_event *ev);\nstatic bool synth_event_is_busy(struct dyn_event *ev);\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic struct dyn_event_operations synth_event_ops = {\n\t.create = create_synth_event,\n\t.show = synth_event_show,\n\t.is_busy = synth_event_is_busy,\n\t.free = synth_event_release,\n\t.match = synth_event_match,\n};\n\nstatic bool is_synth_event(struct dyn_event *ev)\n{\n\treturn ev->ops == &synth_event_ops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev);\nstatic int synth_event_release(struct dyn_event *ev);\nstatic bool synth_event_is_busy(struct dyn_event *ev);\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\n\nstatic int synth_events_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dyn_event *ev = v;\n\n\tif (!is_synth_event(ev))\n\t\treturn 0;\n\n\treturn __synth_event_show(m, to_synth_event(ev));\n}"
  },
  {
    "function_name": "synth_event_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "2149-2156",
    "snippet": "static int synth_event_show(struct seq_file *m, struct dyn_event *ev)\n{\n\tstruct synth_event *event = to_synth_event(ev);\n\n\tseq_printf(m, \"s:%s/\", event->class.system);\n\n\treturn __synth_event_show(m, event);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int synth_event_show(struct seq_file *m, struct dyn_event *ev);",
      "static int synth_event_release(struct dyn_event *ev);",
      "static bool synth_event_is_busy(struct dyn_event *ev);",
      "static bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__synth_event_show",
          "args": [
            "m",
            "event"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "__synth_event_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "2121-2147",
          "snippet": "static int __synth_event_show(struct seq_file *m, struct synth_event *event)\n{\n\tstruct synth_field *field;\n\tunsigned int i;\n\tchar *type, *t;\n\n\tseq_printf(m, \"%s\\t\", event->name);\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfield = event->fields[i];\n\n\t\ttype = field->type;\n\t\tt = strstr(type, \"__data_loc\");\n\t\tif (t) { /* __data_loc belongs in format but not event desc */\n\t\t\tt += sizeof(\"__data_loc\");\n\t\t\ttype = t;\n\t\t}\n\n\t\t/* parameter values */\n\t\tseq_printf(m, \"%s %s%s\", type, field->name,\n\t\t\t   i == event->n_fields - 1 ? \"\" : \"; \");\n\t}\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int __synth_event_show(struct seq_file *m, struct synth_event *event)\n{\n\tstruct synth_field *field;\n\tunsigned int i;\n\tchar *type, *t;\n\n\tseq_printf(m, \"%s\\t\", event->name);\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfield = event->fields[i];\n\n\t\ttype = field->type;\n\t\tt = strstr(type, \"__data_loc\");\n\t\tif (t) { /* __data_loc belongs in format but not event desc */\n\t\t\tt += sizeof(\"__data_loc\");\n\t\t\ttype = t;\n\t\t}\n\n\t\t/* parameter values */\n\t\tseq_printf(m, \"%s %s%s\", type, field->name,\n\t\t\t   i == event->n_fields - 1 ? \"\" : \"; \");\n\t}\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"s:%s/\"",
            "event->class.system"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_synth_event",
          "args": [
            "ev"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "to_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "86-89",
          "snippet": "static struct synth_event *to_synth_event(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct synth_event, devent);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int synth_event_show(struct seq_file *m, struct dyn_event *ev);",
            "static int synth_event_release(struct dyn_event *ev);",
            "static bool synth_event_is_busy(struct dyn_event *ev);",
            "static bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev);\nstatic int synth_event_release(struct dyn_event *ev);\nstatic bool synth_event_is_busy(struct dyn_event *ev);\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\n\nstatic struct synth_event *to_synth_event(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct synth_event, devent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev);\nstatic int synth_event_release(struct dyn_event *ev);\nstatic bool synth_event_is_busy(struct dyn_event *ev);\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev)\n{\n\tstruct synth_event *event = to_synth_event(ev);\n\n\tseq_printf(m, \"s:%s/\", event->class.system);\n\n\treturn __synth_event_show(m, event);\n}"
  },
  {
    "function_name": "__synth_event_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "2121-2147",
    "snippet": "static int __synth_event_show(struct seq_file *m, struct synth_event *event)\n{\n\tstruct synth_field *field;\n\tunsigned int i;\n\tchar *type, *t;\n\n\tseq_printf(m, \"%s\\t\", event->name);\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfield = event->fields[i];\n\n\t\ttype = field->type;\n\t\tt = strstr(type, \"__data_loc\");\n\t\tif (t) { /* __data_loc belongs in format but not event desc */\n\t\t\tt += sizeof(\"__data_loc\");\n\t\t\ttype = t;\n\t\t}\n\n\t\t/* parameter values */\n\t\tseq_printf(m, \"%s %s%s\", type, field->name,\n\t\t\t   i == event->n_fields - 1 ? \"\" : \"; \");\n\t}\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s %s%s\"",
            "type",
            "field->name",
            "i == event->n_fields - 1 ? \"\" : \"; \""
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "type",
            "\"__data_loc\""
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int __synth_event_show(struct seq_file *m, struct synth_event *event)\n{\n\tstruct synth_field *field;\n\tunsigned int i;\n\tchar *type, *t;\n\n\tseq_printf(m, \"%s\\t\", event->name);\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfield = event->fields[i];\n\n\t\ttype = field->type;\n\t\tt = strstr(type, \"__data_loc\");\n\t\tif (t) { /* __data_loc belongs in format but not event desc */\n\t\t\tt += sizeof(\"__data_loc\");\n\t\t\ttype = t;\n\t\t}\n\n\t\t/* parameter values */\n\t\tseq_printf(m, \"%s %s%s\", type, field->name,\n\t\t\t   i == event->n_fields - 1 ? \"\" : \"; \");\n\t}\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "synth_event_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "2101-2119",
    "snippet": "static int synth_event_release(struct dyn_event *ev)\n{\n\tstruct synth_event *event = to_synth_event(ev);\n\tint ret;\n\n\tif (event->ref)\n\t\treturn -EBUSY;\n\n\tif (trace_event_dyn_busy(&event->call))\n\t\treturn -EBUSY;\n\n\tret = unregister_synth_event(event);\n\tif (ret)\n\t\treturn ret;\n\n\tdyn_event_remove(ev);\n\tfree_synth_event(event);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int synth_event_show(struct seq_file *m, struct dyn_event *ev);",
      "static int synth_event_release(struct dyn_event *ev);",
      "static bool synth_event_is_busy(struct dyn_event *ev);",
      "static bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_synth_event",
          "args": [
            "event"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "833-850",
          "snippet": "static void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->dynamic_fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->dynamic_fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_remove",
          "args": [
            "ev"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.h",
          "lines": "92-96",
          "snippet": "static inline void dyn_event_remove(struct dyn_event *ev)\n{\n\tlockdep_assert_held(&event_mutex);\n\tlist_del_init(&ev->list);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n\nstatic inline void dyn_event_remove(struct dyn_event *ev)\n{\n\tlockdep_assert_held(&event_mutex);\n\tlist_del_init(&ev->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_synth_event",
          "args": [
            "event"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "823-831",
          "snippet": "static int unregister_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret;\n\n\tret = trace_remove_event_call(call);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int unregister_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret;\n\n\tret = trace_remove_event_call(call);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_dyn_busy",
          "args": [
            "&event->call"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_dyn_busy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "54-57",
          "snippet": "bool trace_event_dyn_busy(struct trace_event_call *call)\n{\n\treturn atomic_read(&call->refcnt) != 0;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nbool trace_event_dyn_busy(struct trace_event_call *call)\n{\n\treturn atomic_read(&call->refcnt) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_synth_event",
          "args": [
            "ev"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "to_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "86-89",
          "snippet": "static struct synth_event *to_synth_event(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct synth_event, devent);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int synth_event_show(struct seq_file *m, struct dyn_event *ev);",
            "static int synth_event_release(struct dyn_event *ev);",
            "static bool synth_event_is_busy(struct dyn_event *ev);",
            "static bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev);\nstatic int synth_event_release(struct dyn_event *ev);\nstatic bool synth_event_is_busy(struct dyn_event *ev);\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\n\nstatic struct synth_event *to_synth_event(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct synth_event, devent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev);\nstatic int synth_event_release(struct dyn_event *ev);\nstatic bool synth_event_is_busy(struct dyn_event *ev);\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\n\nstatic int synth_event_release(struct dyn_event *ev)\n{\n\tstruct synth_event *event = to_synth_event(ev);\n\tint ret;\n\n\tif (event->ref)\n\t\treturn -EBUSY;\n\n\tif (trace_event_dyn_busy(&event->call))\n\t\treturn -EBUSY;\n\n\tret = unregister_synth_event(event);\n\tif (ret)\n\t\treturn ret;\n\n\tdyn_event_remove(ev);\n\tfree_synth_event(event);\n\treturn 0;\n}"
  },
  {
    "function_name": "create_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "2045-2099",
    "snippet": "static int create_synth_event(const char *raw_command)\n{\n\tchar *fields, *p;\n\tconst char *name;\n\tint len, ret = 0;\n\n\traw_command = skip_spaces(raw_command);\n\tif (raw_command[0] == '\\0')\n\t\treturn ret;\n\n\tlast_cmd_set(raw_command);\n\n\tname = raw_command;\n\n\t/* Don't try to process if not our system */\n\tif (name[0] != 's' || name[1] != ':')\n\t\treturn -ECANCELED;\n\tname += 2;\n\n\tp = strpbrk(raw_command, \" \\t\");\n\tif (!p) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn -EINVAL;\n\t}\n\n\tfields = skip_spaces(p);\n\n\t/* This interface accepts group name prefix */\n\tif (strchr(name, '/')) {\n\t\tlen = str_has_prefix(name, SYNTH_SYSTEM \"/\");\n\t\tif (len == 0) {\n\t\t\tsynth_err(SYNTH_ERR_INVALID_DYN_CMD, 0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tname += len;\n\t}\n\n\tlen = name - raw_command;\n\n\tret = check_command(raw_command + len);\n\tif (ret) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn ret;\n\t}\n\n\tname = kmemdup_nul(raw_command + len, p - raw_command - len, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = __create_synth_event(name, fields);\n\n\tkfree(name);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int create_synth_event(const char *raw_command);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__create_synth_event",
          "args": [
            "name",
            "fields"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "__create_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1179-1316",
          "snippet": "static int __create_synth_event(const char *name, const char *raw_fields)\n{\n\tchar **argv, *field_str, *tmp_fields, *saved_fields = NULL;\n\tstruct synth_field *field, *fields[SYNTH_FIELDS_MAX];\n\tint consumed, cmd_version = 1, n_fields_this_loop;\n\tint i, argc, n_fields = 0, ret = 0;\n\tstruct synth_event *event = NULL;\n\n\t/*\n\t * Argument syntax:\n\t *  - Add synthetic event: <event_name> field[;field] ...\n\t *  - Remove synthetic event: !<event_name> field[;field] ...\n\t *      where 'field' = type field_name\n\t */\n\n\tif (name[0] == '\\0') {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_good_name(name)) {\n\t\tsynth_err(SYNTH_ERR_BAD_NAME, errpos(name));\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tevent = find_synth_event(name);\n\tif (event) {\n\t\tsynth_err(SYNTH_ERR_EVENT_EXISTS, errpos(name));\n\t\tret = -EEXIST;\n\t\tgoto err;\n\t}\n\n\ttmp_fields = saved_fields = kstrdup(raw_fields, GFP_KERNEL);\n\tif (!tmp_fields) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\twhile ((field_str = strsep(&tmp_fields, \";\")) != NULL) {\n\t\targv = argv_split(GFP_KERNEL, field_str, &argc);\n\t\tif (!argv) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!argc) {\n\t\t\targv_free(argv);\n\t\t\tcontinue;\n\t\t}\n\n\t\tn_fields_this_loop = 0;\n\t\tconsumed = 0;\n\t\twhile (argc > consumed) {\n\t\t\tint field_version;\n\n\t\t\tfield = parse_synth_field(argc - consumed,\n\t\t\t\t\t\t  argv + consumed, &consumed,\n\t\t\t\t\t\t  &field_version);\n\t\t\tif (IS_ERR(field)) {\n\t\t\t\tret = PTR_ERR(field);\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Track the highest version of any field we\n\t\t\t * found in the command.\n\t\t\t */\n\t\t\tif (field_version > cmd_version)\n\t\t\t\tcmd_version = field_version;\n\n\t\t\t/*\n\t\t\t * Now sort out what is and isn't valid for\n\t\t\t * each supported version.\n\t\t\t *\n\t\t\t * If we see more than 1 field per loop, it\n\t\t\t * means we have multiple fields between\n\t\t\t * semicolons, and that's something we no\n\t\t\t * longer support in a version 2 or greater\n\t\t\t * command.\n\t\t\t */\n\t\t\tif (cmd_version > 1 && n_fields_this_loop >= 1) {\n\t\t\t\tsynth_err(SYNTH_ERR_INVALID_CMD, errpos(field_str));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\tfields[n_fields++] = field;\n\t\t\tif (n_fields == SYNTH_FIELDS_MAX) {\n\t\t\t\tsynth_err(SYNTH_ERR_TOO_MANY_FIELDS, 0);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\tn_fields_this_loop++;\n\t\t}\n\t\targv_free(argv);\n\n\t\tif (consumed < argc) {\n\t\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t}\n\n\tif (n_fields == 0) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tevent = alloc_synth_event(name, n_fields, fields);\n\tif (IS_ERR(event)) {\n\t\tret = PTR_ERR(event);\n\t\tevent = NULL;\n\t\tgoto err;\n\t}\n\tret = register_synth_event(event);\n\tif (!ret)\n\t\tdyn_event_add(&event->devent, &event->call);\n\telse\n\t\tfree_synth_event(event);\n out:\n\tmutex_unlock(&event_mutex);\n\n\tkfree(saved_fields);\n\n\treturn ret;\n err_free_arg:\n\targv_free(argv);\n err:\n\tfor (i = 0; i < n_fields; i++)\n\t\tfree_synth_field(fields[i]);\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int __create_synth_event(const char *name, const char *raw_fields)\n{\n\tchar **argv, *field_str, *tmp_fields, *saved_fields = NULL;\n\tstruct synth_field *field, *fields[SYNTH_FIELDS_MAX];\n\tint consumed, cmd_version = 1, n_fields_this_loop;\n\tint i, argc, n_fields = 0, ret = 0;\n\tstruct synth_event *event = NULL;\n\n\t/*\n\t * Argument syntax:\n\t *  - Add synthetic event: <event_name> field[;field] ...\n\t *  - Remove synthetic event: !<event_name> field[;field] ...\n\t *      where 'field' = type field_name\n\t */\n\n\tif (name[0] == '\\0') {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_good_name(name)) {\n\t\tsynth_err(SYNTH_ERR_BAD_NAME, errpos(name));\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tevent = find_synth_event(name);\n\tif (event) {\n\t\tsynth_err(SYNTH_ERR_EVENT_EXISTS, errpos(name));\n\t\tret = -EEXIST;\n\t\tgoto err;\n\t}\n\n\ttmp_fields = saved_fields = kstrdup(raw_fields, GFP_KERNEL);\n\tif (!tmp_fields) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\twhile ((field_str = strsep(&tmp_fields, \";\")) != NULL) {\n\t\targv = argv_split(GFP_KERNEL, field_str, &argc);\n\t\tif (!argv) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!argc) {\n\t\t\targv_free(argv);\n\t\t\tcontinue;\n\t\t}\n\n\t\tn_fields_this_loop = 0;\n\t\tconsumed = 0;\n\t\twhile (argc > consumed) {\n\t\t\tint field_version;\n\n\t\t\tfield = parse_synth_field(argc - consumed,\n\t\t\t\t\t\t  argv + consumed, &consumed,\n\t\t\t\t\t\t  &field_version);\n\t\t\tif (IS_ERR(field)) {\n\t\t\t\tret = PTR_ERR(field);\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Track the highest version of any field we\n\t\t\t * found in the command.\n\t\t\t */\n\t\t\tif (field_version > cmd_version)\n\t\t\t\tcmd_version = field_version;\n\n\t\t\t/*\n\t\t\t * Now sort out what is and isn't valid for\n\t\t\t * each supported version.\n\t\t\t *\n\t\t\t * If we see more than 1 field per loop, it\n\t\t\t * means we have multiple fields between\n\t\t\t * semicolons, and that's something we no\n\t\t\t * longer support in a version 2 or greater\n\t\t\t * command.\n\t\t\t */\n\t\t\tif (cmd_version > 1 && n_fields_this_loop >= 1) {\n\t\t\t\tsynth_err(SYNTH_ERR_INVALID_CMD, errpos(field_str));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\tfields[n_fields++] = field;\n\t\t\tif (n_fields == SYNTH_FIELDS_MAX) {\n\t\t\t\tsynth_err(SYNTH_ERR_TOO_MANY_FIELDS, 0);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\tn_fields_this_loop++;\n\t\t}\n\t\targv_free(argv);\n\n\t\tif (consumed < argc) {\n\t\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t}\n\n\tif (n_fields == 0) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tevent = alloc_synth_event(name, n_fields, fields);\n\tif (IS_ERR(event)) {\n\t\tret = PTR_ERR(event);\n\t\tevent = NULL;\n\t\tgoto err;\n\t}\n\tret = register_synth_event(event);\n\tif (!ret)\n\t\tdyn_event_add(&event->devent, &event->call);\n\telse\n\t\tfree_synth_event(event);\n out:\n\tmutex_unlock(&event_mutex);\n\n\tkfree(saved_fields);\n\n\treturn ret;\n err_free_arg:\n\targv_free(argv);\n err:\n\tfor (i = 0; i < n_fields; i++)\n\t\tfree_synth_field(fields[i]);\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup_nul",
          "args": [
            "raw_command + len",
            "p - raw_command - len",
            "GFP_KERNEL"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_err",
          "args": [
            "SYNTH_ERR_INVALID_CMD",
            "0"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "synth_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "60-64",
          "snippet": "static void synth_err(u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(NULL, \"synthetic_events\", last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic void synth_err(u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(NULL, \"synthetic_events\", last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_command",
          "args": [
            "raw_command + len"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "check_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1429-1460",
          "snippet": "static int check_command(const char *raw_command)\n{\n\tchar **argv = NULL, *cmd, *saved_cmd, *name_and_field;\n\tint argc, ret = 0;\n\n\tcmd = saved_cmd = kstrdup(raw_command, GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tname_and_field = strsep(&cmd, \";\");\n\tif (!name_and_field) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (name_and_field[0] == '!')\n\t\tgoto free;\n\n\targv = argv_split(GFP_KERNEL, name_and_field, &argc);\n\tif (!argv) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\targv_free(argv);\n\n\tif (argc < 3)\n\t\tret = -EINVAL;\nfree:\n\tkfree(saved_cmd);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int create_synth_event(const char *raw_command);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_synth_event(const char *raw_command);\n\nstatic int check_command(const char *raw_command)\n{\n\tchar **argv = NULL, *cmd, *saved_cmd, *name_and_field;\n\tint argc, ret = 0;\n\n\tcmd = saved_cmd = kstrdup(raw_command, GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tname_and_field = strsep(&cmd, \";\");\n\tif (!name_and_field) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (name_and_field[0] == '!')\n\t\tgoto free;\n\n\targv = argv_split(GFP_KERNEL, name_and_field, &argc);\n\tif (!argv) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\targv_free(argv);\n\n\tif (argc < 3)\n\t\tret = -EINVAL;\nfree:\n\tkfree(saved_cmd);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "name",
            "SYNTH_SYSTEM \"/\""
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "'/'"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "p"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "proc_skip_spaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "333-340",
          "snippet": "static size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "raw_command",
            "\" \\t\""
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "last_cmd_set",
          "args": [
            "raw_command"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "last_cmd_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "52-58",
          "snippet": "static void last_cmd_set(const char *str)\n{\n\tif (!str)\n\t\treturn;\n\n\tstrncpy(last_cmd, str, MAX_FILTER_STR_VAL - 1);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic void last_cmd_set(const char *str)\n{\n\tif (!str)\n\t\treturn;\n\n\tstrncpy(last_cmd, str, MAX_FILTER_STR_VAL - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_synth_event(const char *raw_command);\n\nstatic int create_synth_event(const char *raw_command)\n{\n\tchar *fields, *p;\n\tconst char *name;\n\tint len, ret = 0;\n\n\traw_command = skip_spaces(raw_command);\n\tif (raw_command[0] == '\\0')\n\t\treturn ret;\n\n\tlast_cmd_set(raw_command);\n\n\tname = raw_command;\n\n\t/* Don't try to process if not our system */\n\tif (name[0] != 's' || name[1] != ':')\n\t\treturn -ECANCELED;\n\tname += 2;\n\n\tp = strpbrk(raw_command, \" \\t\");\n\tif (!p) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn -EINVAL;\n\t}\n\n\tfields = skip_spaces(p);\n\n\t/* This interface accepts group name prefix */\n\tif (strchr(name, '/')) {\n\t\tlen = str_has_prefix(name, SYNTH_SYSTEM \"/\");\n\t\tif (len == 0) {\n\t\t\tsynth_err(SYNTH_ERR_INVALID_DYN_CMD, 0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tname += len;\n\t}\n\n\tlen = name - raw_command;\n\n\tret = check_command(raw_command + len);\n\tif (ret) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn ret;\n\t}\n\n\tname = kmemdup_nul(raw_command + len, p - raw_command - len, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = __create_synth_event(name, fields);\n\n\tkfree(name);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "synth_event_trace_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "2034-2042",
    "snippet": "int synth_event_trace_end(struct synth_event_trace_state *trace_state)\n{\n\tif (!trace_state)\n\t\treturn -EINVAL;\n\n\t__synth_event_trace_end(trace_state);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__synth_event_trace_end",
          "args": [
            "trace_state"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "__synth_event_trace_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1597-1603",
          "snippet": "static inline void\n__synth_event_trace_end(struct synth_event_trace_state *trace_state)\n{\n\ttrace_event_buffer_commit(&trace_state->fbuffer);\n\n\tring_buffer_nest_end(trace_state->buffer);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void\n__synth_event_trace_end(struct synth_event_trace_state *trace_state)\n{\n\ttrace_event_buffer_commit(&trace_state->fbuffer);\n\n\tring_buffer_nest_end(trace_state->buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_trace_end(struct synth_event_trace_state *trace_state)\n{\n\tif (!trace_state)\n\t\treturn -EINVAL;\n\n\t__synth_event_trace_end(trace_state);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "synth_event_add_val",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "2007-2011",
    "snippet": "int synth_event_add_val(const char *field_name, u64 val,\n\t\t\tstruct synth_event_trace_state *trace_state)\n{\n\treturn __synth_event_add_val(field_name, val, trace_state);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__synth_event_add_val",
          "args": [
            "field_name",
            "val",
            "trace_state"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "__synth_event_add_val",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1854-1942",
          "snippet": "static int __synth_event_add_val(const char *field_name, u64 val,\n\t\t\t\t struct synth_event_trace_state *trace_state)\n{\n\tstruct synth_field *field = NULL;\n\tstruct synth_trace_event *entry;\n\tstruct synth_event *event;\n\tint i, ret = 0;\n\n\tif (!trace_state) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* can't mix add_next_synth_val() with add_synth_val() */\n\tif (field_name) {\n\t\tif (trace_state->add_next) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrace_state->add_name = true;\n\t} else {\n\t\tif (trace_state->add_name) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrace_state->add_next = true;\n\t}\n\n\tif (trace_state->disabled)\n\t\tgoto out;\n\n\tevent = trace_state->event;\n\tif (trace_state->add_name) {\n\t\tfor (i = 0; i < event->n_fields; i++) {\n\t\t\tfield = event->fields[i];\n\t\t\tif (strcmp(field->name, field_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!field) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (trace_state->cur_field >= event->n_fields) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tfield = event->fields[trace_state->cur_field++];\n\t}\n\n\tentry = trace_state->entry;\n\tif (field->is_string) {\n\t\tchar *str_val = (char *)(long)val;\n\t\tchar *str_field;\n\n\t\tif (field->is_dynamic) { /* add_val can't do dynamic strings */\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!str_val) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tstr_field = (char *)&entry->fields[field->offset];\n\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t} else {\n\t\tswitch (field->size) {\n\t\tcase 1:\n\t\t\t*(u8 *)&trace_state->entry->fields[field->offset] = (u8)val;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t*(u16 *)&trace_state->entry->fields[field->offset] = (u16)val;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\t*(u32 *)&trace_state->entry->fields[field->offset] = (u32)val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ttrace_state->entry->fields[field->offset] = val;\n\t\t\tbreak;\n\t\t}\n\t}\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int __synth_event_add_val(const char *field_name, u64 val,\n\t\t\t\t struct synth_event_trace_state *trace_state)\n{\n\tstruct synth_field *field = NULL;\n\tstruct synth_trace_event *entry;\n\tstruct synth_event *event;\n\tint i, ret = 0;\n\n\tif (!trace_state) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* can't mix add_next_synth_val() with add_synth_val() */\n\tif (field_name) {\n\t\tif (trace_state->add_next) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrace_state->add_name = true;\n\t} else {\n\t\tif (trace_state->add_name) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrace_state->add_next = true;\n\t}\n\n\tif (trace_state->disabled)\n\t\tgoto out;\n\n\tevent = trace_state->event;\n\tif (trace_state->add_name) {\n\t\tfor (i = 0; i < event->n_fields; i++) {\n\t\t\tfield = event->fields[i];\n\t\t\tif (strcmp(field->name, field_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!field) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (trace_state->cur_field >= event->n_fields) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tfield = event->fields[trace_state->cur_field++];\n\t}\n\n\tentry = trace_state->entry;\n\tif (field->is_string) {\n\t\tchar *str_val = (char *)(long)val;\n\t\tchar *str_field;\n\n\t\tif (field->is_dynamic) { /* add_val can't do dynamic strings */\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!str_val) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tstr_field = (char *)&entry->fields[field->offset];\n\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t} else {\n\t\tswitch (field->size) {\n\t\tcase 1:\n\t\t\t*(u8 *)&trace_state->entry->fields[field->offset] = (u8)val;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t*(u16 *)&trace_state->entry->fields[field->offset] = (u16)val;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\t*(u32 *)&trace_state->entry->fields[field->offset] = (u32)val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ttrace_state->entry->fields[field->offset] = val;\n\t\t\tbreak;\n\t\t}\n\t}\n out:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_add_val(const char *field_name, u64 val,\n\t\t\tstruct synth_event_trace_state *trace_state)\n{\n\treturn __synth_event_add_val(field_name, val, trace_state);\n}"
  },
  {
    "function_name": "synth_event_add_next_val",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1972-1976",
    "snippet": "int synth_event_add_next_val(u64 val,\n\t\t\t     struct synth_event_trace_state *trace_state)\n{\n\treturn __synth_event_add_val(NULL, val, trace_state);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__synth_event_add_val",
          "args": [
            "NULL",
            "val",
            "trace_state"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "__synth_event_add_val",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1854-1942",
          "snippet": "static int __synth_event_add_val(const char *field_name, u64 val,\n\t\t\t\t struct synth_event_trace_state *trace_state)\n{\n\tstruct synth_field *field = NULL;\n\tstruct synth_trace_event *entry;\n\tstruct synth_event *event;\n\tint i, ret = 0;\n\n\tif (!trace_state) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* can't mix add_next_synth_val() with add_synth_val() */\n\tif (field_name) {\n\t\tif (trace_state->add_next) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrace_state->add_name = true;\n\t} else {\n\t\tif (trace_state->add_name) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrace_state->add_next = true;\n\t}\n\n\tif (trace_state->disabled)\n\t\tgoto out;\n\n\tevent = trace_state->event;\n\tif (trace_state->add_name) {\n\t\tfor (i = 0; i < event->n_fields; i++) {\n\t\t\tfield = event->fields[i];\n\t\t\tif (strcmp(field->name, field_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!field) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (trace_state->cur_field >= event->n_fields) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tfield = event->fields[trace_state->cur_field++];\n\t}\n\n\tentry = trace_state->entry;\n\tif (field->is_string) {\n\t\tchar *str_val = (char *)(long)val;\n\t\tchar *str_field;\n\n\t\tif (field->is_dynamic) { /* add_val can't do dynamic strings */\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!str_val) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tstr_field = (char *)&entry->fields[field->offset];\n\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t} else {\n\t\tswitch (field->size) {\n\t\tcase 1:\n\t\t\t*(u8 *)&trace_state->entry->fields[field->offset] = (u8)val;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t*(u16 *)&trace_state->entry->fields[field->offset] = (u16)val;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\t*(u32 *)&trace_state->entry->fields[field->offset] = (u32)val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ttrace_state->entry->fields[field->offset] = val;\n\t\t\tbreak;\n\t\t}\n\t}\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int __synth_event_add_val(const char *field_name, u64 val,\n\t\t\t\t struct synth_event_trace_state *trace_state)\n{\n\tstruct synth_field *field = NULL;\n\tstruct synth_trace_event *entry;\n\tstruct synth_event *event;\n\tint i, ret = 0;\n\n\tif (!trace_state) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* can't mix add_next_synth_val() with add_synth_val() */\n\tif (field_name) {\n\t\tif (trace_state->add_next) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrace_state->add_name = true;\n\t} else {\n\t\tif (trace_state->add_name) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrace_state->add_next = true;\n\t}\n\n\tif (trace_state->disabled)\n\t\tgoto out;\n\n\tevent = trace_state->event;\n\tif (trace_state->add_name) {\n\t\tfor (i = 0; i < event->n_fields; i++) {\n\t\t\tfield = event->fields[i];\n\t\t\tif (strcmp(field->name, field_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!field) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (trace_state->cur_field >= event->n_fields) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tfield = event->fields[trace_state->cur_field++];\n\t}\n\n\tentry = trace_state->entry;\n\tif (field->is_string) {\n\t\tchar *str_val = (char *)(long)val;\n\t\tchar *str_field;\n\n\t\tif (field->is_dynamic) { /* add_val can't do dynamic strings */\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!str_val) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tstr_field = (char *)&entry->fields[field->offset];\n\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t} else {\n\t\tswitch (field->size) {\n\t\tcase 1:\n\t\t\t*(u8 *)&trace_state->entry->fields[field->offset] = (u8)val;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t*(u16 *)&trace_state->entry->fields[field->offset] = (u16)val;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\t*(u32 *)&trace_state->entry->fields[field->offset] = (u32)val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ttrace_state->entry->fields[field->offset] = val;\n\t\t\tbreak;\n\t\t}\n\t}\n out:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_add_next_val(u64 val,\n\t\t\t     struct synth_event_trace_state *trace_state)\n{\n\treturn __synth_event_add_val(NULL, val, trace_state);\n}"
  },
  {
    "function_name": "__synth_event_add_val",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1854-1942",
    "snippet": "static int __synth_event_add_val(const char *field_name, u64 val,\n\t\t\t\t struct synth_event_trace_state *trace_state)\n{\n\tstruct synth_field *field = NULL;\n\tstruct synth_trace_event *entry;\n\tstruct synth_event *event;\n\tint i, ret = 0;\n\n\tif (!trace_state) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* can't mix add_next_synth_val() with add_synth_val() */\n\tif (field_name) {\n\t\tif (trace_state->add_next) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrace_state->add_name = true;\n\t} else {\n\t\tif (trace_state->add_name) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrace_state->add_next = true;\n\t}\n\n\tif (trace_state->disabled)\n\t\tgoto out;\n\n\tevent = trace_state->event;\n\tif (trace_state->add_name) {\n\t\tfor (i = 0; i < event->n_fields; i++) {\n\t\t\tfield = event->fields[i];\n\t\t\tif (strcmp(field->name, field_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!field) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (trace_state->cur_field >= event->n_fields) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tfield = event->fields[trace_state->cur_field++];\n\t}\n\n\tentry = trace_state->entry;\n\tif (field->is_string) {\n\t\tchar *str_val = (char *)(long)val;\n\t\tchar *str_field;\n\n\t\tif (field->is_dynamic) { /* add_val can't do dynamic strings */\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!str_val) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tstr_field = (char *)&entry->fields[field->offset];\n\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t} else {\n\t\tswitch (field->size) {\n\t\tcase 1:\n\t\t\t*(u8 *)&trace_state->entry->fields[field->offset] = (u8)val;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t*(u16 *)&trace_state->entry->fields[field->offset] = (u16)val;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\t*(u32 *)&trace_state->entry->fields[field->offset] = (u32)val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ttrace_state->entry->fields[field->offset] = val;\n\t\t\tbreak;\n\t\t}\n\t}\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "str_field",
            "str_val",
            "STR_VAR_LEN_MAX"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field->name",
            "field_name"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int __synth_event_add_val(const char *field_name, u64 val,\n\t\t\t\t struct synth_event_trace_state *trace_state)\n{\n\tstruct synth_field *field = NULL;\n\tstruct synth_trace_event *entry;\n\tstruct synth_event *event;\n\tint i, ret = 0;\n\n\tif (!trace_state) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* can't mix add_next_synth_val() with add_synth_val() */\n\tif (field_name) {\n\t\tif (trace_state->add_next) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrace_state->add_name = true;\n\t} else {\n\t\tif (trace_state->add_name) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrace_state->add_next = true;\n\t}\n\n\tif (trace_state->disabled)\n\t\tgoto out;\n\n\tevent = trace_state->event;\n\tif (trace_state->add_name) {\n\t\tfor (i = 0; i < event->n_fields; i++) {\n\t\t\tfield = event->fields[i];\n\t\t\tif (strcmp(field->name, field_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!field) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (trace_state->cur_field >= event->n_fields) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tfield = event->fields[trace_state->cur_field++];\n\t}\n\n\tentry = trace_state->entry;\n\tif (field->is_string) {\n\t\tchar *str_val = (char *)(long)val;\n\t\tchar *str_field;\n\n\t\tif (field->is_dynamic) { /* add_val can't do dynamic strings */\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!str_val) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tstr_field = (char *)&entry->fields[field->offset];\n\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t} else {\n\t\tswitch (field->size) {\n\t\tcase 1:\n\t\t\t*(u8 *)&trace_state->entry->fields[field->offset] = (u8)val;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t*(u16 *)&trace_state->entry->fields[field->offset] = (u16)val;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\t*(u32 *)&trace_state->entry->fields[field->offset] = (u32)val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ttrace_state->entry->fields[field->offset] = val;\n\t\t\tbreak;\n\t\t}\n\t}\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "synth_event_trace_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1830-1851",
    "snippet": "int synth_event_trace_start(struct trace_event_file *file,\n\t\t\t    struct synth_event_trace_state *trace_state)\n{\n\tint ret;\n\n\tif (!trace_state)\n\t\treturn -EINVAL;\n\n\tret = __synth_event_trace_init(file, trace_state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (trace_state->event->n_dynamic_fields)\n\t\treturn -ENOTSUPP;\n\n\tret = __synth_event_trace_start(file, trace_state, 0);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__synth_event_trace_start",
          "args": [
            "file",
            "trace_state",
            "0"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "__synth_event_trace_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1567-1595",
          "snippet": "static inline int\n__synth_event_trace_start(struct trace_event_file *file,\n\t\t\t  struct synth_event_trace_state *trace_state,\n\t\t\t  int dynamic_fields_size)\n{\n\tint entry_size, fields_size = 0;\n\tint ret = 0;\n\n\tfields_size = trace_state->event->n_u64 * sizeof(u64);\n\tfields_size += dynamic_fields_size;\n\n\t/*\n\t * Avoid ring buffer recursion detection, as this event\n\t * is being performed within another event.\n\t */\n\ttrace_state->buffer = file->tr->array_buffer.buffer;\n\tring_buffer_nest_start(trace_state->buffer);\n\n\tentry_size = sizeof(*trace_state->entry) + fields_size;\n\ttrace_state->entry = trace_event_buffer_reserve(&trace_state->fbuffer,\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tentry_size);\n\tif (!trace_state->entry) {\n\t\tring_buffer_nest_end(trace_state->buffer);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline int\n__synth_event_trace_start(struct trace_event_file *file,\n\t\t\t  struct synth_event_trace_state *trace_state,\n\t\t\t  int dynamic_fields_size)\n{\n\tint entry_size, fields_size = 0;\n\tint ret = 0;\n\n\tfields_size = trace_state->event->n_u64 * sizeof(u64);\n\tfields_size += dynamic_fields_size;\n\n\t/*\n\t * Avoid ring buffer recursion detection, as this event\n\t * is being performed within another event.\n\t */\n\ttrace_state->buffer = file->tr->array_buffer.buffer;\n\tring_buffer_nest_start(trace_state->buffer);\n\n\tentry_size = sizeof(*trace_state->entry) + fields_size;\n\ttrace_state->entry = trace_event_buffer_reserve(&trace_state->fbuffer,\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tentry_size);\n\tif (!trace_state->entry) {\n\t\tring_buffer_nest_end(trace_state->buffer);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__synth_event_trace_init",
          "args": [
            "file",
            "trace_state"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "__synth_event_trace_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1538-1565",
          "snippet": "static inline int\n__synth_event_trace_init(struct trace_event_file *file,\n\t\t\t struct synth_event_trace_state *trace_state)\n{\n\tint ret = 0;\n\n\tmemset(trace_state, '\\0', sizeof(*trace_state));\n\n\t/*\n\t * Normal event tracing doesn't get called at all unless the\n\t * ENABLED bit is set (which attaches the probe thus allowing\n\t * this code to be called, etc).  Because this is called\n\t * directly by the user, we don't have that but we still need\n\t * to honor not logging when disabled.  For the iterated\n\t * trace case, we save the enabled state upon start and just\n\t * ignore the following data calls.\n\t */\n\tif (!(file->flags & EVENT_FILE_FL_ENABLED) ||\n\t    trace_trigger_soft_disabled(file)) {\n\t\ttrace_state->disabled = true;\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttrace_state->event = file->event_call->data;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline int\n__synth_event_trace_init(struct trace_event_file *file,\n\t\t\t struct synth_event_trace_state *trace_state)\n{\n\tint ret = 0;\n\n\tmemset(trace_state, '\\0', sizeof(*trace_state));\n\n\t/*\n\t * Normal event tracing doesn't get called at all unless the\n\t * ENABLED bit is set (which attaches the probe thus allowing\n\t * this code to be called, etc).  Because this is called\n\t * directly by the user, we don't have that but we still need\n\t * to honor not logging when disabled.  For the iterated\n\t * trace case, we save the enabled state upon start and just\n\t * ignore the following data calls.\n\t */\n\tif (!(file->flags & EVENT_FILE_FL_ENABLED) ||\n\t    trace_trigger_soft_disabled(file)) {\n\t\ttrace_state->disabled = true;\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttrace_state->event = file->event_call->data;\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_trace_start(struct trace_event_file *file,\n\t\t\t    struct synth_event_trace_state *trace_state)\n{\n\tint ret;\n\n\tif (!trace_state)\n\t\treturn -EINVAL;\n\n\tret = __synth_event_trace_init(file, trace_state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (trace_state->event->n_dynamic_fields)\n\t\treturn -ENOTSUPP;\n\n\tret = __synth_event_trace_start(file, trace_state, 0);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "synth_event_trace_array",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1728-1799",
    "snippet": "int synth_event_trace_array(struct trace_event_file *file, u64 *vals,\n\t\t\t    unsigned int n_vals)\n{\n\tunsigned int i, n_u64, field_pos, len, data_size = 0;\n\tstruct synth_event_trace_state state;\n\tchar *str_val;\n\tint ret;\n\n\tret = __synth_event_trace_init(file, &state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (state.event->n_dynamic_fields) {\n\t\tfor (i = 0; i < state.event->n_dynamic_fields; i++) {\n\t\t\tfield_pos = state.event->dynamic_fields[i]->field_pos;\n\t\t\tstr_val = (char *)(long)vals[field_pos];\n\t\t\tlen = strlen(str_val) + 1;\n\t\t\tdata_size += len;\n\t\t}\n\t}\n\n\tret = __synth_event_trace_start(file, &state, data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (n_vals != state.event->n_fields) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_size = 0;\n\n\tfor (i = 0, n_u64 = 0; i < state.event->n_fields; i++) {\n\t\tif (state.event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)vals[i];\n\n\t\t\tlen = trace_string(state.entry, state.event, str_val,\n\t\t\t\t\t   state.event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len; /* only dynamic string increments */\n\t\t} else {\n\t\t\tstruct synth_field *field = state.event->fields[i];\n\t\t\tu64 val = vals[i];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\t*(u8 *)&state.entry->fields[n_u64] = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t*(u16 *)&state.entry->fields[n_u64] = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\t*(u32 *)&state.entry->fields[n_u64] = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate.entry->fields[n_u64] = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\nout:\n\t__synth_event_trace_end(&state);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__synth_event_trace_end",
          "args": [
            "&state"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "__synth_event_trace_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1597-1603",
          "snippet": "static inline void\n__synth_event_trace_end(struct synth_event_trace_state *trace_state)\n{\n\ttrace_event_buffer_commit(&trace_state->fbuffer);\n\n\tring_buffer_nest_end(trace_state->buffer);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void\n__synth_event_trace_end(struct synth_event_trace_state *trace_state)\n{\n\ttrace_event_buffer_commit(&trace_state->fbuffer);\n\n\tring_buffer_nest_end(trace_state->buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_string",
          "args": [
            "state.entry",
            "state.event",
            "str_val",
            "state.event->fields[i]->is_dynamic",
            "data_size",
            "&n_u64"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "trace_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "395-429",
          "snippet": "static unsigned int trace_string(struct synth_trace_event *entry,\n\t\t\t\t struct synth_event *event,\n\t\t\t\t char *str_val,\n\t\t\t\t bool is_dynamic,\n\t\t\t\t unsigned int data_size,\n\t\t\t\t unsigned int *n_u64)\n{\n\tunsigned int len = 0;\n\tchar *str_field;\n\n\tif (is_dynamic) {\n\t\tu32 data_offset;\n\n\t\tdata_offset = offsetof(typeof(*entry), fields);\n\t\tdata_offset += event->n_u64 * sizeof(u64);\n\t\tdata_offset += data_size;\n\n\t\tstr_field = (char *)entry + data_offset;\n\n\t\tlen = strlen(str_val) + 1;\n\t\tstrscpy(str_field, str_val, len);\n\n\t\tdata_offset |= len << 16;\n\t\t*(u32 *)&entry->fields[*n_u64] = data_offset;\n\n\t\t(*n_u64)++;\n\t} else {\n\t\tstr_field = (char *)&entry->fields[*n_u64];\n\n\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t\t(*n_u64) += STR_VAR_LEN_MAX / sizeof(u64);\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic unsigned int trace_string(struct synth_trace_event *entry,\n\t\t\t\t struct synth_event *event,\n\t\t\t\t char *str_val,\n\t\t\t\t bool is_dynamic,\n\t\t\t\t unsigned int data_size,\n\t\t\t\t unsigned int *n_u64)\n{\n\tunsigned int len = 0;\n\tchar *str_field;\n\n\tif (is_dynamic) {\n\t\tu32 data_offset;\n\n\t\tdata_offset = offsetof(typeof(*entry), fields);\n\t\tdata_offset += event->n_u64 * sizeof(u64);\n\t\tdata_offset += data_size;\n\n\t\tstr_field = (char *)entry + data_offset;\n\n\t\tlen = strlen(str_val) + 1;\n\t\tstrscpy(str_field, str_val, len);\n\n\t\tdata_offset |= len << 16;\n\t\t*(u32 *)&entry->fields[*n_u64] = data_offset;\n\n\t\t(*n_u64)++;\n\t} else {\n\t\tstr_field = (char *)&entry->fields[*n_u64];\n\n\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t\t(*n_u64) += STR_VAR_LEN_MAX / sizeof(u64);\n\t}\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__synth_event_trace_start",
          "args": [
            "file",
            "&state",
            "data_size"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "__synth_event_trace_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1567-1595",
          "snippet": "static inline int\n__synth_event_trace_start(struct trace_event_file *file,\n\t\t\t  struct synth_event_trace_state *trace_state,\n\t\t\t  int dynamic_fields_size)\n{\n\tint entry_size, fields_size = 0;\n\tint ret = 0;\n\n\tfields_size = trace_state->event->n_u64 * sizeof(u64);\n\tfields_size += dynamic_fields_size;\n\n\t/*\n\t * Avoid ring buffer recursion detection, as this event\n\t * is being performed within another event.\n\t */\n\ttrace_state->buffer = file->tr->array_buffer.buffer;\n\tring_buffer_nest_start(trace_state->buffer);\n\n\tentry_size = sizeof(*trace_state->entry) + fields_size;\n\ttrace_state->entry = trace_event_buffer_reserve(&trace_state->fbuffer,\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tentry_size);\n\tif (!trace_state->entry) {\n\t\tring_buffer_nest_end(trace_state->buffer);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline int\n__synth_event_trace_start(struct trace_event_file *file,\n\t\t\t  struct synth_event_trace_state *trace_state,\n\t\t\t  int dynamic_fields_size)\n{\n\tint entry_size, fields_size = 0;\n\tint ret = 0;\n\n\tfields_size = trace_state->event->n_u64 * sizeof(u64);\n\tfields_size += dynamic_fields_size;\n\n\t/*\n\t * Avoid ring buffer recursion detection, as this event\n\t * is being performed within another event.\n\t */\n\ttrace_state->buffer = file->tr->array_buffer.buffer;\n\tring_buffer_nest_start(trace_state->buffer);\n\n\tentry_size = sizeof(*trace_state->entry) + fields_size;\n\ttrace_state->entry = trace_event_buffer_reserve(&trace_state->fbuffer,\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tentry_size);\n\tif (!trace_state->entry) {\n\t\tring_buffer_nest_end(trace_state->buffer);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str_val"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__synth_event_trace_init",
          "args": [
            "file",
            "&state"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "__synth_event_trace_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1538-1565",
          "snippet": "static inline int\n__synth_event_trace_init(struct trace_event_file *file,\n\t\t\t struct synth_event_trace_state *trace_state)\n{\n\tint ret = 0;\n\n\tmemset(trace_state, '\\0', sizeof(*trace_state));\n\n\t/*\n\t * Normal event tracing doesn't get called at all unless the\n\t * ENABLED bit is set (which attaches the probe thus allowing\n\t * this code to be called, etc).  Because this is called\n\t * directly by the user, we don't have that but we still need\n\t * to honor not logging when disabled.  For the iterated\n\t * trace case, we save the enabled state upon start and just\n\t * ignore the following data calls.\n\t */\n\tif (!(file->flags & EVENT_FILE_FL_ENABLED) ||\n\t    trace_trigger_soft_disabled(file)) {\n\t\ttrace_state->disabled = true;\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttrace_state->event = file->event_call->data;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline int\n__synth_event_trace_init(struct trace_event_file *file,\n\t\t\t struct synth_event_trace_state *trace_state)\n{\n\tint ret = 0;\n\n\tmemset(trace_state, '\\0', sizeof(*trace_state));\n\n\t/*\n\t * Normal event tracing doesn't get called at all unless the\n\t * ENABLED bit is set (which attaches the probe thus allowing\n\t * this code to be called, etc).  Because this is called\n\t * directly by the user, we don't have that but we still need\n\t * to honor not logging when disabled.  For the iterated\n\t * trace case, we save the enabled state upon start and just\n\t * ignore the following data calls.\n\t */\n\tif (!(file->flags & EVENT_FILE_FL_ENABLED) ||\n\t    trace_trigger_soft_disabled(file)) {\n\t\ttrace_state->disabled = true;\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttrace_state->event = file->event_call->data;\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_trace_array(struct trace_event_file *file, u64 *vals,\n\t\t\t    unsigned int n_vals)\n{\n\tunsigned int i, n_u64, field_pos, len, data_size = 0;\n\tstruct synth_event_trace_state state;\n\tchar *str_val;\n\tint ret;\n\n\tret = __synth_event_trace_init(file, &state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (state.event->n_dynamic_fields) {\n\t\tfor (i = 0; i < state.event->n_dynamic_fields; i++) {\n\t\t\tfield_pos = state.event->dynamic_fields[i]->field_pos;\n\t\t\tstr_val = (char *)(long)vals[field_pos];\n\t\t\tlen = strlen(str_val) + 1;\n\t\t\tdata_size += len;\n\t\t}\n\t}\n\n\tret = __synth_event_trace_start(file, &state, data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (n_vals != state.event->n_fields) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_size = 0;\n\n\tfor (i = 0, n_u64 = 0; i < state.event->n_fields; i++) {\n\t\tif (state.event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)vals[i];\n\n\t\t\tlen = trace_string(state.entry, state.event, str_val,\n\t\t\t\t\t   state.event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len; /* only dynamic string increments */\n\t\t} else {\n\t\t\tstruct synth_field *field = state.event->fields[i];\n\t\t\tu64 val = vals[i];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\t*(u8 *)&state.entry->fields[n_u64] = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t*(u16 *)&state.entry->fields[n_u64] = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\t*(u32 *)&state.entry->fields[n_u64] = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate.entry->fields[n_u64] = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\nout:\n\t__synth_event_trace_end(&state);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "synth_event_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1624-1707",
    "snippet": "int synth_event_trace(struct trace_event_file *file, unsigned int n_vals, ...)\n{\n\tunsigned int i, n_u64, len, data_size = 0;\n\tstruct synth_event_trace_state state;\n\tva_list args;\n\tint ret;\n\n\tret = __synth_event_trace_init(file, &state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (state.event->n_dynamic_fields) {\n\t\tva_start(args, n_vals);\n\n\t\tfor (i = 0; i < state.event->n_fields; i++) {\n\t\t\tu64 val = va_arg(args, u64);\n\n\t\t\tif (state.event->fields[i]->is_string &&\n\t\t\t    state.event->fields[i]->is_dynamic) {\n\t\t\t\tchar *str_val = (char *)(long)val;\n\n\t\t\t\tdata_size += strlen(str_val) + 1;\n\t\t\t}\n\t\t}\n\n\t\tva_end(args);\n\t}\n\n\tret = __synth_event_trace_start(file, &state, data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (n_vals != state.event->n_fields) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_size = 0;\n\n\tva_start(args, n_vals);\n\tfor (i = 0, n_u64 = 0; i < state.event->n_fields; i++) {\n\t\tu64 val;\n\n\t\tval = va_arg(args, u64);\n\n\t\tif (state.event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)val;\n\n\t\t\tlen = trace_string(state.entry, state.event, str_val,\n\t\t\t\t\t   state.event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len; /* only dynamic string increments */\n\t\t} else {\n\t\t\tstruct synth_field *field = state.event->fields[i];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\t*(u8 *)&state.entry->fields[n_u64] = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t*(u16 *)&state.entry->fields[n_u64] = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\t*(u32 *)&state.entry->fields[n_u64] = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate.entry->fields[n_u64] = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\n\tva_end(args);\nout:\n\t__synth_event_trace_end(&state);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__synth_event_trace_end",
          "args": [
            "&state"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "__synth_event_trace_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1597-1603",
          "snippet": "static inline void\n__synth_event_trace_end(struct synth_event_trace_state *trace_state)\n{\n\ttrace_event_buffer_commit(&trace_state->fbuffer);\n\n\tring_buffer_nest_end(trace_state->buffer);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void\n__synth_event_trace_end(struct synth_event_trace_state *trace_state)\n{\n\ttrace_event_buffer_commit(&trace_state->fbuffer);\n\n\tring_buffer_nest_end(trace_state->buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_string",
          "args": [
            "state.entry",
            "state.event",
            "str_val",
            "state.event->fields[i]->is_dynamic",
            "data_size",
            "&n_u64"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "trace_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "395-429",
          "snippet": "static unsigned int trace_string(struct synth_trace_event *entry,\n\t\t\t\t struct synth_event *event,\n\t\t\t\t char *str_val,\n\t\t\t\t bool is_dynamic,\n\t\t\t\t unsigned int data_size,\n\t\t\t\t unsigned int *n_u64)\n{\n\tunsigned int len = 0;\n\tchar *str_field;\n\n\tif (is_dynamic) {\n\t\tu32 data_offset;\n\n\t\tdata_offset = offsetof(typeof(*entry), fields);\n\t\tdata_offset += event->n_u64 * sizeof(u64);\n\t\tdata_offset += data_size;\n\n\t\tstr_field = (char *)entry + data_offset;\n\n\t\tlen = strlen(str_val) + 1;\n\t\tstrscpy(str_field, str_val, len);\n\n\t\tdata_offset |= len << 16;\n\t\t*(u32 *)&entry->fields[*n_u64] = data_offset;\n\n\t\t(*n_u64)++;\n\t} else {\n\t\tstr_field = (char *)&entry->fields[*n_u64];\n\n\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t\t(*n_u64) += STR_VAR_LEN_MAX / sizeof(u64);\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic unsigned int trace_string(struct synth_trace_event *entry,\n\t\t\t\t struct synth_event *event,\n\t\t\t\t char *str_val,\n\t\t\t\t bool is_dynamic,\n\t\t\t\t unsigned int data_size,\n\t\t\t\t unsigned int *n_u64)\n{\n\tunsigned int len = 0;\n\tchar *str_field;\n\n\tif (is_dynamic) {\n\t\tu32 data_offset;\n\n\t\tdata_offset = offsetof(typeof(*entry), fields);\n\t\tdata_offset += event->n_u64 * sizeof(u64);\n\t\tdata_offset += data_size;\n\n\t\tstr_field = (char *)entry + data_offset;\n\n\t\tlen = strlen(str_val) + 1;\n\t\tstrscpy(str_field, str_val, len);\n\n\t\tdata_offset |= len << 16;\n\t\t*(u32 *)&entry->fields[*n_u64] = data_offset;\n\n\t\t(*n_u64)++;\n\t} else {\n\t\tstr_field = (char *)&entry->fields[*n_u64];\n\n\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t\t(*n_u64) += STR_VAR_LEN_MAX / sizeof(u64);\n\t}\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "u64"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "n_vals"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__synth_event_trace_start",
          "args": [
            "file",
            "&state",
            "data_size"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "__synth_event_trace_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1567-1595",
          "snippet": "static inline int\n__synth_event_trace_start(struct trace_event_file *file,\n\t\t\t  struct synth_event_trace_state *trace_state,\n\t\t\t  int dynamic_fields_size)\n{\n\tint entry_size, fields_size = 0;\n\tint ret = 0;\n\n\tfields_size = trace_state->event->n_u64 * sizeof(u64);\n\tfields_size += dynamic_fields_size;\n\n\t/*\n\t * Avoid ring buffer recursion detection, as this event\n\t * is being performed within another event.\n\t */\n\ttrace_state->buffer = file->tr->array_buffer.buffer;\n\tring_buffer_nest_start(trace_state->buffer);\n\n\tentry_size = sizeof(*trace_state->entry) + fields_size;\n\ttrace_state->entry = trace_event_buffer_reserve(&trace_state->fbuffer,\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tentry_size);\n\tif (!trace_state->entry) {\n\t\tring_buffer_nest_end(trace_state->buffer);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline int\n__synth_event_trace_start(struct trace_event_file *file,\n\t\t\t  struct synth_event_trace_state *trace_state,\n\t\t\t  int dynamic_fields_size)\n{\n\tint entry_size, fields_size = 0;\n\tint ret = 0;\n\n\tfields_size = trace_state->event->n_u64 * sizeof(u64);\n\tfields_size += dynamic_fields_size;\n\n\t/*\n\t * Avoid ring buffer recursion detection, as this event\n\t * is being performed within another event.\n\t */\n\ttrace_state->buffer = file->tr->array_buffer.buffer;\n\tring_buffer_nest_start(trace_state->buffer);\n\n\tentry_size = sizeof(*trace_state->entry) + fields_size;\n\ttrace_state->entry = trace_event_buffer_reserve(&trace_state->fbuffer,\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tentry_size);\n\tif (!trace_state->entry) {\n\t\tring_buffer_nest_end(trace_state->buffer);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str_val"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "u64"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "n_vals"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__synth_event_trace_init",
          "args": [
            "file",
            "&state"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "__synth_event_trace_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1538-1565",
          "snippet": "static inline int\n__synth_event_trace_init(struct trace_event_file *file,\n\t\t\t struct synth_event_trace_state *trace_state)\n{\n\tint ret = 0;\n\n\tmemset(trace_state, '\\0', sizeof(*trace_state));\n\n\t/*\n\t * Normal event tracing doesn't get called at all unless the\n\t * ENABLED bit is set (which attaches the probe thus allowing\n\t * this code to be called, etc).  Because this is called\n\t * directly by the user, we don't have that but we still need\n\t * to honor not logging when disabled.  For the iterated\n\t * trace case, we save the enabled state upon start and just\n\t * ignore the following data calls.\n\t */\n\tif (!(file->flags & EVENT_FILE_FL_ENABLED) ||\n\t    trace_trigger_soft_disabled(file)) {\n\t\ttrace_state->disabled = true;\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttrace_state->event = file->event_call->data;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline int\n__synth_event_trace_init(struct trace_event_file *file,\n\t\t\t struct synth_event_trace_state *trace_state)\n{\n\tint ret = 0;\n\n\tmemset(trace_state, '\\0', sizeof(*trace_state));\n\n\t/*\n\t * Normal event tracing doesn't get called at all unless the\n\t * ENABLED bit is set (which attaches the probe thus allowing\n\t * this code to be called, etc).  Because this is called\n\t * directly by the user, we don't have that but we still need\n\t * to honor not logging when disabled.  For the iterated\n\t * trace case, we save the enabled state upon start and just\n\t * ignore the following data calls.\n\t */\n\tif (!(file->flags & EVENT_FILE_FL_ENABLED) ||\n\t    trace_trigger_soft_disabled(file)) {\n\t\ttrace_state->disabled = true;\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttrace_state->event = file->event_call->data;\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_trace(struct trace_event_file *file, unsigned int n_vals, ...)\n{\n\tunsigned int i, n_u64, len, data_size = 0;\n\tstruct synth_event_trace_state state;\n\tva_list args;\n\tint ret;\n\n\tret = __synth_event_trace_init(file, &state);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0; /* just disabled, not really an error */\n\t\treturn ret;\n\t}\n\n\tif (state.event->n_dynamic_fields) {\n\t\tva_start(args, n_vals);\n\n\t\tfor (i = 0; i < state.event->n_fields; i++) {\n\t\t\tu64 val = va_arg(args, u64);\n\n\t\t\tif (state.event->fields[i]->is_string &&\n\t\t\t    state.event->fields[i]->is_dynamic) {\n\t\t\t\tchar *str_val = (char *)(long)val;\n\n\t\t\t\tdata_size += strlen(str_val) + 1;\n\t\t\t}\n\t\t}\n\n\t\tva_end(args);\n\t}\n\n\tret = __synth_event_trace_start(file, &state, data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (n_vals != state.event->n_fields) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdata_size = 0;\n\n\tva_start(args, n_vals);\n\tfor (i = 0, n_u64 = 0; i < state.event->n_fields; i++) {\n\t\tu64 val;\n\n\t\tval = va_arg(args, u64);\n\n\t\tif (state.event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)val;\n\n\t\t\tlen = trace_string(state.entry, state.event, str_val,\n\t\t\t\t\t   state.event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len; /* only dynamic string increments */\n\t\t} else {\n\t\t\tstruct synth_field *field = state.event->fields[i];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\t*(u8 *)&state.entry->fields[n_u64] = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t*(u16 *)&state.entry->fields[n_u64] = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\t*(u32 *)&state.entry->fields[n_u64] = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate.entry->fields[n_u64] = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\n\tva_end(args);\nout:\n\t__synth_event_trace_end(&state);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__synth_event_trace_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1597-1603",
    "snippet": "static inline void\n__synth_event_trace_end(struct synth_event_trace_state *trace_state)\n{\n\ttrace_event_buffer_commit(&trace_state->fbuffer);\n\n\tring_buffer_nest_end(trace_state->buffer);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_nest_end",
          "args": [
            "trace_state->buffer"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_nest_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "3236-3247",
          "snippet": "void ring_buffer_nest_end(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\t/* disabled by ring_buffer_nest_start() */\n\tcpu = raw_smp_processor_id();\n\tcpu_buffer = buffer->buffers[cpu];\n\t/* This is the shift value for the above recursive locking */\n\tcpu_buffer->nest -= NESTED_BITS;\n\tpreempt_enable_notrace();\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [
            "#define NESTED_BITS 5"
          ],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\n#define NESTED_BITS 5\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid ring_buffer_nest_end(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\t/* disabled by ring_buffer_nest_start() */\n\tcpu = raw_smp_processor_id();\n\tcpu_buffer = buffer->buffers[cpu];\n\t/* This is the shift value for the above recursive locking */\n\tcpu_buffer->nest -= NESTED_BITS;\n\tpreempt_enable_notrace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_commit",
          "args": [
            "&trace_state->fbuffer"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2893-2915",
          "snippet": "void trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct trace_event_file *file = fbuffer->trace_file;\n\n\tif (__event_trigger_test_discard(file, fbuffer->buffer, fbuffer->event,\n\t\t\tfbuffer->entry, &tt))\n\t\tgoto discard;\n\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tif (static_branch_unlikely(&trace_event_exports_enabled))\n\t\tftrace_exports(fbuffer->event, TRACE_EXPORT_EVENT);\n\n\ttrace_buffer_unlock_commit_regs(file->tr, fbuffer->buffer,\n\t\t\tfbuffer->event, fbuffer->trace_ctx, fbuffer->regs);\n\ndiscard:\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);",
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static DEFINE_STATIC_KEY_FALSE(trace_event_exports_enabled);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic DEFINE_STATIC_KEY_FALSE(trace_event_exports_enabled);\nstatic __always_inline struct;\n\nvoid trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct trace_event_file *file = fbuffer->trace_file;\n\n\tif (__event_trigger_test_discard(file, fbuffer->buffer, fbuffer->event,\n\t\t\tfbuffer->entry, &tt))\n\t\tgoto discard;\n\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tif (static_branch_unlikely(&trace_event_exports_enabled))\n\t\tftrace_exports(fbuffer->event, TRACE_EXPORT_EVENT);\n\n\ttrace_buffer_unlock_commit_regs(file->tr, fbuffer->buffer,\n\t\t\tfbuffer->event, fbuffer->trace_ctx, fbuffer->regs);\n\ndiscard:\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void\n__synth_event_trace_end(struct synth_event_trace_state *trace_state)\n{\n\ttrace_event_buffer_commit(&trace_state->fbuffer);\n\n\tring_buffer_nest_end(trace_state->buffer);\n}"
  },
  {
    "function_name": "__synth_event_trace_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1567-1595",
    "snippet": "static inline int\n__synth_event_trace_start(struct trace_event_file *file,\n\t\t\t  struct synth_event_trace_state *trace_state,\n\t\t\t  int dynamic_fields_size)\n{\n\tint entry_size, fields_size = 0;\n\tint ret = 0;\n\n\tfields_size = trace_state->event->n_u64 * sizeof(u64);\n\tfields_size += dynamic_fields_size;\n\n\t/*\n\t * Avoid ring buffer recursion detection, as this event\n\t * is being performed within another event.\n\t */\n\ttrace_state->buffer = file->tr->array_buffer.buffer;\n\tring_buffer_nest_start(trace_state->buffer);\n\n\tentry_size = sizeof(*trace_state->entry) + fields_size;\n\ttrace_state->entry = trace_event_buffer_reserve(&trace_state->fbuffer,\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tentry_size);\n\tif (!trace_state->entry) {\n\t\tring_buffer_nest_end(trace_state->buffer);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_nest_end",
          "args": [
            "trace_state->buffer"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_nest_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "3236-3247",
          "snippet": "void ring_buffer_nest_end(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\t/* disabled by ring_buffer_nest_start() */\n\tcpu = raw_smp_processor_id();\n\tcpu_buffer = buffer->buffers[cpu];\n\t/* This is the shift value for the above recursive locking */\n\tcpu_buffer->nest -= NESTED_BITS;\n\tpreempt_enable_notrace();\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [
            "#define NESTED_BITS 5"
          ],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\n#define NESTED_BITS 5\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid ring_buffer_nest_end(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\t/* disabled by ring_buffer_nest_start() */\n\tcpu = raw_smp_processor_id();\n\tcpu_buffer = buffer->buffers[cpu];\n\t/* This is the shift value for the above recursive locking */\n\tcpu_buffer->nest -= NESTED_BITS;\n\tpreempt_enable_notrace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_reserve",
          "args": [
            "&trace_state->fbuffer",
            "file",
            "entry_size"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "462-491",
          "snippet": "void *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\t/*\n\t * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tfbuffer->trace_ctx = tracing_gen_ctx_dec();\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->trace_ctx);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->regs = NULL;\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nvoid *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\t/*\n\t * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tfbuffer->trace_ctx = tracing_gen_ctx_dec();\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->trace_ctx);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->regs = NULL;\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_nest_start",
          "args": [
            "trace_state->buffer"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_nest_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "3216-3227",
          "snippet": "void ring_buffer_nest_start(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\t/* Enabled by ring_buffer_nest_end() */\n\tpreempt_disable_notrace();\n\tcpu = raw_smp_processor_id();\n\tcpu_buffer = buffer->buffers[cpu];\n\t/* This is the shift value for the above recursive locking */\n\tcpu_buffer->nest += NESTED_BITS;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [
            "#define NESTED_BITS 5"
          ],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\n#define NESTED_BITS 5\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid ring_buffer_nest_start(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\t/* Enabled by ring_buffer_nest_end() */\n\tpreempt_disable_notrace();\n\tcpu = raw_smp_processor_id();\n\tcpu_buffer = buffer->buffers[cpu];\n\t/* This is the shift value for the above recursive locking */\n\tcpu_buffer->nest += NESTED_BITS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline int\n__synth_event_trace_start(struct trace_event_file *file,\n\t\t\t  struct synth_event_trace_state *trace_state,\n\t\t\t  int dynamic_fields_size)\n{\n\tint entry_size, fields_size = 0;\n\tint ret = 0;\n\n\tfields_size = trace_state->event->n_u64 * sizeof(u64);\n\tfields_size += dynamic_fields_size;\n\n\t/*\n\t * Avoid ring buffer recursion detection, as this event\n\t * is being performed within another event.\n\t */\n\ttrace_state->buffer = file->tr->array_buffer.buffer;\n\tring_buffer_nest_start(trace_state->buffer);\n\n\tentry_size = sizeof(*trace_state->entry) + fields_size;\n\ttrace_state->entry = trace_event_buffer_reserve(&trace_state->fbuffer,\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tentry_size);\n\tif (!trace_state->entry) {\n\t\tring_buffer_nest_end(trace_state->buffer);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__synth_event_trace_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1538-1565",
    "snippet": "static inline int\n__synth_event_trace_init(struct trace_event_file *file,\n\t\t\t struct synth_event_trace_state *trace_state)\n{\n\tint ret = 0;\n\n\tmemset(trace_state, '\\0', sizeof(*trace_state));\n\n\t/*\n\t * Normal event tracing doesn't get called at all unless the\n\t * ENABLED bit is set (which attaches the probe thus allowing\n\t * this code to be called, etc).  Because this is called\n\t * directly by the user, we don't have that but we still need\n\t * to honor not logging when disabled.  For the iterated\n\t * trace case, we save the enabled state upon start and just\n\t * ignore the following data calls.\n\t */\n\tif (!(file->flags & EVENT_FILE_FL_ENABLED) ||\n\t    trace_trigger_soft_disabled(file)) {\n\t\ttrace_state->disabled = true;\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttrace_state->event = file->event_call->data;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_trigger_soft_disabled",
          "args": [
            "file"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "trace_state",
            "'\\0'",
            "sizeof(*trace_state)"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline int\n__synth_event_trace_init(struct trace_event_file *file,\n\t\t\t struct synth_event_trace_state *trace_state)\n{\n\tint ret = 0;\n\n\tmemset(trace_state, '\\0', sizeof(*trace_state));\n\n\t/*\n\t * Normal event tracing doesn't get called at all unless the\n\t * ENABLED bit is set (which attaches the probe thus allowing\n\t * this code to be called, etc).  Because this is called\n\t * directly by the user, we don't have that but we still need\n\t * to honor not logging when disabled.  For the iterated\n\t * trace case, we save the enabled state upon start and just\n\t * ignore the following data calls.\n\t */\n\tif (!(file->flags & EVENT_FILE_FL_ENABLED) ||\n\t    trace_trigger_soft_disabled(file)) {\n\t\ttrace_state->disabled = true;\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttrace_state->event = file->event_call->data;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "synth_event_cmd_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1531-1535",
    "snippet": "void synth_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_SYNTH,\n\t\t\t  synth_event_run_command);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dynevent_cmd_init",
          "args": [
            "cmd",
            "buf",
            "maxlen",
            "DYNEVENT_TYPE_SYNTH",
            "synth_event_run_command"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "dynevent_cmd_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "407-416",
          "snippet": "void dynevent_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen,\n\t\t       enum dynevent_type type,\n\t\t       dynevent_create_fn_t run_command)\n{\n\tmemset(cmd, '\\0', sizeof(*cmd));\n\n\tseq_buf_init(&cmd->seq, buf, maxlen);\n\tcmd->type = type;\n\tcmd->run_command = run_command;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nvoid dynevent_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen,\n\t\t       enum dynevent_type type,\n\t\t       dynevent_create_fn_t run_command)\n{\n\tmemset(cmd, '\\0', sizeof(*cmd));\n\n\tseq_buf_init(&cmd->seq, buf, maxlen);\n\tcmd->type = type;\n\tcmd->run_command = run_command;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nvoid synth_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_SYNTH,\n\t\t\t  synth_event_run_command);\n}"
  },
  {
    "function_name": "synth_event_run_command",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1504-1520",
    "snippet": "static int synth_event_run_command(struct dynevent_cmd *cmd)\n{\n\tstruct synth_event *se;\n\tint ret;\n\n\tret = create_or_delete_synth_event(cmd->seq.buffer);\n\tif (ret)\n\t\treturn ret;\n\n\tse = find_synth_event(cmd->event_name);\n\tif (WARN_ON(!se))\n\t\treturn -ENOENT;\n\n\tse->mod = cmd->private_data;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!se"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_synth_event",
          "args": [
            "cmd->event_name"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "find_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "748-762",
          "snippet": "struct synth_event *find_synth_event(const char *name)\n{\n\tstruct dyn_event *pos;\n\tstruct synth_event *event;\n\n\tfor_each_dyn_event(pos) {\n\t\tif (!is_synth_event(pos))\n\t\t\tcontinue;\n\t\tevent = to_synth_event(pos);\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstruct synth_event *find_synth_event(const char *name)\n{\n\tstruct dyn_event *pos;\n\tstruct synth_event *event;\n\n\tfor_each_dyn_event(pos) {\n\t\tif (!is_synth_event(pos))\n\t\t\tcontinue;\n\t\tevent = to_synth_event(pos);\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_or_delete_synth_event",
          "args": [
            "cmd->seq.buffer"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "create_or_delete_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1462-1502",
          "snippet": "static int create_or_delete_synth_event(const char *raw_command)\n{\n\tchar *name = NULL, *fields, *p;\n\tint ret = 0;\n\n\traw_command = skip_spaces(raw_command);\n\tif (raw_command[0] == '\\0')\n\t\treturn ret;\n\n\tlast_cmd_set(raw_command);\n\n\tret = check_command(raw_command);\n\tif (ret) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn ret;\n\t}\n\n\tp = strpbrk(raw_command, \" \\t\");\n\tif (!p && raw_command[0] != '!') {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tname = kmemdup_nul(raw_command, p ? p - raw_command : strlen(raw_command), GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tif (name[0] == '!') {\n\t\tret = synth_event_delete(name + 1);\n\t\tgoto free;\n\t}\n\n\tfields = skip_spaces(p);\n\n\tret = __create_synth_event(name, fields);\nfree:\n\tkfree(name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int create_synth_event(const char *raw_command);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_synth_event(const char *raw_command);\n\nstatic int create_or_delete_synth_event(const char *raw_command)\n{\n\tchar *name = NULL, *fields, *p;\n\tint ret = 0;\n\n\traw_command = skip_spaces(raw_command);\n\tif (raw_command[0] == '\\0')\n\t\treturn ret;\n\n\tlast_cmd_set(raw_command);\n\n\tret = check_command(raw_command);\n\tif (ret) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn ret;\n\t}\n\n\tp = strpbrk(raw_command, \" \\t\");\n\tif (!p && raw_command[0] != '!') {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tname = kmemdup_nul(raw_command, p ? p - raw_command : strlen(raw_command), GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tif (name[0] == '!') {\n\t\tret = synth_event_delete(name + 1);\n\t\tgoto free;\n\t}\n\n\tfields = skip_spaces(p);\n\n\tret = __create_synth_event(name, fields);\nfree:\n\tkfree(name);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_run_command(struct dynevent_cmd *cmd)\n{\n\tstruct synth_event *se;\n\tint ret;\n\n\tret = create_or_delete_synth_event(cmd->seq.buffer);\n\tif (ret)\n\t\treturn ret;\n\n\tse = find_synth_event(cmd->event_name);\n\tif (WARN_ON(!se))\n\t\treturn -ENOENT;\n\n\tse->mod = cmd->private_data;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "create_or_delete_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1462-1502",
    "snippet": "static int create_or_delete_synth_event(const char *raw_command)\n{\n\tchar *name = NULL, *fields, *p;\n\tint ret = 0;\n\n\traw_command = skip_spaces(raw_command);\n\tif (raw_command[0] == '\\0')\n\t\treturn ret;\n\n\tlast_cmd_set(raw_command);\n\n\tret = check_command(raw_command);\n\tif (ret) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn ret;\n\t}\n\n\tp = strpbrk(raw_command, \" \\t\");\n\tif (!p && raw_command[0] != '!') {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tname = kmemdup_nul(raw_command, p ? p - raw_command : strlen(raw_command), GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tif (name[0] == '!') {\n\t\tret = synth_event_delete(name + 1);\n\t\tgoto free;\n\t}\n\n\tfields = skip_spaces(p);\n\n\tret = __create_synth_event(name, fields);\nfree:\n\tkfree(name);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int create_synth_event(const char *raw_command);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__create_synth_event",
          "args": [
            "name",
            "fields"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "__create_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1179-1316",
          "snippet": "static int __create_synth_event(const char *name, const char *raw_fields)\n{\n\tchar **argv, *field_str, *tmp_fields, *saved_fields = NULL;\n\tstruct synth_field *field, *fields[SYNTH_FIELDS_MAX];\n\tint consumed, cmd_version = 1, n_fields_this_loop;\n\tint i, argc, n_fields = 0, ret = 0;\n\tstruct synth_event *event = NULL;\n\n\t/*\n\t * Argument syntax:\n\t *  - Add synthetic event: <event_name> field[;field] ...\n\t *  - Remove synthetic event: !<event_name> field[;field] ...\n\t *      where 'field' = type field_name\n\t */\n\n\tif (name[0] == '\\0') {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_good_name(name)) {\n\t\tsynth_err(SYNTH_ERR_BAD_NAME, errpos(name));\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tevent = find_synth_event(name);\n\tif (event) {\n\t\tsynth_err(SYNTH_ERR_EVENT_EXISTS, errpos(name));\n\t\tret = -EEXIST;\n\t\tgoto err;\n\t}\n\n\ttmp_fields = saved_fields = kstrdup(raw_fields, GFP_KERNEL);\n\tif (!tmp_fields) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\twhile ((field_str = strsep(&tmp_fields, \";\")) != NULL) {\n\t\targv = argv_split(GFP_KERNEL, field_str, &argc);\n\t\tif (!argv) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!argc) {\n\t\t\targv_free(argv);\n\t\t\tcontinue;\n\t\t}\n\n\t\tn_fields_this_loop = 0;\n\t\tconsumed = 0;\n\t\twhile (argc > consumed) {\n\t\t\tint field_version;\n\n\t\t\tfield = parse_synth_field(argc - consumed,\n\t\t\t\t\t\t  argv + consumed, &consumed,\n\t\t\t\t\t\t  &field_version);\n\t\t\tif (IS_ERR(field)) {\n\t\t\t\tret = PTR_ERR(field);\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Track the highest version of any field we\n\t\t\t * found in the command.\n\t\t\t */\n\t\t\tif (field_version > cmd_version)\n\t\t\t\tcmd_version = field_version;\n\n\t\t\t/*\n\t\t\t * Now sort out what is and isn't valid for\n\t\t\t * each supported version.\n\t\t\t *\n\t\t\t * If we see more than 1 field per loop, it\n\t\t\t * means we have multiple fields between\n\t\t\t * semicolons, and that's something we no\n\t\t\t * longer support in a version 2 or greater\n\t\t\t * command.\n\t\t\t */\n\t\t\tif (cmd_version > 1 && n_fields_this_loop >= 1) {\n\t\t\t\tsynth_err(SYNTH_ERR_INVALID_CMD, errpos(field_str));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\tfields[n_fields++] = field;\n\t\t\tif (n_fields == SYNTH_FIELDS_MAX) {\n\t\t\t\tsynth_err(SYNTH_ERR_TOO_MANY_FIELDS, 0);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\tn_fields_this_loop++;\n\t\t}\n\t\targv_free(argv);\n\n\t\tif (consumed < argc) {\n\t\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t}\n\n\tif (n_fields == 0) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tevent = alloc_synth_event(name, n_fields, fields);\n\tif (IS_ERR(event)) {\n\t\tret = PTR_ERR(event);\n\t\tevent = NULL;\n\t\tgoto err;\n\t}\n\tret = register_synth_event(event);\n\tif (!ret)\n\t\tdyn_event_add(&event->devent, &event->call);\n\telse\n\t\tfree_synth_event(event);\n out:\n\tmutex_unlock(&event_mutex);\n\n\tkfree(saved_fields);\n\n\treturn ret;\n err_free_arg:\n\targv_free(argv);\n err:\n\tfor (i = 0; i < n_fields; i++)\n\t\tfree_synth_field(fields[i]);\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int __create_synth_event(const char *name, const char *raw_fields)\n{\n\tchar **argv, *field_str, *tmp_fields, *saved_fields = NULL;\n\tstruct synth_field *field, *fields[SYNTH_FIELDS_MAX];\n\tint consumed, cmd_version = 1, n_fields_this_loop;\n\tint i, argc, n_fields = 0, ret = 0;\n\tstruct synth_event *event = NULL;\n\n\t/*\n\t * Argument syntax:\n\t *  - Add synthetic event: <event_name> field[;field] ...\n\t *  - Remove synthetic event: !<event_name> field[;field] ...\n\t *      where 'field' = type field_name\n\t */\n\n\tif (name[0] == '\\0') {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_good_name(name)) {\n\t\tsynth_err(SYNTH_ERR_BAD_NAME, errpos(name));\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tevent = find_synth_event(name);\n\tif (event) {\n\t\tsynth_err(SYNTH_ERR_EVENT_EXISTS, errpos(name));\n\t\tret = -EEXIST;\n\t\tgoto err;\n\t}\n\n\ttmp_fields = saved_fields = kstrdup(raw_fields, GFP_KERNEL);\n\tif (!tmp_fields) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\twhile ((field_str = strsep(&tmp_fields, \";\")) != NULL) {\n\t\targv = argv_split(GFP_KERNEL, field_str, &argc);\n\t\tif (!argv) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!argc) {\n\t\t\targv_free(argv);\n\t\t\tcontinue;\n\t\t}\n\n\t\tn_fields_this_loop = 0;\n\t\tconsumed = 0;\n\t\twhile (argc > consumed) {\n\t\t\tint field_version;\n\n\t\t\tfield = parse_synth_field(argc - consumed,\n\t\t\t\t\t\t  argv + consumed, &consumed,\n\t\t\t\t\t\t  &field_version);\n\t\t\tif (IS_ERR(field)) {\n\t\t\t\tret = PTR_ERR(field);\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Track the highest version of any field we\n\t\t\t * found in the command.\n\t\t\t */\n\t\t\tif (field_version > cmd_version)\n\t\t\t\tcmd_version = field_version;\n\n\t\t\t/*\n\t\t\t * Now sort out what is and isn't valid for\n\t\t\t * each supported version.\n\t\t\t *\n\t\t\t * If we see more than 1 field per loop, it\n\t\t\t * means we have multiple fields between\n\t\t\t * semicolons, and that's something we no\n\t\t\t * longer support in a version 2 or greater\n\t\t\t * command.\n\t\t\t */\n\t\t\tif (cmd_version > 1 && n_fields_this_loop >= 1) {\n\t\t\t\tsynth_err(SYNTH_ERR_INVALID_CMD, errpos(field_str));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\tfields[n_fields++] = field;\n\t\t\tif (n_fields == SYNTH_FIELDS_MAX) {\n\t\t\t\tsynth_err(SYNTH_ERR_TOO_MANY_FIELDS, 0);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\tn_fields_this_loop++;\n\t\t}\n\t\targv_free(argv);\n\n\t\tif (consumed < argc) {\n\t\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t}\n\n\tif (n_fields == 0) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tevent = alloc_synth_event(name, n_fields, fields);\n\tif (IS_ERR(event)) {\n\t\tret = PTR_ERR(event);\n\t\tevent = NULL;\n\t\tgoto err;\n\t}\n\tret = register_synth_event(event);\n\tif (!ret)\n\t\tdyn_event_add(&event->devent, &event->call);\n\telse\n\t\tfree_synth_event(event);\n out:\n\tmutex_unlock(&event_mutex);\n\n\tkfree(saved_fields);\n\n\treturn ret;\n err_free_arg:\n\targv_free(argv);\n err:\n\tfor (i = 0; i < n_fields; i++)\n\t\tfree_synth_field(fields[i]);\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "p"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "proc_skip_spaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "333-340",
          "snippet": "static size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_delete",
          "args": [
            "name + 1"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_delete",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1395-1426",
          "snippet": "int synth_event_delete(const char *event_name)\n{\n\tstruct synth_event *se = NULL;\n\tstruct module *mod = NULL;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&event_mutex);\n\tse = find_synth_event(event_name);\n\tif (se) {\n\t\tmod = se->mod;\n\t\tret = destroy_synth_event(se);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tif (mod) {\n\t\tmutex_lock(&trace_types_lock);\n\t\t/*\n\t\t * It is safest to reset the ring buffer if the module\n\t\t * being unloaded registered any events that were\n\t\t * used. The only worry is if a new module gets\n\t\t * loaded, and takes on the same id as the events of\n\t\t * this module. When printing out the buffer, traced\n\t\t * events left over from this module may be passed to\n\t\t * the new module events and unexpected results may\n\t\t * occur.\n\t\t */\n\t\ttracing_reset_all_online_cpus();\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_delete(const char *event_name)\n{\n\tstruct synth_event *se = NULL;\n\tstruct module *mod = NULL;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&event_mutex);\n\tse = find_synth_event(event_name);\n\tif (se) {\n\t\tmod = se->mod;\n\t\tret = destroy_synth_event(se);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tif (mod) {\n\t\tmutex_lock(&trace_types_lock);\n\t\t/*\n\t\t * It is safest to reset the ring buffer if the module\n\t\t * being unloaded registered any events that were\n\t\t * used. The only worry is if a new module gets\n\t\t * loaded, and takes on the same id as the events of\n\t\t * this module. When printing out the buffer, traced\n\t\t * events left over from this module may be passed to\n\t\t * the new module events and unexpected results may\n\t\t * occur.\n\t\t */\n\t\ttracing_reset_all_online_cpus();\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup_nul",
          "args": [
            "raw_command",
            "p ? p - raw_command : strlen(raw_command)",
            "GFP_KERNEL"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "raw_command"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_err",
          "args": [
            "SYNTH_ERR_INVALID_CMD",
            "0"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "synth_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "60-64",
          "snippet": "static void synth_err(u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(NULL, \"synthetic_events\", last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic void synth_err(u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(NULL, \"synthetic_events\", last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "raw_command",
            "\" \\t\""
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_command",
          "args": [
            "raw_command"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "check_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1429-1460",
          "snippet": "static int check_command(const char *raw_command)\n{\n\tchar **argv = NULL, *cmd, *saved_cmd, *name_and_field;\n\tint argc, ret = 0;\n\n\tcmd = saved_cmd = kstrdup(raw_command, GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tname_and_field = strsep(&cmd, \";\");\n\tif (!name_and_field) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (name_and_field[0] == '!')\n\t\tgoto free;\n\n\targv = argv_split(GFP_KERNEL, name_and_field, &argc);\n\tif (!argv) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\targv_free(argv);\n\n\tif (argc < 3)\n\t\tret = -EINVAL;\nfree:\n\tkfree(saved_cmd);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int create_synth_event(const char *raw_command);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_synth_event(const char *raw_command);\n\nstatic int check_command(const char *raw_command)\n{\n\tchar **argv = NULL, *cmd, *saved_cmd, *name_and_field;\n\tint argc, ret = 0;\n\n\tcmd = saved_cmd = kstrdup(raw_command, GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tname_and_field = strsep(&cmd, \";\");\n\tif (!name_and_field) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (name_and_field[0] == '!')\n\t\tgoto free;\n\n\targv = argv_split(GFP_KERNEL, name_and_field, &argc);\n\tif (!argv) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\targv_free(argv);\n\n\tif (argc < 3)\n\t\tret = -EINVAL;\nfree:\n\tkfree(saved_cmd);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "last_cmd_set",
          "args": [
            "raw_command"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "last_cmd_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "52-58",
          "snippet": "static void last_cmd_set(const char *str)\n{\n\tif (!str)\n\t\treturn;\n\n\tstrncpy(last_cmd, str, MAX_FILTER_STR_VAL - 1);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic void last_cmd_set(const char *str)\n{\n\tif (!str)\n\t\treturn;\n\n\tstrncpy(last_cmd, str, MAX_FILTER_STR_VAL - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_synth_event(const char *raw_command);\n\nstatic int create_or_delete_synth_event(const char *raw_command)\n{\n\tchar *name = NULL, *fields, *p;\n\tint ret = 0;\n\n\traw_command = skip_spaces(raw_command);\n\tif (raw_command[0] == '\\0')\n\t\treturn ret;\n\n\tlast_cmd_set(raw_command);\n\n\tret = check_command(raw_command);\n\tif (ret) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn ret;\n\t}\n\n\tp = strpbrk(raw_command, \" \\t\");\n\tif (!p && raw_command[0] != '!') {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tname = kmemdup_nul(raw_command, p ? p - raw_command : strlen(raw_command), GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tif (name[0] == '!') {\n\t\tret = synth_event_delete(name + 1);\n\t\tgoto free;\n\t}\n\n\tfields = skip_spaces(p);\n\n\tret = __create_synth_event(name, fields);\nfree:\n\tkfree(name);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "check_command",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1429-1460",
    "snippet": "static int check_command(const char *raw_command)\n{\n\tchar **argv = NULL, *cmd, *saved_cmd, *name_and_field;\n\tint argc, ret = 0;\n\n\tcmd = saved_cmd = kstrdup(raw_command, GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tname_and_field = strsep(&cmd, \";\");\n\tif (!name_and_field) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (name_and_field[0] == '!')\n\t\tgoto free;\n\n\targv = argv_split(GFP_KERNEL, name_and_field, &argc);\n\tif (!argv) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\targv_free(argv);\n\n\tif (argc < 3)\n\t\tret = -EINVAL;\nfree:\n\tkfree(saved_cmd);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int create_synth_event(const char *raw_command);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "saved_cmd"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "argv_free",
          "args": [
            "argv"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv_split",
          "args": [
            "GFP_KERNEL",
            "name_and_field",
            "&argc"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&cmd",
            "\";\""
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "raw_command",
            "GFP_KERNEL"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_synth_event(const char *raw_command);\n\nstatic int check_command(const char *raw_command)\n{\n\tchar **argv = NULL, *cmd, *saved_cmd, *name_and_field;\n\tint argc, ret = 0;\n\n\tcmd = saved_cmd = kstrdup(raw_command, GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tname_and_field = strsep(&cmd, \";\");\n\tif (!name_and_field) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (name_and_field[0] == '!')\n\t\tgoto free;\n\n\targv = argv_split(GFP_KERNEL, name_and_field, &argc);\n\tif (!argv) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\targv_free(argv);\n\n\tif (argc < 3)\n\t\tret = -EINVAL;\nfree:\n\tkfree(saved_cmd);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "synth_event_delete",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1395-1426",
    "snippet": "int synth_event_delete(const char *event_name)\n{\n\tstruct synth_event *se = NULL;\n\tstruct module *mod = NULL;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&event_mutex);\n\tse = find_synth_event(event_name);\n\tif (se) {\n\t\tmod = se->mod;\n\t\tret = destroy_synth_event(se);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tif (mod) {\n\t\tmutex_lock(&trace_types_lock);\n\t\t/*\n\t\t * It is safest to reset the ring buffer if the module\n\t\t * being unloaded registered any events that were\n\t\t * used. The only worry is if a new module gets\n\t\t * loaded, and takes on the same id as the events of\n\t\t * this module. When printing out the buffer, traced\n\t\t * events left over from this module may be passed to\n\t\t * the new module events and unexpected results may\n\t\t * occur.\n\t\t */\n\t\ttracing_reset_all_online_cpus();\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_reset_all_online_cpus",
          "args": [],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_reset_all_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2158-2171",
          "snippet": "void tracing_reset_all_online_cpus(void)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->clear_trace)\n\t\t\tcontinue;\n\t\ttr->clear_trace = false;\n\t\ttracing_reset_online_cpus(&tr->array_buffer);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\ttracing_reset_online_cpus(&tr->max_buffer);\n#endif\n\t}\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid tracing_reset_all_online_cpus(void)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->clear_trace)\n\t\t\tcontinue;\n\t\ttr->clear_trace = false;\n\t\ttracing_reset_online_cpus(&tr->array_buffer);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\ttracing_reset_online_cpus(&tr->max_buffer);\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_synth_event",
          "args": [
            "se"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1368-1385",
          "snippet": "static int destroy_synth_event(struct synth_event *se)\n{\n\tint ret;\n\n\tif (se->ref)\n\t\treturn -EBUSY;\n\n\tif (trace_event_dyn_busy(&se->call))\n\t\treturn -EBUSY;\n\n\tret = unregister_synth_event(se);\n\tif (!ret) {\n\t\tdyn_event_remove(&se->devent);\n\t\tfree_synth_event(se);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int destroy_synth_event(struct synth_event *se)\n{\n\tint ret;\n\n\tif (se->ref)\n\t\treturn -EBUSY;\n\n\tif (trace_event_dyn_busy(&se->call))\n\t\treturn -EBUSY;\n\n\tret = unregister_synth_event(se);\n\tif (!ret) {\n\t\tdyn_event_remove(&se->devent);\n\t\tfree_synth_event(se);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_synth_event",
          "args": [
            "event_name"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "find_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "748-762",
          "snippet": "struct synth_event *find_synth_event(const char *name)\n{\n\tstruct dyn_event *pos;\n\tstruct synth_event *event;\n\n\tfor_each_dyn_event(pos) {\n\t\tif (!is_synth_event(pos))\n\t\t\tcontinue;\n\t\tevent = to_synth_event(pos);\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstruct synth_event *find_synth_event(const char *name)\n{\n\tstruct dyn_event *pos;\n\tstruct synth_event *event;\n\n\tfor_each_dyn_event(pos) {\n\t\tif (!is_synth_event(pos))\n\t\t\tcontinue;\n\t\tevent = to_synth_event(pos);\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_delete(const char *event_name)\n{\n\tstruct synth_event *se = NULL;\n\tstruct module *mod = NULL;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&event_mutex);\n\tse = find_synth_event(event_name);\n\tif (se) {\n\t\tmod = se->mod;\n\t\tret = destroy_synth_event(se);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tif (mod) {\n\t\tmutex_lock(&trace_types_lock);\n\t\t/*\n\t\t * It is safest to reset the ring buffer if the module\n\t\t * being unloaded registered any events that were\n\t\t * used. The only worry is if a new module gets\n\t\t * loaded, and takes on the same id as the events of\n\t\t * this module. When printing out the buffer, traced\n\t\t * events left over from this module may be passed to\n\t\t * the new module events and unexpected results may\n\t\t * occur.\n\t\t */\n\t\ttracing_reset_all_online_cpus();\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "destroy_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1368-1385",
    "snippet": "static int destroy_synth_event(struct synth_event *se)\n{\n\tint ret;\n\n\tif (se->ref)\n\t\treturn -EBUSY;\n\n\tif (trace_event_dyn_busy(&se->call))\n\t\treturn -EBUSY;\n\n\tret = unregister_synth_event(se);\n\tif (!ret) {\n\t\tdyn_event_remove(&se->devent);\n\t\tfree_synth_event(se);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_synth_event",
          "args": [
            "se"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "833-850",
          "snippet": "static void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->dynamic_fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->dynamic_fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_remove",
          "args": [
            "&se->devent"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.h",
          "lines": "92-96",
          "snippet": "static inline void dyn_event_remove(struct dyn_event *ev)\n{\n\tlockdep_assert_held(&event_mutex);\n\tlist_del_init(&ev->list);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n\nstatic inline void dyn_event_remove(struct dyn_event *ev)\n{\n\tlockdep_assert_held(&event_mutex);\n\tlist_del_init(&ev->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_synth_event",
          "args": [
            "se"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "823-831",
          "snippet": "static int unregister_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret;\n\n\tret = trace_remove_event_call(call);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int unregister_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret;\n\n\tret = trace_remove_event_call(call);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_dyn_busy",
          "args": [
            "&se->call"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_dyn_busy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "54-57",
          "snippet": "bool trace_event_dyn_busy(struct trace_event_call *call)\n{\n\treturn atomic_read(&call->refcnt) != 0;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nbool trace_event_dyn_busy(struct trace_event_call *call)\n{\n\treturn atomic_read(&call->refcnt) != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int destroy_synth_event(struct synth_event *se)\n{\n\tint ret;\n\n\tif (se->ref)\n\t\treturn -EBUSY;\n\n\tif (trace_event_dyn_busy(&se->call))\n\t\treturn -EBUSY;\n\n\tret = unregister_synth_event(se);\n\tif (!ret) {\n\t\tdyn_event_remove(&se->devent);\n\t\tfree_synth_event(se);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "synth_event_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1342-1365",
    "snippet": "int synth_event_create(const char *name, struct synth_field_desc *fields,\n\t\t       unsigned int n_fields, struct module *mod)\n{\n\tstruct dynevent_cmd cmd;\n\tchar *buf;\n\tint ret;\n\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tsynth_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\tret = synth_event_gen_cmd_array_start(&cmd, name, mod,\n\t\t\t\t\t      fields, n_fields);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_gen_cmd_end(&cmd);\n out:\n\tkfree(buf);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_gen_cmd_end",
          "args": [
            "&cmd"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_event_gen_cmd_array_start",
          "args": [
            "&cmd",
            "name",
            "mod",
            "fields",
            "n_fields"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_gen_cmd_array_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1142-1176",
          "snippet": "int synth_event_gen_cmd_array_start(struct dynevent_cmd *cmd, const char *name,\n\t\t\t\t    struct module *mod,\n\t\t\t\t    struct synth_field_desc *fields,\n\t\t\t\t    unsigned int n_fields)\n{\n\tstruct dynevent_arg arg;\n\tunsigned int i;\n\tint ret = 0;\n\n\tcmd->event_name = name;\n\tcmd->private_data = mod;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tif (n_fields > SYNTH_FIELDS_MAX)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = name;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_gen_cmd_array_start(struct dynevent_cmd *cmd, const char *name,\n\t\t\t\t    struct module *mod,\n\t\t\t\t    struct synth_field_desc *fields,\n\t\t\t\t    unsigned int n_fields)\n{\n\tstruct dynevent_arg arg;\n\tunsigned int i;\n\tint ret = 0;\n\n\tcmd->event_name = name;\n\tcmd->private_data = mod;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tif (n_fields > SYNTH_FIELDS_MAX)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = name;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_event_cmd_init",
          "args": [
            "&cmd",
            "buf",
            "MAX_DYNEVENT_CMD_LEN"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_cmd_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1531-1535",
          "snippet": "void synth_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_SYNTH,\n\t\t\t  synth_event_run_command);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nvoid synth_event_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen)\n{\n\tdynevent_cmd_init(cmd, buf, maxlen, DYNEVENT_TYPE_SYNTH,\n\t\t\t  synth_event_run_command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "MAX_DYNEVENT_CMD_LEN",
            "GFP_KERNEL"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_create(const char *name, struct synth_field_desc *fields,\n\t\t       unsigned int n_fields, struct module *mod)\n{\n\tstruct dynevent_cmd cmd;\n\tchar *buf;\n\tint ret;\n\n\tbuf = kzalloc(MAX_DYNEVENT_CMD_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tsynth_event_cmd_init(&cmd, buf, MAX_DYNEVENT_CMD_LEN);\n\n\tret = synth_event_gen_cmd_array_start(&cmd, name, mod,\n\t\t\t\t\t      fields, n_fields);\n\tif (ret)\n\t\tgoto out;\n\n\tret = synth_event_gen_cmd_end(&cmd);\n out:\n\tkfree(buf);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__create_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1179-1316",
    "snippet": "static int __create_synth_event(const char *name, const char *raw_fields)\n{\n\tchar **argv, *field_str, *tmp_fields, *saved_fields = NULL;\n\tstruct synth_field *field, *fields[SYNTH_FIELDS_MAX];\n\tint consumed, cmd_version = 1, n_fields_this_loop;\n\tint i, argc, n_fields = 0, ret = 0;\n\tstruct synth_event *event = NULL;\n\n\t/*\n\t * Argument syntax:\n\t *  - Add synthetic event: <event_name> field[;field] ...\n\t *  - Remove synthetic event: !<event_name> field[;field] ...\n\t *      where 'field' = type field_name\n\t */\n\n\tif (name[0] == '\\0') {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_good_name(name)) {\n\t\tsynth_err(SYNTH_ERR_BAD_NAME, errpos(name));\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tevent = find_synth_event(name);\n\tif (event) {\n\t\tsynth_err(SYNTH_ERR_EVENT_EXISTS, errpos(name));\n\t\tret = -EEXIST;\n\t\tgoto err;\n\t}\n\n\ttmp_fields = saved_fields = kstrdup(raw_fields, GFP_KERNEL);\n\tif (!tmp_fields) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\twhile ((field_str = strsep(&tmp_fields, \";\")) != NULL) {\n\t\targv = argv_split(GFP_KERNEL, field_str, &argc);\n\t\tif (!argv) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!argc) {\n\t\t\targv_free(argv);\n\t\t\tcontinue;\n\t\t}\n\n\t\tn_fields_this_loop = 0;\n\t\tconsumed = 0;\n\t\twhile (argc > consumed) {\n\t\t\tint field_version;\n\n\t\t\tfield = parse_synth_field(argc - consumed,\n\t\t\t\t\t\t  argv + consumed, &consumed,\n\t\t\t\t\t\t  &field_version);\n\t\t\tif (IS_ERR(field)) {\n\t\t\t\tret = PTR_ERR(field);\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Track the highest version of any field we\n\t\t\t * found in the command.\n\t\t\t */\n\t\t\tif (field_version > cmd_version)\n\t\t\t\tcmd_version = field_version;\n\n\t\t\t/*\n\t\t\t * Now sort out what is and isn't valid for\n\t\t\t * each supported version.\n\t\t\t *\n\t\t\t * If we see more than 1 field per loop, it\n\t\t\t * means we have multiple fields between\n\t\t\t * semicolons, and that's something we no\n\t\t\t * longer support in a version 2 or greater\n\t\t\t * command.\n\t\t\t */\n\t\t\tif (cmd_version > 1 && n_fields_this_loop >= 1) {\n\t\t\t\tsynth_err(SYNTH_ERR_INVALID_CMD, errpos(field_str));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\tfields[n_fields++] = field;\n\t\t\tif (n_fields == SYNTH_FIELDS_MAX) {\n\t\t\t\tsynth_err(SYNTH_ERR_TOO_MANY_FIELDS, 0);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\tn_fields_this_loop++;\n\t\t}\n\t\targv_free(argv);\n\n\t\tif (consumed < argc) {\n\t\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t}\n\n\tif (n_fields == 0) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tevent = alloc_synth_event(name, n_fields, fields);\n\tif (IS_ERR(event)) {\n\t\tret = PTR_ERR(event);\n\t\tevent = NULL;\n\t\tgoto err;\n\t}\n\tret = register_synth_event(event);\n\tif (!ret)\n\t\tdyn_event_add(&event->devent, &event->call);\n\telse\n\t\tfree_synth_event(event);\n out:\n\tmutex_unlock(&event_mutex);\n\n\tkfree(saved_fields);\n\n\treturn ret;\n err_free_arg:\n\targv_free(argv);\n err:\n\tfor (i = 0; i < n_fields; i++)\n\t\tfree_synth_field(fields[i]);\n\n\tgoto out;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_synth_field",
          "args": [
            "fields[i]"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "576-581",
          "snippet": "static void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "argv_free",
          "args": [
            "argv"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "saved_fields"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_synth_event",
          "args": [
            "event"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "833-850",
          "snippet": "static void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->dynamic_fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->dynamic_fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_add",
          "args": [
            "&event->devent",
            "&event->call"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.h",
          "lines": "79-90",
          "snippet": "static inline int dyn_event_add(struct dyn_event *ev,\n\t\t\t\tstruct trace_event_call *call)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\tif (!ev || !ev->ops)\n\t\treturn -EINVAL;\n\n\tcall->flags |= TRACE_EVENT_FL_DYNAMIC;\n\tlist_add_tail(&ev->list, &dyn_event_list);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n\nstatic inline int dyn_event_add(struct dyn_event *ev,\n\t\t\t\tstruct trace_event_call *call)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\tif (!ev || !ev->ops)\n\t\treturn -EINVAL;\n\n\tcall->flags |= TRACE_EVENT_FL_DYNAMIC;\n\tlist_add_tail(&ev->list, &dyn_event_list);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_synth_event",
          "args": [
            "event"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "823-831",
          "snippet": "static int unregister_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret;\n\n\tret = trace_remove_event_call(call);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int unregister_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret;\n\n\tret = trace_remove_event_call(call);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "event"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "event"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_synth_event",
          "args": [
            "name",
            "n_fields",
            "fields"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "852-906",
          "snippet": "static struct synth_event *alloc_synth_event(const char *name, int n_fields,\n\t\t\t\t\t     struct synth_field **fields)\n{\n\tunsigned int i, j, n_dynamic_fields = 0;\n\tstruct synth_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event) {\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->name = kstrdup(name, GFP_KERNEL);\n\tif (!event->name) {\n\t\tkfree(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->fields = kcalloc(n_fields, sizeof(*event->fields), GFP_KERNEL);\n\tif (!event->fields) {\n\t\tfree_synth_event(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < n_fields; i++)\n\t\tif (fields[i]->is_dynamic)\n\t\t\tn_dynamic_fields++;\n\n\tif (n_dynamic_fields) {\n\t\tevent->dynamic_fields = kcalloc(n_dynamic_fields,\n\t\t\t\t\t\tsizeof(*event->dynamic_fields),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!event->dynamic_fields) {\n\t\t\tfree_synth_event(event);\n\t\t\tevent = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdyn_event_init(&event->devent, &synth_event_ops);\n\n\tfor (i = 0, j = 0; i < n_fields; i++) {\n\t\tfields[i]->field_pos = i;\n\t\tevent->fields[i] = fields[i];\n\n\t\tif (fields[i]->is_dynamic)\n\t\t\tevent->dynamic_fields[j++] = fields[i];\n\t}\n\tevent->n_dynamic_fields = j;\n\tevent->n_fields = n_fields;\n out:\n\treturn event;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dyn_event_operations synth_event_ops = {\n\t.create = create_synth_event,\n\t.show = synth_event_show,\n\t.is_busy = synth_event_is_busy,\n\t.free = synth_event_release,\n\t.match = synth_event_match,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct dyn_event_operations synth_event_ops = {\n\t.create = create_synth_event,\n\t.show = synth_event_show,\n\t.is_busy = synth_event_is_busy,\n\t.free = synth_event_release,\n\t.match = synth_event_match,\n};\n\nstatic struct synth_event *alloc_synth_event(const char *name, int n_fields,\n\t\t\t\t\t     struct synth_field **fields)\n{\n\tunsigned int i, j, n_dynamic_fields = 0;\n\tstruct synth_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event) {\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->name = kstrdup(name, GFP_KERNEL);\n\tif (!event->name) {\n\t\tkfree(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->fields = kcalloc(n_fields, sizeof(*event->fields), GFP_KERNEL);\n\tif (!event->fields) {\n\t\tfree_synth_event(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < n_fields; i++)\n\t\tif (fields[i]->is_dynamic)\n\t\t\tn_dynamic_fields++;\n\n\tif (n_dynamic_fields) {\n\t\tevent->dynamic_fields = kcalloc(n_dynamic_fields,\n\t\t\t\t\t\tsizeof(*event->dynamic_fields),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!event->dynamic_fields) {\n\t\t\tfree_synth_event(event);\n\t\t\tevent = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdyn_event_init(&event->devent, &synth_event_ops);\n\n\tfor (i = 0, j = 0; i < n_fields; i++) {\n\t\tfields[i]->field_pos = i;\n\t\tevent->fields[i] = fields[i];\n\n\t\tif (fields[i]->is_dynamic)\n\t\t\tevent->dynamic_fields[j++] = fields[i];\n\t}\n\tevent->n_dynamic_fields = j;\n\tevent->n_fields = n_fields;\n out:\n\treturn event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_err",
          "args": [
            "SYNTH_ERR_INVALID_CMD",
            "0"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "synth_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "60-64",
          "snippet": "static void synth_err(u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(NULL, \"synthetic_events\", last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic void synth_err(u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(NULL, \"synthetic_events\", last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "argv_free",
          "args": [
            "argv"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "field_str"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "47-50",
          "snippet": "static int errpos(const char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(const char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "field"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "field"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_synth_field",
          "args": [
            "argc - consumed",
            "argv + consumed",
            "&consumed",
            "&field_version"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "parse_synth_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "600-720",
          "snippet": "static struct synth_field *parse_synth_field(int argc, char **argv,\n\t\t\t\t\t     int *consumed, int *field_version)\n{\n\tconst char *prefix = NULL, *field_type = argv[0], *field_name, *array;\n\tstruct synth_field *field;\n\tint len, ret = -ENOMEM;\n\tstruct seq_buf s;\n\tssize_t size;\n\n\tif (!strcmp(field_type, \"unsigned\")) {\n\t\tif (argc < 3) {\n\t\t\tsynth_err(SYNTH_ERR_INCOMPLETE_TYPE, errpos(field_type));\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tprefix = \"unsigned \";\n\t\tfield_type = argv[1];\n\t\tfield_name = argv[2];\n\t\t*consumed += 3;\n\t} else {\n\t\tfield_name = argv[1];\n\t\t*consumed += 2;\n\t}\n\n\tif (!field_name) {\n\t\tsynth_err(SYNTH_ERR_INVALID_FIELD, errpos(field_type));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t*field_version = check_field_version(prefix, field_type, field_name);\n\n\tfield = kzalloc(sizeof(*field), GFP_KERNEL);\n\tif (!field)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlen = strlen(field_name);\n\tarray = strchr(field_name, '[');\n\tif (array)\n\t\tlen -= strlen(array);\n\n\tfield->name = kmemdup_nul(field_name, len, GFP_KERNEL);\n\tif (!field->name)\n\t\tgoto free;\n\n\tif (!is_good_name(field->name)) {\n\t\tsynth_err(SYNTH_ERR_BAD_NAME, errpos(field_name));\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tlen = strlen(field_type) + 1;\n\n\tif (array)\n\t\tlen += strlen(array);\n\n\tif (prefix)\n\t\tlen += strlen(prefix);\n\n\tfield->type = kzalloc(len, GFP_KERNEL);\n\tif (!field->type)\n\t\tgoto free;\n\n\tseq_buf_init(&s, field->type, len);\n\tif (prefix)\n\t\tseq_buf_puts(&s, prefix);\n\tseq_buf_puts(&s, field_type);\n\tif (array)\n\t\tseq_buf_puts(&s, array);\n\tif (WARN_ON_ONCE(!seq_buf_buffer_left(&s)))\n\t\tgoto free;\n\n\ts.buffer[s.len] = '\\0';\n\n\tsize = synth_field_size(field->type);\n\tif (size < 0) {\n\t\tif (array)\n\t\t\tsynth_err(SYNTH_ERR_INVALID_ARRAY_SPEC, errpos(field_name));\n\t\telse\n\t\t\tsynth_err(SYNTH_ERR_INVALID_TYPE, errpos(field_type));\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t} else if (size == 0) {\n\t\tif (synth_field_is_string(field->type)) {\n\t\t\tchar *type;\n\n\t\t\tlen = sizeof(\"__data_loc \") + strlen(field->type) + 1;\n\t\t\ttype = kzalloc(len, GFP_KERNEL);\n\t\t\tif (!type)\n\t\t\t\tgoto free;\n\n\t\t\tseq_buf_init(&s, type, len);\n\t\t\tseq_buf_puts(&s, \"__data_loc \");\n\t\t\tseq_buf_puts(&s, field->type);\n\n\t\t\tif (WARN_ON_ONCE(!seq_buf_buffer_left(&s)))\n\t\t\t\tgoto free;\n\t\t\ts.buffer[s.len] = '\\0';\n\n\t\t\tkfree(field->type);\n\t\t\tfield->type = type;\n\n\t\t\tfield->is_dynamic = true;\n\t\t\tsize = sizeof(u64);\n\t\t} else {\n\t\t\tsynth_err(SYNTH_ERR_INVALID_TYPE, errpos(field_type));\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t}\n\tfield->size = size;\n\n\tif (synth_field_is_string(field->type))\n\t\tfield->is_string = true;\n\n\tfield->is_signed = synth_field_signed(field->type);\n out:\n\treturn field;\n free:\n\tfree_synth_field(field);\n\tfield = ERR_PTR(ret);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct synth_field *parse_synth_field(int argc, char **argv,\n\t\t\t\t\t     int *consumed, int *field_version)\n{\n\tconst char *prefix = NULL, *field_type = argv[0], *field_name, *array;\n\tstruct synth_field *field;\n\tint len, ret = -ENOMEM;\n\tstruct seq_buf s;\n\tssize_t size;\n\n\tif (!strcmp(field_type, \"unsigned\")) {\n\t\tif (argc < 3) {\n\t\t\tsynth_err(SYNTH_ERR_INCOMPLETE_TYPE, errpos(field_type));\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tprefix = \"unsigned \";\n\t\tfield_type = argv[1];\n\t\tfield_name = argv[2];\n\t\t*consumed += 3;\n\t} else {\n\t\tfield_name = argv[1];\n\t\t*consumed += 2;\n\t}\n\n\tif (!field_name) {\n\t\tsynth_err(SYNTH_ERR_INVALID_FIELD, errpos(field_type));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t*field_version = check_field_version(prefix, field_type, field_name);\n\n\tfield = kzalloc(sizeof(*field), GFP_KERNEL);\n\tif (!field)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlen = strlen(field_name);\n\tarray = strchr(field_name, '[');\n\tif (array)\n\t\tlen -= strlen(array);\n\n\tfield->name = kmemdup_nul(field_name, len, GFP_KERNEL);\n\tif (!field->name)\n\t\tgoto free;\n\n\tif (!is_good_name(field->name)) {\n\t\tsynth_err(SYNTH_ERR_BAD_NAME, errpos(field_name));\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tlen = strlen(field_type) + 1;\n\n\tif (array)\n\t\tlen += strlen(array);\n\n\tif (prefix)\n\t\tlen += strlen(prefix);\n\n\tfield->type = kzalloc(len, GFP_KERNEL);\n\tif (!field->type)\n\t\tgoto free;\n\n\tseq_buf_init(&s, field->type, len);\n\tif (prefix)\n\t\tseq_buf_puts(&s, prefix);\n\tseq_buf_puts(&s, field_type);\n\tif (array)\n\t\tseq_buf_puts(&s, array);\n\tif (WARN_ON_ONCE(!seq_buf_buffer_left(&s)))\n\t\tgoto free;\n\n\ts.buffer[s.len] = '\\0';\n\n\tsize = synth_field_size(field->type);\n\tif (size < 0) {\n\t\tif (array)\n\t\t\tsynth_err(SYNTH_ERR_INVALID_ARRAY_SPEC, errpos(field_name));\n\t\telse\n\t\t\tsynth_err(SYNTH_ERR_INVALID_TYPE, errpos(field_type));\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t} else if (size == 0) {\n\t\tif (synth_field_is_string(field->type)) {\n\t\t\tchar *type;\n\n\t\t\tlen = sizeof(\"__data_loc \") + strlen(field->type) + 1;\n\t\t\ttype = kzalloc(len, GFP_KERNEL);\n\t\t\tif (!type)\n\t\t\t\tgoto free;\n\n\t\t\tseq_buf_init(&s, type, len);\n\t\t\tseq_buf_puts(&s, \"__data_loc \");\n\t\t\tseq_buf_puts(&s, field->type);\n\n\t\t\tif (WARN_ON_ONCE(!seq_buf_buffer_left(&s)))\n\t\t\t\tgoto free;\n\t\t\ts.buffer[s.len] = '\\0';\n\n\t\t\tkfree(field->type);\n\t\t\tfield->type = type;\n\n\t\t\tfield->is_dynamic = true;\n\t\t\tsize = sizeof(u64);\n\t\t} else {\n\t\t\tsynth_err(SYNTH_ERR_INVALID_TYPE, errpos(field_type));\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t}\n\tfield->size = size;\n\n\tif (synth_field_is_string(field->type))\n\t\tfield->is_string = true;\n\n\tfield->is_signed = synth_field_signed(field->type);\n out:\n\treturn field;\n free:\n\tfree_synth_field(field);\n\tfield = ERR_PTR(ret);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "argv_free",
          "args": [
            "argv"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv_split",
          "args": [
            "GFP_KERNEL",
            "field_str",
            "&argc"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&tmp_fields",
            "\";\""
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "raw_fields",
            "GFP_KERNEL"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_synth_event",
          "args": [
            "name"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "find_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "748-762",
          "snippet": "struct synth_event *find_synth_event(const char *name)\n{\n\tstruct dyn_event *pos;\n\tstruct synth_event *event;\n\n\tfor_each_dyn_event(pos) {\n\t\tif (!is_synth_event(pos))\n\t\t\tcontinue;\n\t\tevent = to_synth_event(pos);\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstruct synth_event *find_synth_event(const char *name)\n{\n\tstruct dyn_event *pos;\n\tstruct synth_event *event;\n\n\tfor_each_dyn_event(pos) {\n\t\tif (!is_synth_event(pos))\n\t\t\tcontinue;\n\t\tevent = to_synth_event(pos);\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_good_name",
          "args": [
            "name"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "is_good_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1976-1985",
          "snippet": "static inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int __create_synth_event(const char *name, const char *raw_fields)\n{\n\tchar **argv, *field_str, *tmp_fields, *saved_fields = NULL;\n\tstruct synth_field *field, *fields[SYNTH_FIELDS_MAX];\n\tint consumed, cmd_version = 1, n_fields_this_loop;\n\tint i, argc, n_fields = 0, ret = 0;\n\tstruct synth_event *event = NULL;\n\n\t/*\n\t * Argument syntax:\n\t *  - Add synthetic event: <event_name> field[;field] ...\n\t *  - Remove synthetic event: !<event_name> field[;field] ...\n\t *      where 'field' = type field_name\n\t */\n\n\tif (name[0] == '\\0') {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_good_name(name)) {\n\t\tsynth_err(SYNTH_ERR_BAD_NAME, errpos(name));\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&event_mutex);\n\n\tevent = find_synth_event(name);\n\tif (event) {\n\t\tsynth_err(SYNTH_ERR_EVENT_EXISTS, errpos(name));\n\t\tret = -EEXIST;\n\t\tgoto err;\n\t}\n\n\ttmp_fields = saved_fields = kstrdup(raw_fields, GFP_KERNEL);\n\tif (!tmp_fields) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\twhile ((field_str = strsep(&tmp_fields, \";\")) != NULL) {\n\t\targv = argv_split(GFP_KERNEL, field_str, &argc);\n\t\tif (!argv) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!argc) {\n\t\t\targv_free(argv);\n\t\t\tcontinue;\n\t\t}\n\n\t\tn_fields_this_loop = 0;\n\t\tconsumed = 0;\n\t\twhile (argc > consumed) {\n\t\t\tint field_version;\n\n\t\t\tfield = parse_synth_field(argc - consumed,\n\t\t\t\t\t\t  argv + consumed, &consumed,\n\t\t\t\t\t\t  &field_version);\n\t\t\tif (IS_ERR(field)) {\n\t\t\t\tret = PTR_ERR(field);\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Track the highest version of any field we\n\t\t\t * found in the command.\n\t\t\t */\n\t\t\tif (field_version > cmd_version)\n\t\t\t\tcmd_version = field_version;\n\n\t\t\t/*\n\t\t\t * Now sort out what is and isn't valid for\n\t\t\t * each supported version.\n\t\t\t *\n\t\t\t * If we see more than 1 field per loop, it\n\t\t\t * means we have multiple fields between\n\t\t\t * semicolons, and that's something we no\n\t\t\t * longer support in a version 2 or greater\n\t\t\t * command.\n\t\t\t */\n\t\t\tif (cmd_version > 1 && n_fields_this_loop >= 1) {\n\t\t\t\tsynth_err(SYNTH_ERR_INVALID_CMD, errpos(field_str));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\tfields[n_fields++] = field;\n\t\t\tif (n_fields == SYNTH_FIELDS_MAX) {\n\t\t\t\tsynth_err(SYNTH_ERR_TOO_MANY_FIELDS, 0);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_free_arg;\n\t\t\t}\n\n\t\t\tn_fields_this_loop++;\n\t\t}\n\t\targv_free(argv);\n\n\t\tif (consumed < argc) {\n\t\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t}\n\n\tif (n_fields == 0) {\n\t\tsynth_err(SYNTH_ERR_INVALID_CMD, 0);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tevent = alloc_synth_event(name, n_fields, fields);\n\tif (IS_ERR(event)) {\n\t\tret = PTR_ERR(event);\n\t\tevent = NULL;\n\t\tgoto err;\n\t}\n\tret = register_synth_event(event);\n\tif (!ret)\n\t\tdyn_event_add(&event->devent, &event->call);\n\telse\n\t\tfree_synth_event(event);\n out:\n\tmutex_unlock(&event_mutex);\n\n\tkfree(saved_fields);\n\n\treturn ret;\n err_free_arg:\n\targv_free(argv);\n err:\n\tfor (i = 0; i < n_fields; i++)\n\t\tfree_synth_field(fields[i]);\n\n\tgoto out;\n}"
  },
  {
    "function_name": "synth_event_gen_cmd_array_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1142-1176",
    "snippet": "int synth_event_gen_cmd_array_start(struct dynevent_cmd *cmd, const char *name,\n\t\t\t\t    struct module *mod,\n\t\t\t\t    struct synth_field_desc *fields,\n\t\t\t\t    unsigned int n_fields)\n{\n\tstruct dynevent_arg arg;\n\tunsigned int i;\n\tint ret = 0;\n\n\tcmd->event_name = name;\n\tcmd->private_data = mod;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tif (n_fields > SYNTH_FIELDS_MAX)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = name;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synth_event_add_field",
          "args": [
            "cmd",
            "fields[i].type",
            "fields[i].name"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_add_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1023-1042",
          "snippet": "int synth_event_add_fields(struct dynevent_cmd *cmd,\n\t\t\t   struct synth_field_desc *fields,\n\t\t\t   unsigned int n_fields)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_add_fields(struct dynevent_cmd *cmd,\n\t\t\t   struct synth_field_desc *fields,\n\t\t\t   unsigned int n_fields)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dynevent_arg_add",
          "args": [
            "cmd",
            "&arg",
            "NULL"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "dynevent_arg_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "294-313",
          "snippet": "int dynevent_arg_add(struct dynevent_cmd *cmd,\n\t\t     struct dynevent_arg *arg,\n\t\t     dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c\", arg->str, arg->separator);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s%c\\n\", arg->str, arg->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dynevent_arg_add(struct dynevent_cmd *cmd,\n\t\t     struct dynevent_arg *arg,\n\t\t     dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c\", arg->str, arg->separator);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s%c\\n\", arg->str, arg->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dynevent_arg_init",
          "args": [
            "&arg",
            "0"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "dynevent_arg_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "430-438",
          "snippet": "void dynevent_arg_init(struct dynevent_arg *arg,\n\t\t       char separator)\n{\n\tmemset(arg, '\\0', sizeof(*arg));\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ->separator = separator;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nvoid dynevent_arg_init(struct dynevent_arg *arg,\n\t\t       char separator)\n{\n\tmemset(arg, '\\0', sizeof(*arg));\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ->separator = separator;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_gen_cmd_array_start(struct dynevent_cmd *cmd, const char *name,\n\t\t\t\t    struct module *mod,\n\t\t\t\t    struct synth_field_desc *fields,\n\t\t\t\t    unsigned int n_fields)\n{\n\tstruct dynevent_arg arg;\n\tunsigned int i;\n\tint ret = 0;\n\n\tcmd->event_name = name;\n\tcmd->private_data = mod;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tif (n_fields > SYNTH_FIELDS_MAX)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = name;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__synth_event_gen_cmd_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1073-1115",
    "snippet": "int __synth_event_gen_cmd_start(struct dynevent_cmd *cmd, const char *name,\n\t\t\t\tstruct module *mod, ...)\n{\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret;\n\n\tcmd->event_name = name;\n\tcmd->private_data = mod;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = name;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tva_start(args, mod);\n\tfor (;;) {\n\t\tconst char *type, *name;\n\n\t\ttype = va_arg(args, const char *);\n\t\tif (!type)\n\t\t\tbreak;\n\t\tname = va_arg(args, const char *);\n\t\tif (!name)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > SYNTH_FIELDS_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, type, name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_event_add_field",
          "args": [
            "cmd",
            "type",
            "name"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_add_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1023-1042",
          "snippet": "int synth_event_add_fields(struct dynevent_cmd *cmd,\n\t\t\t   struct synth_field_desc *fields,\n\t\t\t   unsigned int n_fields)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_add_fields(struct dynevent_cmd *cmd,\n\t\t\t   struct synth_field_desc *fields,\n\t\t\t   unsigned int n_fields)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "constchar *"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "constchar *"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "mod"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dynevent_arg_add",
          "args": [
            "cmd",
            "&arg",
            "NULL"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "dynevent_arg_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "294-313",
          "snippet": "int dynevent_arg_add(struct dynevent_cmd *cmd,\n\t\t     struct dynevent_arg *arg,\n\t\t     dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c\", arg->str, arg->separator);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s%c\\n\", arg->str, arg->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dynevent_arg_add(struct dynevent_cmd *cmd,\n\t\t     struct dynevent_arg *arg,\n\t\t     dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c\", arg->str, arg->separator);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s%c\\n\", arg->str, arg->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dynevent_arg_init",
          "args": [
            "&arg",
            "0"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "dynevent_arg_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "430-438",
          "snippet": "void dynevent_arg_init(struct dynevent_arg *arg,\n\t\t       char separator)\n{\n\tmemset(arg, '\\0', sizeof(*arg));\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ->separator = separator;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nvoid dynevent_arg_init(struct dynevent_arg *arg,\n\t\t       char separator)\n{\n\tmemset(arg, '\\0', sizeof(*arg));\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ->separator = separator;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint __synth_event_gen_cmd_start(struct dynevent_cmd *cmd, const char *name,\n\t\t\t\tstruct module *mod, ...)\n{\n\tstruct dynevent_arg arg;\n\tva_list args;\n\tint ret;\n\n\tcmd->event_name = name;\n\tcmd->private_data = mod;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, 0);\n\targ.str = name;\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tva_start(args, mod);\n\tfor (;;) {\n\t\tconst char *type, *name;\n\n\t\ttype = va_arg(args, const char *);\n\t\tif (!type)\n\t\t\tbreak;\n\t\tname = va_arg(args, const char *);\n\t\tif (!name)\n\t\t\tbreak;\n\n\t\tif (++cmd->n_fields > SYNTH_FIELDS_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, type, name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tva_end(args);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "synth_event_add_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "1023-1042",
    "snippet": "int synth_event_add_fields(struct dynevent_cmd *cmd,\n\t\t\t   struct synth_field_desc *fields,\n\t\t\t   unsigned int n_fields)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synth_event_add_field",
          "args": [
            "cmd",
            "fields[i].type",
            "fields[i].name"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_add_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "1023-1042",
          "snippet": "int synth_event_add_fields(struct dynevent_cmd *cmd,\n\t\t\t   struct synth_field_desc *fields,\n\t\t\t   unsigned int n_fields)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_add_fields(struct dynevent_cmd *cmd,\n\t\t\t   struct synth_field_desc *fields,\n\t\t\t   unsigned int n_fields)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < n_fields; i++) {\n\t\tif (fields[i].type == NULL || fields[i].name == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = synth_event_add_field(cmd, fields[i].type, fields[i].name);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "synth_event_add_field_str",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "980-1003",
    "snippet": "int synth_event_add_field_str(struct dynevent_cmd *cmd, const char *type_name)\n{\n\tstruct dynevent_arg arg;\n\tint ret;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tif (!type_name)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, ';');\n\n\targ.str = type_name;\n\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (++cmd->n_fields > SYNTH_FIELDS_MAX)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dynevent_arg_add",
          "args": [
            "cmd",
            "&arg",
            "NULL"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "dynevent_arg_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "294-313",
          "snippet": "int dynevent_arg_add(struct dynevent_cmd *cmd,\n\t\t     struct dynevent_arg *arg,\n\t\t     dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c\", arg->str, arg->separator);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s%c\\n\", arg->str, arg->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dynevent_arg_add(struct dynevent_cmd *cmd,\n\t\t     struct dynevent_arg *arg,\n\t\t     dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c\", arg->str, arg->separator);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s%c\\n\", arg->str, arg->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dynevent_arg_init",
          "args": [
            "&arg",
            "';'"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "dynevent_arg_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "430-438",
          "snippet": "void dynevent_arg_init(struct dynevent_arg *arg,\n\t\t       char separator)\n{\n\tmemset(arg, '\\0', sizeof(*arg));\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ->separator = separator;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nvoid dynevent_arg_init(struct dynevent_arg *arg,\n\t\t       char separator)\n{\n\tmemset(arg, '\\0', sizeof(*arg));\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ->separator = separator;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_add_field_str(struct dynevent_cmd *cmd, const char *type_name)\n{\n\tstruct dynevent_arg arg;\n\tint ret;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tif (!type_name)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_init(&arg, ';');\n\n\targ.str = type_name;\n\n\tret = dynevent_arg_add(cmd, &arg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (++cmd->n_fields > SYNTH_FIELDS_MAX)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "synth_event_add_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "936-961",
    "snippet": "int synth_event_add_field(struct dynevent_cmd *cmd, const char *type,\n\t\t\t  const char *name)\n{\n\tstruct dynevent_arg_pair arg_pair;\n\tint ret;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tif (!type || !name)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_pair_init(&arg_pair, 0, ';');\n\n\targ_pair.lhs = type;\n\targ_pair.rhs = name;\n\n\tret = dynevent_arg_pair_add(cmd, &arg_pair, synth_event_check_arg_fn);\n\tif (ret)\n\t\treturn ret;\n\n\tif (++cmd->n_fields > SYNTH_FIELDS_MAX)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dynevent_arg_pair_add",
          "args": [
            "cmd",
            "&arg_pair",
            "synth_event_check_arg_fn"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "dynevent_arg_pair_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "339-362",
          "snippet": "int dynevent_arg_pair_add(struct dynevent_cmd *cmd,\n\t\t\t  struct dynevent_arg_pair *arg_pair,\n\t\t\t  dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg_pair);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c%s%c\", arg_pair->lhs,\n\t\t\t     arg_pair->operator, arg_pair->rhs,\n\t\t\t     arg_pair->separator);\n\tif (ret) {\n\t\tpr_err(\"field string is too long: %s%c%s%c\\n\", arg_pair->lhs,\n\t\t       arg_pair->operator, arg_pair->rhs,\n\t\t       arg_pair->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dynevent_arg_pair_add(struct dynevent_cmd *cmd,\n\t\t\t  struct dynevent_arg_pair *arg_pair,\n\t\t\t  dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg_pair);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c%s%c\", arg_pair->lhs,\n\t\t\t     arg_pair->operator, arg_pair->rhs,\n\t\t\t     arg_pair->separator);\n\tif (ret) {\n\t\tpr_err(\"field string is too long: %s%c%s%c\\n\", arg_pair->lhs,\n\t\t       arg_pair->operator, arg_pair->rhs,\n\t\t       arg_pair->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dynevent_arg_pair_init",
          "args": [
            "&arg_pair",
            "0",
            "';'"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "dynevent_arg_pair_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "457-469",
          "snippet": "void dynevent_arg_pair_init(struct dynevent_arg_pair *arg_pair,\n\t\t\t    char operator, char separator)\n{\n\tmemset(arg_pair, '\\0', sizeof(*arg_pair));\n\n\tif (!operator)\n\t\toperator = ' ';\n\targ_pair->operator = operator;\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ_pair->separator = separator;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nvoid dynevent_arg_pair_init(struct dynevent_arg_pair *arg_pair,\n\t\t\t    char operator, char separator)\n{\n\tmemset(arg_pair, '\\0', sizeof(*arg_pair));\n\n\tif (!operator)\n\t\toperator = ' ';\n\targ_pair->operator = operator;\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ_pair->separator = separator;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nint synth_event_add_field(struct dynevent_cmd *cmd, const char *type,\n\t\t\t  const char *name)\n{\n\tstruct dynevent_arg_pair arg_pair;\n\tint ret;\n\n\tif (cmd->type != DYNEVENT_TYPE_SYNTH)\n\t\treturn -EINVAL;\n\n\tif (!type || !name)\n\t\treturn -EINVAL;\n\n\tdynevent_arg_pair_init(&arg_pair, 0, ';');\n\n\targ_pair.lhs = type;\n\targ_pair.rhs = name;\n\n\tret = dynevent_arg_pair_add(cmd, &arg_pair, synth_event_check_arg_fn);\n\tif (ret)\n\t\treturn ret;\n\n\tif (++cmd->n_fields > SYNTH_FIELDS_MAX)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "synth_event_check_arg_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "908-920",
    "snippet": "static int synth_event_check_arg_fn(void *data)\n{\n\tstruct dynevent_arg_pair *arg_pair = data;\n\tint size;\n\n\tsize = synth_field_size((char *)arg_pair->lhs);\n\tif (size == 0) {\n\t\tif (strstr((char *)arg_pair->lhs, \"[\"))\n\t\t\treturn 0;\n\t}\n\n\treturn size ? 0 : -EINVAL;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "(char *)arg_pair->lhs",
            "\"[\""
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_field_size",
          "args": [
            "(char *)arg_pair->lhs"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "201-243",
          "snippet": "static int synth_field_size(char *type)\n{\n\tint size = 0;\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tsize = sizeof(s64);\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tsize = sizeof(u64);\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tsize = sizeof(s32);\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tsize = sizeof(u32);\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tsize = sizeof(s16);\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tsize = sizeof(u16);\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tsize = sizeof(s8);\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tsize = sizeof(u8);\n\telse if (strcmp(type, \"char\") == 0)\n\t\tsize = sizeof(char);\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tsize = sizeof(unsigned char);\n\telse if (strcmp(type, \"int\") == 0)\n\t\tsize = sizeof(int);\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tsize = sizeof(unsigned int);\n\telse if (strcmp(type, \"long\") == 0)\n\t\tsize = sizeof(long);\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tsize = sizeof(unsigned long);\n\telse if (strcmp(type, \"bool\") == 0)\n\t\tsize = sizeof(bool);\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tsize = sizeof(pid_t);\n\telse if (strcmp(type, \"gfp_t\") == 0)\n\t\tsize = sizeof(gfp_t);\n\telse if (synth_field_is_string(type))\n\t\tsize = synth_field_string_size(type);\n\n\treturn size;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_field_size(char *type)\n{\n\tint size = 0;\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tsize = sizeof(s64);\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tsize = sizeof(u64);\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tsize = sizeof(s32);\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tsize = sizeof(u32);\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tsize = sizeof(s16);\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tsize = sizeof(u16);\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tsize = sizeof(s8);\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tsize = sizeof(u8);\n\telse if (strcmp(type, \"char\") == 0)\n\t\tsize = sizeof(char);\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tsize = sizeof(unsigned char);\n\telse if (strcmp(type, \"int\") == 0)\n\t\tsize = sizeof(int);\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tsize = sizeof(unsigned int);\n\telse if (strcmp(type, \"long\") == 0)\n\t\tsize = sizeof(long);\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tsize = sizeof(unsigned long);\n\telse if (strcmp(type, \"bool\") == 0)\n\t\tsize = sizeof(bool);\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tsize = sizeof(pid_t);\n\telse if (strcmp(type, \"gfp_t\") == 0)\n\t\tsize = sizeof(gfp_t);\n\telse if (synth_field_is_string(type))\n\t\tsize = synth_field_string_size(type);\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_check_arg_fn(void *data)\n{\n\tstruct dynevent_arg_pair *arg_pair = data;\n\tint size;\n\n\tsize = synth_field_size((char *)arg_pair->lhs);\n\tif (size == 0) {\n\t\tif (strstr((char *)arg_pair->lhs, \"[\"))\n\t\t\treturn 0;\n\t}\n\n\treturn size ? 0 : -EINVAL;\n}"
  },
  {
    "function_name": "alloc_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "852-906",
    "snippet": "static struct synth_event *alloc_synth_event(const char *name, int n_fields,\n\t\t\t\t\t     struct synth_field **fields)\n{\n\tunsigned int i, j, n_dynamic_fields = 0;\n\tstruct synth_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event) {\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->name = kstrdup(name, GFP_KERNEL);\n\tif (!event->name) {\n\t\tkfree(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->fields = kcalloc(n_fields, sizeof(*event->fields), GFP_KERNEL);\n\tif (!event->fields) {\n\t\tfree_synth_event(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < n_fields; i++)\n\t\tif (fields[i]->is_dynamic)\n\t\t\tn_dynamic_fields++;\n\n\tif (n_dynamic_fields) {\n\t\tevent->dynamic_fields = kcalloc(n_dynamic_fields,\n\t\t\t\t\t\tsizeof(*event->dynamic_fields),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!event->dynamic_fields) {\n\t\t\tfree_synth_event(event);\n\t\t\tevent = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdyn_event_init(&event->devent, &synth_event_ops);\n\n\tfor (i = 0, j = 0; i < n_fields; i++) {\n\t\tfields[i]->field_pos = i;\n\t\tevent->fields[i] = fields[i];\n\n\t\tif (fields[i]->is_dynamic)\n\t\t\tevent->dynamic_fields[j++] = fields[i];\n\t}\n\tevent->n_dynamic_fields = j;\n\tevent->n_fields = n_fields;\n out:\n\treturn event;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dyn_event_operations synth_event_ops = {\n\t.create = create_synth_event,\n\t.show = synth_event_show,\n\t.is_busy = synth_event_is_busy,\n\t.free = synth_event_release,\n\t.match = synth_event_match,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dyn_event_init",
          "args": [
            "&event->devent",
            "&synth_event_ops"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.h",
          "lines": "68-77",
          "snippet": "static inline\nint dyn_event_init(struct dyn_event *ev, struct dyn_event_operations *ops)\n{\n\tif (!ev || !ops)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ev->list);\n\tev->ops = ops;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n\nstatic inline\nint dyn_event_init(struct dyn_event *ev, struct dyn_event_operations *ops)\n{\n\tif (!ev || !ops)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ev->list);\n\tev->ops = ops;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_synth_event",
          "args": [
            "event"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "833-850",
          "snippet": "static void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->dynamic_fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->dynamic_fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "n_dynamic_fields",
            "sizeof(*event->dynamic_fields)",
            "GFP_KERNEL"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "n_fields",
            "sizeof(*event->fields)",
            "GFP_KERNEL"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "event"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*event)",
            "GFP_KERNEL"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct dyn_event_operations synth_event_ops = {\n\t.create = create_synth_event,\n\t.show = synth_event_show,\n\t.is_busy = synth_event_is_busy,\n\t.free = synth_event_release,\n\t.match = synth_event_match,\n};\n\nstatic struct synth_event *alloc_synth_event(const char *name, int n_fields,\n\t\t\t\t\t     struct synth_field **fields)\n{\n\tunsigned int i, j, n_dynamic_fields = 0;\n\tstruct synth_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event) {\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->name = kstrdup(name, GFP_KERNEL);\n\tif (!event->name) {\n\t\tkfree(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->fields = kcalloc(n_fields, sizeof(*event->fields), GFP_KERNEL);\n\tif (!event->fields) {\n\t\tfree_synth_event(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < n_fields; i++)\n\t\tif (fields[i]->is_dynamic)\n\t\t\tn_dynamic_fields++;\n\n\tif (n_dynamic_fields) {\n\t\tevent->dynamic_fields = kcalloc(n_dynamic_fields,\n\t\t\t\t\t\tsizeof(*event->dynamic_fields),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!event->dynamic_fields) {\n\t\t\tfree_synth_event(event);\n\t\t\tevent = ERR_PTR(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdyn_event_init(&event->devent, &synth_event_ops);\n\n\tfor (i = 0, j = 0; i < n_fields; i++) {\n\t\tfields[i]->field_pos = i;\n\t\tevent->fields[i] = fields[i];\n\n\t\tif (fields[i]->is_dynamic)\n\t\t\tevent->dynamic_fields[j++] = fields[i];\n\t}\n\tevent->n_dynamic_fields = j;\n\tevent->n_fields = n_fields;\n out:\n\treturn event;\n}"
  },
  {
    "function_name": "free_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "833-850",
    "snippet": "static void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->dynamic_fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "event"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_synth_event_print_fmt",
          "args": [
            "&event->call"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_event_print_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "513-519",
          "snippet": "static void free_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tif (call) {\n\t\tkfree(call->print_fmt);\n\t\tcall->print_fmt = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tif (call) {\n\t\tkfree(call->print_fmt);\n\t\tcall->print_fmt = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_synth_tracepoint",
          "args": [
            "event->tp"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_tracepoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "722-729",
          "snippet": "static void free_synth_tracepoint(struct tracepoint *tp)\n{\n\tif (!tp)\n\t\treturn;\n\n\tkfree(tp->name);\n\tkfree(tp);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_tracepoint(struct tracepoint *tp)\n{\n\tif (!tp)\n\t\treturn;\n\n\tkfree(tp->name);\n\tkfree(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_synth_field",
          "args": [
            "event->fields[i]"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "576-581",
          "snippet": "static void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->dynamic_fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}"
  },
  {
    "function_name": "unregister_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "823-831",
    "snippet": "static int unregister_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret;\n\n\tret = trace_remove_event_call(call);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_remove_event_call",
          "args": [
            "call"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "trace_remove_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2808-2821",
          "snippet": "int trace_remove_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tmutex_lock(&trace_types_lock);\n\tdown_write(&trace_event_sem);\n\tret = probe_remove_event_call(call);\n\tup_write(&trace_event_sem);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_remove_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tmutex_lock(&trace_types_lock);\n\tdown_write(&trace_event_sem);\n\tret = probe_remove_event_call(call);\n\tup_write(&trace_event_sem);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int unregister_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret;\n\n\tret = trace_remove_event_call(call);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "register_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "770-821",
    "snippet": "static int register_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret = 0;\n\n\tevent->call.class = &event->class;\n\tevent->class.system = kstrdup(SYNTH_SYSTEM, GFP_KERNEL);\n\tif (!event->class.system) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tevent->tp = alloc_synth_tracepoint(event->name);\n\tif (IS_ERR(event->tp)) {\n\t\tret = PTR_ERR(event->tp);\n\t\tevent->tp = NULL;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&call->class->fields);\n\tcall->event.funcs = &synth_event_funcs;\n\tcall->class->fields_array = synth_event_fields_array;\n\n\tret = register_trace_event(&call->event);\n\tif (!ret) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tcall->flags = TRACE_EVENT_FL_TRACEPOINT;\n\tcall->class->reg = trace_event_reg;\n\tcall->class->probe = trace_event_raw_event_synth;\n\tcall->data = event;\n\tcall->tp = event->tp;\n\n\tret = trace_add_event_call(call);\n\tif (ret) {\n\t\tpr_warn(\"Failed to register synthetic event: %s\\n\",\n\t\t\ttrace_event_name(call));\n\t\tgoto err;\n\t}\n\n\tret = set_synth_event_print_fmt(call);\n\tif (ret < 0) {\n\t\ttrace_remove_event_call(call);\n\t\tgoto err;\n\t}\n out:\n\treturn ret;\n err:\n\tunregister_trace_event(&call->event);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_event_functions synth_event_funcs = {\n\t.trace\t\t= print_synth_event\n};",
      "static struct trace_event_fields synth_event_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = synth_event_define_fields },\n\t{}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_event",
          "args": [
            "&call->event"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "826-833",
          "snippet": "int unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_remove_event_call",
          "args": [
            "call"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "trace_remove_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2808-2821",
          "snippet": "int trace_remove_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tmutex_lock(&trace_types_lock);\n\tdown_write(&trace_event_sem);\n\tret = probe_remove_event_call(call);\n\tup_write(&trace_event_sem);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_remove_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tmutex_lock(&trace_types_lock);\n\tdown_write(&trace_event_sem);\n\tret = probe_remove_event_call(call);\n\tup_write(&trace_event_sem);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_synth_event_print_fmt",
          "args": [
            "call"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "set_synth_event_print_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "556-574",
          "snippet": "static int set_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tstruct synth_event *event = call->data;\n\tchar *print_fmt;\n\tint len;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_synth_event_print_fmt(event, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_synth_event_print_fmt(event, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int set_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tstruct synth_event *event = call->data;\n\tchar *print_fmt;\n\tint len;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_synth_event_print_fmt(event, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_synth_event_print_fmt(event, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to register synthetic event: %s\\n\"",
            "trace_event_name(call)"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_add_event_call",
          "args": [
            "call"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "trace_add_event_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2747-2760",
          "snippet": "int trace_add_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\tlockdep_assert_held(&event_mutex);\n\n\tmutex_lock(&trace_types_lock);\n\n\tret = __register_event(call, NULL);\n\tif (ret >= 0)\n\t\t__add_event_to_tracers(call);\n\n\tmutex_unlock(&trace_types_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_add_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\tlockdep_assert_held(&event_mutex);\n\n\tmutex_lock(&trace_types_lock);\n\n\tret = __register_event(call, NULL);\n\tif (ret >= 0)\n\t\t__add_event_to_tracers(call);\n\n\tmutex_unlock(&trace_types_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&call->class->fields"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "event->tp"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "event->tp"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_synth_tracepoint",
          "args": [
            "event->name"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_synth_tracepoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "731-746",
          "snippet": "static struct tracepoint *alloc_synth_tracepoint(char *name)\n{\n\tstruct tracepoint *tp;\n\n\ttp = kzalloc(sizeof(*tp), GFP_KERNEL);\n\tif (!tp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttp->name = kstrdup(name, GFP_KERNEL);\n\tif (!tp->name) {\n\t\tkfree(tp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn tp;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct tracepoint *alloc_synth_tracepoint(char *name)\n{\n\tstruct tracepoint *tp;\n\n\ttp = kzalloc(sizeof(*tp), GFP_KERNEL);\n\tif (!tp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttp->name = kstrdup(name, GFP_KERNEL);\n\tif (!tp->name) {\n\t\tkfree(tp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "SYNTH_SYSTEM",
            "GFP_KERNEL"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_event_functions synth_event_funcs = {\n\t.trace\t\t= print_synth_event\n};\nstatic struct trace_event_fields synth_event_fields_array[] = {\n\t{ .type = TRACE_FUNCTION_TYPE,\n\t  .define_fields = synth_event_define_fields },\n\t{}\n};\n\nstatic int register_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret = 0;\n\n\tevent->call.class = &event->class;\n\tevent->class.system = kstrdup(SYNTH_SYSTEM, GFP_KERNEL);\n\tif (!event->class.system) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tevent->tp = alloc_synth_tracepoint(event->name);\n\tif (IS_ERR(event->tp)) {\n\t\tret = PTR_ERR(event->tp);\n\t\tevent->tp = NULL;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&call->class->fields);\n\tcall->event.funcs = &synth_event_funcs;\n\tcall->class->fields_array = synth_event_fields_array;\n\n\tret = register_trace_event(&call->event);\n\tif (!ret) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tcall->flags = TRACE_EVENT_FL_TRACEPOINT;\n\tcall->class->reg = trace_event_reg;\n\tcall->class->probe = trace_event_raw_event_synth;\n\tcall->data = event;\n\tcall->tp = event->tp;\n\n\tret = trace_add_event_call(call);\n\tif (ret) {\n\t\tpr_warn(\"Failed to register synthetic event: %s\\n\",\n\t\t\ttrace_event_name(call));\n\t\tgoto err;\n\t}\n\n\tret = set_synth_event_print_fmt(call);\n\tif (ret < 0) {\n\t\ttrace_remove_event_call(call);\n\t\tgoto err;\n\t}\n out:\n\treturn ret;\n err:\n\tunregister_trace_event(&call->event);\n\tgoto out;\n}"
  },
  {
    "function_name": "find_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "748-762",
    "snippet": "struct synth_event *find_synth_event(const char *name)\n{\n\tstruct dyn_event *pos;\n\tstruct synth_event *event;\n\n\tfor_each_dyn_event(pos) {\n\t\tif (!is_synth_event(pos))\n\t\t\tcontinue;\n\t\tevent = to_synth_event(pos);\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "event->name",
            "name"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_synth_event",
          "args": [
            "pos"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "to_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "86-89",
          "snippet": "static struct synth_event *to_synth_event(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct synth_event, devent);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int synth_event_show(struct seq_file *m, struct dyn_event *ev);",
            "static int synth_event_release(struct dyn_event *ev);",
            "static bool synth_event_is_busy(struct dyn_event *ev);",
            "static bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev);\nstatic int synth_event_release(struct dyn_event *ev);\nstatic bool synth_event_is_busy(struct dyn_event *ev);\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\n\nstatic struct synth_event *to_synth_event(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct synth_event, devent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_synth_event",
          "args": [
            "pos"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "is_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "81-84",
          "snippet": "static bool is_synth_event(struct dyn_event *ev)\n{\n\treturn ev->ops == &synth_event_ops;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int synth_event_show(struct seq_file *m, struct dyn_event *ev);",
            "static int synth_event_release(struct dyn_event *ev);",
            "static bool synth_event_is_busy(struct dyn_event *ev);",
            "static bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
            "static struct dyn_event_operations synth_event_ops = {\n\t.create = create_synth_event,\n\t.show = synth_event_show,\n\t.is_busy = synth_event_is_busy,\n\t.free = synth_event_release,\n\t.match = synth_event_match,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev);\nstatic int synth_event_release(struct dyn_event *ev);\nstatic bool synth_event_is_busy(struct dyn_event *ev);\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic struct dyn_event_operations synth_event_ops = {\n\t.create = create_synth_event,\n\t.show = synth_event_show,\n\t.is_busy = synth_event_is_busy,\n\t.free = synth_event_release,\n\t.match = synth_event_match,\n};\n\nstatic bool is_synth_event(struct dyn_event *ev)\n{\n\treturn ev->ops == &synth_event_ops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstruct synth_event *find_synth_event(const char *name)\n{\n\tstruct dyn_event *pos;\n\tstruct synth_event *event;\n\n\tfor_each_dyn_event(pos) {\n\t\tif (!is_synth_event(pos))\n\t\t\tcontinue;\n\t\tevent = to_synth_event(pos);\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "alloc_synth_tracepoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "731-746",
    "snippet": "static struct tracepoint *alloc_synth_tracepoint(char *name)\n{\n\tstruct tracepoint *tp;\n\n\ttp = kzalloc(sizeof(*tp), GFP_KERNEL);\n\tif (!tp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttp->name = kstrdup(name, GFP_KERNEL);\n\tif (!tp->name) {\n\t\tkfree(tp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn tp;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tp"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tp)",
            "GFP_KERNEL"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct tracepoint *alloc_synth_tracepoint(char *name)\n{\n\tstruct tracepoint *tp;\n\n\ttp = kzalloc(sizeof(*tp), GFP_KERNEL);\n\tif (!tp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttp->name = kstrdup(name, GFP_KERNEL);\n\tif (!tp->name) {\n\t\tkfree(tp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn tp;\n}"
  },
  {
    "function_name": "free_synth_tracepoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "722-729",
    "snippet": "static void free_synth_tracepoint(struct tracepoint *tp)\n{\n\tif (!tp)\n\t\treturn;\n\n\tkfree(tp->name);\n\tkfree(tp);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tp"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_tracepoint(struct tracepoint *tp)\n{\n\tif (!tp)\n\t\treturn;\n\n\tkfree(tp->name);\n\tkfree(tp);\n}"
  },
  {
    "function_name": "parse_synth_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "600-720",
    "snippet": "static struct synth_field *parse_synth_field(int argc, char **argv,\n\t\t\t\t\t     int *consumed, int *field_version)\n{\n\tconst char *prefix = NULL, *field_type = argv[0], *field_name, *array;\n\tstruct synth_field *field;\n\tint len, ret = -ENOMEM;\n\tstruct seq_buf s;\n\tssize_t size;\n\n\tif (!strcmp(field_type, \"unsigned\")) {\n\t\tif (argc < 3) {\n\t\t\tsynth_err(SYNTH_ERR_INCOMPLETE_TYPE, errpos(field_type));\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tprefix = \"unsigned \";\n\t\tfield_type = argv[1];\n\t\tfield_name = argv[2];\n\t\t*consumed += 3;\n\t} else {\n\t\tfield_name = argv[1];\n\t\t*consumed += 2;\n\t}\n\n\tif (!field_name) {\n\t\tsynth_err(SYNTH_ERR_INVALID_FIELD, errpos(field_type));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t*field_version = check_field_version(prefix, field_type, field_name);\n\n\tfield = kzalloc(sizeof(*field), GFP_KERNEL);\n\tif (!field)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlen = strlen(field_name);\n\tarray = strchr(field_name, '[');\n\tif (array)\n\t\tlen -= strlen(array);\n\n\tfield->name = kmemdup_nul(field_name, len, GFP_KERNEL);\n\tif (!field->name)\n\t\tgoto free;\n\n\tif (!is_good_name(field->name)) {\n\t\tsynth_err(SYNTH_ERR_BAD_NAME, errpos(field_name));\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tlen = strlen(field_type) + 1;\n\n\tif (array)\n\t\tlen += strlen(array);\n\n\tif (prefix)\n\t\tlen += strlen(prefix);\n\n\tfield->type = kzalloc(len, GFP_KERNEL);\n\tif (!field->type)\n\t\tgoto free;\n\n\tseq_buf_init(&s, field->type, len);\n\tif (prefix)\n\t\tseq_buf_puts(&s, prefix);\n\tseq_buf_puts(&s, field_type);\n\tif (array)\n\t\tseq_buf_puts(&s, array);\n\tif (WARN_ON_ONCE(!seq_buf_buffer_left(&s)))\n\t\tgoto free;\n\n\ts.buffer[s.len] = '\\0';\n\n\tsize = synth_field_size(field->type);\n\tif (size < 0) {\n\t\tif (array)\n\t\t\tsynth_err(SYNTH_ERR_INVALID_ARRAY_SPEC, errpos(field_name));\n\t\telse\n\t\t\tsynth_err(SYNTH_ERR_INVALID_TYPE, errpos(field_type));\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t} else if (size == 0) {\n\t\tif (synth_field_is_string(field->type)) {\n\t\t\tchar *type;\n\n\t\t\tlen = sizeof(\"__data_loc \") + strlen(field->type) + 1;\n\t\t\ttype = kzalloc(len, GFP_KERNEL);\n\t\t\tif (!type)\n\t\t\t\tgoto free;\n\n\t\t\tseq_buf_init(&s, type, len);\n\t\t\tseq_buf_puts(&s, \"__data_loc \");\n\t\t\tseq_buf_puts(&s, field->type);\n\n\t\t\tif (WARN_ON_ONCE(!seq_buf_buffer_left(&s)))\n\t\t\t\tgoto free;\n\t\t\ts.buffer[s.len] = '\\0';\n\n\t\t\tkfree(field->type);\n\t\t\tfield->type = type;\n\n\t\t\tfield->is_dynamic = true;\n\t\t\tsize = sizeof(u64);\n\t\t} else {\n\t\t\tsynth_err(SYNTH_ERR_INVALID_TYPE, errpos(field_type));\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t}\n\tfield->size = size;\n\n\tif (synth_field_is_string(field->type))\n\t\tfield->is_string = true;\n\n\tfield->is_signed = synth_field_signed(field->type);\n out:\n\treturn field;\n free:\n\tfree_synth_field(field);\n\tfield = ERR_PTR(ret);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_synth_field",
          "args": [
            "field"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "576-581",
          "snippet": "static void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_field_signed",
          "args": [
            "field->type"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_signed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "148-156",
          "snippet": "static bool synth_field_signed(char *type)\n{\n\tif (str_has_prefix(type, \"u\"))\n\t\treturn false;\n\tif (strcmp(type, \"gfp_t\") == 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool synth_field_signed(char *type)\n{\n\tif (str_has_prefix(type, \"u\"))\n\t\treturn false;\n\tif (strcmp(type, \"gfp_t\") == 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_field_is_string",
          "args": [
            "field->type"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_is_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "158-164",
          "snippet": "static int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_err",
          "args": [
            "SYNTH_ERR_INVALID_TYPE",
            "errpos(field_type)"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "synth_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "60-64",
          "snippet": "static void synth_err(u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(NULL, \"synthetic_events\", last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *err_text[] = { ERRORS };",
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic void synth_err(u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(NULL, \"synthetic_events\", last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errpos",
          "args": [
            "field_type"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "errpos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "47-50",
          "snippet": "static int errpos(const char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(const char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "field->type"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!seq_buf_buffer_left(&s)"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_buffer_left",
          "args": [
            "&s"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_puts",
          "args": [
            "&s",
            "field->type"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_puts",
          "args": [
            "&s",
            "\"__data_loc \""
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_init",
          "args": [
            "&s",
            "type",
            "len"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "field->type"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_field_size",
          "args": [
            "field->type"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "201-243",
          "snippet": "static int synth_field_size(char *type)\n{\n\tint size = 0;\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tsize = sizeof(s64);\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tsize = sizeof(u64);\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tsize = sizeof(s32);\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tsize = sizeof(u32);\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tsize = sizeof(s16);\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tsize = sizeof(u16);\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tsize = sizeof(s8);\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tsize = sizeof(u8);\n\telse if (strcmp(type, \"char\") == 0)\n\t\tsize = sizeof(char);\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tsize = sizeof(unsigned char);\n\telse if (strcmp(type, \"int\") == 0)\n\t\tsize = sizeof(int);\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tsize = sizeof(unsigned int);\n\telse if (strcmp(type, \"long\") == 0)\n\t\tsize = sizeof(long);\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tsize = sizeof(unsigned long);\n\telse if (strcmp(type, \"bool\") == 0)\n\t\tsize = sizeof(bool);\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tsize = sizeof(pid_t);\n\telse if (strcmp(type, \"gfp_t\") == 0)\n\t\tsize = sizeof(gfp_t);\n\telse if (synth_field_is_string(type))\n\t\tsize = synth_field_string_size(type);\n\n\treturn size;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_field_size(char *type)\n{\n\tint size = 0;\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tsize = sizeof(s64);\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tsize = sizeof(u64);\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tsize = sizeof(s32);\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tsize = sizeof(u32);\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tsize = sizeof(s16);\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tsize = sizeof(u16);\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tsize = sizeof(s8);\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tsize = sizeof(u8);\n\telse if (strcmp(type, \"char\") == 0)\n\t\tsize = sizeof(char);\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tsize = sizeof(unsigned char);\n\telse if (strcmp(type, \"int\") == 0)\n\t\tsize = sizeof(int);\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tsize = sizeof(unsigned int);\n\telse if (strcmp(type, \"long\") == 0)\n\t\tsize = sizeof(long);\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tsize = sizeof(unsigned long);\n\telse if (strcmp(type, \"bool\") == 0)\n\t\tsize = sizeof(bool);\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tsize = sizeof(pid_t);\n\telse if (strcmp(type, \"gfp_t\") == 0)\n\t\tsize = sizeof(gfp_t);\n\telse if (synth_field_is_string(type))\n\t\tsize = synth_field_string_size(type);\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!seq_buf_buffer_left(&s)"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_buffer_left",
          "args": [
            "&s"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_puts",
          "args": [
            "&s",
            "array"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_puts",
          "args": [
            "&s",
            "field_type"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_puts",
          "args": [
            "&s",
            "prefix"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_init",
          "args": [
            "&s",
            "field->type",
            "len"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_good_name",
          "args": [
            "field->name"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "is_good_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1976-1985",
          "snippet": "static inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_good_name(const char *name)\n{\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn false;\n\twhile (*++name != '\\0') {\n\t\tif (!isalpha(*name) && !isdigit(*name) && *name != '_')\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup_nul",
          "args": [
            "field_name",
            "len",
            "GFP_KERNEL"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "field_name",
            "'['"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*field)",
            "GFP_KERNEL"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_field_version",
          "args": [
            "prefix",
            "field_type",
            "field_name"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "check_field_version",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "583-598",
          "snippet": "static int check_field_version(const char *prefix, const char *field_type,\n\t\t\t       const char *field_name)\n{\n\t/*\n\t * For backward compatibility, the old synthetic event command\n\t * format did not require semicolons, and in order to not\n\t * break user space, that old format must still work. If a new\n\t * feature is added, then the format that uses the new feature\n\t * will be required to have semicolons, as nothing that uses\n\t * the old format would be using the new, yet to be created,\n\t * feature. When a new feature is added, this will detect it,\n\t * and return a number greater than 1, and require the format\n\t * to use semicolons.\n\t */\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int check_field_version(const char *prefix, const char *field_type,\n\t\t\t       const char *field_name)\n{\n\t/*\n\t * For backward compatibility, the old synthetic event command\n\t * format did not require semicolons, and in order to not\n\t * break user space, that old format must still work. If a new\n\t * feature is added, then the format that uses the new feature\n\t * will be required to have semicolons, as nothing that uses\n\t * the old format would be using the new, yet to be created,\n\t * feature. When a new feature is added, this will detect it,\n\t * and return a number greater than 1, and require the format\n\t * to use semicolons.\n\t */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field_type",
            "\"unsigned\""
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct synth_field *parse_synth_field(int argc, char **argv,\n\t\t\t\t\t     int *consumed, int *field_version)\n{\n\tconst char *prefix = NULL, *field_type = argv[0], *field_name, *array;\n\tstruct synth_field *field;\n\tint len, ret = -ENOMEM;\n\tstruct seq_buf s;\n\tssize_t size;\n\n\tif (!strcmp(field_type, \"unsigned\")) {\n\t\tif (argc < 3) {\n\t\t\tsynth_err(SYNTH_ERR_INCOMPLETE_TYPE, errpos(field_type));\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tprefix = \"unsigned \";\n\t\tfield_type = argv[1];\n\t\tfield_name = argv[2];\n\t\t*consumed += 3;\n\t} else {\n\t\tfield_name = argv[1];\n\t\t*consumed += 2;\n\t}\n\n\tif (!field_name) {\n\t\tsynth_err(SYNTH_ERR_INVALID_FIELD, errpos(field_type));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t*field_version = check_field_version(prefix, field_type, field_name);\n\n\tfield = kzalloc(sizeof(*field), GFP_KERNEL);\n\tif (!field)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlen = strlen(field_name);\n\tarray = strchr(field_name, '[');\n\tif (array)\n\t\tlen -= strlen(array);\n\n\tfield->name = kmemdup_nul(field_name, len, GFP_KERNEL);\n\tif (!field->name)\n\t\tgoto free;\n\n\tif (!is_good_name(field->name)) {\n\t\tsynth_err(SYNTH_ERR_BAD_NAME, errpos(field_name));\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tlen = strlen(field_type) + 1;\n\n\tif (array)\n\t\tlen += strlen(array);\n\n\tif (prefix)\n\t\tlen += strlen(prefix);\n\n\tfield->type = kzalloc(len, GFP_KERNEL);\n\tif (!field->type)\n\t\tgoto free;\n\n\tseq_buf_init(&s, field->type, len);\n\tif (prefix)\n\t\tseq_buf_puts(&s, prefix);\n\tseq_buf_puts(&s, field_type);\n\tif (array)\n\t\tseq_buf_puts(&s, array);\n\tif (WARN_ON_ONCE(!seq_buf_buffer_left(&s)))\n\t\tgoto free;\n\n\ts.buffer[s.len] = '\\0';\n\n\tsize = synth_field_size(field->type);\n\tif (size < 0) {\n\t\tif (array)\n\t\t\tsynth_err(SYNTH_ERR_INVALID_ARRAY_SPEC, errpos(field_name));\n\t\telse\n\t\t\tsynth_err(SYNTH_ERR_INVALID_TYPE, errpos(field_type));\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t} else if (size == 0) {\n\t\tif (synth_field_is_string(field->type)) {\n\t\t\tchar *type;\n\n\t\t\tlen = sizeof(\"__data_loc \") + strlen(field->type) + 1;\n\t\t\ttype = kzalloc(len, GFP_KERNEL);\n\t\t\tif (!type)\n\t\t\t\tgoto free;\n\n\t\t\tseq_buf_init(&s, type, len);\n\t\t\tseq_buf_puts(&s, \"__data_loc \");\n\t\t\tseq_buf_puts(&s, field->type);\n\n\t\t\tif (WARN_ON_ONCE(!seq_buf_buffer_left(&s)))\n\t\t\t\tgoto free;\n\t\t\ts.buffer[s.len] = '\\0';\n\n\t\t\tkfree(field->type);\n\t\t\tfield->type = type;\n\n\t\t\tfield->is_dynamic = true;\n\t\t\tsize = sizeof(u64);\n\t\t} else {\n\t\t\tsynth_err(SYNTH_ERR_INVALID_TYPE, errpos(field_type));\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t}\n\tfield->size = size;\n\n\tif (synth_field_is_string(field->type))\n\t\tfield->is_string = true;\n\n\tfield->is_signed = synth_field_signed(field->type);\n out:\n\treturn field;\n free:\n\tfree_synth_field(field);\n\tfield = ERR_PTR(ret);\n\tgoto out;\n}"
  },
  {
    "function_name": "check_field_version",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "583-598",
    "snippet": "static int check_field_version(const char *prefix, const char *field_type,\n\t\t\t       const char *field_name)\n{\n\t/*\n\t * For backward compatibility, the old synthetic event command\n\t * format did not require semicolons, and in order to not\n\t * break user space, that old format must still work. If a new\n\t * feature is added, then the format that uses the new feature\n\t * will be required to have semicolons, as nothing that uses\n\t * the old format would be using the new, yet to be created,\n\t * feature. When a new feature is added, this will detect it,\n\t * and return a number greater than 1, and require the format\n\t * to use semicolons.\n\t */\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int check_field_version(const char *prefix, const char *field_type,\n\t\t\t       const char *field_name)\n{\n\t/*\n\t * For backward compatibility, the old synthetic event command\n\t * format did not require semicolons, and in order to not\n\t * break user space, that old format must still work. If a new\n\t * feature is added, then the format that uses the new feature\n\t * will be required to have semicolons, as nothing that uses\n\t * the old format would be using the new, yet to be created,\n\t * feature. When a new feature is added, this will detect it,\n\t * and return a number greater than 1, and require the format\n\t * to use semicolons.\n\t */\n\treturn 1;\n}"
  },
  {
    "function_name": "free_synth_field",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "576-581",
    "snippet": "static void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "field"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}"
  },
  {
    "function_name": "set_synth_event_print_fmt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "556-574",
    "snippet": "static int set_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tstruct synth_event *event = call->data;\n\tchar *print_fmt;\n\tint len;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_synth_event_print_fmt(event, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_synth_event_print_fmt(event, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_synth_event_print_fmt",
          "args": [
            "event",
            "print_fmt",
            "len + 1"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "__set_synth_event_print_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "521-554",
          "snippet": "static int __set_synth_event_print_fmt(struct synth_event *event,\n\t\t\t\t       char *buf, int len)\n{\n\tconst char *fmt;\n\tint pos = 0;\n\tint i;\n\n\t/* When len=0, we just calculate the needed length */\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfmt = synth_field_fmt(event->fields[i]->type);\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s=%s%s\",\n\t\t\t\tevent->fields[i]->name, fmt,\n\t\t\t\ti == event->n_fields - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tif (event->fields[i]->is_string &&\n\t\t    event->fields[i]->is_dynamic)\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", __get_str(%s)\", event->fields[i]->name);\n\t\telse\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\t\", REC->%s\", event->fields[i]->name);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LEN_OR_ZERO (len ? len - pos : 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\nstatic int __set_synth_event_print_fmt(struct synth_event *event,\n\t\t\t\t       char *buf, int len)\n{\n\tconst char *fmt;\n\tint pos = 0;\n\tint i;\n\n\t/* When len=0, we just calculate the needed length */\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfmt = synth_field_fmt(event->fields[i]->type);\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s=%s%s\",\n\t\t\t\tevent->fields[i]->name, fmt,\n\t\t\t\ti == event->n_fields - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tif (event->fields[i]->is_string &&\n\t\t    event->fields[i]->is_dynamic)\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", __get_str(%s)\", event->fields[i]->name);\n\t\telse\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\t\", REC->%s\", event->fields[i]->name);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + 1",
            "GFP_KERNEL"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int set_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tstruct synth_event *event = call->data;\n\tchar *print_fmt;\n\tint len;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_synth_event_print_fmt(event, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_synth_event_print_fmt(event, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__set_synth_event_print_fmt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "521-554",
    "snippet": "static int __set_synth_event_print_fmt(struct synth_event *event,\n\t\t\t\t       char *buf, int len)\n{\n\tconst char *fmt;\n\tint pos = 0;\n\tint i;\n\n\t/* When len=0, we just calculate the needed length */\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfmt = synth_field_fmt(event->fields[i]->type);\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s=%s%s\",\n\t\t\t\tevent->fields[i]->name, fmt,\n\t\t\t\ti == event->n_fields - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tif (event->fields[i]->is_string &&\n\t\t    event->fields[i]->is_dynamic)\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", __get_str(%s)\", event->fields[i]->name);\n\t\telse\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\t\", REC->%s\", event->fields[i]->name);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define LEN_OR_ZERO (len ? len - pos : 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\", REC->%s\"",
            "event->fields[i]->name"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\", __get_str(%s)\"",
            "event->fields[i]->name"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"\\\"\""
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "btf_snprintf_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5972-5992",
          "snippet": "static void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"%s=%s%s\"",
            "event->fields[i]->name",
            "fmt",
            "i == event->n_fields - 1 ? \"\" : \", \""
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_snprintf_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5994-6013",
          "snippet": "int btf_type_snprintf_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t   char *buf, int len, u64 flags)\n{\n\tstruct btf_show_snprintf ssnprintf;\n\n\tssnprintf.show.target = buf;\n\tssnprintf.show.flags = flags;\n\tssnprintf.show.showfn = btf_snprintf_show;\n\tssnprintf.len_left = len;\n\tssnprintf.len = 0;\n\n\tbtf_type_show(btf, type_id, obj, (struct btf_show *)&ssnprintf);\n\n\t/* If we encontered an error, return it. */\n\tif (ssnprintf.show.state.status)\n\t\treturn ssnprintf.show.state.status;\n\n\t/* Otherwise return length we would have written */\n\treturn ssnprintf.len;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nint btf_type_snprintf_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t   char *buf, int len, u64 flags)\n{\n\tstruct btf_show_snprintf ssnprintf;\n\n\tssnprintf.show.target = buf;\n\tssnprintf.show.flags = flags;\n\tssnprintf.show.showfn = btf_snprintf_show;\n\tssnprintf.len_left = len;\n\tssnprintf.len = 0;\n\n\tbtf_type_show(btf, type_id, obj, (struct btf_show *)&ssnprintf);\n\n\t/* If we encontered an error, return it. */\n\tif (ssnprintf.show.state.status)\n\t\treturn ssnprintf.show.state.status;\n\n\t/* Otherwise return length we would have written */\n\treturn ssnprintf.len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_field_fmt",
          "args": [
            "event->fields[i]->type"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "245-287",
          "snippet": "static const char *synth_field_fmt(char *type)\n{\n\tconst char *fmt = \"%llu\";\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tfmt = \"%lld\";\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tfmt = \"%llu\";\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"char\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"int\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"long\") == 0)\n\t\tfmt = \"%ld\";\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tfmt = \"%lu\";\n\telse if (strcmp(type, \"bool\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"gfp_t\") == 0)\n\t\tfmt = \"%x\";\n\telse if (synth_field_is_string(type))\n\t\tfmt = \"%.*s\";\n\n\treturn fmt;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *synth_field_fmt(char *type)\n{\n\tconst char *fmt = \"%llu\";\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tfmt = \"%lld\";\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tfmt = \"%llu\";\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"char\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"int\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"long\") == 0)\n\t\tfmt = \"%ld\";\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tfmt = \"%lu\";\n\telse if (strcmp(type, \"bool\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"gfp_t\") == 0)\n\t\tfmt = \"%x\";\n\telse if (synth_field_is_string(type))\n\t\tfmt = \"%.*s\";\n\n\treturn fmt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\nstatic int __set_synth_event_print_fmt(struct synth_event *event,\n\t\t\t\t       char *buf, int len)\n{\n\tconst char *fmt;\n\tint pos = 0;\n\tint i;\n\n\t/* When len=0, we just calculate the needed length */\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfmt = synth_field_fmt(event->fields[i]->type);\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s=%s%s\",\n\t\t\t\tevent->fields[i]->name, fmt,\n\t\t\t\ti == event->n_fields - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tif (event->fields[i]->is_string &&\n\t\t    event->fields[i]->is_dynamic)\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", __get_str(%s)\", event->fields[i]->name);\n\t\telse\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\t\", REC->%s\", event->fields[i]->name);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}"
  },
  {
    "function_name": "free_synth_event_print_fmt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "513-519",
    "snippet": "static void free_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tif (call) {\n\t\tkfree(call->print_fmt);\n\t\tcall->print_fmt = NULL;\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "call->print_fmt"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tif (call) {\n\t\tkfree(call->print_fmt);\n\t\tcall->print_fmt = NULL;\n\t}\n}"
  },
  {
    "function_name": "trace_event_raw_event_synth",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "431-511",
    "snippet": "static notrace void trace_event_raw_event_synth(void *__data,\n\t\t\t\t\t\tu64 *var_ref_vals,\n\t\t\t\t\t\tunsigned int *var_ref_idx)\n{\n\tunsigned int i, n_u64, val_idx, len, data_size = 0;\n\tstruct trace_event_file *trace_file = __data;\n\tstruct synth_trace_event *entry;\n\tstruct trace_event_buffer fbuffer;\n\tstruct trace_buffer *buffer;\n\tstruct synth_event *event;\n\tint fields_size = 0;\n\n\tevent = trace_file->event_call->data;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tfields_size = event->n_u64 * sizeof(u64);\n\n\tfor (i = 0; i < event->n_dynamic_fields; i++) {\n\t\tunsigned int field_pos = event->dynamic_fields[i]->field_pos;\n\t\tchar *str_val;\n\n\t\tval_idx = var_ref_idx[field_pos];\n\t\tstr_val = (char *)(long)var_ref_vals[val_idx];\n\n\t\tlen = strlen(str_val) + 1;\n\n\t\tfields_size += len;\n\t}\n\n\t/*\n\t * Avoid ring buffer recursion detection, as this event\n\t * is being performed within another event.\n\t */\n\tbuffer = trace_file->tr->array_buffer.buffer;\n\tring_buffer_nest_start(buffer);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,\n\t\t\t\t\t   sizeof(*entry) + fields_size);\n\tif (!entry)\n\t\tgoto out;\n\n\tfor (i = 0, n_u64 = 0; i < event->n_fields; i++) {\n\t\tval_idx = var_ref_idx[i];\n\t\tif (event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)var_ref_vals[val_idx];\n\n\t\t\tlen = trace_string(entry, event, str_val,\n\t\t\t\t\t   event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len; /* only dynamic string increments */\n\t\t} else {\n\t\t\tstruct synth_field *field = event->fields[i];\n\t\t\tu64 val = var_ref_vals[val_idx];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\t*(u8 *)&entry->fields[n_u64] = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t*(u16 *)&entry->fields[n_u64] = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\t*(u32 *)&entry->fields[n_u64] = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tentry->fields[n_u64] = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\n\n\ttrace_event_buffer_commit(&fbuffer);\nout:\n\tring_buffer_nest_end(buffer);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_nest_end",
          "args": [
            "buffer"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_nest_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "3236-3247",
          "snippet": "void ring_buffer_nest_end(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\t/* disabled by ring_buffer_nest_start() */\n\tcpu = raw_smp_processor_id();\n\tcpu_buffer = buffer->buffers[cpu];\n\t/* This is the shift value for the above recursive locking */\n\tcpu_buffer->nest -= NESTED_BITS;\n\tpreempt_enable_notrace();\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [
            "#define NESTED_BITS 5"
          ],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\n#define NESTED_BITS 5\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid ring_buffer_nest_end(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\t/* disabled by ring_buffer_nest_start() */\n\tcpu = raw_smp_processor_id();\n\tcpu_buffer = buffer->buffers[cpu];\n\t/* This is the shift value for the above recursive locking */\n\tcpu_buffer->nest -= NESTED_BITS;\n\tpreempt_enable_notrace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_commit",
          "args": [
            "&fbuffer"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2893-2915",
          "snippet": "void trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct trace_event_file *file = fbuffer->trace_file;\n\n\tif (__event_trigger_test_discard(file, fbuffer->buffer, fbuffer->event,\n\t\t\tfbuffer->entry, &tt))\n\t\tgoto discard;\n\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tif (static_branch_unlikely(&trace_event_exports_enabled))\n\t\tftrace_exports(fbuffer->event, TRACE_EXPORT_EVENT);\n\n\ttrace_buffer_unlock_commit_regs(file->tr, fbuffer->buffer,\n\t\t\tfbuffer->event, fbuffer->trace_ctx, fbuffer->regs);\n\ndiscard:\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);",
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static DEFINE_STATIC_KEY_FALSE(trace_event_exports_enabled);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic DEFINE_STATIC_KEY_FALSE(trace_event_exports_enabled);\nstatic __always_inline struct;\n\nvoid trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct trace_event_file *file = fbuffer->trace_file;\n\n\tif (__event_trigger_test_discard(file, fbuffer->buffer, fbuffer->event,\n\t\t\tfbuffer->entry, &tt))\n\t\tgoto discard;\n\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tif (static_branch_unlikely(&trace_event_exports_enabled))\n\t\tftrace_exports(fbuffer->event, TRACE_EXPORT_EVENT);\n\n\ttrace_buffer_unlock_commit_regs(file->tr, fbuffer->buffer,\n\t\t\tfbuffer->event, fbuffer->trace_ctx, fbuffer->regs);\n\ndiscard:\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_string",
          "args": [
            "entry",
            "event",
            "str_val",
            "event->fields[i]->is_dynamic",
            "data_size",
            "&n_u64"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "trace_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "395-429",
          "snippet": "static unsigned int trace_string(struct synth_trace_event *entry,\n\t\t\t\t struct synth_event *event,\n\t\t\t\t char *str_val,\n\t\t\t\t bool is_dynamic,\n\t\t\t\t unsigned int data_size,\n\t\t\t\t unsigned int *n_u64)\n{\n\tunsigned int len = 0;\n\tchar *str_field;\n\n\tif (is_dynamic) {\n\t\tu32 data_offset;\n\n\t\tdata_offset = offsetof(typeof(*entry), fields);\n\t\tdata_offset += event->n_u64 * sizeof(u64);\n\t\tdata_offset += data_size;\n\n\t\tstr_field = (char *)entry + data_offset;\n\n\t\tlen = strlen(str_val) + 1;\n\t\tstrscpy(str_field, str_val, len);\n\n\t\tdata_offset |= len << 16;\n\t\t*(u32 *)&entry->fields[*n_u64] = data_offset;\n\n\t\t(*n_u64)++;\n\t} else {\n\t\tstr_field = (char *)&entry->fields[*n_u64];\n\n\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t\t(*n_u64) += STR_VAR_LEN_MAX / sizeof(u64);\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic unsigned int trace_string(struct synth_trace_event *entry,\n\t\t\t\t struct synth_event *event,\n\t\t\t\t char *str_val,\n\t\t\t\t bool is_dynamic,\n\t\t\t\t unsigned int data_size,\n\t\t\t\t unsigned int *n_u64)\n{\n\tunsigned int len = 0;\n\tchar *str_field;\n\n\tif (is_dynamic) {\n\t\tu32 data_offset;\n\n\t\tdata_offset = offsetof(typeof(*entry), fields);\n\t\tdata_offset += event->n_u64 * sizeof(u64);\n\t\tdata_offset += data_size;\n\n\t\tstr_field = (char *)entry + data_offset;\n\n\t\tlen = strlen(str_val) + 1;\n\t\tstrscpy(str_field, str_val, len);\n\n\t\tdata_offset |= len << 16;\n\t\t*(u32 *)&entry->fields[*n_u64] = data_offset;\n\n\t\t(*n_u64)++;\n\t} else {\n\t\tstr_field = (char *)&entry->fields[*n_u64];\n\n\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t\t(*n_u64) += STR_VAR_LEN_MAX / sizeof(u64);\n\t}\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_reserve",
          "args": [
            "&fbuffer",
            "trace_file",
            "sizeof(*entry) + fields_size"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "462-491",
          "snippet": "void *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\t/*\n\t * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tfbuffer->trace_ctx = tracing_gen_ctx_dec();\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->trace_ctx);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->regs = NULL;\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nvoid *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\t/*\n\t * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tfbuffer->trace_ctx = tracing_gen_ctx_dec();\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->trace_ctx);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->regs = NULL;\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_nest_start",
          "args": [
            "buffer"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_nest_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "3216-3227",
          "snippet": "void ring_buffer_nest_start(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\t/* Enabled by ring_buffer_nest_end() */\n\tpreempt_disable_notrace();\n\tcpu = raw_smp_processor_id();\n\tcpu_buffer = buffer->buffers[cpu];\n\t/* This is the shift value for the above recursive locking */\n\tcpu_buffer->nest += NESTED_BITS;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [
            "#define NESTED_BITS 5"
          ],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\n#define NESTED_BITS 5\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid ring_buffer_nest_start(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\t/* Enabled by ring_buffer_nest_end() */\n\tpreempt_disable_notrace();\n\tcpu = raw_smp_processor_id();\n\tcpu_buffer = buffer->buffers[cpu];\n\t/* This is the shift value for the above recursive locking */\n\tcpu_buffer->nest += NESTED_BITS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str_val"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_trigger_soft_disabled",
          "args": [
            "trace_file"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic notrace void trace_event_raw_event_synth(void *__data,\n\t\t\t\t\t\tu64 *var_ref_vals,\n\t\t\t\t\t\tunsigned int *var_ref_idx)\n{\n\tunsigned int i, n_u64, val_idx, len, data_size = 0;\n\tstruct trace_event_file *trace_file = __data;\n\tstruct synth_trace_event *entry;\n\tstruct trace_event_buffer fbuffer;\n\tstruct trace_buffer *buffer;\n\tstruct synth_event *event;\n\tint fields_size = 0;\n\n\tevent = trace_file->event_call->data;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tfields_size = event->n_u64 * sizeof(u64);\n\n\tfor (i = 0; i < event->n_dynamic_fields; i++) {\n\t\tunsigned int field_pos = event->dynamic_fields[i]->field_pos;\n\t\tchar *str_val;\n\n\t\tval_idx = var_ref_idx[field_pos];\n\t\tstr_val = (char *)(long)var_ref_vals[val_idx];\n\n\t\tlen = strlen(str_val) + 1;\n\n\t\tfields_size += len;\n\t}\n\n\t/*\n\t * Avoid ring buffer recursion detection, as this event\n\t * is being performed within another event.\n\t */\n\tbuffer = trace_file->tr->array_buffer.buffer;\n\tring_buffer_nest_start(buffer);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,\n\t\t\t\t\t   sizeof(*entry) + fields_size);\n\tif (!entry)\n\t\tgoto out;\n\n\tfor (i = 0, n_u64 = 0; i < event->n_fields; i++) {\n\t\tval_idx = var_ref_idx[i];\n\t\tif (event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)var_ref_vals[val_idx];\n\n\t\t\tlen = trace_string(entry, event, str_val,\n\t\t\t\t\t   event->fields[i]->is_dynamic,\n\t\t\t\t\t   data_size, &n_u64);\n\t\t\tdata_size += len; /* only dynamic string increments */\n\t\t} else {\n\t\t\tstruct synth_field *field = event->fields[i];\n\t\t\tu64 val = var_ref_vals[val_idx];\n\n\t\t\tswitch (field->size) {\n\t\t\tcase 1:\n\t\t\t\t*(u8 *)&entry->fields[n_u64] = (u8)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t*(u16 *)&entry->fields[n_u64] = (u16)val;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\t*(u32 *)&entry->fields[n_u64] = (u32)val;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tentry->fields[n_u64] = val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\n\n\ttrace_event_buffer_commit(&fbuffer);\nout:\n\tring_buffer_nest_end(buffer);\n}"
  },
  {
    "function_name": "trace_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "395-429",
    "snippet": "static unsigned int trace_string(struct synth_trace_event *entry,\n\t\t\t\t struct synth_event *event,\n\t\t\t\t char *str_val,\n\t\t\t\t bool is_dynamic,\n\t\t\t\t unsigned int data_size,\n\t\t\t\t unsigned int *n_u64)\n{\n\tunsigned int len = 0;\n\tchar *str_field;\n\n\tif (is_dynamic) {\n\t\tu32 data_offset;\n\n\t\tdata_offset = offsetof(typeof(*entry), fields);\n\t\tdata_offset += event->n_u64 * sizeof(u64);\n\t\tdata_offset += data_size;\n\n\t\tstr_field = (char *)entry + data_offset;\n\n\t\tlen = strlen(str_val) + 1;\n\t\tstrscpy(str_field, str_val, len);\n\n\t\tdata_offset |= len << 16;\n\t\t*(u32 *)&entry->fields[*n_u64] = data_offset;\n\n\t\t(*n_u64)++;\n\t} else {\n\t\tstr_field = (char *)&entry->fields[*n_u64];\n\n\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t\t(*n_u64) += STR_VAR_LEN_MAX / sizeof(u64);\n\t}\n\n\treturn len;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "str_field",
            "str_val",
            "STR_VAR_LEN_MAX"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "str_field",
            "str_val",
            "len"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str_val"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic unsigned int trace_string(struct synth_trace_event *entry,\n\t\t\t\t struct synth_event *event,\n\t\t\t\t char *str_val,\n\t\t\t\t bool is_dynamic,\n\t\t\t\t unsigned int data_size,\n\t\t\t\t unsigned int *n_u64)\n{\n\tunsigned int len = 0;\n\tchar *str_field;\n\n\tif (is_dynamic) {\n\t\tu32 data_offset;\n\n\t\tdata_offset = offsetof(typeof(*entry), fields);\n\t\tdata_offset += event->n_u64 * sizeof(u64);\n\t\tdata_offset += data_size;\n\n\t\tstr_field = (char *)entry + data_offset;\n\n\t\tlen = strlen(str_val) + 1;\n\t\tstrscpy(str_field, str_val, len);\n\n\t\tdata_offset |= len << 16;\n\t\t*(u32 *)&entry->fields[*n_u64] = data_offset;\n\n\t\t(*n_u64)++;\n\t} else {\n\t\tstr_field = (char *)&entry->fields[*n_u64];\n\n\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t\t(*n_u64) += STR_VAR_LEN_MAX / sizeof(u64);\n\t}\n\n\treturn len;\n}"
  },
  {
    "function_name": "print_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "312-389",
    "snippet": "static enum print_line_t print_synth_event(struct trace_iterator *iter,\n\t\t\t\t\t   int flags,\n\t\t\t\t\t   struct trace_event *event)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct synth_trace_event *entry;\n\tstruct synth_event *se;\n\tunsigned int i, n_u64;\n\tchar print_fmt[32];\n\tconst char *fmt;\n\n\tentry = (struct synth_trace_event *)iter->ent;\n\tse = container_of(event, struct synth_event, call.event);\n\n\ttrace_seq_printf(s, \"%s: \", se->name);\n\n\tfor (i = 0, n_u64 = 0; i < se->n_fields; i++) {\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\tgoto end;\n\n\t\tfmt = synth_field_fmt(se->fields[i]->type);\n\n\t\t/* parameter types */\n\t\tif (tr && tr->trace_flags & TRACE_ITER_VERBOSE)\n\t\t\ttrace_seq_printf(s, \"%s \", fmt);\n\n\t\tsnprintf(print_fmt, sizeof(print_fmt), \"%%s=%s%%s\", fmt);\n\n\t\t/* parameter values */\n\t\tif (se->fields[i]->is_string) {\n\t\t\tif (se->fields[i]->is_dynamic) {\n\t\t\t\tu32 offset, data_offset;\n\t\t\t\tchar *str_field;\n\n\t\t\t\toffset = (u32)entry->fields[n_u64];\n\t\t\t\tdata_offset = offset & 0xffff;\n\n\t\t\t\tstr_field = (char *)entry + data_offset;\n\n\t\t\t\ttrace_seq_printf(s, print_fmt, se->fields[i]->name,\n\t\t\t\t\t\t STR_VAR_LEN_MAX,\n\t\t\t\t\t\t str_field,\n\t\t\t\t\t\t i == se->n_fields - 1 ? \"\" : \" \");\n\t\t\t\tn_u64++;\n\t\t\t} else {\n\t\t\t\ttrace_seq_printf(s, print_fmt, se->fields[i]->name,\n\t\t\t\t\t\t STR_VAR_LEN_MAX,\n\t\t\t\t\t\t (char *)&entry->fields[n_u64],\n\t\t\t\t\t\t i == se->n_fields - 1 ? \"\" : \" \");\n\t\t\t\tn_u64 += STR_VAR_LEN_MAX / sizeof(u64);\n\t\t\t}\n\t\t} else {\n\t\t\tstruct trace_print_flags __flags[] = {\n\t\t\t    __def_gfpflag_names, {-1, NULL} };\n\t\t\tchar *space = (i == se->n_fields - 1 ? \"\" : \" \");\n\n\t\t\tprint_synth_event_num_val(s, print_fmt,\n\t\t\t\t\t\t  se->fields[i]->name,\n\t\t\t\t\t\t  se->fields[i]->size,\n\t\t\t\t\t\t  entry->fields[n_u64],\n\t\t\t\t\t\t  space);\n\n\t\t\tif (strcmp(se->fields[i]->type, \"gfp_t\") == 0) {\n\t\t\t\ttrace_seq_puts(s, \" (\");\n\t\t\t\ttrace_print_flags_seq(s, \"|\",\n\t\t\t\t\t\t      entry->fields[n_u64],\n\t\t\t\t\t\t      __flags);\n\t\t\t\ttrace_seq_putc(s, ')');\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\nend:\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_flags_seq",
          "args": [
            "s",
            "\"|\"",
            "entry->fields[n_u64]",
            "__flags"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_flags_seq_u64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "129-164",
          "snippet": "const char *\ntrace_print_flags_seq_u64(struct trace_seq *p, const char *delim,\n\t\t      unsigned long long flags,\n\t\t      const struct trace_print_flags_u64 *flag_array)\n{\n\tunsigned long long mask;\n\tconst char *str;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tint i, first = 1;\n\n\tfor (i = 0;  flag_array[i].name && flags; i++) {\n\n\t\tmask = flag_array[i].mask;\n\t\tif ((flags & mask) != mask)\n\t\t\tcontinue;\n\n\t\tstr = flag_array[i].name;\n\t\tflags &= ~mask;\n\t\tif (!first && delim)\n\t\t\ttrace_seq_puts(p, delim);\n\t\telse\n\t\t\tfirst = 0;\n\t\ttrace_seq_puts(p, str);\n\t}\n\n\t/* check for left over flags */\n\tif (flags) {\n\t\tif (!first && delim)\n\t\t\ttrace_seq_puts(p, delim);\n\t\ttrace_seq_printf(p, \"0x%llx\", flags);\n\t}\n\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nconst char *\ntrace_print_flags_seq_u64(struct trace_seq *p, const char *delim,\n\t\t      unsigned long long flags,\n\t\t      const struct trace_print_flags_u64 *flag_array)\n{\n\tunsigned long long mask;\n\tconst char *str;\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tint i, first = 1;\n\n\tfor (i = 0;  flag_array[i].name && flags; i++) {\n\n\t\tmask = flag_array[i].mask;\n\t\tif ((flags & mask) != mask)\n\t\t\tcontinue;\n\n\t\tstr = flag_array[i].name;\n\t\tflags &= ~mask;\n\t\tif (!first && delim)\n\t\t\ttrace_seq_puts(p, delim);\n\t\telse\n\t\t\tfirst = 0;\n\t\ttrace_seq_puts(p, str);\n\t}\n\n\t/* check for left over flags */\n\tif (flags) {\n\t\tif (!first && delim)\n\t\t\ttrace_seq_puts(p, delim);\n\t\ttrace_seq_printf(p, \"0x%llx\", flags);\n\t}\n\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\" (\""
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "se->fields[i]->type",
            "\"gfp_t\""
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_synth_event_num_val",
          "args": [
            "s",
            "print_fmt",
            "se->fields[i]->name",
            "se->fields[i]->size",
            "entry->fields[n_u64]",
            "space"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "print_synth_event_num_val",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "289-310",
          "snippet": "static void print_synth_event_num_val(struct trace_seq *s,\n\t\t\t\t      char *print_fmt, char *name,\n\t\t\t\t      int size, u64 val, char *space)\n{\n\tswitch (size) {\n\tcase 1:\n\t\ttrace_seq_printf(s, print_fmt, name, (u8)val, space);\n\t\tbreak;\n\n\tcase 2:\n\t\ttrace_seq_printf(s, print_fmt, name, (u16)val, space);\n\t\tbreak;\n\n\tcase 4:\n\t\ttrace_seq_printf(s, print_fmt, name, (u32)val, space);\n\t\tbreak;\n\n\tdefault:\n\t\ttrace_seq_printf(s, print_fmt, name, val, space);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void print_synth_event_num_val(struct trace_seq *s,\n\t\t\t\t      char *print_fmt, char *name,\n\t\t\t\t      int size, u64 val, char *space)\n{\n\tswitch (size) {\n\tcase 1:\n\t\ttrace_seq_printf(s, print_fmt, name, (u8)val, space);\n\t\tbreak;\n\n\tcase 2:\n\t\ttrace_seq_printf(s, print_fmt, name, (u16)val, space);\n\t\tbreak;\n\n\tcase 4:\n\t\ttrace_seq_printf(s, print_fmt, name, (u32)val, space);\n\t\tbreak;\n\n\tdefault:\n\t\ttrace_seq_printf(s, print_fmt, name, val, space);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "print_fmt",
            "se->fields[i]->name",
            "STR_VAR_LEN_MAX",
            "(char *)&entry->fields[n_u64]",
            "i == se->n_fields - 1 ? \"\" : \" \""
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "print_fmt",
            "sizeof(print_fmt)",
            "\"%%s=%s%%s\"",
            "fmt"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_field_fmt",
          "args": [
            "se->fields[i]->type"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "245-287",
          "snippet": "static const char *synth_field_fmt(char *type)\n{\n\tconst char *fmt = \"%llu\";\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tfmt = \"%lld\";\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tfmt = \"%llu\";\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"char\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"int\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"long\") == 0)\n\t\tfmt = \"%ld\";\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tfmt = \"%lu\";\n\telse if (strcmp(type, \"bool\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"gfp_t\") == 0)\n\t\tfmt = \"%x\";\n\telse if (synth_field_is_string(type))\n\t\tfmt = \"%.*s\";\n\n\treturn fmt;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *synth_field_fmt(char *type)\n{\n\tconst char *fmt = \"%llu\";\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tfmt = \"%lld\";\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tfmt = \"%llu\";\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"char\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"int\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"long\") == 0)\n\t\tfmt = \"%ld\";\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tfmt = \"%lu\";\n\telse if (strcmp(type, \"bool\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"gfp_t\") == 0)\n\t\tfmt = \"%x\";\n\telse if (synth_field_is_string(type))\n\t\tfmt = \"%.*s\";\n\n\treturn fmt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "event",
            "structsynth_event",
            "call.event"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic enum print_line_t print_synth_event(struct trace_iterator *iter,\n\t\t\t\t\t   int flags,\n\t\t\t\t\t   struct trace_event *event)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct synth_trace_event *entry;\n\tstruct synth_event *se;\n\tunsigned int i, n_u64;\n\tchar print_fmt[32];\n\tconst char *fmt;\n\n\tentry = (struct synth_trace_event *)iter->ent;\n\tse = container_of(event, struct synth_event, call.event);\n\n\ttrace_seq_printf(s, \"%s: \", se->name);\n\n\tfor (i = 0, n_u64 = 0; i < se->n_fields; i++) {\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\tgoto end;\n\n\t\tfmt = synth_field_fmt(se->fields[i]->type);\n\n\t\t/* parameter types */\n\t\tif (tr && tr->trace_flags & TRACE_ITER_VERBOSE)\n\t\t\ttrace_seq_printf(s, \"%s \", fmt);\n\n\t\tsnprintf(print_fmt, sizeof(print_fmt), \"%%s=%s%%s\", fmt);\n\n\t\t/* parameter values */\n\t\tif (se->fields[i]->is_string) {\n\t\t\tif (se->fields[i]->is_dynamic) {\n\t\t\t\tu32 offset, data_offset;\n\t\t\t\tchar *str_field;\n\n\t\t\t\toffset = (u32)entry->fields[n_u64];\n\t\t\t\tdata_offset = offset & 0xffff;\n\n\t\t\t\tstr_field = (char *)entry + data_offset;\n\n\t\t\t\ttrace_seq_printf(s, print_fmt, se->fields[i]->name,\n\t\t\t\t\t\t STR_VAR_LEN_MAX,\n\t\t\t\t\t\t str_field,\n\t\t\t\t\t\t i == se->n_fields - 1 ? \"\" : \" \");\n\t\t\t\tn_u64++;\n\t\t\t} else {\n\t\t\t\ttrace_seq_printf(s, print_fmt, se->fields[i]->name,\n\t\t\t\t\t\t STR_VAR_LEN_MAX,\n\t\t\t\t\t\t (char *)&entry->fields[n_u64],\n\t\t\t\t\t\t i == se->n_fields - 1 ? \"\" : \" \");\n\t\t\t\tn_u64 += STR_VAR_LEN_MAX / sizeof(u64);\n\t\t\t}\n\t\t} else {\n\t\t\tstruct trace_print_flags __flags[] = {\n\t\t\t    __def_gfpflag_names, {-1, NULL} };\n\t\t\tchar *space = (i == se->n_fields - 1 ? \"\" : \" \");\n\n\t\t\tprint_synth_event_num_val(s, print_fmt,\n\t\t\t\t\t\t  se->fields[i]->name,\n\t\t\t\t\t\t  se->fields[i]->size,\n\t\t\t\t\t\t  entry->fields[n_u64],\n\t\t\t\t\t\t  space);\n\n\t\t\tif (strcmp(se->fields[i]->type, \"gfp_t\") == 0) {\n\t\t\t\ttrace_seq_puts(s, \" (\");\n\t\t\t\ttrace_print_flags_seq(s, \"|\",\n\t\t\t\t\t\t      entry->fields[n_u64],\n\t\t\t\t\t\t      __flags);\n\t\t\t\ttrace_seq_putc(s, ')');\n\t\t\t}\n\t\t\tn_u64++;\n\t\t}\n\t}\nend:\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "print_synth_event_num_val",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "289-310",
    "snippet": "static void print_synth_event_num_val(struct trace_seq *s,\n\t\t\t\t      char *print_fmt, char *name,\n\t\t\t\t      int size, u64 val, char *space)\n{\n\tswitch (size) {\n\tcase 1:\n\t\ttrace_seq_printf(s, print_fmt, name, (u8)val, space);\n\t\tbreak;\n\n\tcase 2:\n\t\ttrace_seq_printf(s, print_fmt, name, (u16)val, space);\n\t\tbreak;\n\n\tcase 4:\n\t\ttrace_seq_printf(s, print_fmt, name, (u32)val, space);\n\t\tbreak;\n\n\tdefault:\n\t\ttrace_seq_printf(s, print_fmt, name, val, space);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "print_fmt",
            "name",
            "val",
            "space"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void print_synth_event_num_val(struct trace_seq *s,\n\t\t\t\t      char *print_fmt, char *name,\n\t\t\t\t      int size, u64 val, char *space)\n{\n\tswitch (size) {\n\tcase 1:\n\t\ttrace_seq_printf(s, print_fmt, name, (u8)val, space);\n\t\tbreak;\n\n\tcase 2:\n\t\ttrace_seq_printf(s, print_fmt, name, (u16)val, space);\n\t\tbreak;\n\n\tcase 4:\n\t\ttrace_seq_printf(s, print_fmt, name, (u32)val, space);\n\t\tbreak;\n\n\tdefault:\n\t\ttrace_seq_printf(s, print_fmt, name, val, space);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "synth_field_fmt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "245-287",
    "snippet": "static const char *synth_field_fmt(char *type)\n{\n\tconst char *fmt = \"%llu\";\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tfmt = \"%lld\";\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tfmt = \"%llu\";\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"char\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"int\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"long\") == 0)\n\t\tfmt = \"%ld\";\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tfmt = \"%lu\";\n\telse if (strcmp(type, \"bool\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"gfp_t\") == 0)\n\t\tfmt = \"%x\";\n\telse if (synth_field_is_string(type))\n\t\tfmt = \"%.*s\";\n\n\treturn fmt;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synth_field_is_string",
          "args": [
            "type"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_is_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "158-164",
          "snippet": "static int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"gfp_t\""
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *synth_field_fmt(char *type)\n{\n\tconst char *fmt = \"%llu\";\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tfmt = \"%lld\";\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tfmt = \"%llu\";\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"char\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"int\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"long\") == 0)\n\t\tfmt = \"%ld\";\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tfmt = \"%lu\";\n\telse if (strcmp(type, \"bool\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"gfp_t\") == 0)\n\t\tfmt = \"%x\";\n\telse if (synth_field_is_string(type))\n\t\tfmt = \"%.*s\";\n\n\treturn fmt;\n}"
  },
  {
    "function_name": "synth_field_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "201-243",
    "snippet": "static int synth_field_size(char *type)\n{\n\tint size = 0;\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tsize = sizeof(s64);\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tsize = sizeof(u64);\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tsize = sizeof(s32);\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tsize = sizeof(u32);\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tsize = sizeof(s16);\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tsize = sizeof(u16);\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tsize = sizeof(s8);\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tsize = sizeof(u8);\n\telse if (strcmp(type, \"char\") == 0)\n\t\tsize = sizeof(char);\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tsize = sizeof(unsigned char);\n\telse if (strcmp(type, \"int\") == 0)\n\t\tsize = sizeof(int);\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tsize = sizeof(unsigned int);\n\telse if (strcmp(type, \"long\") == 0)\n\t\tsize = sizeof(long);\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tsize = sizeof(unsigned long);\n\telse if (strcmp(type, \"bool\") == 0)\n\t\tsize = sizeof(bool);\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tsize = sizeof(pid_t);\n\telse if (strcmp(type, \"gfp_t\") == 0)\n\t\tsize = sizeof(gfp_t);\n\telse if (synth_field_is_string(type))\n\t\tsize = synth_field_string_size(type);\n\n\treturn size;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synth_field_string_size",
          "args": [
            "type"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_string_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "166-199",
          "snippet": "static int synth_field_string_size(char *type)\n{\n\tchar buf[4], *end, *start;\n\tunsigned int len;\n\tint size, err;\n\n\tstart = strstr(type, \"char[\");\n\tif (start == NULL)\n\t\treturn -EINVAL;\n\tstart += sizeof(\"char[\") - 1;\n\n\tend = strchr(type, ']');\n\tif (!end || end < start || type + strlen(type) > end + 1)\n\t\treturn -EINVAL;\n\n\tlen = end - start;\n\tif (len > 3)\n\t\treturn -EINVAL;\n\n\tif (len == 0)\n\t\treturn 0; /* variable-length string */\n\n\tstrncpy(buf, start, len);\n\tbuf[len] = '\\0';\n\n\terr = kstrtouint(buf, 0, &size);\n\tif (err)\n\t\treturn err;\n\n\tif (size > STR_VAR_LEN_MAX)\n\t\treturn -EINVAL;\n\n\treturn size;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_field_string_size(char *type)\n{\n\tchar buf[4], *end, *start;\n\tunsigned int len;\n\tint size, err;\n\n\tstart = strstr(type, \"char[\");\n\tif (start == NULL)\n\t\treturn -EINVAL;\n\tstart += sizeof(\"char[\") - 1;\n\n\tend = strchr(type, ']');\n\tif (!end || end < start || type + strlen(type) > end + 1)\n\t\treturn -EINVAL;\n\n\tlen = end - start;\n\tif (len > 3)\n\t\treturn -EINVAL;\n\n\tif (len == 0)\n\t\treturn 0; /* variable-length string */\n\n\tstrncpy(buf, start, len);\n\tbuf[len] = '\\0';\n\n\terr = kstrtouint(buf, 0, &size);\n\tif (err)\n\t\treturn err;\n\n\tif (size > STR_VAR_LEN_MAX)\n\t\treturn -EINVAL;\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_field_is_string",
          "args": [
            "type"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_is_string",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "158-164",
          "snippet": "static int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"gfp_t\""
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_field_size(char *type)\n{\n\tint size = 0;\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tsize = sizeof(s64);\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tsize = sizeof(u64);\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tsize = sizeof(s32);\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tsize = sizeof(u32);\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tsize = sizeof(s16);\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tsize = sizeof(u16);\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tsize = sizeof(s8);\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tsize = sizeof(u8);\n\telse if (strcmp(type, \"char\") == 0)\n\t\tsize = sizeof(char);\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tsize = sizeof(unsigned char);\n\telse if (strcmp(type, \"int\") == 0)\n\t\tsize = sizeof(int);\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tsize = sizeof(unsigned int);\n\telse if (strcmp(type, \"long\") == 0)\n\t\tsize = sizeof(long);\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tsize = sizeof(unsigned long);\n\telse if (strcmp(type, \"bool\") == 0)\n\t\tsize = sizeof(bool);\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tsize = sizeof(pid_t);\n\telse if (strcmp(type, \"gfp_t\") == 0)\n\t\tsize = sizeof(gfp_t);\n\telse if (synth_field_is_string(type))\n\t\tsize = synth_field_string_size(type);\n\n\treturn size;\n}"
  },
  {
    "function_name": "synth_field_string_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "166-199",
    "snippet": "static int synth_field_string_size(char *type)\n{\n\tchar buf[4], *end, *start;\n\tunsigned int len;\n\tint size, err;\n\n\tstart = strstr(type, \"char[\");\n\tif (start == NULL)\n\t\treturn -EINVAL;\n\tstart += sizeof(\"char[\") - 1;\n\n\tend = strchr(type, ']');\n\tif (!end || end < start || type + strlen(type) > end + 1)\n\t\treturn -EINVAL;\n\n\tlen = end - start;\n\tif (len > 3)\n\t\treturn -EINVAL;\n\n\tif (len == 0)\n\t\treturn 0; /* variable-length string */\n\n\tstrncpy(buf, start, len);\n\tbuf[len] = '\\0';\n\n\terr = kstrtouint(buf, 0, &size);\n\tif (err)\n\t\treturn err;\n\n\tif (size > STR_VAR_LEN_MAX)\n\t\treturn -EINVAL;\n\n\treturn size;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "buf",
            "0",
            "&size"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "buf",
            "start",
            "len"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "type"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "type",
            "']'"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "type",
            "\"char[\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_field_string_size(char *type)\n{\n\tchar buf[4], *end, *start;\n\tunsigned int len;\n\tint size, err;\n\n\tstart = strstr(type, \"char[\");\n\tif (start == NULL)\n\t\treturn -EINVAL;\n\tstart += sizeof(\"char[\") - 1;\n\n\tend = strchr(type, ']');\n\tif (!end || end < start || type + strlen(type) > end + 1)\n\t\treturn -EINVAL;\n\n\tlen = end - start;\n\tif (len > 3)\n\t\treturn -EINVAL;\n\n\tif (len == 0)\n\t\treturn 0; /* variable-length string */\n\n\tstrncpy(buf, start, len);\n\tbuf[len] = '\\0';\n\n\terr = kstrtouint(buf, 0, &size);\n\tif (err)\n\t\treturn err;\n\n\tif (size > STR_VAR_LEN_MAX)\n\t\treturn -EINVAL;\n\n\treturn size;\n}"
  },
  {
    "function_name": "synth_field_is_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "158-164",
    "snippet": "static int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "type",
            "\"char[\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "synth_field_signed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "148-156",
    "snippet": "static bool synth_field_signed(char *type)\n{\n\tif (str_has_prefix(type, \"u\"))\n\t\treturn false;\n\tif (strcmp(type, \"gfp_t\") == 0)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"gfp_t\""
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "type",
            "\"u\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool synth_field_signed(char *type)\n{\n\tif (str_has_prefix(type, \"u\"))\n\t\treturn false;\n\tif (strcmp(type, \"gfp_t\") == 0)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "synth_event_define_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "112-146",
    "snippet": "static int synth_event_define_fields(struct trace_event_call *call)\n{\n\tstruct synth_trace_event trace;\n\tint offset = offsetof(typeof(trace), fields);\n\tstruct synth_event *event = call->data;\n\tunsigned int i, size, n_u64;\n\tchar *name, *type;\n\tbool is_signed;\n\tint ret = 0;\n\n\tfor (i = 0, n_u64 = 0; i < event->n_fields; i++) {\n\t\tsize = event->fields[i]->size;\n\t\tis_signed = event->fields[i]->is_signed;\n\t\ttype = event->fields[i]->type;\n\t\tname = event->fields[i]->name;\n\t\tret = trace_define_field(call, type, name, offset, size,\n\t\t\t\t\t is_signed, FILTER_OTHER);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tevent->fields[i]->offset = n_u64;\n\n\t\tif (event->fields[i]->is_string && !event->fields[i]->is_dynamic) {\n\t\t\toffset += STR_VAR_LEN_MAX;\n\t\t\tn_u64 += STR_VAR_LEN_MAX / sizeof(u64);\n\t\t} else {\n\t\t\toffset += sizeof(u64);\n\t\t\tn_u64++;\n\t\t}\n\t}\n\n\tevent->n_u64 = n_u64;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_define_field",
          "args": [
            "call",
            "type",
            "name",
            "offset",
            "size",
            "is_signed",
            "FILTER_OTHER"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "trace_define_field",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "134-146",
          "snippet": "int trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_define_fields(struct trace_event_call *call)\n{\n\tstruct synth_trace_event trace;\n\tint offset = offsetof(typeof(trace), fields);\n\tstruct synth_event *event = call->data;\n\tunsigned int i, size, n_u64;\n\tchar *name, *type;\n\tbool is_signed;\n\tint ret = 0;\n\n\tfor (i = 0, n_u64 = 0; i < event->n_fields; i++) {\n\t\tsize = event->fields[i]->size;\n\t\tis_signed = event->fields[i]->is_signed;\n\t\ttype = event->fields[i]->type;\n\t\tname = event->fields[i]->name;\n\t\tret = trace_define_field(call, type, name, offset, size,\n\t\t\t\t\t is_signed, FILTER_OTHER);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tevent->fields[i]->offset = n_u64;\n\n\t\tif (event->fields[i]->is_string && !event->fields[i]->is_dynamic) {\n\t\t\toffset += STR_VAR_LEN_MAX;\n\t\t\tn_u64 += STR_VAR_LEN_MAX / sizeof(u64);\n\t\t} else {\n\t\t\toffset += sizeof(u64);\n\t\t\tn_u64++;\n\t\t}\n\t}\n\n\tevent->n_u64 = n_u64;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "synth_event_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "98-105",
    "snippet": "static bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev)\n{\n\tstruct synth_event *sev = to_synth_event(ev);\n\n\treturn strcmp(sev->name, event) == 0 &&\n\t\t(!system || strcmp(system, SYNTH_SYSTEM) == 0);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int synth_event_show(struct seq_file *m, struct dyn_event *ev);",
      "static int synth_event_release(struct dyn_event *ev);",
      "static bool synth_event_is_busy(struct dyn_event *ev);",
      "static bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "system",
            "SYNTH_SYSTEM"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_synth_event",
          "args": [
            "ev"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "to_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "86-89",
          "snippet": "static struct synth_event *to_synth_event(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct synth_event, devent);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int synth_event_show(struct seq_file *m, struct dyn_event *ev);",
            "static int synth_event_release(struct dyn_event *ev);",
            "static bool synth_event_is_busy(struct dyn_event *ev);",
            "static bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev);\nstatic int synth_event_release(struct dyn_event *ev);\nstatic bool synth_event_is_busy(struct dyn_event *ev);\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\n\nstatic struct synth_event *to_synth_event(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct synth_event, devent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev);\nstatic int synth_event_release(struct dyn_event *ev);\nstatic bool synth_event_is_busy(struct dyn_event *ev);\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\n\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev)\n{\n\tstruct synth_event *sev = to_synth_event(ev);\n\n\treturn strcmp(sev->name, event) == 0 &&\n\t\t(!system || strcmp(system, SYNTH_SYSTEM) == 0);\n}"
  },
  {
    "function_name": "synth_event_is_busy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "91-96",
    "snippet": "static bool synth_event_is_busy(struct dyn_event *ev)\n{\n\tstruct synth_event *event = to_synth_event(ev);\n\n\treturn event->ref != 0;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int synth_event_show(struct seq_file *m, struct dyn_event *ev);",
      "static int synth_event_release(struct dyn_event *ev);",
      "static bool synth_event_is_busy(struct dyn_event *ev);",
      "static bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_synth_event",
          "args": [
            "ev"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "to_synth_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "86-89",
          "snippet": "static struct synth_event *to_synth_event(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct synth_event, devent);\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int synth_event_show(struct seq_file *m, struct dyn_event *ev);",
            "static int synth_event_release(struct dyn_event *ev);",
            "static bool synth_event_is_busy(struct dyn_event *ev);",
            "static bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev);\nstatic int synth_event_release(struct dyn_event *ev);\nstatic bool synth_event_is_busy(struct dyn_event *ev);\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\n\nstatic struct synth_event *to_synth_event(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct synth_event, devent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev);\nstatic int synth_event_release(struct dyn_event *ev);\nstatic bool synth_event_is_busy(struct dyn_event *ev);\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\n\nstatic bool synth_event_is_busy(struct dyn_event *ev)\n{\n\tstruct synth_event *event = to_synth_event(ev);\n\n\treturn event->ref != 0;\n}"
  },
  {
    "function_name": "to_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "86-89",
    "snippet": "static struct synth_event *to_synth_event(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct synth_event, devent);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int synth_event_show(struct seq_file *m, struct dyn_event *ev);",
      "static int synth_event_release(struct dyn_event *ev);",
      "static bool synth_event_is_busy(struct dyn_event *ev);",
      "static bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ev",
            "structsynth_event",
            "devent"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev);\nstatic int synth_event_release(struct dyn_event *ev);\nstatic bool synth_event_is_busy(struct dyn_event *ev);\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\n\nstatic struct synth_event *to_synth_event(struct dyn_event *ev)\n{\n\treturn container_of(ev, struct synth_event, devent);\n}"
  },
  {
    "function_name": "is_synth_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "81-84",
    "snippet": "static bool is_synth_event(struct dyn_event *ev)\n{\n\treturn ev->ops == &synth_event_ops;\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int synth_event_show(struct seq_file *m, struct dyn_event *ev);",
      "static int synth_event_release(struct dyn_event *ev);",
      "static bool synth_event_is_busy(struct dyn_event *ev);",
      "static bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);",
      "static struct dyn_event_operations synth_event_ops = {\n\t.create = create_synth_event,\n\t.show = synth_event_show,\n\t.is_busy = synth_event_is_busy,\n\t.free = synth_event_release,\n\t.match = synth_event_match,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_show(struct seq_file *m, struct dyn_event *ev);\nstatic int synth_event_release(struct dyn_event *ev);\nstatic bool synth_event_is_busy(struct dyn_event *ev);\nstatic bool synth_event_match(const char *system, const char *event,\n\t\t\tint argc, const char **argv, struct dyn_event *ev);\nstatic struct dyn_event_operations synth_event_ops = {\n\t.create = create_synth_event,\n\t.show = synth_event_show,\n\t.is_busy = synth_event_is_busy,\n\t.free = synth_event_release,\n\t.match = synth_event_match,\n};\n\nstatic bool is_synth_event(struct dyn_event *ev)\n{\n\treturn ev->ops == &synth_event_ops;\n}"
  },
  {
    "function_name": "synth_err",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "60-64",
    "snippet": "static void synth_err(u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(NULL, \"synthetic_events\", last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *err_text[] = { ERRORS };",
      "static char last_cmd[MAX_FILTER_STR_VAL];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_log_err",
          "args": [
            "NULL",
            "\"synthetic_events\"",
            "last_cmd",
            "err_text",
            "err_type",
            "err_pos"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_log_err",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "7807-7833",
          "snippet": "void tracing_log_err(struct trace_array *tr,\n\t\t     const char *loc, const char *cmd,\n\t\t     const char **errs, u8 type, u8 pos)\n{\n\tstruct tracing_log_err *err;\n\n\tif (!tr)\n\t\ttr = &global_trace;\n\n\tmutex_lock(&tracing_err_log_lock);\n\terr = get_tracing_log_err(tr);\n\tif (PTR_ERR(err) == -ENOMEM) {\n\t\tmutex_unlock(&tracing_err_log_lock);\n\t\treturn;\n\t}\n\n\tsnprintf(err->loc, TRACING_LOG_LOC_MAX, \"%s: error: \", loc);\n\tsnprintf(err->cmd, MAX_FILTER_STR_VAL,\"\\n\" CMD_PREFIX \"%s\\n\", cmd);\n\n\terr->info.errs = errs;\n\terr->info.type = type;\n\terr->info.pos = pos;\n\terr->info.ts = local_clock();\n\n\tlist_add_tail(&err->list, &tr->err_log);\n\tmutex_unlock(&tracing_err_log_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define CMD_PREFIX \"  Command: \"",
            "#define TRACING_LOG_LOC_MAX\t128"
          ],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct",
            "static DEFINE_MUTEX(tracing_err_log_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define CMD_PREFIX \"  Command: \"\n#define TRACING_LOG_LOC_MAX\t128\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\nstatic DEFINE_MUTEX(tracing_err_log_lock);\n\nvoid tracing_log_err(struct trace_array *tr,\n\t\t     const char *loc, const char *cmd,\n\t\t     const char **errs, u8 type, u8 pos)\n{\n\tstruct tracing_log_err *err;\n\n\tif (!tr)\n\t\ttr = &global_trace;\n\n\tmutex_lock(&tracing_err_log_lock);\n\terr = get_tracing_log_err(tr);\n\tif (PTR_ERR(err) == -ENOMEM) {\n\t\tmutex_unlock(&tracing_err_log_lock);\n\t\treturn;\n\t}\n\n\tsnprintf(err->loc, TRACING_LOG_LOC_MAX, \"%s: error: \", loc);\n\tsnprintf(err->cmd, MAX_FILTER_STR_VAL,\"\\n\" CMD_PREFIX \"%s\\n\", cmd);\n\n\terr->info.errs = errs;\n\terr->info.type = type;\n\terr->info.pos = pos;\n\terr->info.ts = local_clock();\n\n\tlist_add_tail(&err->list, &tr->err_log);\n\tmutex_unlock(&tracing_err_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *err_text[] = { ERRORS };\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic void synth_err(u8 err_type, u8 err_pos)\n{\n\ttracing_log_err(NULL, \"synthetic_events\", last_cmd, err_text,\n\t\t\terr_type, err_pos);\n}"
  },
  {
    "function_name": "last_cmd_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "52-58",
    "snippet": "static void last_cmd_set(const char *str)\n{\n\tif (!str)\n\t\treturn;\n\n\tstrncpy(last_cmd, str, MAX_FILTER_STR_VAL - 1);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char last_cmd[MAX_FILTER_STR_VAL];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "last_cmd",
            "str",
            "MAX_FILTER_STR_VAL - 1"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic void last_cmd_set(const char *str)\n{\n\tif (!str)\n\t\treturn;\n\n\tstrncpy(last_cmd, str, MAX_FILTER_STR_VAL - 1);\n}"
  },
  {
    "function_name": "errpos",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
    "lines": "47-50",
    "snippet": "static int errpos(const char *str)\n{\n\treturn err_pos(last_cmd, str);\n}",
    "includes": [
      "#include \"trace_synth.h\"",
      "#include <trace/events/mmflags.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char last_cmd[MAX_FILTER_STR_VAL];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_pos",
          "args": [
            "last_cmd",
            "str"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "err_pos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "7766-7778",
          "snippet": "unsigned int err_pos(char *cmd, const char *str)\n{\n\tchar *found;\n\n\tif (WARN_ON(!strlen(cmd)))\n\t\treturn 0;\n\n\tfound = strstr(cmd, str);\n\tif (found)\n\t\treturn found - cmd;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nunsigned int err_pos(char *cmd, const char *str)\n{\n\tchar *found;\n\n\tif (WARN_ON(!strlen(cmd)))\n\t\treturn 0;\n\n\tfound = strstr(cmd, str);\n\tif (found)\n\t\treturn found - cmd;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_cmd[MAX_FILTER_STR_VAL];\n\nstatic int errpos(const char *str)\n{\n\treturn err_pos(last_cmd, str);\n}"
  }
]