[
  {
    "function_name": "kcsan_ignore_data_race",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/permissive.h",
    "lines": "37-92",
    "snippet": "static bool\nkcsan_ignore_data_race(size_t size, int type, u64 old, u64 new, u64 diff)\n{\n\tif (!IS_ENABLED(CONFIG_KCSAN_PERMISSIVE))\n\t\treturn false;\n\n\t/*\n\t * Rules here are only for plain read accesses, so that we still report\n\t * data races between plain read-write accesses.\n\t */\n\tif (type || size > sizeof(long))\n\t\treturn false;\n\n\t/*\n\t * A common pattern is checking/setting just 1 bit in a variable; for\n\t * example:\n\t *\n\t *\tif (flags & SOME_FLAG) { ... }\n\t *\n\t * and elsewhere flags is updated concurrently:\n\t *\n\t *\tflags |= SOME_OTHER_FLAG; // just 1 bit\n\t *\n\t * While it is still recommended that such accesses be marked\n\t * appropriately, in many cases these types of data races are so common\n\t * that marking them all is often unrealistic and left to maintainer\n\t * preference.\n\t *\n\t * The assumption in all cases is that with all known compiler\n\t * optimizations (including those that tear accesses), because no more\n\t * than 1 bit changed, the plain accesses are safe despite the presence\n\t * of data races.\n\t *\n\t * The rules here will ignore the data races if we observe no more than\n\t * 1 bit changed.\n\t *\n\t * Of course many operations can effecively change just 1 bit, but the\n\t * general assuption that data races involving 1-bit changes can be\n\t * tolerated still applies.\n\t *\n\t * And in case a true bug is missed, the bug likely manifests as a\n\t * reportable data race elsewhere.\n\t */\n\tif (hweight64(diff) == 1) {\n\t\t/*\n\t\t * Exception: Report data races where the values look like\n\t\t * ordinary booleans (one of them was 0 and the 0th bit was\n\t\t * changed) More often than not, they come with interesting\n\t\t * memory ordering requirements, so let's report them.\n\t\t */\n\t\tif (!((!old || !new) && diff == 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hweight64",
          "args": [
            "diff"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_PERMISSIVE"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/bitops.h>\n\nstatic bool\nkcsan_ignore_data_race(size_t size, int type, u64 old, u64 new, u64 diff)\n{\n\tif (!IS_ENABLED(CONFIG_KCSAN_PERMISSIVE))\n\t\treturn false;\n\n\t/*\n\t * Rules here are only for plain read accesses, so that we still report\n\t * data races between plain read-write accesses.\n\t */\n\tif (type || size > sizeof(long))\n\t\treturn false;\n\n\t/*\n\t * A common pattern is checking/setting just 1 bit in a variable; for\n\t * example:\n\t *\n\t *\tif (flags & SOME_FLAG) { ... }\n\t *\n\t * and elsewhere flags is updated concurrently:\n\t *\n\t *\tflags |= SOME_OTHER_FLAG; // just 1 bit\n\t *\n\t * While it is still recommended that such accesses be marked\n\t * appropriately, in many cases these types of data races are so common\n\t * that marking them all is often unrealistic and left to maintainer\n\t * preference.\n\t *\n\t * The assumption in all cases is that with all known compiler\n\t * optimizations (including those that tear accesses), because no more\n\t * than 1 bit changed, the plain accesses are safe despite the presence\n\t * of data races.\n\t *\n\t * The rules here will ignore the data races if we observe no more than\n\t * 1 bit changed.\n\t *\n\t * Of course many operations can effecively change just 1 bit, but the\n\t * general assuption that data races involving 1-bit changes can be\n\t * tolerated still applies.\n\t *\n\t * And in case a true bug is missed, the bug likely manifests as a\n\t * reportable data race elsewhere.\n\t */\n\tif (hweight64(diff) == 1) {\n\t\t/*\n\t\t * Exception: Report data races where the values look like\n\t\t * ordinary booleans (one of them was 0 and the 0th bit was\n\t\t * changed) More often than not, they come with interesting\n\t\t * memory ordering requirements, so let's report them.\n\t\t */\n\t\tif (!((!old || !new) && diff == 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "kcsan_ignore_address",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/permissive.h",
    "lines": "22-32",
    "snippet": "static __always_inline bool kcsan_ignore_address(const volatile void *ptr)\n{\n\tif (!IS_ENABLED(CONFIG_KCSAN_PERMISSIVE))\n\t\treturn false;\n\n\t/*\n\t * Data-racy bitops on current->flags are too common, ignore completely\n\t * for now.\n\t */\n\treturn ptr == &current->flags;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KCSAN_PERMISSIVE"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/bitops.h>\n\nstatic __always_inline bool kcsan_ignore_address(const volatile void *ptr)\n{\n\tif (!IS_ENABLED(CONFIG_KCSAN_PERMISSIVE))\n\t\treturn false;\n\n\t/*\n\t * Data-racy bitops on current->flags are too common, ignore completely\n\t * for now.\n\t */\n\treturn ptr == &current->flags;\n}"
  }
]