[
  {
    "function_name": "audit_exe_compare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "524-537",
    "snippet": "int audit_exe_compare(struct task_struct *tsk, struct audit_fsnotify_mark *mark)\n{\n\tstruct file *exe_file;\n\tunsigned long ino;\n\tdev_t dev;\n\n\texe_file = get_task_exe_file(tsk);\n\tif (!exe_file)\n\t\treturn 0;\n\tino = file_inode(exe_file)->i_ino;\n\tdev = file_inode(exe_file)->i_sb->s_dev;\n\tfput(exe_file);\n\treturn audit_mark_compare(mark, ino, dev);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_mark_compare",
          "args": [
            "mark",
            "ino",
            "dev"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mark_compare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_fsnotify.c",
          "lines": "60-65",
          "snippet": "int audit_mark_compare(struct audit_fsnotify_mark *mark, unsigned long ino, dev_t dev)\n{\n\tif (mark->ino == AUDIT_INO_UNSET)\n\t\treturn 0;\n\treturn (mark->ino == ino) && (mark->dev == dev);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_mark_compare(struct audit_fsnotify_mark *mark, unsigned long ino, dev_t dev)\n{\n\tif (mark->ino == AUDIT_INO_UNSET)\n\t\treturn 0;\n\treturn (mark->ino == ino) && (mark->dev == dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "exe_file"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "exe_file"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "exe_file"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_exe_file",
          "args": [
            "tsk"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "get_task_exe_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1273-1286",
          "snippet": "struct file *get_task_exe_file(struct task_struct *task)\n{\n\tstruct file *exe_file = NULL;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (!(task->flags & PF_KTHREAD))\n\t\t\texe_file = get_mm_exe_file(mm);\n\t}\n\ttask_unlock(task);\n\treturn exe_file;\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstruct file *get_task_exe_file(struct task_struct *task)\n{\n\tstruct file *exe_file = NULL;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (!(task->flags & PF_KTHREAD))\n\t\t\texe_file = get_mm_exe_file(mm);\n\t}\n\ttask_unlock(task);\n\treturn exe_file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_exe_compare(struct task_struct *tsk, struct audit_fsnotify_mark *mark)\n{\n\tstruct file *exe_file;\n\tunsigned long ino;\n\tdev_t dev;\n\n\texe_file = get_task_exe_file(tsk);\n\tif (!exe_file)\n\t\treturn 0;\n\tino = file_inode(exe_file)->i_ino;\n\tdev = file_inode(exe_file)->i_sb->s_dev;\n\tfput(exe_file);\n\treturn audit_mark_compare(mark, ino, dev);\n}"
  },
  {
    "function_name": "audit_dupe_exe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "505-522",
    "snippet": "int audit_dupe_exe(struct audit_krule *new, struct audit_krule *old)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tchar *pathname;\n\n\tpathname = kstrdup(audit_mark_path(old->exe), GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\taudit_mark = audit_alloc_mark(new, pathname, strlen(pathname));\n\tif (IS_ERR(audit_mark)) {\n\t\tkfree(pathname);\n\t\treturn PTR_ERR(audit_mark);\n\t}\n\tnew->exe = audit_mark;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "audit_mark"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pathname"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "audit_mark"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_alloc_mark",
          "args": [
            "new",
            "pathname",
            "strlen(pathname)"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "audit_alloc_mark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_fsnotify.c",
          "lines": "74-112",
          "snippet": "struct audit_fsnotify_mark *audit_alloc_mark(struct audit_krule *krule, char *pathname, int len)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tstruct path path;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint ret;\n\n\tif (pathname[0] != '/' || pathname[len-1] == '/')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdentry = kern_path_locked(pathname, &path);\n\tif (IS_ERR(dentry))\n\t\treturn ERR_CAST(dentry); /* returning an error */\n\tinode = path.dentry->d_inode;\n\tinode_unlock(inode);\n\n\taudit_mark = kzalloc(sizeof(*audit_mark), GFP_KERNEL);\n\tif (unlikely(!audit_mark)) {\n\t\taudit_mark = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfsnotify_init_mark(&audit_mark->mark, audit_fsnotify_group);\n\taudit_mark->mark.mask = AUDIT_FS_EVENTS;\n\taudit_mark->path = pathname;\n\taudit_update_mark(audit_mark, dentry->d_inode);\n\taudit_mark->rule = krule;\n\n\tret = fsnotify_add_inode_mark(&audit_mark->mark, inode, true);\n\tif (ret < 0) {\n\t\tfsnotify_put_mark(&audit_mark->mark);\n\t\taudit_mark = ERR_PTR(ret);\n\t}\nout:\n\tdput(dentry);\n\tpath_put(&path);\n\treturn audit_mark;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define AUDIT_FS_EVENTS (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\t FS_MOVE_SELF)"
          ],
          "globals_used": [
            "static struct fsnotify_group *audit_fsnotify_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\n#define AUDIT_FS_EVENTS (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\t FS_MOVE_SELF)\n\nstatic struct fsnotify_group *audit_fsnotify_group;\n\nstruct audit_fsnotify_mark *audit_alloc_mark(struct audit_krule *krule, char *pathname, int len)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tstruct path path;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint ret;\n\n\tif (pathname[0] != '/' || pathname[len-1] == '/')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdentry = kern_path_locked(pathname, &path);\n\tif (IS_ERR(dentry))\n\t\treturn ERR_CAST(dentry); /* returning an error */\n\tinode = path.dentry->d_inode;\n\tinode_unlock(inode);\n\n\taudit_mark = kzalloc(sizeof(*audit_mark), GFP_KERNEL);\n\tif (unlikely(!audit_mark)) {\n\t\taudit_mark = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfsnotify_init_mark(&audit_mark->mark, audit_fsnotify_group);\n\taudit_mark->mark.mask = AUDIT_FS_EVENTS;\n\taudit_mark->path = pathname;\n\taudit_update_mark(audit_mark, dentry->d_inode);\n\taudit_mark->rule = krule;\n\n\tret = fsnotify_add_inode_mark(&audit_mark->mark, inode, true);\n\tif (ret < 0) {\n\t\tfsnotify_put_mark(&audit_mark->mark);\n\t\taudit_mark = ERR_PTR(ret);\n\t}\nout:\n\tdput(dentry);\n\tpath_put(&path);\n\treturn audit_mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pathname"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "audit_mark_path(old->exe)",
            "GFP_KERNEL"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_mark_path",
          "args": [
            "old->exe"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mark_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_fsnotify.c",
          "lines": "55-58",
          "snippet": "char *audit_mark_path(struct audit_fsnotify_mark *mark)\n{\n\treturn mark->path;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nchar *audit_mark_path(struct audit_fsnotify_mark *mark)\n{\n\treturn mark->path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_dupe_exe(struct audit_krule *new, struct audit_krule *old)\n{\n\tstruct audit_fsnotify_mark *audit_mark;\n\tchar *pathname;\n\n\tpathname = kstrdup(audit_mark_path(old->exe), GFP_KERNEL);\n\tif (!pathname)\n\t\treturn -ENOMEM;\n\n\taudit_mark = audit_alloc_mark(new, pathname, strlen(pathname));\n\tif (IS_ERR(audit_mark)) {\n\t\tkfree(pathname);\n\t\treturn PTR_ERR(audit_mark);\n\t}\n\tnew->exe = audit_mark;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_watch_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "494-502",
    "snippet": "static int __init audit_watch_init(void)\n{\n\taudit_watch_group = fsnotify_alloc_group(&audit_watch_fsnotify_ops);\n\tif (IS_ERR(audit_watch_group)) {\n\t\taudit_watch_group = NULL;\n\t\taudit_panic(\"cannot create audit fsnotify group\");\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_watch_group;",
      "static const struct fsnotify_ops audit_watch_fsnotify_ops = {\n\t.handle_inode_event =\taudit_watch_handle_event,\n\t.free_mark =\t\taudit_watch_free_mark,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"cannot create audit fsnotify group\""
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "302-315",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "audit_watch_group"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_alloc_group",
          "args": [
            "&audit_watch_fsnotify_ops"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\nstatic const struct fsnotify_ops audit_watch_fsnotify_ops = {\n\t.handle_inode_event =\taudit_watch_handle_event,\n\t.free_mark =\t\taudit_watch_free_mark,\n};\n\nstatic int __init audit_watch_init(void)\n{\n\taudit_watch_group = fsnotify_alloc_group(&audit_watch_fsnotify_ops);\n\tif (IS_ERR(audit_watch_group)) {\n\t\taudit_watch_group = NULL;\n\t\taudit_panic(\"cannot create audit fsnotify group\");\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_watch_handle_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "468-487",
    "snippet": "static int audit_watch_handle_event(struct fsnotify_mark *inode_mark, u32 mask,\n\t\t\t\t    struct inode *inode, struct inode *dir,\n\t\t\t\t    const struct qstr *dname, u32 cookie)\n{\n\tstruct audit_parent *parent;\n\n\tparent = container_of(inode_mark, struct audit_parent, mark);\n\n\tif (WARN_ON_ONCE(inode_mark->group != audit_watch_group))\n\t\treturn 0;\n\n\tif (mask & (FS_CREATE|FS_MOVED_TO) && inode)\n\t\taudit_update_watch(parent, dname, inode->i_sb->s_dev, inode->i_ino, 0);\n\telse if (mask & (FS_DELETE|FS_MOVED_FROM))\n\t\taudit_update_watch(parent, dname, AUDIT_DEV_UNSET, AUDIT_INO_UNSET, 1);\n\telse if (mask & (FS_DELETE_SELF|FS_UNMOUNT|FS_MOVE_SELF))\n\t\taudit_remove_parent_watches(parent);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_watch_group;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_remove_parent_watches",
          "args": [
            "parent"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_parent_watches",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "322-345",
          "snippet": "static void audit_remove_parent_watches(struct audit_parent *parent)\n{\n\tstruct audit_watch *w, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *e;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_for_each_entry_safe(w, nextw, &parent->watches, wlist) {\n\t\tlist_for_each_entry_safe(r, nextr, &w->rules, rlist) {\n\t\t\te = container_of(r, struct audit_entry, rule);\n\t\t\taudit_watch_log_rule_change(r, w, \"remove_rule\");\n\t\t\tif (e->rule.exe)\n\t\t\t\taudit_remove_mark(e->rule.exe);\n\t\t\tlist_del(&r->rlist);\n\t\t\tlist_del(&r->list);\n\t\t\tlist_del_rcu(&e->list);\n\t\t\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\t\t}\n\t\taudit_remove_watch(w);\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\n\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_watch_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nstatic void audit_remove_parent_watches(struct audit_parent *parent)\n{\n\tstruct audit_watch *w, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *e;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_for_each_entry_safe(w, nextw, &parent->watches, wlist) {\n\t\tlist_for_each_entry_safe(r, nextr, &w->rules, rlist) {\n\t\t\te = container_of(r, struct audit_entry, rule);\n\t\t\taudit_watch_log_rule_change(r, w, \"remove_rule\");\n\t\t\tif (e->rule.exe)\n\t\t\t\taudit_remove_mark(e->rule.exe);\n\t\t\tlist_del(&r->rlist);\n\t\t\tlist_del(&r->list);\n\t\t\tlist_del_rcu(&e->list);\n\t\t\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\t\t}\n\t\taudit_remove_watch(w);\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\n\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_update_watch",
          "args": [
            "parent",
            "dname",
            "AUDIT_DEV_UNSET",
            "AUDIT_INO_UNSET",
            "1"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "audit_update_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "245-319",
          "snippet": "static void audit_update_watch(struct audit_parent *parent,\n\t\t\t       const struct qstr *dname, dev_t dev,\n\t\t\t       unsigned long ino, unsigned invalidating)\n{\n\tstruct audit_watch *owatch, *nwatch, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *oentry, *nentry;\n\n\tmutex_lock(&audit_filter_mutex);\n\t/* Run all of the watches on this parent looking for the one that\n\t * matches the given dname */\n\tlist_for_each_entry_safe(owatch, nextw, &parent->watches, wlist) {\n\t\tif (audit_compare_dname_path(dname, owatch->path,\n\t\t\t\t\t     AUDIT_NAME_FULL))\n\t\t\tcontinue;\n\n\t\t/* If the update involves invalidating rules, do the inode-based\n\t\t * filtering now, so we don't omit records. */\n\t\tif (invalidating && !audit_dummy_context())\n\t\t\taudit_filter_inodes(current, audit_context());\n\n\t\t/* updating ino will likely change which audit_hash_list we\n\t\t * are on so we need a new watch for the new list */\n\t\tnwatch = audit_dupe_watch(owatch);\n\t\tif (IS_ERR(nwatch)) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\taudit_panic(\"error updating watch, skipping\");\n\t\t\treturn;\n\t\t}\n\t\tnwatch->dev = dev;\n\t\tnwatch->ino = ino;\n\n\t\tlist_for_each_entry_safe(r, nextr, &owatch->rules, rlist) {\n\n\t\t\toentry = container_of(r, struct audit_entry, rule);\n\t\t\tlist_del(&oentry->rule.rlist);\n\t\t\tlist_del_rcu(&oentry->list);\n\n\t\t\tnentry = audit_dupe_rule(&oentry->rule);\n\t\t\tif (IS_ERR(nentry)) {\n\t\t\t\tlist_del(&oentry->rule.list);\n\t\t\t\taudit_panic(\"error updating watch, removing\");\n\t\t\t} else {\n\t\t\t\tint h = audit_hash_ino((u32)ino);\n\n\t\t\t\t/*\n\t\t\t\t * nentry->rule.watch == oentry->rule.watch so\n\t\t\t\t * we must drop that reference and set it to our\n\t\t\t\t * new watch.\n\t\t\t\t */\n\t\t\t\taudit_put_watch(nentry->rule.watch);\n\t\t\t\taudit_get_watch(nwatch);\n\t\t\t\tnentry->rule.watch = nwatch;\n\t\t\t\tlist_add(&nentry->rule.rlist, &nwatch->rules);\n\t\t\t\tlist_add_rcu(&nentry->list, &audit_inode_hash[h]);\n\t\t\t\tlist_replace(&oentry->rule.list,\n\t\t\t\t\t     &nentry->rule.list);\n\t\t\t}\n\t\t\tif (oentry->rule.exe)\n\t\t\t\taudit_remove_mark(oentry->rule.exe);\n\n\t\t\tcall_rcu(&oentry->rcu, audit_free_rule_rcu);\n\t\t}\n\n\t\taudit_remove_watch(owatch);\n\t\tgoto add_watch_to_parent; /* event applies to a single watch */\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n\nadd_watch_to_parent:\n\tlist_add(&nwatch->wlist, &parent->watches);\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_update_watch(struct audit_parent *parent,\n\t\t\t       const struct qstr *dname, dev_t dev,\n\t\t\t       unsigned long ino, unsigned invalidating)\n{\n\tstruct audit_watch *owatch, *nwatch, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *oentry, *nentry;\n\n\tmutex_lock(&audit_filter_mutex);\n\t/* Run all of the watches on this parent looking for the one that\n\t * matches the given dname */\n\tlist_for_each_entry_safe(owatch, nextw, &parent->watches, wlist) {\n\t\tif (audit_compare_dname_path(dname, owatch->path,\n\t\t\t\t\t     AUDIT_NAME_FULL))\n\t\t\tcontinue;\n\n\t\t/* If the update involves invalidating rules, do the inode-based\n\t\t * filtering now, so we don't omit records. */\n\t\tif (invalidating && !audit_dummy_context())\n\t\t\taudit_filter_inodes(current, audit_context());\n\n\t\t/* updating ino will likely change which audit_hash_list we\n\t\t * are on so we need a new watch for the new list */\n\t\tnwatch = audit_dupe_watch(owatch);\n\t\tif (IS_ERR(nwatch)) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\taudit_panic(\"error updating watch, skipping\");\n\t\t\treturn;\n\t\t}\n\t\tnwatch->dev = dev;\n\t\tnwatch->ino = ino;\n\n\t\tlist_for_each_entry_safe(r, nextr, &owatch->rules, rlist) {\n\n\t\t\toentry = container_of(r, struct audit_entry, rule);\n\t\t\tlist_del(&oentry->rule.rlist);\n\t\t\tlist_del_rcu(&oentry->list);\n\n\t\t\tnentry = audit_dupe_rule(&oentry->rule);\n\t\t\tif (IS_ERR(nentry)) {\n\t\t\t\tlist_del(&oentry->rule.list);\n\t\t\t\taudit_panic(\"error updating watch, removing\");\n\t\t\t} else {\n\t\t\t\tint h = audit_hash_ino((u32)ino);\n\n\t\t\t\t/*\n\t\t\t\t * nentry->rule.watch == oentry->rule.watch so\n\t\t\t\t * we must drop that reference and set it to our\n\t\t\t\t * new watch.\n\t\t\t\t */\n\t\t\t\taudit_put_watch(nentry->rule.watch);\n\t\t\t\taudit_get_watch(nwatch);\n\t\t\t\tnentry->rule.watch = nwatch;\n\t\t\t\tlist_add(&nentry->rule.rlist, &nwatch->rules);\n\t\t\t\tlist_add_rcu(&nentry->list, &audit_inode_hash[h]);\n\t\t\t\tlist_replace(&oentry->rule.list,\n\t\t\t\t\t     &nentry->rule.list);\n\t\t\t}\n\t\t\tif (oentry->rule.exe)\n\t\t\t\taudit_remove_mark(oentry->rule.exe);\n\n\t\t\tcall_rcu(&oentry->rcu, audit_free_rule_rcu);\n\t\t}\n\n\t\taudit_remove_watch(owatch);\n\t\tgoto add_watch_to_parent; /* event applies to a single watch */\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n\nadd_watch_to_parent:\n\tlist_add(&nwatch->wlist, &parent->watches);\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "inode_mark->group != audit_watch_group"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "inode_mark",
            "structaudit_parent",
            "mark"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nstatic int audit_watch_handle_event(struct fsnotify_mark *inode_mark, u32 mask,\n\t\t\t\t    struct inode *inode, struct inode *dir,\n\t\t\t\t    const struct qstr *dname, u32 cookie)\n{\n\tstruct audit_parent *parent;\n\n\tparent = container_of(inode_mark, struct audit_parent, mark);\n\n\tif (WARN_ON_ONCE(inode_mark->group != audit_watch_group))\n\t\treturn 0;\n\n\tif (mask & (FS_CREATE|FS_MOVED_TO) && inode)\n\t\taudit_update_watch(parent, dname, inode->i_sb->s_dev, inode->i_ino, 0);\n\telse if (mask & (FS_DELETE|FS_MOVED_FROM))\n\t\taudit_update_watch(parent, dname, AUDIT_DEV_UNSET, AUDIT_INO_UNSET, 1);\n\telse if (mask & (FS_DELETE_SELF|FS_UNMOUNT|FS_MOVE_SELF))\n\t\taudit_remove_parent_watches(parent);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_remove_watch_rule",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "447-465",
    "snippet": "void audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_watch_group;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_put_parent",
          "args": [
            "parent"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "78-82",
          "snippet": "static void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_mark",
          "args": [
            "&parent->mark",
            "audit_watch_group"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&parent->watches"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_watch",
          "args": [
            "watch"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_watch_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "447-465",
          "snippet": "void audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_parent",
          "args": [
            "parent"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "72-76",
          "snippet": "static void audit_get_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_get_mark(&parent->mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_get_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_get_mark(&parent->mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&krule->rlist"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nvoid audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}"
  },
  {
    "function_name": "audit_add_watch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "400-445",
    "snippet": "int audit_add_watch(struct audit_krule *krule, struct list_head **list)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent;\n\tstruct path parent_path;\n\tint h, ret = 0;\n\n\t/*\n\t * When we will be calling audit_add_to_parent, krule->watch might have\n\t * been updated and watch might have been freed.\n\t * So we need to keep a reference of watch.\n\t */\n\taudit_get_watch(watch);\n\n\tmutex_unlock(&audit_filter_mutex);\n\n\t/* Avoid calling path_lookup under audit_filter_mutex. */\n\tret = audit_get_nd(watch, &parent_path);\n\n\t/* caller expects mutex locked */\n\tmutex_lock(&audit_filter_mutex);\n\n\tif (ret) {\n\t\taudit_put_watch(watch);\n\t\treturn ret;\n\t}\n\n\t/* either find an old parent or attach a new one */\n\tparent = audit_find_parent(d_backing_inode(parent_path.dentry));\n\tif (!parent) {\n\t\tparent = audit_init_parent(&parent_path);\n\t\tif (IS_ERR(parent)) {\n\t\t\tret = PTR_ERR(parent);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\taudit_add_to_parent(krule, parent);\n\n\th = audit_hash_ino((u32)watch->ino);\n\t*list = &audit_inode_hash[h];\nerror:\n\tpath_put(&parent_path);\n\taudit_put_watch(watch);\n\treturn ret;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_put_watch",
          "args": [
            "watch"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "105-113",
          "snippet": "void audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&parent_path"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_hash_ino",
          "args": [
            "(u32)watch->ino"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "audit_hash_ino",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.h",
          "lines": "218-221",
          "snippet": "static inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}",
          "includes": [
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <linux/tty.h>",
            "#include <uapi/linux/mqueue.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/audit.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define AUDIT_INODE_BUCKETS\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/openat2.h> // struct open_how\n#include <linux/tty.h>\n#include <uapi/linux/mqueue.h>\n#include <linux/skbuff.h>\n#include <linux/audit.h>\n#include <linux/fs.h>\n\n#define AUDIT_INODE_BUCKETS\t32\n\nstatic inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_add_to_parent",
          "args": [
            "krule",
            "parent"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "audit_add_to_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "365-396",
          "snippet": "static void audit_add_to_parent(struct audit_krule *krule,\n\t\t\t\tstruct audit_parent *parent)\n{\n\tstruct audit_watch *w, *watch = krule->watch;\n\tint watch_found = 0;\n\n\tBUG_ON(!mutex_is_locked(&audit_filter_mutex));\n\n\tlist_for_each_entry(w, &parent->watches, wlist) {\n\t\tif (strcmp(watch->path, w->path))\n\t\t\tcontinue;\n\n\t\twatch_found = 1;\n\n\t\t/* put krule's ref to temporary watch */\n\t\taudit_put_watch(watch);\n\n\t\taudit_get_watch(w);\n\t\tkrule->watch = watch = w;\n\n\t\taudit_put_parent(parent);\n\t\tbreak;\n\t}\n\n\tif (!watch_found) {\n\t\twatch->parent = parent;\n\n\t\taudit_get_watch(watch);\n\t\tlist_add(&watch->wlist, &parent->watches);\n\t}\n\tlist_add(&krule->rlist, &watch->rules);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_add_to_parent(struct audit_krule *krule,\n\t\t\t\tstruct audit_parent *parent)\n{\n\tstruct audit_watch *w, *watch = krule->watch;\n\tint watch_found = 0;\n\n\tBUG_ON(!mutex_is_locked(&audit_filter_mutex));\n\n\tlist_for_each_entry(w, &parent->watches, wlist) {\n\t\tif (strcmp(watch->path, w->path))\n\t\t\tcontinue;\n\n\t\twatch_found = 1;\n\n\t\t/* put krule's ref to temporary watch */\n\t\taudit_put_watch(watch);\n\n\t\taudit_get_watch(w);\n\t\tkrule->watch = watch = w;\n\n\t\taudit_put_parent(parent);\n\t\tbreak;\n\t}\n\n\tif (!watch_found) {\n\t\twatch->parent = parent;\n\n\t\taudit_get_watch(watch);\n\t\tlist_add(&watch->wlist, &parent->watches);\n\t}\n\tlist_add(&krule->rlist, &watch->rules);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "parent"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "parent"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_init_parent",
          "args": [
            "&parent_path"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "audit_init_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "136-157",
          "snippet": "static struct audit_parent *audit_init_parent(struct path *path)\n{\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tstruct audit_parent *parent;\n\tint ret;\n\n\tparent = kzalloc(sizeof(*parent), GFP_KERNEL);\n\tif (unlikely(!parent))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&parent->watches);\n\n\tfsnotify_init_mark(&parent->mark, audit_watch_group);\n\tparent->mark.mask = AUDIT_FS_WATCH;\n\tret = fsnotify_add_inode_mark(&parent->mark, inode, 0);\n\tif (ret < 0) {\n\t\taudit_free_parent(parent);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn parent;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_FS_WATCH (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\tFS_MOVE_SELF | FS_UNMOUNT)"
          ],
          "globals_used": [
            "static struct fsnotify_group *audit_watch_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\n#define AUDIT_FS_WATCH (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\tFS_MOVE_SELF | FS_UNMOUNT)\n\nstatic struct fsnotify_group *audit_watch_group;\n\nstatic struct audit_parent *audit_init_parent(struct path *path)\n{\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tstruct audit_parent *parent;\n\tint ret;\n\n\tparent = kzalloc(sizeof(*parent), GFP_KERNEL);\n\tif (unlikely(!parent))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&parent->watches);\n\n\tfsnotify_init_mark(&parent->mark, audit_watch_group);\n\tparent->mark.mask = AUDIT_FS_WATCH;\n\tret = fsnotify_add_inode_mark(&parent->mark, inode, 0);\n\tif (ret < 0) {\n\t\taudit_free_parent(parent);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_find_parent",
          "args": [
            "d_backing_inode(parent_path.dentry)"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "audit_find_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "88-98",
          "snippet": "static inline struct audit_parent *audit_find_parent(struct inode *inode)\n{\n\tstruct audit_parent *parent = NULL;\n\tstruct fsnotify_mark *entry;\n\n\tentry = fsnotify_find_mark(&inode->i_fsnotify_marks, audit_watch_group);\n\tif (entry)\n\t\tparent = container_of(entry, struct audit_parent, mark);\n\n\treturn parent;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_watch_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nstatic inline struct audit_parent *audit_find_parent(struct inode *inode)\n{\n\tstruct audit_parent *parent = NULL;\n\tstruct fsnotify_mark *entry;\n\n\tentry = fsnotify_find_mark(&inode->i_fsnotify_marks, audit_watch_group);\n\tif (entry)\n\t\tparent = container_of(entry, struct audit_parent, mark);\n\n\treturn parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "parent_path.dentry"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_nd",
          "args": [
            "watch",
            "&parent_path"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_nd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "348-361",
          "snippet": "static int audit_get_nd(struct audit_watch *watch, struct path *parent)\n{\n\tstruct dentry *d = kern_path_locked(watch->path, parent);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\tif (d_is_positive(d)) {\n\t\t/* update watch filter fields */\n\t\twatch->dev = d->d_sb->s_dev;\n\t\twatch->ino = d_backing_inode(d)->i_ino;\n\t}\n\tinode_unlock(d_backing_inode(parent->dentry));\n\tdput(d);\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic int audit_get_nd(struct audit_watch *watch, struct path *parent)\n{\n\tstruct dentry *d = kern_path_locked(watch->path, parent);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\tif (d_is_positive(d)) {\n\t\t/* update watch filter fields */\n\t\twatch->dev = d->d_sb->s_dev;\n\t\twatch->ino = d_backing_inode(d)->i_ino;\n\t}\n\tinode_unlock(d_backing_inode(parent->dentry));\n\tdput(d);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_watch",
          "args": [
            "watch"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "100-103",
          "snippet": "void audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_add_watch(struct audit_krule *krule, struct list_head **list)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent;\n\tstruct path parent_path;\n\tint h, ret = 0;\n\n\t/*\n\t * When we will be calling audit_add_to_parent, krule->watch might have\n\t * been updated and watch might have been freed.\n\t * So we need to keep a reference of watch.\n\t */\n\taudit_get_watch(watch);\n\n\tmutex_unlock(&audit_filter_mutex);\n\n\t/* Avoid calling path_lookup under audit_filter_mutex. */\n\tret = audit_get_nd(watch, &parent_path);\n\n\t/* caller expects mutex locked */\n\tmutex_lock(&audit_filter_mutex);\n\n\tif (ret) {\n\t\taudit_put_watch(watch);\n\t\treturn ret;\n\t}\n\n\t/* either find an old parent or attach a new one */\n\tparent = audit_find_parent(d_backing_inode(parent_path.dentry));\n\tif (!parent) {\n\t\tparent = audit_init_parent(&parent_path);\n\t\tif (IS_ERR(parent)) {\n\t\t\tret = PTR_ERR(parent);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\taudit_add_to_parent(krule, parent);\n\n\th = audit_hash_ino((u32)watch->ino);\n\t*list = &audit_inode_hash[h];\nerror:\n\tpath_put(&parent_path);\n\taudit_put_watch(watch);\n\treturn ret;\n}"
  },
  {
    "function_name": "audit_add_to_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "365-396",
    "snippet": "static void audit_add_to_parent(struct audit_krule *krule,\n\t\t\t\tstruct audit_parent *parent)\n{\n\tstruct audit_watch *w, *watch = krule->watch;\n\tint watch_found = 0;\n\n\tBUG_ON(!mutex_is_locked(&audit_filter_mutex));\n\n\tlist_for_each_entry(w, &parent->watches, wlist) {\n\t\tif (strcmp(watch->path, w->path))\n\t\t\tcontinue;\n\n\t\twatch_found = 1;\n\n\t\t/* put krule's ref to temporary watch */\n\t\taudit_put_watch(watch);\n\n\t\taudit_get_watch(w);\n\t\tkrule->watch = watch = w;\n\n\t\taudit_put_parent(parent);\n\t\tbreak;\n\t}\n\n\tif (!watch_found) {\n\t\twatch->parent = parent;\n\n\t\taudit_get_watch(watch);\n\t\tlist_add(&watch->wlist, &parent->watches);\n\t}\n\tlist_add(&krule->rlist, &watch->rules);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&krule->rlist",
            "&watch->rules"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_watch",
          "args": [
            "watch"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "100-103",
          "snippet": "void audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_parent",
          "args": [
            "parent"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "78-82",
          "snippet": "static void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_watch",
          "args": [
            "watch"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "105-113",
          "snippet": "void audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "watch->path",
            "w->path"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "w",
            "&parent->watches",
            "wlist"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&audit_filter_mutex)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_is_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "86-89",
          "snippet": "bool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nbool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_add_to_parent(struct audit_krule *krule,\n\t\t\t\tstruct audit_parent *parent)\n{\n\tstruct audit_watch *w, *watch = krule->watch;\n\tint watch_found = 0;\n\n\tBUG_ON(!mutex_is_locked(&audit_filter_mutex));\n\n\tlist_for_each_entry(w, &parent->watches, wlist) {\n\t\tif (strcmp(watch->path, w->path))\n\t\t\tcontinue;\n\n\t\twatch_found = 1;\n\n\t\t/* put krule's ref to temporary watch */\n\t\taudit_put_watch(watch);\n\n\t\taudit_get_watch(w);\n\t\tkrule->watch = watch = w;\n\n\t\taudit_put_parent(parent);\n\t\tbreak;\n\t}\n\n\tif (!watch_found) {\n\t\twatch->parent = parent;\n\n\t\taudit_get_watch(watch);\n\t\tlist_add(&watch->wlist, &parent->watches);\n\t}\n\tlist_add(&krule->rlist, &watch->rules);\n}"
  },
  {
    "function_name": "audit_get_nd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "348-361",
    "snippet": "static int audit_get_nd(struct audit_watch *watch, struct path *parent)\n{\n\tstruct dentry *d = kern_path_locked(watch->path, parent);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\tif (d_is_positive(d)) {\n\t\t/* update watch filter fields */\n\t\twatch->dev = d->d_sb->s_dev;\n\t\twatch->ino = d_backing_inode(d)->i_ino;\n\t}\n\tinode_unlock(d_backing_inode(parent->dentry));\n\tdput(d);\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "d"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "d_backing_inode(parent->dentry)"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "parent->dentry"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "d"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_positive",
          "args": [
            "d"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "d"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "d"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path_locked",
          "args": [
            "watch->path",
            "parent"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic int audit_get_nd(struct audit_watch *watch, struct path *parent)\n{\n\tstruct dentry *d = kern_path_locked(watch->path, parent);\n\tif (IS_ERR(d))\n\t\treturn PTR_ERR(d);\n\tif (d_is_positive(d)) {\n\t\t/* update watch filter fields */\n\t\twatch->dev = d->d_sb->s_dev;\n\t\twatch->ino = d_backing_inode(d)->i_ino;\n\t}\n\tinode_unlock(d_backing_inode(parent->dentry));\n\tdput(d);\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_remove_parent_watches",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "322-345",
    "snippet": "static void audit_remove_parent_watches(struct audit_parent *parent)\n{\n\tstruct audit_watch *w, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *e;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_for_each_entry_safe(w, nextw, &parent->watches, wlist) {\n\t\tlist_for_each_entry_safe(r, nextr, &w->rules, rlist) {\n\t\t\te = container_of(r, struct audit_entry, rule);\n\t\t\taudit_watch_log_rule_change(r, w, \"remove_rule\");\n\t\t\tif (e->rule.exe)\n\t\t\t\taudit_remove_mark(e->rule.exe);\n\t\t\tlist_del(&r->rlist);\n\t\t\tlist_del(&r->list);\n\t\t\tlist_del_rcu(&e->list);\n\t\t\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\t\t}\n\t\taudit_remove_watch(w);\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\n\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_watch_group;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_destroy_mark",
          "args": [
            "&parent->mark",
            "audit_watch_group"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_watch",
          "args": [
            "w"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_watch_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "447-465",
          "snippet": "void audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_watch_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nvoid audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&e->rcu",
            "audit_free_rule_rcu"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&e->list"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&r->list"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_mark",
          "args": [
            "e->rule.exe"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_mark_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_fsnotify.c",
          "lines": "138-143",
          "snippet": "void audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_watch_log_rule_change",
          "args": [
            "r",
            "w",
            "\"remove_rule\""
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "audit_watch_log_rule_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "227-242",
          "snippet": "static void audit_watch_log_rule_change(struct audit_krule *r, struct audit_watch *w, char *op)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(audit_context(), GFP_NOFS, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_session_info(ab);\n\taudit_log_format(ab, \"op=%s path=\", op);\n\taudit_log_untrustedstring(ab, w->path);\n\taudit_log_key(ab, r->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", r->listnr);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_watch_log_rule_change(struct audit_krule *r, struct audit_watch *w, char *op)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(audit_context(), GFP_NOFS, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_session_info(ab);\n\taudit_log_format(ab, \"op=%s path=\", op);\n\taudit_log_untrustedstring(ab, w->path);\n\taudit_log_key(ab, r->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", r->listnr);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "r",
            "structaudit_entry",
            "rule"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "r",
            "nextr",
            "&w->rules",
            "rlist"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "w",
            "nextw",
            "&parent->watches",
            "wlist"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nstatic void audit_remove_parent_watches(struct audit_parent *parent)\n{\n\tstruct audit_watch *w, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *e;\n\n\tmutex_lock(&audit_filter_mutex);\n\tlist_for_each_entry_safe(w, nextw, &parent->watches, wlist) {\n\t\tlist_for_each_entry_safe(r, nextr, &w->rules, rlist) {\n\t\t\te = container_of(r, struct audit_entry, rule);\n\t\t\taudit_watch_log_rule_change(r, w, \"remove_rule\");\n\t\t\tif (e->rule.exe)\n\t\t\t\taudit_remove_mark(e->rule.exe);\n\t\t\tlist_del(&r->rlist);\n\t\t\tlist_del(&r->list);\n\t\t\tlist_del_rcu(&e->list);\n\t\t\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\t\t}\n\t\taudit_remove_watch(w);\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\n\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n}"
  },
  {
    "function_name": "audit_update_watch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "245-319",
    "snippet": "static void audit_update_watch(struct audit_parent *parent,\n\t\t\t       const struct qstr *dname, dev_t dev,\n\t\t\t       unsigned long ino, unsigned invalidating)\n{\n\tstruct audit_watch *owatch, *nwatch, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *oentry, *nentry;\n\n\tmutex_lock(&audit_filter_mutex);\n\t/* Run all of the watches on this parent looking for the one that\n\t * matches the given dname */\n\tlist_for_each_entry_safe(owatch, nextw, &parent->watches, wlist) {\n\t\tif (audit_compare_dname_path(dname, owatch->path,\n\t\t\t\t\t     AUDIT_NAME_FULL))\n\t\t\tcontinue;\n\n\t\t/* If the update involves invalidating rules, do the inode-based\n\t\t * filtering now, so we don't omit records. */\n\t\tif (invalidating && !audit_dummy_context())\n\t\t\taudit_filter_inodes(current, audit_context());\n\n\t\t/* updating ino will likely change which audit_hash_list we\n\t\t * are on so we need a new watch for the new list */\n\t\tnwatch = audit_dupe_watch(owatch);\n\t\tif (IS_ERR(nwatch)) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\taudit_panic(\"error updating watch, skipping\");\n\t\t\treturn;\n\t\t}\n\t\tnwatch->dev = dev;\n\t\tnwatch->ino = ino;\n\n\t\tlist_for_each_entry_safe(r, nextr, &owatch->rules, rlist) {\n\n\t\t\toentry = container_of(r, struct audit_entry, rule);\n\t\t\tlist_del(&oentry->rule.rlist);\n\t\t\tlist_del_rcu(&oentry->list);\n\n\t\t\tnentry = audit_dupe_rule(&oentry->rule);\n\t\t\tif (IS_ERR(nentry)) {\n\t\t\t\tlist_del(&oentry->rule.list);\n\t\t\t\taudit_panic(\"error updating watch, removing\");\n\t\t\t} else {\n\t\t\t\tint h = audit_hash_ino((u32)ino);\n\n\t\t\t\t/*\n\t\t\t\t * nentry->rule.watch == oentry->rule.watch so\n\t\t\t\t * we must drop that reference and set it to our\n\t\t\t\t * new watch.\n\t\t\t\t */\n\t\t\t\taudit_put_watch(nentry->rule.watch);\n\t\t\t\taudit_get_watch(nwatch);\n\t\t\t\tnentry->rule.watch = nwatch;\n\t\t\t\tlist_add(&nentry->rule.rlist, &nwatch->rules);\n\t\t\t\tlist_add_rcu(&nentry->list, &audit_inode_hash[h]);\n\t\t\t\tlist_replace(&oentry->rule.list,\n\t\t\t\t\t     &nentry->rule.list);\n\t\t\t}\n\t\t\tif (oentry->rule.exe)\n\t\t\t\taudit_remove_mark(oentry->rule.exe);\n\n\t\t\tcall_rcu(&oentry->rcu, audit_free_rule_rcu);\n\t\t}\n\n\t\taudit_remove_watch(owatch);\n\t\tgoto add_watch_to_parent; /* event applies to a single watch */\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n\nadd_watch_to_parent:\n\tlist_add(&nwatch->wlist, &parent->watches);\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&nwatch->wlist",
            "&parent->watches"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_watch",
          "args": [
            "owatch"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_watch_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "447-465",
          "snippet": "void audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fsnotify_group *audit_watch_group;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nvoid audit_remove_watch_rule(struct audit_krule *krule)\n{\n\tstruct audit_watch *watch = krule->watch;\n\tstruct audit_parent *parent = watch->parent;\n\n\tlist_del(&krule->rlist);\n\n\tif (list_empty(&watch->rules)) {\n\t\t/*\n\t\t * audit_remove_watch() drops our reference to 'parent' which\n\t\t * can get freed. Grab our own reference to be safe.\n\t\t */\n\t\taudit_get_parent(parent);\n\t\taudit_remove_watch(watch);\n\t\tif (list_empty(&parent->watches))\n\t\t\tfsnotify_destroy_mark(&parent->mark, audit_watch_group);\n\t\taudit_put_parent(parent);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&oentry->rcu",
            "audit_free_rule_rcu"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_remove_mark",
          "args": [
            "oentry->rule.exe"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "audit_remove_mark_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_fsnotify.c",
          "lines": "138-143",
          "snippet": "void audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_remove_mark_rule(struct audit_krule *krule)\n{\n\tstruct audit_fsnotify_mark *mark = krule->exe;\n\n\taudit_remove_mark(mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_replace",
          "args": [
            "&oentry->rule.list",
            "&nentry->rule.list"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&nentry->list",
            "&audit_inode_hash[h]"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_watch",
          "args": [
            "nwatch"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "100-103",
          "snippet": "void audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_watch",
          "args": [
            "nentry->rule.watch"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "105-113",
          "snippet": "void audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_hash_ino",
          "args": [
            "(u32)ino"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "audit_hash_ino",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.h",
          "lines": "218-221",
          "snippet": "static inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}",
          "includes": [
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <linux/tty.h>",
            "#include <uapi/linux/mqueue.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/audit.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define AUDIT_INODE_BUCKETS\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/openat2.h> // struct open_how\n#include <linux/tty.h>\n#include <uapi/linux/mqueue.h>\n#include <linux/skbuff.h>\n#include <linux/audit.h>\n#include <linux/fs.h>\n\n#define AUDIT_INODE_BUCKETS\t32\n\nstatic inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"error updating watch, removing\""
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "302-315",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&oentry->rule.list"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nentry"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_dupe_rule",
          "args": [
            "&oentry->rule"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "audit_dupe_rule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "819-895",
          "snippet": "struct audit_entry *audit_dupe_rule(struct audit_krule *old)\n{\n\tu32 fcount = old->field_count;\n\tstruct audit_entry *entry;\n\tstruct audit_krule *new;\n\tchar *fk;\n\tint i, err = 0;\n\n\tentry = audit_init_entry(fcount);\n\tif (unlikely(!entry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = &entry->rule;\n\tnew->flags = old->flags;\n\tnew->pflags = old->pflags;\n\tnew->listnr = old->listnr;\n\tnew->action = old->action;\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tnew->mask[i] = old->mask[i];\n\tnew->prio = old->prio;\n\tnew->buflen = old->buflen;\n\tnew->inode_f = old->inode_f;\n\tnew->field_count = old->field_count;\n\n\t/*\n\t * note that we are OK with not refcounting here; audit_match_tree()\n\t * never dereferences tree and we can't get false positives there\n\t * since we'd have to have rule gone from the list *and* removed\n\t * before the chunks found by lookup had been allocated, i.e. before\n\t * the beginning of list scan.\n\t */\n\tnew->tree = old->tree;\n\tmemcpy(new->fields, old->fields, sizeof(struct audit_field) * fcount);\n\n\t/* deep copy this information, updating the lsm_rule fields, because\n\t * the originals will all be freed when the old rule is freed. */\n\tfor (i = 0; i < fcount; i++) {\n\t\tswitch (new->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\terr = audit_dupe_lsm_field(&new->fields[i],\n\t\t\t\t\t\t       &old->fields[i]);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tfk = kstrdup(old->filterkey, GFP_KERNEL);\n\t\t\tif (unlikely(!fk))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse\n\t\t\t\tnew->filterkey = fk;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\terr = audit_dupe_exe(new, old);\n\t\t\tbreak;\n\t\t}\n\t\tif (err) {\n\t\t\tif (new->exe)\n\t\t\t\taudit_remove_mark(new->exe);\n\t\t\taudit_free_rule(entry);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tif (old->watch) {\n\t\taudit_get_watch(old->watch);\n\t\tnew->watch = old->watch;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstruct audit_entry *audit_dupe_rule(struct audit_krule *old)\n{\n\tu32 fcount = old->field_count;\n\tstruct audit_entry *entry;\n\tstruct audit_krule *new;\n\tchar *fk;\n\tint i, err = 0;\n\n\tentry = audit_init_entry(fcount);\n\tif (unlikely(!entry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = &entry->rule;\n\tnew->flags = old->flags;\n\tnew->pflags = old->pflags;\n\tnew->listnr = old->listnr;\n\tnew->action = old->action;\n\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\tnew->mask[i] = old->mask[i];\n\tnew->prio = old->prio;\n\tnew->buflen = old->buflen;\n\tnew->inode_f = old->inode_f;\n\tnew->field_count = old->field_count;\n\n\t/*\n\t * note that we are OK with not refcounting here; audit_match_tree()\n\t * never dereferences tree and we can't get false positives there\n\t * since we'd have to have rule gone from the list *and* removed\n\t * before the chunks found by lookup had been allocated, i.e. before\n\t * the beginning of list scan.\n\t */\n\tnew->tree = old->tree;\n\tmemcpy(new->fields, old->fields, sizeof(struct audit_field) * fcount);\n\n\t/* deep copy this information, updating the lsm_rule fields, because\n\t * the originals will all be freed when the old rule is freed. */\n\tfor (i = 0; i < fcount; i++) {\n\t\tswitch (new->fields[i].type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\terr = audit_dupe_lsm_field(&new->fields[i],\n\t\t\t\t\t\t       &old->fields[i]);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\tfk = kstrdup(old->filterkey, GFP_KERNEL);\n\t\t\tif (unlikely(!fk))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse\n\t\t\t\tnew->filterkey = fk;\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\terr = audit_dupe_exe(new, old);\n\t\t\tbreak;\n\t\t}\n\t\tif (err) {\n\t\t\tif (new->exe)\n\t\t\t\taudit_remove_mark(new->exe);\n\t\t\taudit_free_rule(entry);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tif (old->watch) {\n\t\taudit_get_watch(old->watch);\n\t\tnew->watch = old->watch;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&oentry->list"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "r",
            "structaudit_entry",
            "rule"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "r",
            "nextr",
            "&owatch->rules",
            "rlist"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nwatch"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_dupe_watch",
          "args": [
            "owatch"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "audit_dupe_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "203-225",
          "snippet": "static struct audit_watch *audit_dupe_watch(struct audit_watch *old)\n{\n\tchar *path;\n\tstruct audit_watch *new;\n\n\tpath = kstrdup(old->path, GFP_KERNEL);\n\tif (unlikely(!path))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = audit_init_watch(path);\n\tif (IS_ERR(new)) {\n\t\tkfree(path);\n\t\tgoto out;\n\t}\n\n\tnew->dev = old->dev;\n\tnew->ino = old->ino;\n\taudit_get_parent(old->parent);\n\tnew->parent = old->parent;\n\nout:\n\treturn new;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct audit_watch *audit_dupe_watch(struct audit_watch *old)\n{\n\tchar *path;\n\tstruct audit_watch *new;\n\n\tpath = kstrdup(old->path, GFP_KERNEL);\n\tif (unlikely(!path))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = audit_init_watch(path);\n\tif (IS_ERR(new)) {\n\t\tkfree(path);\n\t\tgoto out;\n\t}\n\n\tnew->dev = old->dev;\n\tnew->ino = old->ino;\n\taudit_get_parent(old->parent);\n\tnew->parent = old->parent;\n\nout:\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_filter_inodes",
          "args": [
            "current",
            "audit_context()"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_inodes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "891-905",
          "snippet": "void audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_dummy_context",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_compare_dname_path",
          "args": [
            "dname",
            "owatch->path",
            "AUDIT_NAME_FULL"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "audit_compare_dname_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "1310-1327",
          "snippet": "int audit_compare_dname_path(const struct qstr *dname, const char *path, int parentlen)\n{\n\tint dlen, pathlen;\n\tconst char *p;\n\n\tdlen = dname->len;\n\tpathlen = strlen(path);\n\tif (pathlen < dlen)\n\t\treturn 1;\n\n\tparentlen = parentlen == AUDIT_NAME_FULL ? parent_len(path) : parentlen;\n\tif (pathlen - parentlen != dlen)\n\t\treturn 1;\n\n\tp = path + parentlen;\n\n\treturn strncmp(p, dname->name, dlen);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_compare_dname_path(const struct qstr *dname, const char *path, int parentlen)\n{\n\tint dlen, pathlen;\n\tconst char *p;\n\n\tdlen = dname->len;\n\tpathlen = strlen(path);\n\tif (pathlen < dlen)\n\t\treturn 1;\n\n\tparentlen = parentlen == AUDIT_NAME_FULL ? parent_len(path) : parentlen;\n\tif (pathlen - parentlen != dlen)\n\t\treturn 1;\n\n\tp = path + parentlen;\n\n\treturn strncmp(p, dname->name, dlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "owatch",
            "nextw",
            "&parent->watches",
            "wlist"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&audit_filter_mutex"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_update_watch(struct audit_parent *parent,\n\t\t\t       const struct qstr *dname, dev_t dev,\n\t\t\t       unsigned long ino, unsigned invalidating)\n{\n\tstruct audit_watch *owatch, *nwatch, *nextw;\n\tstruct audit_krule *r, *nextr;\n\tstruct audit_entry *oentry, *nentry;\n\n\tmutex_lock(&audit_filter_mutex);\n\t/* Run all of the watches on this parent looking for the one that\n\t * matches the given dname */\n\tlist_for_each_entry_safe(owatch, nextw, &parent->watches, wlist) {\n\t\tif (audit_compare_dname_path(dname, owatch->path,\n\t\t\t\t\t     AUDIT_NAME_FULL))\n\t\t\tcontinue;\n\n\t\t/* If the update involves invalidating rules, do the inode-based\n\t\t * filtering now, so we don't omit records. */\n\t\tif (invalidating && !audit_dummy_context())\n\t\t\taudit_filter_inodes(current, audit_context());\n\n\t\t/* updating ino will likely change which audit_hash_list we\n\t\t * are on so we need a new watch for the new list */\n\t\tnwatch = audit_dupe_watch(owatch);\n\t\tif (IS_ERR(nwatch)) {\n\t\t\tmutex_unlock(&audit_filter_mutex);\n\t\t\taudit_panic(\"error updating watch, skipping\");\n\t\t\treturn;\n\t\t}\n\t\tnwatch->dev = dev;\n\t\tnwatch->ino = ino;\n\n\t\tlist_for_each_entry_safe(r, nextr, &owatch->rules, rlist) {\n\n\t\t\toentry = container_of(r, struct audit_entry, rule);\n\t\t\tlist_del(&oentry->rule.rlist);\n\t\t\tlist_del_rcu(&oentry->list);\n\n\t\t\tnentry = audit_dupe_rule(&oentry->rule);\n\t\t\tif (IS_ERR(nentry)) {\n\t\t\t\tlist_del(&oentry->rule.list);\n\t\t\t\taudit_panic(\"error updating watch, removing\");\n\t\t\t} else {\n\t\t\t\tint h = audit_hash_ino((u32)ino);\n\n\t\t\t\t/*\n\t\t\t\t * nentry->rule.watch == oentry->rule.watch so\n\t\t\t\t * we must drop that reference and set it to our\n\t\t\t\t * new watch.\n\t\t\t\t */\n\t\t\t\taudit_put_watch(nentry->rule.watch);\n\t\t\t\taudit_get_watch(nwatch);\n\t\t\t\tnentry->rule.watch = nwatch;\n\t\t\t\tlist_add(&nentry->rule.rlist, &nwatch->rules);\n\t\t\t\tlist_add_rcu(&nentry->list, &audit_inode_hash[h]);\n\t\t\t\tlist_replace(&oentry->rule.list,\n\t\t\t\t\t     &nentry->rule.list);\n\t\t\t}\n\t\t\tif (oentry->rule.exe)\n\t\t\t\taudit_remove_mark(oentry->rule.exe);\n\n\t\t\tcall_rcu(&oentry->rcu, audit_free_rule_rcu);\n\t\t}\n\n\t\taudit_remove_watch(owatch);\n\t\tgoto add_watch_to_parent; /* event applies to a single watch */\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n\nadd_watch_to_parent:\n\tlist_add(&nwatch->wlist, &parent->watches);\n\tmutex_unlock(&audit_filter_mutex);\n\treturn;\n}"
  },
  {
    "function_name": "audit_watch_log_rule_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "227-242",
    "snippet": "static void audit_watch_log_rule_change(struct audit_krule *r, struct audit_watch *w, char *op)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(audit_context(), GFP_NOFS, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_session_info(ab);\n\taudit_log_format(ab, \"op=%s path=\", op);\n\taudit_log_untrustedstring(ab, w->path);\n\taudit_log_key(ab, r->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", r->listnr);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2386-2410",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" list=%d res=1\"",
            "r->listnr"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1968-1977",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_key",
          "args": [
            "ab",
            "r->filterkey"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2134-2141",
          "snippet": "void audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "w->path"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2097-2100",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_session_info",
          "args": [
            "ab"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_session_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2126-2132",
          "snippet": "void audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \"auid=%u ses=%u\", auid, sessionid);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_session_info(struct audit_buffer *ab)\n{\n\tunsigned int sessionid = audit_get_sessionid(current);\n\tuid_t auid = from_kuid(&init_user_ns, audit_get_loginuid(current));\n\n\taudit_log_format(ab, \"auid=%u ses=%u\", auid, sessionid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "audit_context()",
            "GFP_NOFS",
            "AUDIT_CONFIG_CHANGE"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "1822-1890",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized = AUDIT_UNINITIALIZED;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized = AUDIT_UNINITIALIZED;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic atomic_t audit_backlog_wait_time_actual = ATOMIC_INIT(0);\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int serial;\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex, although we do penalize the sender\n\t *    later in audit_receive() when it is safe to block\n\t */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tlong rtime = stime;\n\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(rtime);\n\t\t\t\tatomic_add(rtime - stime, &audit_backlog_wait_time_actual);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\t/* cancel dummy context to enable supporting records */\n\tif (ctx)\n\t\tctx->dummy = 0;\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_watch_log_rule_change(struct audit_krule *r, struct audit_watch *w, char *op)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\tab = audit_log_start(audit_context(), GFP_NOFS, AUDIT_CONFIG_CHANGE);\n\tif (!ab)\n\t\treturn;\n\taudit_log_session_info(ab);\n\taudit_log_format(ab, \"op=%s path=\", op);\n\taudit_log_untrustedstring(ab, w->path);\n\taudit_log_key(ab, r->filterkey);\n\taudit_log_format(ab, \" list=%d res=1\", r->listnr);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_dupe_watch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "203-225",
    "snippet": "static struct audit_watch *audit_dupe_watch(struct audit_watch *old)\n{\n\tchar *path;\n\tstruct audit_watch *new;\n\n\tpath = kstrdup(old->path, GFP_KERNEL);\n\tif (unlikely(!path))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = audit_init_watch(path);\n\tif (IS_ERR(new)) {\n\t\tkfree(path);\n\t\tgoto out;\n\t}\n\n\tnew->dev = old->dev;\n\tnew->ino = old->ino;\n\taudit_get_parent(old->parent);\n\tnew->parent = old->parent;\n\nout:\n\treturn new;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_get_parent",
          "args": [
            "old->parent"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "72-76",
          "snippet": "static void audit_get_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_get_mark(&parent->mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_get_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_get_mark(&parent->mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "path"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_init_watch",
          "args": [
            "path"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "audit_init_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "160-175",
          "snippet": "static struct audit_watch *audit_init_watch(char *path)\n{\n\tstruct audit_watch *watch;\n\n\twatch = kzalloc(sizeof(*watch), GFP_KERNEL);\n\tif (unlikely(!watch))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&watch->rules);\n\trefcount_set(&watch->count, 1);\n\twatch->path = path;\n\twatch->dev = AUDIT_DEV_UNSET;\n\twatch->ino = AUDIT_INO_UNSET;\n\n\treturn watch;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct audit_watch *audit_init_watch(char *path)\n{\n\tstruct audit_watch *watch;\n\n\twatch = kzalloc(sizeof(*watch), GFP_KERNEL);\n\tif (unlikely(!watch))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&watch->rules);\n\trefcount_set(&watch->count, 1);\n\twatch->path = path;\n\twatch->dev = AUDIT_DEV_UNSET;\n\twatch->ino = AUDIT_INO_UNSET;\n\n\treturn watch;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!path"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "old->path",
            "GFP_KERNEL"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct audit_watch *audit_dupe_watch(struct audit_watch *old)\n{\n\tchar *path;\n\tstruct audit_watch *new;\n\n\tpath = kstrdup(old->path, GFP_KERNEL);\n\tif (unlikely(!path))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew = audit_init_watch(path);\n\tif (IS_ERR(new)) {\n\t\tkfree(path);\n\t\tgoto out;\n\t}\n\n\tnew->dev = old->dev;\n\tnew->ino = old->ino;\n\taudit_get_parent(old->parent);\n\tnew->parent = old->parent;\n\nout:\n\treturn new;\n}"
  },
  {
    "function_name": "audit_to_watch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "178-199",
    "snippet": "int audit_to_watch(struct audit_krule *krule, char *path, int len, u32 op)\n{\n\tstruct audit_watch *watch;\n\n\tif (!audit_watch_group)\n\t\treturn -EOPNOTSUPP;\n\n\tif (path[0] != '/' || path[len-1] == '/' ||\n\t    (krule->listnr != AUDIT_FILTER_EXIT &&\n\t     krule->listnr != AUDIT_FILTER_URING_EXIT) ||\n\t    op != Audit_equal ||\n\t    krule->inode_f || krule->watch || krule->tree)\n\t\treturn -EINVAL;\n\n\twatch = audit_init_watch(path);\n\tif (IS_ERR(watch))\n\t\treturn PTR_ERR(watch);\n\n\tkrule->watch = watch;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_watch_group;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "watch"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "watch"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_init_watch",
          "args": [
            "path"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "audit_init_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "160-175",
          "snippet": "static struct audit_watch *audit_init_watch(char *path)\n{\n\tstruct audit_watch *watch;\n\n\twatch = kzalloc(sizeof(*watch), GFP_KERNEL);\n\tif (unlikely(!watch))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&watch->rules);\n\trefcount_set(&watch->count, 1);\n\twatch->path = path;\n\twatch->dev = AUDIT_DEV_UNSET;\n\twatch->ino = AUDIT_INO_UNSET;\n\n\treturn watch;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct audit_watch *audit_init_watch(char *path)\n{\n\tstruct audit_watch *watch;\n\n\twatch = kzalloc(sizeof(*watch), GFP_KERNEL);\n\tif (unlikely(!watch))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&watch->rules);\n\trefcount_set(&watch->count, 1);\n\twatch->path = path;\n\twatch->dev = AUDIT_DEV_UNSET;\n\twatch->ino = AUDIT_INO_UNSET;\n\n\treturn watch;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nint audit_to_watch(struct audit_krule *krule, char *path, int len, u32 op)\n{\n\tstruct audit_watch *watch;\n\n\tif (!audit_watch_group)\n\t\treturn -EOPNOTSUPP;\n\n\tif (path[0] != '/' || path[len-1] == '/' ||\n\t    (krule->listnr != AUDIT_FILTER_EXIT &&\n\t     krule->listnr != AUDIT_FILTER_URING_EXIT) ||\n\t    op != Audit_equal ||\n\t    krule->inode_f || krule->watch || krule->tree)\n\t\treturn -EINVAL;\n\n\twatch = audit_init_watch(path);\n\tif (IS_ERR(watch))\n\t\treturn PTR_ERR(watch);\n\n\tkrule->watch = watch;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_init_watch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "160-175",
    "snippet": "static struct audit_watch *audit_init_watch(char *path)\n{\n\tstruct audit_watch *watch;\n\n\twatch = kzalloc(sizeof(*watch), GFP_KERNEL);\n\tif (unlikely(!watch))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&watch->rules);\n\trefcount_set(&watch->count, 1);\n\twatch->path = path;\n\twatch->dev = AUDIT_DEV_UNSET;\n\twatch->ino = AUDIT_INO_UNSET;\n\n\treturn watch;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&watch->count",
            "1"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&watch->rules"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!watch"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*watch)",
            "GFP_KERNEL"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct audit_watch *audit_init_watch(char *path)\n{\n\tstruct audit_watch *watch;\n\n\twatch = kzalloc(sizeof(*watch), GFP_KERNEL);\n\tif (unlikely(!watch))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&watch->rules);\n\trefcount_set(&watch->count, 1);\n\twatch->path = path;\n\twatch->dev = AUDIT_DEV_UNSET;\n\twatch->ino = AUDIT_INO_UNSET;\n\n\treturn watch;\n}"
  },
  {
    "function_name": "audit_init_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "136-157",
    "snippet": "static struct audit_parent *audit_init_parent(struct path *path)\n{\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tstruct audit_parent *parent;\n\tint ret;\n\n\tparent = kzalloc(sizeof(*parent), GFP_KERNEL);\n\tif (unlikely(!parent))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&parent->watches);\n\n\tfsnotify_init_mark(&parent->mark, audit_watch_group);\n\tparent->mark.mask = AUDIT_FS_WATCH;\n\tret = fsnotify_add_inode_mark(&parent->mark, inode, 0);\n\tif (ret < 0) {\n\t\taudit_free_parent(parent);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn parent;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define AUDIT_FS_WATCH (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\tFS_MOVE_SELF | FS_UNMOUNT)"
    ],
    "globals_used": [
      "static struct fsnotify_group *audit_watch_group;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_free_parent",
          "args": [
            "parent"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "58-62",
          "snippet": "static void audit_free_parent(struct audit_parent *parent)\n{\n\tWARN_ON(!list_empty(&parent->watches));\n\tkfree(parent);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_free_parent(struct audit_parent *parent)\n{\n\tWARN_ON(!list_empty(&parent->watches));\n\tkfree(parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_add_inode_mark",
          "args": [
            "&parent->mark",
            "inode",
            "0"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_init_mark",
          "args": [
            "&parent->mark",
            "audit_watch_group"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&parent->watches"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!parent"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*parent)",
            "GFP_KERNEL"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "path->dentry"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\n#define AUDIT_FS_WATCH (FS_MOVE | FS_CREATE | FS_DELETE | FS_DELETE_SELF |\\\n\t\t\tFS_MOVE_SELF | FS_UNMOUNT)\n\nstatic struct fsnotify_group *audit_watch_group;\n\nstatic struct audit_parent *audit_init_parent(struct path *path)\n{\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tstruct audit_parent *parent;\n\tint ret;\n\n\tparent = kzalloc(sizeof(*parent), GFP_KERNEL);\n\tif (unlikely(!parent))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&parent->watches);\n\n\tfsnotify_init_mark(&parent->mark, audit_watch_group);\n\tparent->mark.mask = AUDIT_FS_WATCH;\n\tret = fsnotify_add_inode_mark(&parent->mark, inode, 0);\n\tif (ret < 0) {\n\t\taudit_free_parent(parent);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn parent;\n}"
  },
  {
    "function_name": "audit_watch_compare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "128-133",
    "snippet": "int audit_watch_compare(struct audit_watch *watch, unsigned long ino, dev_t dev)\n{\n\treturn (watch->ino != AUDIT_INO_UNSET) &&\n\t\t(watch->ino == ino) &&\n\t\t(watch->dev == dev);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_watch_compare(struct audit_watch *watch, unsigned long ino, dev_t dev)\n{\n\treturn (watch->ino != AUDIT_INO_UNSET) &&\n\t\t(watch->ino == ino) &&\n\t\t(watch->dev == dev);\n}"
  },
  {
    "function_name": "audit_watch_path",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "123-126",
    "snippet": "char *audit_watch_path(struct audit_watch *watch)\n{\n\treturn watch->path;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nchar *audit_watch_path(struct audit_watch *watch)\n{\n\treturn watch->path;\n}"
  },
  {
    "function_name": "audit_remove_watch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "115-121",
    "snippet": "static void audit_remove_watch(struct audit_watch *watch)\n{\n\tlist_del(&watch->wlist);\n\taudit_put_parent(watch->parent);\n\twatch->parent = NULL;\n\taudit_put_watch(watch); /* match initial get */\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_put_watch",
          "args": [
            "watch"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_watch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "105-113",
          "snippet": "void audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_parent",
          "args": [
            "watch->parent"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "78-82",
          "snippet": "static void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&watch->wlist"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_remove_watch(struct audit_watch *watch)\n{\n\tlist_del(&watch->wlist);\n\taudit_put_parent(watch->parent);\n\twatch->parent = NULL;\n\taudit_put_watch(watch); /* match initial get */\n}"
  },
  {
    "function_name": "audit_put_watch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "105-113",
    "snippet": "void audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "watch"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&watch->rules)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&watch->rules"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "watch->parent"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&watch->count"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_put_watch(struct audit_watch *watch)\n{\n\tif (refcount_dec_and_test(&watch->count)) {\n\t\tWARN_ON(watch->parent);\n\t\tWARN_ON(!list_empty(&watch->rules));\n\t\tkfree(watch->path);\n\t\tkfree(watch);\n\t}\n}"
  },
  {
    "function_name": "audit_get_watch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "100-103",
    "snippet": "void audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refcount_inc",
          "args": [
            "&watch->count"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "53-56",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nvoid audit_get_watch(struct audit_watch *watch)\n{\n\trefcount_inc(&watch->count);\n}"
  },
  {
    "function_name": "audit_find_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "88-98",
    "snippet": "static inline struct audit_parent *audit_find_parent(struct inode *inode)\n{\n\tstruct audit_parent *parent = NULL;\n\tstruct fsnotify_mark *entry;\n\n\tentry = fsnotify_find_mark(&inode->i_fsnotify_marks, audit_watch_group);\n\tif (entry)\n\t\tparent = container_of(entry, struct audit_parent, mark);\n\n\treturn parent;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fsnotify_group *audit_watch_group;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "entry",
            "structaudit_parent",
            "mark"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_find_mark",
          "args": [
            "&inode->i_fsnotify_marks",
            "audit_watch_group"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic struct fsnotify_group *audit_watch_group;\n\nstatic inline struct audit_parent *audit_find_parent(struct inode *inode)\n{\n\tstruct audit_parent *parent = NULL;\n\tstruct fsnotify_mark *entry;\n\n\tentry = fsnotify_find_mark(&inode->i_fsnotify_marks, audit_watch_group);\n\tif (entry)\n\t\tparent = container_of(entry, struct audit_parent, mark);\n\n\treturn parent;\n}"
  },
  {
    "function_name": "audit_put_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "78-82",
    "snippet": "static void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "&parent->mark"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "parent"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_put_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_put_mark(&parent->mark);\n}"
  },
  {
    "function_name": "audit_get_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "72-76",
    "snippet": "static void audit_get_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_get_mark(&parent->mark);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_get_mark",
          "args": [
            "&parent->mark"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "parent"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_get_parent(struct audit_parent *parent)\n{\n\tif (likely(parent))\n\t\tfsnotify_get_mark(&parent->mark);\n}"
  },
  {
    "function_name": "audit_watch_free_mark",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "64-70",
    "snippet": "static void audit_watch_free_mark(struct fsnotify_mark *entry)\n{\n\tstruct audit_parent *parent;\n\n\tparent = container_of(entry, struct audit_parent, mark);\n\taudit_free_parent(parent);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_free_parent",
          "args": [
            "parent"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
          "lines": "58-62",
          "snippet": "static void audit_free_parent(struct audit_parent *parent)\n{\n\tWARN_ON(!list_empty(&parent->watches));\n\tkfree(parent);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_free_parent(struct audit_parent *parent)\n{\n\tWARN_ON(!list_empty(&parent->watches));\n\tkfree(parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "entry",
            "structaudit_parent",
            "mark"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_watch_free_mark(struct fsnotify_mark *entry)\n{\n\tstruct audit_parent *parent;\n\n\tparent = container_of(entry, struct audit_parent, mark);\n\taudit_free_parent(parent);\n}"
  },
  {
    "function_name": "audit_free_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_watch.c",
    "lines": "58-62",
    "snippet": "static void audit_free_parent(struct audit_parent *parent)\n{\n\tWARN_ON(!list_empty(&parent->watches));\n\tkfree(parent);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/refcount.h>",
      "#include <linux/netlink.h>",
      "#include <linux/namei.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kthread.h>",
      "#include <linux/audit.h>",
      "#include <linux/kernel.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "parent"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&parent->watches)"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&parent->watches"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nstatic void audit_free_parent(struct audit_parent *parent)\n{\n\tWARN_ON(!list_empty(&parent->watches));\n\tkfree(parent);\n}"
  }
]