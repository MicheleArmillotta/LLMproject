[
  {
    "function_name": "netns_bpf_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "562-565",
    "snippet": "static int __init netns_bpf_init(void)\n{\n\treturn register_pernet_subsys(&netns_bpf_pernet_ops);\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_pernet_subsys",
          "args": [
            "&netns_bpf_pernet_ops"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int __init netns_bpf_init(void)\n{\n\treturn register_pernet_subsys(&netns_bpf_pernet_ops);\n}"
  },
  {
    "function_name": "netns_bpf_pernet_pre_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "539-555",
    "snippet": "static void __net_exit netns_bpf_pernet_pre_exit(struct net *net)\n{\n\tenum netns_bpf_attach_type type;\n\tstruct bpf_netns_link *net_link;\n\n\tmutex_lock(&netns_bpf_mutex);\n\tfor (type = 0; type < MAX_NETNS_BPF_ATTACH_TYPE; type++) {\n\t\tnetns_bpf_run_array_detach(net, type);\n\t\tlist_for_each_entry(net_link, &net->bpf.links[type], node) {\n\t\t\tnet_link->net = NULL; /* auto-detach link */\n\t\t\tnetns_bpf_attach_type_unneed(type);\n\t\t}\n\t\tif (net->bpf.progs[type])\n\t\t\tbpf_prog_put(net->bpf.progs[type]);\n\t}\n\tmutex_unlock(&netns_bpf_mutex);\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "net->bpf.progs[type]"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netns_bpf_attach_type_unneed",
          "args": [
            "type"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "netns_bpf_attach_type_unneed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "29-40",
          "snippet": "static void netns_bpf_attach_type_unneed(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n#ifdef CONFIG_INET\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\tstatic_branch_dec(&bpf_sk_lookup_enabled);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void netns_bpf_attach_type_unneed(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n#ifdef CONFIG_INET\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\tstatic_branch_dec(&bpf_sk_lookup_enabled);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "net_link",
            "&net->bpf.links[type]",
            "node"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netns_bpf_run_array_detach",
          "args": [
            "net",
            "type"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "netns_bpf_run_array_detach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "56-64",
          "snippet": "static void netns_bpf_run_array_detach(struct net *net,\n\t\t\t\t       enum netns_bpf_attach_type type)\n{\n\tstruct bpf_prog_array *run_array;\n\n\trun_array = rcu_replace_pointer(net->bpf.run_array[type], NULL,\n\t\t\t\t\tlockdep_is_held(&netns_bpf_mutex));\n\tbpf_prog_array_free(run_array);\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void netns_bpf_run_array_detach(struct net *net,\n\t\t\t\t       enum netns_bpf_attach_type type)\n{\n\tstruct bpf_prog_array *run_array;\n\n\trun_array = rcu_replace_pointer(net->bpf.run_array[type], NULL,\n\t\t\t\t\tlockdep_is_held(&netns_bpf_mutex));\n\tbpf_prog_array_free(run_array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void __net_exit netns_bpf_pernet_pre_exit(struct net *net)\n{\n\tenum netns_bpf_attach_type type;\n\tstruct bpf_netns_link *net_link;\n\n\tmutex_lock(&netns_bpf_mutex);\n\tfor (type = 0; type < MAX_NETNS_BPF_ATTACH_TYPE; type++) {\n\t\tnetns_bpf_run_array_detach(net, type);\n\t\tlist_for_each_entry(net_link, &net->bpf.links[type], node) {\n\t\t\tnet_link->net = NULL; /* auto-detach link */\n\t\t\tnetns_bpf_attach_type_unneed(type);\n\t\t}\n\t\tif (net->bpf.progs[type])\n\t\t\tbpf_prog_put(net->bpf.progs[type]);\n\t}\n\tmutex_unlock(&netns_bpf_mutex);\n}"
  },
  {
    "function_name": "netns_bpf_pernet_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "529-537",
    "snippet": "static int __net_init netns_bpf_pernet_init(struct net *net)\n{\n\tint type;\n\n\tfor (type = 0; type < MAX_NETNS_BPF_ATTACH_TYPE; type++)\n\t\tINIT_LIST_HEAD(&net->bpf.links[type]);\n\n\treturn 0;\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&net->bpf.links[type]"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int __net_init netns_bpf_pernet_init(struct net *net)\n{\n\tint type;\n\n\tfor (type = 0; type < MAX_NETNS_BPF_ATTACH_TYPE; type++)\n\t\tINIT_LIST_HEAD(&net->bpf.links[type]);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "netns_bpf_link_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "477-527",
    "snippet": "int netns_bpf_link_create(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tenum netns_bpf_attach_type netns_type;\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_netns_link *net_link;\n\tenum bpf_attach_type type;\n\tstruct net *net;\n\tint err;\n\n\tif (attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\ttype = attr->link_create.attach_type;\n\tnetns_type = to_netns_bpf_attach_type(type);\n\tif (netns_type < 0)\n\t\treturn -EINVAL;\n\n\tnet = get_net_ns_by_fd(attr->link_create.target_fd);\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\tnet_link = kzalloc(sizeof(*net_link), GFP_USER);\n\tif (!net_link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_net;\n\t}\n\tbpf_link_init(&net_link->link, BPF_LINK_TYPE_NETNS,\n\t\t      &bpf_netns_link_ops, prog);\n\tnet_link->net = net;\n\tnet_link->type = type;\n\tnet_link->netns_type = netns_type;\n\n\terr = bpf_link_prime(&net_link->link, &link_primer);\n\tif (err) {\n\t\tkfree(net_link);\n\t\tgoto out_put_net;\n\t}\n\n\terr = netns_bpf_link_attach(net, &net_link->link, netns_type);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_net;\n\t}\n\n\tput_net(net);\n\treturn bpf_link_settle(&link_primer);\n\nout_put_net:\n\tput_net(net);\n\treturn err;\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_link_ops bpf_netns_link_ops = {\n\t.release = bpf_netns_link_release,\n\t.dealloc = bpf_netns_link_dealloc,\n\t.detach = bpf_netns_link_detach,\n\t.update_prog = bpf_netns_link_update_prog,\n\t.fill_link_info = bpf_netns_link_fill_info,\n\t.show_fdinfo = bpf_netns_link_show_fdinfo,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "net"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_settle",
          "args": [
            "&link_primer"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_settle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2598-2608",
          "snippet": "int bpf_link_settle(struct bpf_link_primer *primer)\n{\n\t/* make bpf_link fetchable by ID */\n\tspin_lock_bh(&link_idr_lock);\n\tprimer->link->id = primer->id;\n\tspin_unlock_bh(&link_idr_lock);\n\t/* make bpf_link fetchable by FD */\n\tfd_install(primer->fd, primer->file);\n\t/* pass through installed FD */\n\treturn primer->fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(link_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_SPINLOCK(link_idr_lock);\n\nint bpf_link_settle(struct bpf_link_primer *primer)\n{\n\t/* make bpf_link fetchable by ID */\n\tspin_lock_bh(&link_idr_lock);\n\tprimer->link->id = primer->id;\n\tspin_unlock_bh(&link_idr_lock);\n\t/* make bpf_link fetchable by FD */\n\tfd_install(primer->fd, primer->file);\n\t/* pass through installed FD */\n\treturn primer->fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "net"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_cleanup",
          "args": [
            "&link_primer"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2443-2449",
          "snippet": "void bpf_link_cleanup(struct bpf_link_primer *primer)\n{\n\tprimer->link->prog = NULL;\n\tbpf_link_free_id(primer->id);\n\tfput(primer->file);\n\tput_unused_fd(primer->fd);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_cleanup(struct bpf_link_primer *primer)\n{\n\tprimer->link->prog = NULL;\n\tbpf_link_free_id(primer->id);\n\tfput(primer->file);\n\tput_unused_fd(primer->fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netns_bpf_link_attach",
          "args": [
            "net",
            "&net_link->link",
            "netns_type"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "netns_bpf_link_attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "421-475",
          "snippet": "static int netns_bpf_link_attach(struct net *net, struct bpf_link *link,\n\t\t\t\t enum netns_bpf_attach_type type)\n{\n\tstruct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tstruct bpf_prog_array *run_array;\n\tint cnt, err;\n\n\tmutex_lock(&netns_bpf_mutex);\n\n\tcnt = link_count(net, type);\n\tif (cnt >= netns_bpf_max_progs(type)) {\n\t\terr = -E2BIG;\n\t\tgoto out_unlock;\n\t}\n\t/* Links are not compatible with attaching prog directly */\n\tif (net->bpf.progs[type]) {\n\t\terr = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (type) {\n\tcase NETNS_BPF_FLOW_DISSECTOR:\n\t\terr = flow_dissector_bpf_prog_attach_check(net, link->prog);\n\t\tbreak;\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\terr = 0; /* nothing to check */\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\tif (err)\n\t\tgoto out_unlock;\n\n\trun_array = bpf_prog_array_alloc(cnt + 1, GFP_KERNEL);\n\tif (!run_array) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tlist_add_tail(&net_link->node, &net->bpf.links[type]);\n\n\tfill_prog_array(net, type, run_array);\n\trun_array = rcu_replace_pointer(net->bpf.run_array[type], run_array,\n\t\t\t\t\tlockdep_is_held(&netns_bpf_mutex));\n\tbpf_prog_array_free(run_array);\n\n\t/* Mark attach point as used */\n\tnetns_bpf_attach_type_need(type);\n\nout_unlock:\n\tmutex_unlock(&netns_bpf_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int netns_bpf_link_attach(struct net *net, struct bpf_link *link,\n\t\t\t\t enum netns_bpf_attach_type type)\n{\n\tstruct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tstruct bpf_prog_array *run_array;\n\tint cnt, err;\n\n\tmutex_lock(&netns_bpf_mutex);\n\n\tcnt = link_count(net, type);\n\tif (cnt >= netns_bpf_max_progs(type)) {\n\t\terr = -E2BIG;\n\t\tgoto out_unlock;\n\t}\n\t/* Links are not compatible with attaching prog directly */\n\tif (net->bpf.progs[type]) {\n\t\terr = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (type) {\n\tcase NETNS_BPF_FLOW_DISSECTOR:\n\t\terr = flow_dissector_bpf_prog_attach_check(net, link->prog);\n\t\tbreak;\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\terr = 0; /* nothing to check */\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\tif (err)\n\t\tgoto out_unlock;\n\n\trun_array = bpf_prog_array_alloc(cnt + 1, GFP_KERNEL);\n\tif (!run_array) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tlist_add_tail(&net_link->node, &net->bpf.links[type]);\n\n\tfill_prog_array(net, type, run_array);\n\trun_array = rcu_replace_pointer(net->bpf.run_array[type], run_array,\n\t\t\t\t\tlockdep_is_held(&netns_bpf_mutex));\n\tbpf_prog_array_free(run_array);\n\n\t/* Mark attach point as used */\n\tnetns_bpf_attach_type_need(type);\n\nout_unlock:\n\tmutex_unlock(&netns_bpf_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "net_link"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_prime",
          "args": [
            "&net_link->link",
            "&link_primer"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_prime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2568-2596",
          "snippet": "int bpf_link_prime(struct bpf_link *link, struct bpf_link_primer *primer)\n{\n\tstruct file *file;\n\tint fd, id;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\n\tid = bpf_link_alloc_id(link);\n\tif (id < 0) {\n\t\tput_unused_fd(fd);\n\t\treturn id;\n\t}\n\n\tfile = anon_inode_getfile(\"bpf_link\", &bpf_link_fops, link, O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tbpf_link_free_id(id);\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tprimer->link = link;\n\tprimer->file = file;\n\tprimer->fd = fd;\n\tprimer->id = id;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_link_prime(struct bpf_link *link, struct bpf_link_primer *primer)\n{\n\tstruct file *file;\n\tint fd, id;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\n\tid = bpf_link_alloc_id(link);\n\tif (id < 0) {\n\t\tput_unused_fd(fd);\n\t\treturn id;\n\t}\n\n\tfile = anon_inode_getfile(\"bpf_link\", &bpf_link_fops, link, O_CLOEXEC);\n\tif (IS_ERR(file)) {\n\t\tbpf_link_free_id(id);\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tprimer->link = link;\n\tprimer->file = file;\n\tprimer->fd = fd;\n\tprimer->id = id;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_init",
          "args": [
            "&net_link->link",
            "BPF_LINK_TYPE_NETNS",
            "&bpf_netns_link_ops",
            "prog"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2416-2424",
          "snippet": "void bpf_link_init(struct bpf_link *link, enum bpf_link_type type,\n\t\t   const struct bpf_link_ops *ops, struct bpf_prog *prog)\n{\n\tatomic64_set(&link->refcnt, 1);\n\tlink->type = type;\n\tlink->id = 0;\n\tlink->ops = ops;\n\tlink->prog = prog;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_init(struct bpf_link *link, enum bpf_link_type type,\n\t\t   const struct bpf_link_ops *ops, struct bpf_prog *prog)\n{\n\tatomic64_set(&link->refcnt, 1);\n\tlink->type = type;\n\tlink->id = 0;\n\tlink->ops = ops;\n\tlink->prog = prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*net_link)",
            "GFP_USER"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "net"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "net"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_net_ns_by_fd",
          "args": [
            "attr->link_create.target_fd"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_netns_bpf_attach_type",
          "args": [
            "type"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_link_ops bpf_netns_link_ops = {\n\t.release = bpf_netns_link_release,\n\t.dealloc = bpf_netns_link_dealloc,\n\t.detach = bpf_netns_link_detach,\n\t.update_prog = bpf_netns_link_update_prog,\n\t.fill_link_info = bpf_netns_link_fill_info,\n\t.show_fdinfo = bpf_netns_link_show_fdinfo,\n};\n\nint netns_bpf_link_create(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tenum netns_bpf_attach_type netns_type;\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_netns_link *net_link;\n\tenum bpf_attach_type type;\n\tstruct net *net;\n\tint err;\n\n\tif (attr->link_create.flags)\n\t\treturn -EINVAL;\n\n\ttype = attr->link_create.attach_type;\n\tnetns_type = to_netns_bpf_attach_type(type);\n\tif (netns_type < 0)\n\t\treturn -EINVAL;\n\n\tnet = get_net_ns_by_fd(attr->link_create.target_fd);\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\tnet_link = kzalloc(sizeof(*net_link), GFP_USER);\n\tif (!net_link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_net;\n\t}\n\tbpf_link_init(&net_link->link, BPF_LINK_TYPE_NETNS,\n\t\t      &bpf_netns_link_ops, prog);\n\tnet_link->net = net;\n\tnet_link->type = type;\n\tnet_link->netns_type = netns_type;\n\n\terr = bpf_link_prime(&net_link->link, &link_primer);\n\tif (err) {\n\t\tkfree(net_link);\n\t\tgoto out_put_net;\n\t}\n\n\terr = netns_bpf_link_attach(net, &net_link->link, netns_type);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tgoto out_put_net;\n\t}\n\n\tput_net(net);\n\treturn bpf_link_settle(&link_primer);\n\nout_put_net:\n\tput_net(net);\n\treturn err;\n}"
  },
  {
    "function_name": "netns_bpf_link_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "421-475",
    "snippet": "static int netns_bpf_link_attach(struct net *net, struct bpf_link *link,\n\t\t\t\t enum netns_bpf_attach_type type)\n{\n\tstruct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tstruct bpf_prog_array *run_array;\n\tint cnt, err;\n\n\tmutex_lock(&netns_bpf_mutex);\n\n\tcnt = link_count(net, type);\n\tif (cnt >= netns_bpf_max_progs(type)) {\n\t\terr = -E2BIG;\n\t\tgoto out_unlock;\n\t}\n\t/* Links are not compatible with attaching prog directly */\n\tif (net->bpf.progs[type]) {\n\t\terr = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (type) {\n\tcase NETNS_BPF_FLOW_DISSECTOR:\n\t\terr = flow_dissector_bpf_prog_attach_check(net, link->prog);\n\t\tbreak;\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\terr = 0; /* nothing to check */\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\tif (err)\n\t\tgoto out_unlock;\n\n\trun_array = bpf_prog_array_alloc(cnt + 1, GFP_KERNEL);\n\tif (!run_array) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tlist_add_tail(&net_link->node, &net->bpf.links[type]);\n\n\tfill_prog_array(net, type, run_array);\n\trun_array = rcu_replace_pointer(net->bpf.run_array[type], run_array,\n\t\t\t\t\tlockdep_is_held(&netns_bpf_mutex));\n\tbpf_prog_array_free(run_array);\n\n\t/* Mark attach point as used */\n\tnetns_bpf_attach_type_need(type);\n\nout_unlock:\n\tmutex_unlock(&netns_bpf_mutex);\n\treturn err;\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netns_bpf_attach_type_need",
          "args": [
            "type"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "netns_bpf_attach_type_need",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "42-53",
          "snippet": "static void netns_bpf_attach_type_need(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n#ifdef CONFIG_INET\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\tstatic_branch_inc(&bpf_sk_lookup_enabled);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void netns_bpf_attach_type_need(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n#ifdef CONFIG_INET\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\tstatic_branch_inc(&bpf_sk_lookup_enabled);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_free",
          "args": [
            "run_array"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "1995-2000",
          "snippet": "void bpf_prog_array_free(struct bpf_prog_array *progs)\n{\n\tif (!progs || progs == &empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nvoid bpf_prog_array_free(struct bpf_prog_array *progs)\n{\n\tif (!progs || progs == &empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_replace_pointer",
          "args": [
            "net->bpf.run_array[type]",
            "run_array",
            "lockdep_is_held(&netns_bpf_mutex)"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_prog_array",
          "args": [
            "net",
            "type",
            "run_array"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "fill_prog_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "90-100",
          "snippet": "static void fill_prog_array(struct net *net, enum netns_bpf_attach_type type,\n\t\t\t    struct bpf_prog_array *prog_array)\n{\n\tstruct bpf_netns_link *pos;\n\tunsigned int i = 0;\n\n\tlist_for_each_entry(pos, &net->bpf.links[type], node) {\n\t\tprog_array->items[i].prog = pos->link.prog;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void fill_prog_array(struct net *net, enum netns_bpf_attach_type type,\n\t\t\t    struct bpf_prog_array *prog_array)\n{\n\tstruct bpf_netns_link *pos;\n\tunsigned int i = 0;\n\n\tlist_for_each_entry(pos, &net->bpf.links[type], node) {\n\t\tprog_array->items[i].prog = pos->link.prog;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&net_link->node",
            "&net->bpf.links[type]"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_alloc",
          "args": [
            "cnt + 1",
            "GFP_KERNEL"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "1984-1993",
          "snippet": "struct bpf_prog_array *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags)\n{\n\tif (prog_cnt)\n\t\treturn kzalloc(sizeof(struct bpf_prog_array) +\n\t\t\t       sizeof(struct bpf_prog_array_item) *\n\t\t\t       (prog_cnt + 1),\n\t\t\t       flags);\n\n\treturn &empty_prog_array.hdr;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nstruct bpf_prog_array *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags)\n{\n\tif (prog_cnt)\n\t\treturn kzalloc(sizeof(struct bpf_prog_array) +\n\t\t\t       sizeof(struct bpf_prog_array_item) *\n\t\t\t       (prog_cnt + 1),\n\t\t\t       flags);\n\n\treturn &empty_prog_array.hdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flow_dissector_bpf_prog_attach_check",
          "args": [
            "net",
            "link->prog"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netns_bpf_max_progs",
          "args": [
            "type"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "netns_bpf_max_progs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "409-419",
          "snippet": "static int netns_bpf_max_progs(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n\tcase NETNS_BPF_FLOW_DISSECTOR:\n\t\treturn 1;\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\treturn 64;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int netns_bpf_max_progs(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n\tcase NETNS_BPF_FLOW_DISSECTOR:\n\t\treturn 1;\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\treturn 64;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_count",
          "args": [
            "net",
            "type"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "link_count",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "80-88",
          "snippet": "static int link_count(struct net *net, enum netns_bpf_attach_type type)\n{\n\tstruct list_head *pos;\n\tint i = 0;\n\n\tlist_for_each(pos, &net->bpf.links[type])\n\t\ti++;\n\treturn i;\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int link_count(struct net *net, enum netns_bpf_attach_type type)\n{\n\tstruct list_head *pos;\n\tint i = 0;\n\n\tlist_for_each(pos, &net->bpf.links[type])\n\t\ti++;\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_netns_link",
            "link"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int netns_bpf_link_attach(struct net *net, struct bpf_link *link,\n\t\t\t\t enum netns_bpf_attach_type type)\n{\n\tstruct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tstruct bpf_prog_array *run_array;\n\tint cnt, err;\n\n\tmutex_lock(&netns_bpf_mutex);\n\n\tcnt = link_count(net, type);\n\tif (cnt >= netns_bpf_max_progs(type)) {\n\t\terr = -E2BIG;\n\t\tgoto out_unlock;\n\t}\n\t/* Links are not compatible with attaching prog directly */\n\tif (net->bpf.progs[type]) {\n\t\terr = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (type) {\n\tcase NETNS_BPF_FLOW_DISSECTOR:\n\t\terr = flow_dissector_bpf_prog_attach_check(net, link->prog);\n\t\tbreak;\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\terr = 0; /* nothing to check */\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\tif (err)\n\t\tgoto out_unlock;\n\n\trun_array = bpf_prog_array_alloc(cnt + 1, GFP_KERNEL);\n\tif (!run_array) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tlist_add_tail(&net_link->node, &net->bpf.links[type]);\n\n\tfill_prog_array(net, type, run_array);\n\trun_array = rcu_replace_pointer(net->bpf.run_array[type], run_array,\n\t\t\t\t\tlockdep_is_held(&netns_bpf_mutex));\n\tbpf_prog_array_free(run_array);\n\n\t/* Mark attach point as used */\n\tnetns_bpf_attach_type_need(type);\n\nout_unlock:\n\tmutex_unlock(&netns_bpf_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "netns_bpf_max_progs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "409-419",
    "snippet": "static int netns_bpf_max_progs(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n\tcase NETNS_BPF_FLOW_DISSECTOR:\n\t\treturn 1;\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\treturn 64;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int netns_bpf_max_progs(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n\tcase NETNS_BPF_FLOW_DISSECTOR:\n\t\treturn 1;\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\treturn 64;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "netns_bpf_prog_detach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "383-407",
    "snippet": "int netns_bpf_prog_detach(const union bpf_attr *attr, enum bpf_prog_type ptype)\n{\n\tenum netns_bpf_attach_type type;\n\tstruct bpf_prog *prog;\n\tint ret;\n\n\tif (attr->target_fd)\n\t\treturn -EINVAL;\n\n\ttype = to_netns_bpf_attach_type(attr->attach_type);\n\tif (type < 0)\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tmutex_lock(&netns_bpf_mutex);\n\tret = __netns_bpf_prog_detach(current->nsproxy->net_ns, type, prog);\n\tmutex_unlock(&netns_bpf_mutex);\n\n\tbpf_prog_put(prog);\n\n\treturn ret;\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__netns_bpf_prog_detach",
          "args": [
            "current->nsproxy->net_ns",
            "type",
            "prog"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "__netns_bpf_prog_detach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "364-381",
          "snippet": "static int __netns_bpf_prog_detach(struct net *net,\n\t\t\t\t   enum netns_bpf_attach_type type,\n\t\t\t\t   struct bpf_prog *old)\n{\n\tstruct bpf_prog *attached;\n\n\t/* Progs attached via links cannot be detached */\n\tif (!list_empty(&net->bpf.links[type]))\n\t\treturn -EINVAL;\n\n\tattached = net->bpf.progs[type];\n\tif (!attached || attached != old)\n\t\treturn -ENOENT;\n\tnetns_bpf_run_array_detach(net, type);\n\tnet->bpf.progs[type] = NULL;\n\tbpf_prog_put(attached);\n\treturn 0;\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int __netns_bpf_prog_detach(struct net *net,\n\t\t\t\t   enum netns_bpf_attach_type type,\n\t\t\t\t   struct bpf_prog *old)\n{\n\tstruct bpf_prog *attached;\n\n\t/* Progs attached via links cannot be detached */\n\tif (!list_empty(&net->bpf.links[type]))\n\t\treturn -EINVAL;\n\n\tattached = net->bpf.progs[type];\n\tif (!attached || attached != old)\n\t\treturn -ENOENT;\n\tnetns_bpf_run_array_detach(net, type);\n\tnet->bpf.progs[type] = NULL;\n\tbpf_prog_put(attached);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "prog"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_type",
          "args": [
            "attr->attach_bpf_fd",
            "ptype"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_type_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "586-598",
          "snippet": "struct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tstruct path path;\n\tint ret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tprog = __get_prog_inode(d_backing_inode(path.dentry), type);\n\tif (!IS_ERR(prog))\n\t\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn prog;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstruct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tstruct path path;\n\tint ret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tprog = __get_prog_inode(d_backing_inode(path.dentry), type);\n\tif (!IS_ERR(prog))\n\t\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_netns_bpf_attach_type",
          "args": [
            "attr->attach_type"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nint netns_bpf_prog_detach(const union bpf_attr *attr, enum bpf_prog_type ptype)\n{\n\tenum netns_bpf_attach_type type;\n\tstruct bpf_prog *prog;\n\tint ret;\n\n\tif (attr->target_fd)\n\t\treturn -EINVAL;\n\n\ttype = to_netns_bpf_attach_type(attr->attach_type);\n\tif (type < 0)\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tmutex_lock(&netns_bpf_mutex);\n\tret = __netns_bpf_prog_detach(current->nsproxy->net_ns, type, prog);\n\tmutex_unlock(&netns_bpf_mutex);\n\n\tbpf_prog_put(prog);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__netns_bpf_prog_detach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "364-381",
    "snippet": "static int __netns_bpf_prog_detach(struct net *net,\n\t\t\t\t   enum netns_bpf_attach_type type,\n\t\t\t\t   struct bpf_prog *old)\n{\n\tstruct bpf_prog *attached;\n\n\t/* Progs attached via links cannot be detached */\n\tif (!list_empty(&net->bpf.links[type]))\n\t\treturn -EINVAL;\n\n\tattached = net->bpf.progs[type];\n\tif (!attached || attached != old)\n\t\treturn -ENOENT;\n\tnetns_bpf_run_array_detach(net, type);\n\tnet->bpf.progs[type] = NULL;\n\tbpf_prog_put(attached);\n\treturn 0;\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "attached"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netns_bpf_run_array_detach",
          "args": [
            "net",
            "type"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "netns_bpf_run_array_detach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "56-64",
          "snippet": "static void netns_bpf_run_array_detach(struct net *net,\n\t\t\t\t       enum netns_bpf_attach_type type)\n{\n\tstruct bpf_prog_array *run_array;\n\n\trun_array = rcu_replace_pointer(net->bpf.run_array[type], NULL,\n\t\t\t\t\tlockdep_is_held(&netns_bpf_mutex));\n\tbpf_prog_array_free(run_array);\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void netns_bpf_run_array_detach(struct net *net,\n\t\t\t\t       enum netns_bpf_attach_type type)\n{\n\tstruct bpf_prog_array *run_array;\n\n\trun_array = rcu_replace_pointer(net->bpf.run_array[type], NULL,\n\t\t\t\t\tlockdep_is_held(&netns_bpf_mutex));\n\tbpf_prog_array_free(run_array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&net->bpf.links[type]"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int __netns_bpf_prog_detach(struct net *net,\n\t\t\t\t   enum netns_bpf_attach_type type,\n\t\t\t\t   struct bpf_prog *old)\n{\n\tstruct bpf_prog *attached;\n\n\t/* Progs attached via links cannot be detached */\n\tif (!list_empty(&net->bpf.links[type]))\n\t\treturn -EINVAL;\n\n\tattached = net->bpf.progs[type];\n\tif (!attached || attached != old)\n\t\treturn -ENOENT;\n\tnetns_bpf_run_array_detach(net, type);\n\tnet->bpf.progs[type] = NULL;\n\tbpf_prog_put(attached);\n\treturn 0;\n}"
  },
  {
    "function_name": "netns_bpf_prog_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "297-361",
    "snippet": "int netns_bpf_prog_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct bpf_prog_array *run_array;\n\tenum netns_bpf_attach_type type;\n\tstruct bpf_prog *attached;\n\tstruct net *net;\n\tint ret;\n\n\tif (attr->target_fd || attr->attach_flags || attr->replace_bpf_fd)\n\t\treturn -EINVAL;\n\n\ttype = to_netns_bpf_attach_type(attr->attach_type);\n\tif (type < 0)\n\t\treturn -EINVAL;\n\n\tnet = current->nsproxy->net_ns;\n\tmutex_lock(&netns_bpf_mutex);\n\n\t/* Attaching prog directly is not compatible with links */\n\tif (!list_empty(&net->bpf.links[type])) {\n\t\tret = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (type) {\n\tcase NETNS_BPF_FLOW_DISSECTOR:\n\t\tret = flow_dissector_bpf_prog_attach_check(net, prog);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tattached = net->bpf.progs[type];\n\tif (attached == prog) {\n\t\t/* The same program cannot be attached twice */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\trun_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tif (run_array) {\n\t\tWRITE_ONCE(run_array->items[0].prog, prog);\n\t} else {\n\t\trun_array = bpf_prog_array_alloc(1, GFP_KERNEL);\n\t\tif (!run_array) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\trun_array->items[0].prog = prog;\n\t\trcu_assign_pointer(net->bpf.run_array[type], run_array);\n\t}\n\n\tnet->bpf.progs[type] = prog;\n\tif (attached)\n\t\tbpf_prog_put(attached);\n\nout_unlock:\n\tmutex_unlock(&netns_bpf_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "attached"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "net->bpf.run_array[type]",
            "run_array"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_alloc",
          "args": [
            "1",
            "GFP_KERNEL"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "1984-1993",
          "snippet": "struct bpf_prog_array *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags)\n{\n\tif (prog_cnt)\n\t\treturn kzalloc(sizeof(struct bpf_prog_array) +\n\t\t\t       sizeof(struct bpf_prog_array_item) *\n\t\t\t       (prog_cnt + 1),\n\t\t\t       flags);\n\n\treturn &empty_prog_array.hdr;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nstruct bpf_prog_array *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags)\n{\n\tif (prog_cnt)\n\t\treturn kzalloc(sizeof(struct bpf_prog_array) +\n\t\t\t       sizeof(struct bpf_prog_array_item) *\n\t\t\t       (prog_cnt + 1),\n\t\t\t       flags);\n\n\treturn &empty_prog_array.hdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "run_array->items[0].prog",
            "prog"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "net->bpf.run_array[type]",
            "lockdep_is_held(&netns_bpf_mutex)"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flow_dissector_bpf_prog_attach_check",
          "args": [
            "net",
            "prog"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&net->bpf.links[type]"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_netns_bpf_attach_type",
          "args": [
            "attr->attach_type"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nint netns_bpf_prog_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct bpf_prog_array *run_array;\n\tenum netns_bpf_attach_type type;\n\tstruct bpf_prog *attached;\n\tstruct net *net;\n\tint ret;\n\n\tif (attr->target_fd || attr->attach_flags || attr->replace_bpf_fd)\n\t\treturn -EINVAL;\n\n\ttype = to_netns_bpf_attach_type(attr->attach_type);\n\tif (type < 0)\n\t\treturn -EINVAL;\n\n\tnet = current->nsproxy->net_ns;\n\tmutex_lock(&netns_bpf_mutex);\n\n\t/* Attaching prog directly is not compatible with links */\n\tif (!list_empty(&net->bpf.links[type])) {\n\t\tret = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (type) {\n\tcase NETNS_BPF_FLOW_DISSECTOR:\n\t\tret = flow_dissector_bpf_prog_attach_check(net, prog);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tattached = net->bpf.progs[type];\n\tif (attached == prog) {\n\t\t/* The same program cannot be attached twice */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\trun_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tif (run_array) {\n\t\tWRITE_ONCE(run_array->items[0].prog, prog);\n\t} else {\n\t\trun_array = bpf_prog_array_alloc(1, GFP_KERNEL);\n\t\tif (!run_array) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\trun_array->items[0].prog = prog;\n\t\trcu_assign_pointer(net->bpf.run_array[type], run_array);\n\t}\n\n\tnet->bpf.progs[type] = prog;\n\tif (attached)\n\t\tbpf_prog_put(attached);\n\nout_unlock:\n\tmutex_unlock(&netns_bpf_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "netns_bpf_prog_query",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "271-295",
    "snippet": "int netns_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t union bpf_attr __user *uattr)\n{\n\tenum netns_bpf_attach_type type;\n\tstruct net *net;\n\tint ret;\n\n\tif (attr->query.query_flags)\n\t\treturn -EINVAL;\n\n\ttype = to_netns_bpf_attach_type(attr->query.attach_type);\n\tif (type < 0)\n\t\treturn -EINVAL;\n\n\tnet = get_net_ns_by_fd(attr->query.target_fd);\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\tmutex_lock(&netns_bpf_mutex);\n\tret = __netns_bpf_prog_query(attr, uattr, net, type);\n\tmutex_unlock(&netns_bpf_mutex);\n\n\tput_net(net);\n\treturn ret;\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "net"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__netns_bpf_prog_query",
          "args": [
            "attr",
            "uattr",
            "net",
            "type"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "__netns_bpf_prog_query",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "246-269",
          "snippet": "static int __netns_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr,\n\t\t\t\t  struct net *net,\n\t\t\t\t  enum netns_bpf_attach_type type)\n{\n\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);\n\tstruct bpf_prog_array *run_array;\n\tu32 prog_cnt = 0, flags = 0;\n\n\trun_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tif (run_array)\n\t\tprog_cnt = bpf_prog_array_length(run_array);\n\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.prog_cnt, &prog_cnt, sizeof(prog_cnt)))\n\t\treturn -EFAULT;\n\tif (!attr->query.prog_cnt || !prog_ids || !prog_cnt)\n\t\treturn 0;\n\n\treturn bpf_prog_array_copy_to_user(run_array, prog_ids,\n\t\t\t\t\t   attr->query.prog_cnt);\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int __netns_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr,\n\t\t\t\t  struct net *net,\n\t\t\t\t  enum netns_bpf_attach_type type)\n{\n\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);\n\tstruct bpf_prog_array *run_array;\n\tu32 prog_cnt = 0, flags = 0;\n\n\trun_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tif (run_array)\n\t\tprog_cnt = bpf_prog_array_length(run_array);\n\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.prog_cnt, &prog_cnt, sizeof(prog_cnt)))\n\t\treturn -EFAULT;\n\tif (!attr->query.prog_cnt || !prog_ids || !prog_cnt)\n\t\treturn 0;\n\n\treturn bpf_prog_array_copy_to_user(run_array, prog_ids,\n\t\t\t\t\t   attr->query.prog_cnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "net"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "net"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_net_ns_by_fd",
          "args": [
            "attr->query.target_fd"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_netns_bpf_attach_type",
          "args": [
            "attr->query.attach_type"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nint netns_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t union bpf_attr __user *uattr)\n{\n\tenum netns_bpf_attach_type type;\n\tstruct net *net;\n\tint ret;\n\n\tif (attr->query.query_flags)\n\t\treturn -EINVAL;\n\n\ttype = to_netns_bpf_attach_type(attr->query.attach_type);\n\tif (type < 0)\n\t\treturn -EINVAL;\n\n\tnet = get_net_ns_by_fd(attr->query.target_fd);\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\tmutex_lock(&netns_bpf_mutex);\n\tret = __netns_bpf_prog_query(attr, uattr, net, type);\n\tmutex_unlock(&netns_bpf_mutex);\n\n\tput_net(net);\n\treturn ret;\n}"
  },
  {
    "function_name": "__netns_bpf_prog_query",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "246-269",
    "snippet": "static int __netns_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr,\n\t\t\t\t  struct net *net,\n\t\t\t\t  enum netns_bpf_attach_type type)\n{\n\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);\n\tstruct bpf_prog_array *run_array;\n\tu32 prog_cnt = 0, flags = 0;\n\n\trun_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tif (run_array)\n\t\tprog_cnt = bpf_prog_array_length(run_array);\n\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.prog_cnt, &prog_cnt, sizeof(prog_cnt)))\n\t\treturn -EFAULT;\n\tif (!attr->query.prog_cnt || !prog_ids || !prog_cnt)\n\t\treturn 0;\n\n\treturn bpf_prog_array_copy_to_user(run_array, prog_ids,\n\t\t\t\t\t   attr->query.prog_cnt);\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_array_copy_to_user",
          "args": [
            "run_array",
            "prog_ids",
            "attr->query.prog_cnt"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2043-2067",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check.\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_length",
          "args": [
            "run_array"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_length",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2002-2011",
          "snippet": "int bpf_prog_array_length(struct bpf_prog_array *array)\n{\n\tstruct bpf_prog_array_item *item;\n\tu32 cnt = 0;\n\n\tfor (item = array->items; item->prog; item++)\n\t\tif (item->prog != &dummy_bpf_prog.prog)\n\t\t\tcnt++;\n\treturn cnt;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstatic struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};\n\nint bpf_prog_array_length(struct bpf_prog_array *array)\n{\n\tstruct bpf_prog_array_item *item;\n\tu32 cnt = 0;\n\n\tfor (item = array->items; item->prog; item++)\n\t\tif (item->prog != &dummy_bpf_prog.prog)\n\t\t\tcnt++;\n\treturn cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "net->bpf.run_array[type]",
            "lockdep_is_held(&netns_bpf_mutex)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->query.prog_ids"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int __netns_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr,\n\t\t\t\t  struct net *net,\n\t\t\t\t  enum netns_bpf_attach_type type)\n{\n\t__u32 __user *prog_ids = u64_to_user_ptr(attr->query.prog_ids);\n\tstruct bpf_prog_array *run_array;\n\tu32 prog_cnt = 0, flags = 0;\n\n\trun_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tif (run_array)\n\t\tprog_cnt = bpf_prog_array_length(run_array);\n\n\tif (copy_to_user(&uattr->query.attach_flags, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\tif (copy_to_user(&uattr->query.prog_cnt, &prog_cnt, sizeof(prog_cnt)))\n\t\treturn -EFAULT;\n\tif (!attr->query.prog_cnt || !prog_ids || !prog_cnt)\n\t\treturn 0;\n\n\treturn bpf_prog_array_copy_to_user(run_array, prog_ids,\n\t\t\t\t\t   attr->query.prog_cnt);\n}"
  },
  {
    "function_name": "bpf_netns_link_show_fdinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "223-234",
    "snippet": "static void bpf_netns_link_show_fdinfo(const struct bpf_link *link,\n\t\t\t\t       struct seq_file *seq)\n{\n\tstruct bpf_link_info info = {};\n\n\tbpf_netns_link_fill_info(link, &info);\n\tseq_printf(seq,\n\t\t   \"netns_ino:\\t%u\\n\"\n\t\t   \"attach_type:\\t%u\\n\",\n\t\t   info.netns.netns_ino,\n\t\t   info.netns.attach_type);\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"netns_ino:\\t%u\\n\"\n\t\t   \"attach_type:\\t%u\\n\"",
            "info.netns.netns_ino",
            "info.netns.attach_type"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_netns_link_fill_info",
          "args": [
            "link",
            "&info"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_netns_link_fill_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "204-221",
          "snippet": "static int bpf_netns_link_fill_info(const struct bpf_link *link,\n\t\t\t\t    struct bpf_link_info *info)\n{\n\tconst struct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tunsigned int inum = 0;\n\tstruct net *net;\n\n\tmutex_lock(&netns_bpf_mutex);\n\tnet = net_link->net;\n\tif (net && check_net(net))\n\t\tinum = net->ns.inum;\n\tmutex_unlock(&netns_bpf_mutex);\n\n\tinfo->netns.netns_ino = inum;\n\tinfo->netns.attach_type = net_link->type;\n\treturn 0;\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int bpf_netns_link_fill_info(const struct bpf_link *link,\n\t\t\t\t    struct bpf_link_info *info)\n{\n\tconst struct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tunsigned int inum = 0;\n\tstruct net *net;\n\n\tmutex_lock(&netns_bpf_mutex);\n\tnet = net_link->net;\n\tif (net && check_net(net))\n\t\tinum = net->ns.inum;\n\tmutex_unlock(&netns_bpf_mutex);\n\n\tinfo->netns.netns_ino = inum;\n\tinfo->netns.attach_type = net_link->type;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void bpf_netns_link_show_fdinfo(const struct bpf_link *link,\n\t\t\t\t       struct seq_file *seq)\n{\n\tstruct bpf_link_info info = {};\n\n\tbpf_netns_link_fill_info(link, &info);\n\tseq_printf(seq,\n\t\t   \"netns_ino:\\t%u\\n\"\n\t\t   \"attach_type:\\t%u\\n\",\n\t\t   info.netns.netns_ino,\n\t\t   info.netns.attach_type);\n}"
  },
  {
    "function_name": "bpf_netns_link_fill_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "204-221",
    "snippet": "static int bpf_netns_link_fill_info(const struct bpf_link *link,\n\t\t\t\t    struct bpf_link_info *info)\n{\n\tconst struct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tunsigned int inum = 0;\n\tstruct net *net;\n\n\tmutex_lock(&netns_bpf_mutex);\n\tnet = net_link->net;\n\tif (net && check_net(net))\n\t\tinum = net->ns.inum;\n\tmutex_unlock(&netns_bpf_mutex);\n\n\tinfo->netns.netns_ino = inum;\n\tinfo->netns.attach_type = net_link->type;\n\treturn 0;\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_net",
          "args": [
            "net"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_netns_link",
            "link"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int bpf_netns_link_fill_info(const struct bpf_link *link,\n\t\t\t\t    struct bpf_link_info *info)\n{\n\tconst struct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tunsigned int inum = 0;\n\tstruct net *net;\n\n\tmutex_lock(&netns_bpf_mutex);\n\tnet = net_link->net;\n\tif (net && check_net(net))\n\t\tinum = net->ns.inum;\n\tmutex_unlock(&netns_bpf_mutex);\n\n\tinfo->netns.netns_ino = inum;\n\tinfo->netns.attach_type = net_link->type;\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_netns_link_update_prog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "164-202",
    "snippet": "static int bpf_netns_link_update_prog(struct bpf_link *link,\n\t\t\t\t      struct bpf_prog *new_prog,\n\t\t\t\t      struct bpf_prog *old_prog)\n{\n\tstruct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tenum netns_bpf_attach_type type = net_link->netns_type;\n\tstruct bpf_prog_array *run_array;\n\tstruct net *net;\n\tint idx, ret;\n\n\tif (old_prog && old_prog != link->prog)\n\t\treturn -EPERM;\n\tif (new_prog->type != link->prog->type)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&netns_bpf_mutex);\n\n\tnet = net_link->net;\n\tif (!net || !check_net(net)) {\n\t\t/* Link auto-detached or netns dying */\n\t\tret = -ENOLINK;\n\t\tgoto out_unlock;\n\t}\n\n\trun_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tidx = link_index(net, type, net_link);\n\tret = bpf_prog_array_update_at(run_array, idx, new_prog);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\told_prog = xchg(&link->prog, new_prog);\n\tbpf_prog_put(old_prog);\n\nout_unlock:\n\tmutex_unlock(&netns_bpf_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "old_prog"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&link->prog",
            "new_prog"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_update_at",
          "args": [
            "run_array",
            "idx",
            "new_prog"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_update_at",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2116-2134",
          "snippet": "int bpf_prog_array_update_at(struct bpf_prog_array *array, int index,\n\t\t\t     struct bpf_prog *prog)\n{\n\tstruct bpf_prog_array_item *item;\n\n\tif (unlikely(index < 0))\n\t\treturn -EINVAL;\n\n\tfor (item = array->items; item->prog; item++) {\n\t\tif (item->prog == &dummy_bpf_prog.prog)\n\t\t\tcontinue;\n\t\tif (!index) {\n\t\t\tWRITE_ONCE(item->prog, prog);\n\t\t\treturn 0;\n\t\t}\n\t\tindex--;\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstatic struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};\n\nint bpf_prog_array_update_at(struct bpf_prog_array *array, int index,\n\t\t\t     struct bpf_prog *prog)\n{\n\tstruct bpf_prog_array_item *item;\n\n\tif (unlikely(index < 0))\n\t\treturn -EINVAL;\n\n\tfor (item = array->items; item->prog; item++) {\n\t\tif (item->prog == &dummy_bpf_prog.prog)\n\t\t\tcontinue;\n\t\tif (!index) {\n\t\t\tWRITE_ONCE(item->prog, prog);\n\t\t\treturn 0;\n\t\t}\n\t\tindex--;\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_index",
          "args": [
            "net",
            "type",
            "net_link"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "link_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "66-78",
          "snippet": "static int link_index(struct net *net, enum netns_bpf_attach_type type,\n\t\t      struct bpf_netns_link *link)\n{\n\tstruct bpf_netns_link *pos;\n\tint i = 0;\n\n\tlist_for_each_entry(pos, &net->bpf.links[type], node) {\n\t\tif (pos == link)\n\t\t\treturn i;\n\t\ti++;\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int link_index(struct net *net, enum netns_bpf_attach_type type,\n\t\t      struct bpf_netns_link *link)\n{\n\tstruct bpf_netns_link *pos;\n\tint i = 0;\n\n\tlist_for_each_entry(pos, &net->bpf.links[type], node) {\n\t\tif (pos == link)\n\t\t\treturn i;\n\t\ti++;\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "net->bpf.run_array[type]",
            "lockdep_is_held(&netns_bpf_mutex)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_net",
          "args": [
            "net"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_netns_link",
            "link"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int bpf_netns_link_update_prog(struct bpf_link *link,\n\t\t\t\t      struct bpf_prog *new_prog,\n\t\t\t\t      struct bpf_prog *old_prog)\n{\n\tstruct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tenum netns_bpf_attach_type type = net_link->netns_type;\n\tstruct bpf_prog_array *run_array;\n\tstruct net *net;\n\tint idx, ret;\n\n\tif (old_prog && old_prog != link->prog)\n\t\treturn -EPERM;\n\tif (new_prog->type != link->prog->type)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&netns_bpf_mutex);\n\n\tnet = net_link->net;\n\tif (!net || !check_net(net)) {\n\t\t/* Link auto-detached or netns dying */\n\t\tret = -ENOLINK;\n\t\tgoto out_unlock;\n\t}\n\n\trun_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tidx = link_index(net, type, net_link);\n\tret = bpf_prog_array_update_at(run_array, idx, new_prog);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\told_prog = xchg(&link->prog, new_prog);\n\tbpf_prog_put(old_prog);\n\nout_unlock:\n\tmutex_unlock(&netns_bpf_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_netns_link_dealloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "156-162",
    "snippet": "static void bpf_netns_link_dealloc(struct bpf_link *link)\n{\n\tstruct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\n\tkfree(net_link);\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "net_link"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_netns_link",
            "link"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void bpf_netns_link_dealloc(struct bpf_link *link)\n{\n\tstruct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\n\tkfree(net_link);\n}"
  },
  {
    "function_name": "bpf_netns_link_detach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "150-154",
    "snippet": "static int bpf_netns_link_detach(struct bpf_link *link)\n{\n\tbpf_netns_link_release(link);\n\treturn 0;\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_netns_link_release",
          "args": [
            "link"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_netns_link_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "102-148",
          "snippet": "static void bpf_netns_link_release(struct bpf_link *link)\n{\n\tstruct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tenum netns_bpf_attach_type type = net_link->netns_type;\n\tstruct bpf_prog_array *old_array, *new_array;\n\tstruct net *net;\n\tint cnt, idx;\n\n\tmutex_lock(&netns_bpf_mutex);\n\n\t/* We can race with cleanup_net, but if we see a non-NULL\n\t * struct net pointer, pre_exit has not run yet and wait for\n\t * netns_bpf_mutex.\n\t */\n\tnet = net_link->net;\n\tif (!net)\n\t\tgoto out_unlock;\n\n\t/* Mark attach point as unused */\n\tnetns_bpf_attach_type_unneed(type);\n\n\t/* Remember link position in case of safe delete */\n\tidx = link_index(net, type, net_link);\n\tlist_del(&net_link->node);\n\n\tcnt = link_count(net, type);\n\tif (!cnt) {\n\t\tnetns_bpf_run_array_detach(net, type);\n\t\tgoto out_unlock;\n\t}\n\n\told_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tnew_array = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!new_array) {\n\t\tWARN_ON(bpf_prog_array_delete_safe_at(old_array, idx));\n\t\tgoto out_unlock;\n\t}\n\tfill_prog_array(net, type, new_array);\n\trcu_assign_pointer(net->bpf.run_array[type], new_array);\n\tbpf_prog_array_free(old_array);\n\nout_unlock:\n\tnet_link->net = NULL;\n\tmutex_unlock(&netns_bpf_mutex);\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void bpf_netns_link_release(struct bpf_link *link)\n{\n\tstruct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tenum netns_bpf_attach_type type = net_link->netns_type;\n\tstruct bpf_prog_array *old_array, *new_array;\n\tstruct net *net;\n\tint cnt, idx;\n\n\tmutex_lock(&netns_bpf_mutex);\n\n\t/* We can race with cleanup_net, but if we see a non-NULL\n\t * struct net pointer, pre_exit has not run yet and wait for\n\t * netns_bpf_mutex.\n\t */\n\tnet = net_link->net;\n\tif (!net)\n\t\tgoto out_unlock;\n\n\t/* Mark attach point as unused */\n\tnetns_bpf_attach_type_unneed(type);\n\n\t/* Remember link position in case of safe delete */\n\tidx = link_index(net, type, net_link);\n\tlist_del(&net_link->node);\n\n\tcnt = link_count(net, type);\n\tif (!cnt) {\n\t\tnetns_bpf_run_array_detach(net, type);\n\t\tgoto out_unlock;\n\t}\n\n\told_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tnew_array = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!new_array) {\n\t\tWARN_ON(bpf_prog_array_delete_safe_at(old_array, idx));\n\t\tgoto out_unlock;\n\t}\n\tfill_prog_array(net, type, new_array);\n\trcu_assign_pointer(net->bpf.run_array[type], new_array);\n\tbpf_prog_array_free(old_array);\n\nout_unlock:\n\tnet_link->net = NULL;\n\tmutex_unlock(&netns_bpf_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int bpf_netns_link_detach(struct bpf_link *link)\n{\n\tbpf_netns_link_release(link);\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_netns_link_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "102-148",
    "snippet": "static void bpf_netns_link_release(struct bpf_link *link)\n{\n\tstruct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tenum netns_bpf_attach_type type = net_link->netns_type;\n\tstruct bpf_prog_array *old_array, *new_array;\n\tstruct net *net;\n\tint cnt, idx;\n\n\tmutex_lock(&netns_bpf_mutex);\n\n\t/* We can race with cleanup_net, but if we see a non-NULL\n\t * struct net pointer, pre_exit has not run yet and wait for\n\t * netns_bpf_mutex.\n\t */\n\tnet = net_link->net;\n\tif (!net)\n\t\tgoto out_unlock;\n\n\t/* Mark attach point as unused */\n\tnetns_bpf_attach_type_unneed(type);\n\n\t/* Remember link position in case of safe delete */\n\tidx = link_index(net, type, net_link);\n\tlist_del(&net_link->node);\n\n\tcnt = link_count(net, type);\n\tif (!cnt) {\n\t\tnetns_bpf_run_array_detach(net, type);\n\t\tgoto out_unlock;\n\t}\n\n\told_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tnew_array = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!new_array) {\n\t\tWARN_ON(bpf_prog_array_delete_safe_at(old_array, idx));\n\t\tgoto out_unlock;\n\t}\n\tfill_prog_array(net, type, new_array);\n\trcu_assign_pointer(net->bpf.run_array[type], new_array);\n\tbpf_prog_array_free(old_array);\n\nout_unlock:\n\tnet_link->net = NULL;\n\tmutex_unlock(&netns_bpf_mutex);\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_free",
          "args": [
            "old_array"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "1995-2000",
          "snippet": "void bpf_prog_array_free(struct bpf_prog_array *progs)\n{\n\tif (!progs || progs == &empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nvoid bpf_prog_array_free(struct bpf_prog_array *progs)\n{\n\tif (!progs || progs == &empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "net->bpf.run_array[type]",
            "new_array"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_prog_array",
          "args": [
            "net",
            "type",
            "new_array"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "fill_prog_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "90-100",
          "snippet": "static void fill_prog_array(struct net *net, enum netns_bpf_attach_type type,\n\t\t\t    struct bpf_prog_array *prog_array)\n{\n\tstruct bpf_netns_link *pos;\n\tunsigned int i = 0;\n\n\tlist_for_each_entry(pos, &net->bpf.links[type], node) {\n\t\tprog_array->items[i].prog = pos->link.prog;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void fill_prog_array(struct net *net, enum netns_bpf_attach_type type,\n\t\t\t    struct bpf_prog_array *prog_array)\n{\n\tstruct bpf_netns_link *pos;\n\tunsigned int i = 0;\n\n\tlist_for_each_entry(pos, &net->bpf.links[type], node) {\n\t\tprog_array->items[i].prog = pos->link.prog;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bpf_prog_array_delete_safe_at(old_array, idx)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_delete_safe_at",
          "args": [
            "old_array",
            "idx"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_delete_safe_at",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2096-2099",
          "snippet": "int bpf_prog_array_delete_safe_at(struct bpf_prog_array *array, int index)\n{\n\treturn bpf_prog_array_update_at(array, index, &dummy_bpf_prog.prog);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstatic struct bpf_prog_dummy {\n\tstruct bpf_prog prog;\n} dummy_bpf_prog = {\n\t.prog = {\n\t\t.bpf_func = __bpf_prog_ret1,\n\t},\n};\n\nint bpf_prog_array_delete_safe_at(struct bpf_prog_array *array, int index)\n{\n\treturn bpf_prog_array_update_at(array, index, &dummy_bpf_prog.prog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_alloc",
          "args": [
            "cnt",
            "GFP_KERNEL"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "1984-1993",
          "snippet": "struct bpf_prog_array *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags)\n{\n\tif (prog_cnt)\n\t\treturn kzalloc(sizeof(struct bpf_prog_array) +\n\t\t\t       sizeof(struct bpf_prog_array_item) *\n\t\t\t       (prog_cnt + 1),\n\t\t\t       flags);\n\n\treturn &empty_prog_array.hdr;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nstruct bpf_prog_array *bpf_prog_array_alloc(u32 prog_cnt, gfp_t flags)\n{\n\tif (prog_cnt)\n\t\treturn kzalloc(sizeof(struct bpf_prog_array) +\n\t\t\t       sizeof(struct bpf_prog_array_item) *\n\t\t\t       (prog_cnt + 1),\n\t\t\t       flags);\n\n\treturn &empty_prog_array.hdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "net->bpf.run_array[type]",
            "lockdep_is_held(&netns_bpf_mutex)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netns_bpf_run_array_detach",
          "args": [
            "net",
            "type"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "netns_bpf_run_array_detach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "56-64",
          "snippet": "static void netns_bpf_run_array_detach(struct net *net,\n\t\t\t\t       enum netns_bpf_attach_type type)\n{\n\tstruct bpf_prog_array *run_array;\n\n\trun_array = rcu_replace_pointer(net->bpf.run_array[type], NULL,\n\t\t\t\t\tlockdep_is_held(&netns_bpf_mutex));\n\tbpf_prog_array_free(run_array);\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void netns_bpf_run_array_detach(struct net *net,\n\t\t\t\t       enum netns_bpf_attach_type type)\n{\n\tstruct bpf_prog_array *run_array;\n\n\trun_array = rcu_replace_pointer(net->bpf.run_array[type], NULL,\n\t\t\t\t\tlockdep_is_held(&netns_bpf_mutex));\n\tbpf_prog_array_free(run_array);\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_count",
          "args": [
            "net",
            "type"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "link_count",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "80-88",
          "snippet": "static int link_count(struct net *net, enum netns_bpf_attach_type type)\n{\n\tstruct list_head *pos;\n\tint i = 0;\n\n\tlist_for_each(pos, &net->bpf.links[type])\n\t\ti++;\n\treturn i;\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int link_count(struct net *net, enum netns_bpf_attach_type type)\n{\n\tstruct list_head *pos;\n\tint i = 0;\n\n\tlist_for_each(pos, &net->bpf.links[type])\n\t\ti++;\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&net_link->node"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_index",
          "args": [
            "net",
            "type",
            "net_link"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "link_index",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "66-78",
          "snippet": "static int link_index(struct net *net, enum netns_bpf_attach_type type,\n\t\t      struct bpf_netns_link *link)\n{\n\tstruct bpf_netns_link *pos;\n\tint i = 0;\n\n\tlist_for_each_entry(pos, &net->bpf.links[type], node) {\n\t\tif (pos == link)\n\t\t\treturn i;\n\t\ti++;\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int link_index(struct net *net, enum netns_bpf_attach_type type,\n\t\t      struct bpf_netns_link *link)\n{\n\tstruct bpf_netns_link *pos;\n\tint i = 0;\n\n\tlist_for_each_entry(pos, &net->bpf.links[type], node) {\n\t\tif (pos == link)\n\t\t\treturn i;\n\t\ti++;\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netns_bpf_attach_type_unneed",
          "args": [
            "type"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "netns_bpf_attach_type_unneed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
          "lines": "29-40",
          "snippet": "static void netns_bpf_attach_type_unneed(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n#ifdef CONFIG_INET\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\tstatic_branch_dec(&bpf_sk_lookup_enabled);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <net/net_namespace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void netns_bpf_attach_type_unneed(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n#ifdef CONFIG_INET\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\tstatic_branch_dec(&bpf_sk_lookup_enabled);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "link",
            "structbpf_netns_link",
            "link"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void bpf_netns_link_release(struct bpf_link *link)\n{\n\tstruct bpf_netns_link *net_link =\n\t\tcontainer_of(link, struct bpf_netns_link, link);\n\tenum netns_bpf_attach_type type = net_link->netns_type;\n\tstruct bpf_prog_array *old_array, *new_array;\n\tstruct net *net;\n\tint cnt, idx;\n\n\tmutex_lock(&netns_bpf_mutex);\n\n\t/* We can race with cleanup_net, but if we see a non-NULL\n\t * struct net pointer, pre_exit has not run yet and wait for\n\t * netns_bpf_mutex.\n\t */\n\tnet = net_link->net;\n\tif (!net)\n\t\tgoto out_unlock;\n\n\t/* Mark attach point as unused */\n\tnetns_bpf_attach_type_unneed(type);\n\n\t/* Remember link position in case of safe delete */\n\tidx = link_index(net, type, net_link);\n\tlist_del(&net_link->node);\n\n\tcnt = link_count(net, type);\n\tif (!cnt) {\n\t\tnetns_bpf_run_array_detach(net, type);\n\t\tgoto out_unlock;\n\t}\n\n\told_array = rcu_dereference_protected(net->bpf.run_array[type],\n\t\t\t\t\t      lockdep_is_held(&netns_bpf_mutex));\n\tnew_array = bpf_prog_array_alloc(cnt, GFP_KERNEL);\n\tif (!new_array) {\n\t\tWARN_ON(bpf_prog_array_delete_safe_at(old_array, idx));\n\t\tgoto out_unlock;\n\t}\n\tfill_prog_array(net, type, new_array);\n\trcu_assign_pointer(net->bpf.run_array[type], new_array);\n\tbpf_prog_array_free(old_array);\n\nout_unlock:\n\tnet_link->net = NULL;\n\tmutex_unlock(&netns_bpf_mutex);\n}"
  },
  {
    "function_name": "fill_prog_array",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "90-100",
    "snippet": "static void fill_prog_array(struct net *net, enum netns_bpf_attach_type type,\n\t\t\t    struct bpf_prog_array *prog_array)\n{\n\tstruct bpf_netns_link *pos;\n\tunsigned int i = 0;\n\n\tlist_for_each_entry(pos, &net->bpf.links[type], node) {\n\t\tprog_array->items[i].prog = pos->link.prog;\n\t\ti++;\n\t}\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pos",
            "&net->bpf.links[type]",
            "node"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void fill_prog_array(struct net *net, enum netns_bpf_attach_type type,\n\t\t\t    struct bpf_prog_array *prog_array)\n{\n\tstruct bpf_netns_link *pos;\n\tunsigned int i = 0;\n\n\tlist_for_each_entry(pos, &net->bpf.links[type], node) {\n\t\tprog_array->items[i].prog = pos->link.prog;\n\t\ti++;\n\t}\n}"
  },
  {
    "function_name": "link_count",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "80-88",
    "snippet": "static int link_count(struct net *net, enum netns_bpf_attach_type type)\n{\n\tstruct list_head *pos;\n\tint i = 0;\n\n\tlist_for_each(pos, &net->bpf.links[type])\n\t\ti++;\n\treturn i;\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "pos",
            "&net->bpf.links[type]"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int link_count(struct net *net, enum netns_bpf_attach_type type)\n{\n\tstruct list_head *pos;\n\tint i = 0;\n\n\tlist_for_each(pos, &net->bpf.links[type])\n\t\ti++;\n\treturn i;\n}"
  },
  {
    "function_name": "link_index",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "66-78",
    "snippet": "static int link_index(struct net *net, enum netns_bpf_attach_type type,\n\t\t      struct bpf_netns_link *link)\n{\n\tstruct bpf_netns_link *pos;\n\tint i = 0;\n\n\tlist_for_each_entry(pos, &net->bpf.links[type], node) {\n\t\tif (pos == link)\n\t\t\treturn i;\n\t\ti++;\n\t}\n\treturn -ENOENT;\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pos",
            "&net->bpf.links[type]",
            "node"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic int link_index(struct net *net, enum netns_bpf_attach_type type,\n\t\t      struct bpf_netns_link *link)\n{\n\tstruct bpf_netns_link *pos;\n\tint i = 0;\n\n\tlist_for_each_entry(pos, &net->bpf.links[type], node) {\n\t\tif (pos == link)\n\t\t\treturn i;\n\t\ti++;\n\t}\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "netns_bpf_run_array_detach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "56-64",
    "snippet": "static void netns_bpf_run_array_detach(struct net *net,\n\t\t\t\t       enum netns_bpf_attach_type type)\n{\n\tstruct bpf_prog_array *run_array;\n\n\trun_array = rcu_replace_pointer(net->bpf.run_array[type], NULL,\n\t\t\t\t\tlockdep_is_held(&netns_bpf_mutex));\n\tbpf_prog_array_free(run_array);\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_array_free",
          "args": [
            "run_array"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "1995-2000",
          "snippet": "void bpf_prog_array_free(struct bpf_prog_array *progs)\n{\n\tif (!progs || progs == &empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nstatic struct {\n\tstruct bpf_prog_array hdr;\n\tstruct bpf_prog *null_prog;\n} empty_prog_array = {\n\t.null_prog = NULL,\n};\n\nvoid bpf_prog_array_free(struct bpf_prog_array *progs)\n{\n\tif (!progs || progs == &empty_prog_array.hdr)\n\t\treturn;\n\tkfree_rcu(progs, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_replace_pointer",
          "args": [
            "net->bpf.run_array[type]",
            "NULL",
            "lockdep_is_held(&netns_bpf_mutex)"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&netns_bpf_mutex"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void netns_bpf_run_array_detach(struct net *net,\n\t\t\t\t       enum netns_bpf_attach_type type)\n{\n\tstruct bpf_prog_array *run_array;\n\n\trun_array = rcu_replace_pointer(net->bpf.run_array[type], NULL,\n\t\t\t\t\tlockdep_is_held(&netns_bpf_mutex));\n\tbpf_prog_array_free(run_array);\n}"
  },
  {
    "function_name": "netns_bpf_attach_type_need",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "42-53",
    "snippet": "static void netns_bpf_attach_type_need(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n#ifdef CONFIG_INET\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\tstatic_branch_inc(&bpf_sk_lookup_enabled);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_inc",
          "args": [
            "&bpf_sk_lookup_enabled"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void netns_bpf_attach_type_need(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n#ifdef CONFIG_INET\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\tstatic_branch_inc(&bpf_sk_lookup_enabled);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "netns_bpf_attach_type_unneed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/net_namespace.c",
    "lines": "29-40",
    "snippet": "static void netns_bpf_attach_type_unneed(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n#ifdef CONFIG_INET\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\tstatic_branch_dec(&bpf_sk_lookup_enabled);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <net/net_namespace.h>",
      "#include <linux/filter.h>",
      "#include <linux/bpf-netns.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_dec",
          "args": [
            "&bpf_sk_lookup_enabled"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/net_namespace.h>\n#include <linux/filter.h>\n#include <linux/bpf-netns.h>\n#include <linux/bpf.h>\n\nstatic void netns_bpf_attach_type_unneed(enum netns_bpf_attach_type type)\n{\n\tswitch (type) {\n#ifdef CONFIG_INET\n\tcase NETNS_BPF_SK_LOOKUP:\n\t\tstatic_branch_dec(&bpf_sk_lookup_enabled);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}"
  }
]