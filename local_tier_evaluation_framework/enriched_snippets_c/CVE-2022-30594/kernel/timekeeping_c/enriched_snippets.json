[
  {
    "function_name": "hardpps",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "2453-2464",
    "snippet": "void hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\t__hardpps(phase_ts, raw_ts);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hardpps",
          "args": [
            "phase_ts",
            "raw_ts"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "__hardpps",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "1030-1077",
          "snippet": "void __hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)\n{\n\tstruct pps_normtime pts_norm, freq_norm;\n\n\tpts_norm = pps_normalize_ts(*phase_ts);\n\n\t/* clear the error bits, they will be set again if needed */\n\ttime_status &= ~(STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR);\n\n\t/* indicate signal presence */\n\ttime_status |= STA_PPSSIGNAL;\n\tpps_valid = PPS_VALID;\n\n\t/* when called for the first time,\n\t * just start the frequency interval */\n\tif (unlikely(pps_fbase.tv_sec == 0)) {\n\t\tpps_fbase = *raw_ts;\n\t\treturn;\n\t}\n\n\t/* ok, now we have a base for frequency calculation */\n\tfreq_norm = pps_normalize_ts(timespec64_sub(*raw_ts, pps_fbase));\n\n\t/* check that the signal is in the range\n\t * [1s - MAXFREQ us, 1s + MAXFREQ us], otherwise reject it */\n\tif ((freq_norm.sec == 0) ||\n\t\t\t(freq_norm.nsec > MAXFREQ * freq_norm.sec) ||\n\t\t\t(freq_norm.nsec < -MAXFREQ * freq_norm.sec)) {\n\t\ttime_status |= STA_PPSJITTER;\n\t\t/* restart the frequency calibration interval */\n\t\tpps_fbase = *raw_ts;\n\t\tprintk_deferred(KERN_ERR \"hardpps: PPSJITTER: bad pulse\\n\");\n\t\treturn;\n\t}\n\n\t/* signal is ok */\n\n\t/* check if the current frequency interval is finished */\n\tif (freq_norm.sec >= (1 << pps_shift)) {\n\t\tpps_calcnt++;\n\t\t/* restart the frequency calibration interval */\n\t\tpps_fbase = *raw_ts;\n\t\thardpps_update_freq(freq_norm);\n\t}\n\n\thardpps_update_phase(pts_norm.nsec);\n\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define PPS_VALID\t10\t/* PPS signal watchdog max (s) */"
          ],
          "globals_used": [
            "static int\t\t\ttime_status = STA_UNSYNC;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_VALID\t10\t/* PPS signal watchdog max (s) */\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nvoid __hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)\n{\n\tstruct pps_normtime pts_norm, freq_norm;\n\n\tpts_norm = pps_normalize_ts(*phase_ts);\n\n\t/* clear the error bits, they will be set again if needed */\n\ttime_status &= ~(STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR);\n\n\t/* indicate signal presence */\n\ttime_status |= STA_PPSSIGNAL;\n\tpps_valid = PPS_VALID;\n\n\t/* when called for the first time,\n\t * just start the frequency interval */\n\tif (unlikely(pps_fbase.tv_sec == 0)) {\n\t\tpps_fbase = *raw_ts;\n\t\treturn;\n\t}\n\n\t/* ok, now we have a base for frequency calculation */\n\tfreq_norm = pps_normalize_ts(timespec64_sub(*raw_ts, pps_fbase));\n\n\t/* check that the signal is in the range\n\t * [1s - MAXFREQ us, 1s + MAXFREQ us], otherwise reject it */\n\tif ((freq_norm.sec == 0) ||\n\t\t\t(freq_norm.nsec > MAXFREQ * freq_norm.sec) ||\n\t\t\t(freq_norm.nsec < -MAXFREQ * freq_norm.sec)) {\n\t\ttime_status |= STA_PPSJITTER;\n\t\t/* restart the frequency calibration interval */\n\t\tpps_fbase = *raw_ts;\n\t\tprintk_deferred(KERN_ERR \"hardpps: PPSJITTER: bad pulse\\n\");\n\t\treturn;\n\t}\n\n\t/* signal is ok */\n\n\t/* check if the current frequency interval is finished */\n\tif (freq_norm.sec >= (1 << pps_shift)) {\n\t\tpps_calcnt++;\n\t\t/* restart the frequency calibration interval */\n\t\tpps_fbase = *raw_ts;\n\t\thardpps_update_freq(freq_norm);\n\t}\n\n\thardpps_update_phase(pts_norm.nsec);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\t__hardpps(phase_ts, raw_ts);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n}"
  },
  {
    "function_name": "do_adjtimex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "2387-2447",
    "snippet": "int do_adjtimex(struct __kernel_timex *txc)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct audit_ntp_data ad;\n\tbool clock_set = false;\n\tstruct timespec64 ts;\n\tunsigned long flags;\n\ts32 orig_tai, tai;\n\tint ret;\n\n\t/* Validate the data before disabling interrupts */\n\tret = timekeeping_validate_timex(txc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (txc->modes & ADJ_SETOFFSET) {\n\t\tstruct timespec64 delta;\n\t\tdelta.tv_sec  = txc->time.tv_sec;\n\t\tdelta.tv_nsec = txc->time.tv_usec;\n\t\tif (!(txc->modes & ADJ_NANO))\n\t\t\tdelta.tv_nsec *= 1000;\n\t\tret = timekeeping_inject_offset(&delta);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\taudit_tk_injoffset(delta);\n\t}\n\n\taudit_ntp_init(&ad);\n\n\tktime_get_real_ts64(&ts);\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\torig_tai = tai = tk->tai_offset;\n\tret = __do_adjtimex(txc, &ts, &tai, &ad);\n\n\tif (tai != orig_tai) {\n\t\t__timekeeping_set_tai_offset(tk, tai);\n\t\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\t\tclock_set = true;\n\t}\n\ttk_update_leap_state(tk);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\taudit_ntp_log(&ad);\n\n\t/* Update the multiplier immediately if frequency was set directly */\n\tif (txc->modes & (ADJ_FREQUENCY | ADJ_TICK))\n\t\tclock_set |= timekeeping_advance(TK_ADV_FREQ);\n\n\tif (clock_set)\n\t\tclock_was_set(CLOCK_REALTIME);\n\n\tntp_notify_cmos_timer();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)",
      "#define TK_MIRROR\t\t(1 << 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntp_notify_cmos_timer",
          "args": [],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_notify_cmos_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "663-672",
          "snippet": "void ntp_notify_cmos_timer(void)\n{\n\t/*\n\t * When the work is currently executed but has not yet the timer\n\t * rearmed this queues the work immediately again. No big issue,\n\t * just a pointless work scheduled.\n\t */\n\tif (ntp_synced() && !hrtimer_is_queued(&sync_hrtimer))\n\t\tqueue_work(system_freezable_power_efficient_wq, &sync_work);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nvoid ntp_notify_cmos_timer(void)\n{\n\t/*\n\t * When the work is currently executed but has not yet the timer\n\t * rearmed this queues the work immediately again. No big issue,\n\t * just a pointless work scheduled.\n\t */\n\tif (ntp_synced() && !hrtimer_is_queued(&sync_hrtimer))\n\t\tqueue_work(system_freezable_power_efficient_wq, &sync_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clock_was_set",
          "args": [
            "CLOCK_REALTIME"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "clock_was_set_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "983-986",
          "snippet": "static void clock_was_set_work(struct work_struct *work)\n{\n\tclock_was_set(CLOCK_SET_WALL);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WORK(hrtimer_work, clock_was_set_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic DECLARE_WORK(hrtimer_work, clock_was_set_work);\n\nstatic void clock_was_set_work(struct work_struct *work)\n{\n\tclock_was_set(CLOCK_SET_WALL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_advance",
          "args": [
            "TK_ADV_FREQ"
          ],
          "line": 2439
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_advance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "2129-2202",
          "snippet": "static bool timekeeping_advance(enum timekeeping_adv_mode mode)\n{\n\tstruct timekeeper *real_tk = &tk_core.timekeeper;\n\tstruct timekeeper *tk = &shadow_timekeeper;\n\tu64 offset;\n\tint shift = 0, maxshift;\n\tunsigned int clock_set = 0;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\n\t/* Make sure we're fully resumed: */\n\tif (unlikely(timekeeping_suspended))\n\t\tgoto out;\n\n\toffset = clocksource_delta(tk_clock_read(&tk->tkr_mono),\n\t\t\t\t   tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\n\t/* Check if there's really nothing to do */\n\tif (offset < real_tk->cycle_interval && mode == TK_ADV_TICK)\n\t\tgoto out;\n\n\t/* Do some additional sanity checking */\n\ttimekeeping_check_update(tk, offset);\n\n\t/*\n\t * With NO_HZ we may have to accumulate many cycle_intervals\n\t * (think \"ticks\") worth of time at once. To do this efficiently,\n\t * we calculate the largest doubling multiple of cycle_intervals\n\t * that is smaller than the offset.  We then accumulate that\n\t * chunk in one go, and then try to consume the next smaller\n\t * doubled multiple.\n\t */\n\tshift = ilog2(offset) - ilog2(tk->cycle_interval);\n\tshift = max(0, shift);\n\t/* Bound shift to one less than what overflows tick_length */\n\tmaxshift = (64 - (ilog2(ntp_tick_length())+1)) - 1;\n\tshift = min(shift, maxshift);\n\twhile (offset >= tk->cycle_interval) {\n\t\toffset = logarithmic_accumulation(tk, offset, shift,\n\t\t\t\t\t\t\t&clock_set);\n\t\tif (offset < tk->cycle_interval<<shift)\n\t\t\tshift--;\n\t}\n\n\t/* Adjust the multiplier to correct NTP error */\n\ttimekeeping_adjust(tk, offset);\n\n\t/*\n\t * Finally, make sure that after the rounding\n\t * xtime_nsec isn't larger than NSEC_PER_SEC\n\t */\n\tclock_set |= accumulate_nsecs_to_secs(tk);\n\n\twrite_seqcount_begin(&tk_core.seq);\n\t/*\n\t * Update the real timekeeper.\n\t *\n\t * We could avoid this memcpy by switching pointers, but that\n\t * requires changes to all other timekeeper usage sites as\n\t * well, i.e. move the timekeeper pointer getter into the\n\t * spinlocked/seqcount protected sections. And we trade this\n\t * memcpy under the tk_core.seq against one before we start\n\t * updating.\n\t */\n\ttimekeeping_update(tk, clock_set);\n\tmemcpy(real_tk, tk, sizeof(*tk));\n\t/* The memcpy must come last. Do not put anything here! */\n\twrite_seqcount_end(&tk_core.seq);\nout:\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\treturn !!clock_set;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic bool timekeeping_advance(enum timekeeping_adv_mode mode)\n{\n\tstruct timekeeper *real_tk = &tk_core.timekeeper;\n\tstruct timekeeper *tk = &shadow_timekeeper;\n\tu64 offset;\n\tint shift = 0, maxshift;\n\tunsigned int clock_set = 0;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\n\t/* Make sure we're fully resumed: */\n\tif (unlikely(timekeeping_suspended))\n\t\tgoto out;\n\n\toffset = clocksource_delta(tk_clock_read(&tk->tkr_mono),\n\t\t\t\t   tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\n\t/* Check if there's really nothing to do */\n\tif (offset < real_tk->cycle_interval && mode == TK_ADV_TICK)\n\t\tgoto out;\n\n\t/* Do some additional sanity checking */\n\ttimekeeping_check_update(tk, offset);\n\n\t/*\n\t * With NO_HZ we may have to accumulate many cycle_intervals\n\t * (think \"ticks\") worth of time at once. To do this efficiently,\n\t * we calculate the largest doubling multiple of cycle_intervals\n\t * that is smaller than the offset.  We then accumulate that\n\t * chunk in one go, and then try to consume the next smaller\n\t * doubled multiple.\n\t */\n\tshift = ilog2(offset) - ilog2(tk->cycle_interval);\n\tshift = max(0, shift);\n\t/* Bound shift to one less than what overflows tick_length */\n\tmaxshift = (64 - (ilog2(ntp_tick_length())+1)) - 1;\n\tshift = min(shift, maxshift);\n\twhile (offset >= tk->cycle_interval) {\n\t\toffset = logarithmic_accumulation(tk, offset, shift,\n\t\t\t\t\t\t\t&clock_set);\n\t\tif (offset < tk->cycle_interval<<shift)\n\t\t\tshift--;\n\t}\n\n\t/* Adjust the multiplier to correct NTP error */\n\ttimekeeping_adjust(tk, offset);\n\n\t/*\n\t * Finally, make sure that after the rounding\n\t * xtime_nsec isn't larger than NSEC_PER_SEC\n\t */\n\tclock_set |= accumulate_nsecs_to_secs(tk);\n\n\twrite_seqcount_begin(&tk_core.seq);\n\t/*\n\t * Update the real timekeeper.\n\t *\n\t * We could avoid this memcpy by switching pointers, but that\n\t * requires changes to all other timekeeper usage sites as\n\t * well, i.e. move the timekeeper pointer getter into the\n\t * spinlocked/seqcount protected sections. And we trade this\n\t * memcpy under the tk_core.seq against one before we start\n\t * updating.\n\t */\n\ttimekeeping_update(tk, clock_set);\n\tmemcpy(real_tk, tk, sizeof(*tk));\n\t/* The memcpy must come last. Do not put anything here! */\n\twrite_seqcount_end(&tk_core.seq);\nout:\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\treturn !!clock_set;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_ntp_log",
          "args": [
            "&ad"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "__audit_ntp_log",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2869-2877",
          "snippet": "void __audit_ntp_log(const struct audit_ntp_data *ad)\n{\n\taudit_log_ntp_val(ad, \"offset\",\tAUDIT_NTP_OFFSET);\n\taudit_log_ntp_val(ad, \"freq\",\tAUDIT_NTP_FREQ);\n\taudit_log_ntp_val(ad, \"status\",\tAUDIT_NTP_STATUS);\n\taudit_log_ntp_val(ad, \"tai\",\tAUDIT_NTP_TAI);\n\taudit_log_ntp_val(ad, \"tick\",\tAUDIT_NTP_TICK);\n\taudit_log_ntp_val(ad, \"adjust\",\tAUDIT_NTP_ADJUST);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_ntp_log(const struct audit_ntp_data *ad)\n{\n\taudit_log_ntp_val(ad, \"offset\",\tAUDIT_NTP_OFFSET);\n\taudit_log_ntp_val(ad, \"freq\",\tAUDIT_NTP_FREQ);\n\taudit_log_ntp_val(ad, \"status\",\tAUDIT_NTP_STATUS);\n\taudit_log_ntp_val(ad, \"tai\",\tAUDIT_NTP_TAI);\n\taudit_log_ntp_val(ad, \"tick\",\tAUDIT_NTP_TICK);\n\taudit_log_ntp_val(ad, \"adjust\",\tAUDIT_NTP_ADJUST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_update_leap_state",
          "args": [
            "tk"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "tk_update_leap_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "696-702",
          "snippet": "static inline void tk_update_leap_state(struct timekeeper *tk)\n{\n\ttk->next_leap_ktime = ntp_get_next_leap();\n\tif (tk->next_leap_ktime != KTIME_MAX)\n\t\t/* Convert to monotonic time */\n\t\ttk->next_leap_ktime = ktime_sub(tk->next_leap_ktime, tk->offs_real);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_update_leap_state(struct timekeeper *tk)\n{\n\ttk->next_leap_ktime = ntp_get_next_leap();\n\tif (tk->next_leap_ktime != KTIME_MAX)\n\t\t/* Convert to monotonic time */\n\t\ttk->next_leap_ktime = ktime_sub(tk->next_leap_ktime, tk->offs_real);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "TK_MIRROR | TK_CLOCK_WAS_SET"
          ],
          "line": 2427
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "738-765",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__timekeeping_set_tai_offset",
          "args": [
            "tk",
            "tai"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "__timekeeping_set_tai_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1416-1420",
          "snippet": "static void __timekeeping_set_tai_offset(struct timekeeper *tk, s32 tai_offset)\n{\n\ttk->tai_offset = tai_offset;\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tai_offset, 0));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void __timekeeping_set_tai_offset(struct timekeeper *tk, s32 tai_offset)\n{\n\ttk->tai_offset = tai_offset;\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tai_offset, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__do_adjtimex",
          "args": [
            "txc",
            "&ts",
            "&tai",
            "&ad"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "__do_adjtimex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "762-846",
          "snippet": "int __do_adjtimex(struct __kernel_timex *txc, const struct timespec64 *ts,\n\t\t  s32 *time_tai, struct audit_ntp_data *ad)\n{\n\tint result;\n\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\tlong save_adjust = time_adjust;\n\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY)) {\n\t\t\t/* adjtime() is independent from ntp_adjtime() */\n\t\t\ttime_adjust = txc->offset;\n\t\t\tntp_update_frequency();\n\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_ADJUST,\tsave_adjust);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_ADJUST,\ttime_adjust);\n\t\t}\n\t\ttxc->offset = save_adjust;\n\t} else {\n\t\t/* If there are input parameters, then process them: */\n\t\tif (txc->modes) {\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_OFFSET,\ttime_offset);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_FREQ,\ttime_freq);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_STATUS,\ttime_status);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_TAI,\t*time_tai);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_TICK,\ttick_usec);\n\n\t\t\tprocess_adjtimex_modes(txc, time_tai);\n\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_OFFSET,\ttime_offset);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_FREQ,\ttime_freq);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_STATUS,\ttime_status);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_TAI,\t*time_tai);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_TICK,\ttick_usec);\n\t\t}\n\n\t\ttxc->offset = shift_right(time_offset * NTP_INTERVAL_FREQ,\n\t\t\t\t  NTP_SCALE_SHIFT);\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttxc->offset = (u32)txc->offset / NSEC_PER_USEC;\n\t}\n\n\tresult = time_state;\t/* mostly `TIME_OK' */\n\t/* check for errors */\n\tif (is_error_status(time_status))\n\t\tresult = TIME_ERROR;\n\n\ttxc->freq\t   = shift_right((time_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV, NTP_SCALE_SHIFT);\n\ttxc->maxerror\t   = time_maxerror;\n\ttxc->esterror\t   = time_esterror;\n\ttxc->status\t   = time_status;\n\ttxc->constant\t   = time_constant;\n\ttxc->precision\t   = 1;\n\ttxc->tolerance\t   = MAXFREQ_SCALED / PPM_SCALE;\n\ttxc->tick\t   = tick_usec;\n\ttxc->tai\t   = *time_tai;\n\n\t/* fill PPS status fields */\n\tpps_fill_timex(txc);\n\n\ttxc->time.tv_sec = ts->tv_sec;\n\ttxc->time.tv_usec = ts->tv_nsec;\n\tif (!(time_status & STA_NANO))\n\t\ttxc->time.tv_usec = ts->tv_nsec / NSEC_PER_USEC;\n\n\t/* Handle leapsec adjustments */\n\tif (unlikely(ts->tv_sec >= ntp_next_leap_sec)) {\n\t\tif ((time_state == TIME_INS) && (time_status & STA_INS)) {\n\t\t\tresult = TIME_OOP;\n\t\t\ttxc->tai++;\n\t\t\ttxc->time.tv_sec--;\n\t\t}\n\t\tif ((time_state == TIME_DEL) && (time_status & STA_DEL)) {\n\t\t\tresult = TIME_WAIT;\n\t\t\ttxc->tai--;\n\t\t\ttxc->time.tv_sec++;\n\t\t}\n\t\tif ((time_state == TIME_OOP) &&\n\t\t\t\t\t(ts->tv_sec == ntp_next_leap_sec)) {\n\t\t\tresult = TIME_WAIT;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
            "static int\t\t\ttime_state = TIME_OK;",
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static s64\t\t\ttime_offset;",
            "static long\t\t\ttime_constant = 2;",
            "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
            "static long\t\t\ttime_esterror = NTP_PHASE_LIMIT;",
            "static s64\t\t\ttime_freq;",
            "static long\t\t\ttime_adjust;",
            "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nstatic int\t\t\ttime_state = TIME_OK;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_constant = 2;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_esterror = NTP_PHASE_LIMIT;\nstatic s64\t\t\ttime_freq;\nstatic long\t\t\ttime_adjust;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nint __do_adjtimex(struct __kernel_timex *txc, const struct timespec64 *ts,\n\t\t  s32 *time_tai, struct audit_ntp_data *ad)\n{\n\tint result;\n\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\tlong save_adjust = time_adjust;\n\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY)) {\n\t\t\t/* adjtime() is independent from ntp_adjtime() */\n\t\t\ttime_adjust = txc->offset;\n\t\t\tntp_update_frequency();\n\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_ADJUST,\tsave_adjust);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_ADJUST,\ttime_adjust);\n\t\t}\n\t\ttxc->offset = save_adjust;\n\t} else {\n\t\t/* If there are input parameters, then process them: */\n\t\tif (txc->modes) {\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_OFFSET,\ttime_offset);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_FREQ,\ttime_freq);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_STATUS,\ttime_status);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_TAI,\t*time_tai);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_TICK,\ttick_usec);\n\n\t\t\tprocess_adjtimex_modes(txc, time_tai);\n\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_OFFSET,\ttime_offset);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_FREQ,\ttime_freq);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_STATUS,\ttime_status);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_TAI,\t*time_tai);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_TICK,\ttick_usec);\n\t\t}\n\n\t\ttxc->offset = shift_right(time_offset * NTP_INTERVAL_FREQ,\n\t\t\t\t  NTP_SCALE_SHIFT);\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttxc->offset = (u32)txc->offset / NSEC_PER_USEC;\n\t}\n\n\tresult = time_state;\t/* mostly `TIME_OK' */\n\t/* check for errors */\n\tif (is_error_status(time_status))\n\t\tresult = TIME_ERROR;\n\n\ttxc->freq\t   = shift_right((time_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV, NTP_SCALE_SHIFT);\n\ttxc->maxerror\t   = time_maxerror;\n\ttxc->esterror\t   = time_esterror;\n\ttxc->status\t   = time_status;\n\ttxc->constant\t   = time_constant;\n\ttxc->precision\t   = 1;\n\ttxc->tolerance\t   = MAXFREQ_SCALED / PPM_SCALE;\n\ttxc->tick\t   = tick_usec;\n\ttxc->tai\t   = *time_tai;\n\n\t/* fill PPS status fields */\n\tpps_fill_timex(txc);\n\n\ttxc->time.tv_sec = ts->tv_sec;\n\ttxc->time.tv_usec = ts->tv_nsec;\n\tif (!(time_status & STA_NANO))\n\t\ttxc->time.tv_usec = ts->tv_nsec / NSEC_PER_USEC;\n\n\t/* Handle leapsec adjustments */\n\tif (unlikely(ts->tv_sec >= ntp_next_leap_sec)) {\n\t\tif ((time_state == TIME_INS) && (time_status & STA_INS)) {\n\t\t\tresult = TIME_OOP;\n\t\t\ttxc->tai++;\n\t\t\ttxc->time.tv_sec--;\n\t\t}\n\t\tif ((time_state == TIME_DEL) && (time_status & STA_DEL)) {\n\t\t\tresult = TIME_WAIT;\n\t\t\ttxc->tai--;\n\t\t\ttxc->time.tv_sec++;\n\t\t}\n\t\tif ((time_state == TIME_OOP) &&\n\t\t\t\t\t(ts->tv_sec == ntp_next_leap_sec)) {\n\t\t\tresult = TIME_WAIT;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_real_ts64",
          "args": [
            "&ts"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_real_ts64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "796-814",
          "snippet": "void ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_ntp_init",
          "args": [
            "&ad"
          ],
          "line": 2415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_tk_injoffset",
          "args": [
            "delta"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "__audit_tk_injoffset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2850-2855",
          "snippet": "void __audit_tk_injoffset(struct timespec64 offset)\n{\n\taudit_log(audit_context(), GFP_KERNEL, AUDIT_TIME_INJOFFSET,\n\t\t  \"sec=%lli nsec=%li\",\n\t\t  (long long)offset.tv_sec, offset.tv_nsec);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_tk_injoffset(struct timespec64 offset)\n{\n\taudit_log(audit_context(), GFP_KERNEL, AUDIT_TIME_INJOFFSET,\n\t\t  \"sec=%lli nsec=%li\",\n\t\t  (long long)offset.tv_sec, offset.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_inject_offset",
          "args": [
            "&delta"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_inject_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1341-1377",
          "snippet": "static int timekeeping_inject_offset(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64 tmp;\n\tint ret = 0;\n\n\tif (ts->tv_nsec < 0 || ts->tv_nsec >= NSEC_PER_SEC)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\t/* Make sure the proposed value is valid */\n\ttmp = timespec64_add(tk_xtime(tk), *ts);\n\tif (timespec64_compare(&tk->wall_to_monotonic, ts) > 0 ||\n\t    !timespec64_valid_settod(&tmp)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk_xtime_add(tk, ts);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *ts));\n\nerror: /* even if we error out, we forwarded the time, so call update */\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* Signal hrtimers about time change */\n\tclock_was_set(CLOCK_SET_WALL);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic int timekeeping_inject_offset(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64 tmp;\n\tint ret = 0;\n\n\tif (ts->tv_nsec < 0 || ts->tv_nsec >= NSEC_PER_SEC)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\t/* Make sure the proposed value is valid */\n\ttmp = timespec64_add(tk_xtime(tk), *ts);\n\tif (timespec64_compare(&tk->wall_to_monotonic, ts) > 0 ||\n\t    !timespec64_valid_settod(&tmp)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk_xtime_add(tk, ts);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *ts));\n\nerror: /* even if we error out, we forwarded the time, so call update */\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* Signal hrtimers about time change */\n\tclock_was_set(CLOCK_SET_WALL);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_validate_timex",
          "args": [
            "txc"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_validate_timex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "2321-2381",
          "snippet": "static int timekeeping_validate_timex(const struct __kernel_timex *txc)\n{\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\t/* singleshot must not be used with any other mode bits */\n\t\tif (!(txc->modes & ADJ_OFFSET_SINGLESHOT))\n\t\t\treturn -EINVAL;\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY) &&\n\t\t    !capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t} else {\n\t\t/* In order to modify anything, you gotta be super-user! */\n\t\tif (txc->modes && !capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * if the quartz is off by more than 10% then\n\t\t * something is VERY wrong!\n\t\t */\n\t\tif (txc->modes & ADJ_TICK &&\n\t\t    (txc->tick <  900000/USER_HZ ||\n\t\t     txc->tick > 1100000/USER_HZ))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (txc->modes & ADJ_SETOFFSET) {\n\t\t/* In order to inject time, you gotta be super-user! */\n\t\tif (!capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Validate if a timespec/timeval used to inject a time\n\t\t * offset is valid.  Offsets can be positive or negative, so\n\t\t * we don't check tv_sec. The value of the timeval/timespec\n\t\t * is the sum of its fields,but *NOTE*:\n\t\t * The field tv_usec/tv_nsec must always be non-negative and\n\t\t * we can't have more nanoseconds/microseconds than a second.\n\t\t */\n\t\tif (txc->time.tv_usec < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (txc->modes & ADJ_NANO) {\n\t\t\tif (txc->time.tv_usec >= NSEC_PER_SEC)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (txc->time.tv_usec >= USEC_PER_SEC)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Check for potential multiplication overflows that can\n\t * only happen on 64-bit systems:\n\t */\n\tif ((txc->modes & ADJ_FREQUENCY) && (BITS_PER_LONG == 64)) {\n\t\tif (LLONG_MIN / PPM_SCALE > txc->freq)\n\t\t\treturn -EINVAL;\n\t\tif (LLONG_MAX / PPM_SCALE < txc->freq)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic int timekeeping_validate_timex(const struct __kernel_timex *txc)\n{\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\t/* singleshot must not be used with any other mode bits */\n\t\tif (!(txc->modes & ADJ_OFFSET_SINGLESHOT))\n\t\t\treturn -EINVAL;\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY) &&\n\t\t    !capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t} else {\n\t\t/* In order to modify anything, you gotta be super-user! */\n\t\tif (txc->modes && !capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * if the quartz is off by more than 10% then\n\t\t * something is VERY wrong!\n\t\t */\n\t\tif (txc->modes & ADJ_TICK &&\n\t\t    (txc->tick <  900000/USER_HZ ||\n\t\t     txc->tick > 1100000/USER_HZ))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (txc->modes & ADJ_SETOFFSET) {\n\t\t/* In order to inject time, you gotta be super-user! */\n\t\tif (!capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Validate if a timespec/timeval used to inject a time\n\t\t * offset is valid.  Offsets can be positive or negative, so\n\t\t * we don't check tv_sec. The value of the timeval/timespec\n\t\t * is the sum of its fields,but *NOTE*:\n\t\t * The field tv_usec/tv_nsec must always be non-negative and\n\t\t * we can't have more nanoseconds/microseconds than a second.\n\t\t */\n\t\tif (txc->time.tv_usec < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (txc->modes & ADJ_NANO) {\n\t\t\tif (txc->time.tv_usec >= NSEC_PER_SEC)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (txc->time.tv_usec >= USEC_PER_SEC)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Check for potential multiplication overflows that can\n\t * only happen on 64-bit systems:\n\t */\n\tif ((txc->modes & ADJ_FREQUENCY) && (BITS_PER_LONG == 64)) {\n\t\tif (LLONG_MIN / PPM_SCALE > txc->freq)\n\t\t\treturn -EINVAL;\n\t\tif (LLONG_MAX / PPM_SCALE < txc->freq)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n\nint do_adjtimex(struct __kernel_timex *txc)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct audit_ntp_data ad;\n\tbool clock_set = false;\n\tstruct timespec64 ts;\n\tunsigned long flags;\n\ts32 orig_tai, tai;\n\tint ret;\n\n\t/* Validate the data before disabling interrupts */\n\tret = timekeeping_validate_timex(txc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (txc->modes & ADJ_SETOFFSET) {\n\t\tstruct timespec64 delta;\n\t\tdelta.tv_sec  = txc->time.tv_sec;\n\t\tdelta.tv_nsec = txc->time.tv_usec;\n\t\tif (!(txc->modes & ADJ_NANO))\n\t\t\tdelta.tv_nsec *= 1000;\n\t\tret = timekeeping_inject_offset(&delta);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\taudit_tk_injoffset(delta);\n\t}\n\n\taudit_ntp_init(&ad);\n\n\tktime_get_real_ts64(&ts);\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\torig_tai = tai = tk->tai_offset;\n\tret = __do_adjtimex(txc, &ts, &tai, &ad);\n\n\tif (tai != orig_tai) {\n\t\t__timekeeping_set_tai_offset(tk, tai);\n\t\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\t\tclock_set = true;\n\t}\n\ttk_update_leap_state(tk);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\taudit_ntp_log(&ad);\n\n\t/* Update the multiplier immediately if frequency was set directly */\n\tif (txc->modes & (ADJ_FREQUENCY | ADJ_TICK))\n\t\tclock_set |= timekeeping_advance(TK_ADV_FREQ);\n\n\tif (clock_set)\n\t\tclock_was_set(CLOCK_REALTIME);\n\n\tntp_notify_cmos_timer();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "timekeeping_validate_timex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "2321-2381",
    "snippet": "static int timekeeping_validate_timex(const struct __kernel_timex *txc)\n{\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\t/* singleshot must not be used with any other mode bits */\n\t\tif (!(txc->modes & ADJ_OFFSET_SINGLESHOT))\n\t\t\treturn -EINVAL;\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY) &&\n\t\t    !capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t} else {\n\t\t/* In order to modify anything, you gotta be super-user! */\n\t\tif (txc->modes && !capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * if the quartz is off by more than 10% then\n\t\t * something is VERY wrong!\n\t\t */\n\t\tif (txc->modes & ADJ_TICK &&\n\t\t    (txc->tick <  900000/USER_HZ ||\n\t\t     txc->tick > 1100000/USER_HZ))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (txc->modes & ADJ_SETOFFSET) {\n\t\t/* In order to inject time, you gotta be super-user! */\n\t\tif (!capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Validate if a timespec/timeval used to inject a time\n\t\t * offset is valid.  Offsets can be positive or negative, so\n\t\t * we don't check tv_sec. The value of the timeval/timespec\n\t\t * is the sum of its fields,but *NOTE*:\n\t\t * The field tv_usec/tv_nsec must always be non-negative and\n\t\t * we can't have more nanoseconds/microseconds than a second.\n\t\t */\n\t\tif (txc->time.tv_usec < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (txc->modes & ADJ_NANO) {\n\t\t\tif (txc->time.tv_usec >= NSEC_PER_SEC)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (txc->time.tv_usec >= USEC_PER_SEC)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Check for potential multiplication overflows that can\n\t * only happen on 64-bit systems:\n\t */\n\tif ((txc->modes & ADJ_FREQUENCY) && (BITS_PER_LONG == 64)) {\n\t\tif (LLONG_MIN / PPM_SCALE > txc->freq)\n\t\t\treturn -EINVAL;\n\t\tif (LLONG_MAX / PPM_SCALE < txc->freq)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_TIME"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic int timekeeping_validate_timex(const struct __kernel_timex *txc)\n{\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\t/* singleshot must not be used with any other mode bits */\n\t\tif (!(txc->modes & ADJ_OFFSET_SINGLESHOT))\n\t\t\treturn -EINVAL;\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY) &&\n\t\t    !capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t} else {\n\t\t/* In order to modify anything, you gotta be super-user! */\n\t\tif (txc->modes && !capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * if the quartz is off by more than 10% then\n\t\t * something is VERY wrong!\n\t\t */\n\t\tif (txc->modes & ADJ_TICK &&\n\t\t    (txc->tick <  900000/USER_HZ ||\n\t\t     txc->tick > 1100000/USER_HZ))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (txc->modes & ADJ_SETOFFSET) {\n\t\t/* In order to inject time, you gotta be super-user! */\n\t\tif (!capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Validate if a timespec/timeval used to inject a time\n\t\t * offset is valid.  Offsets can be positive or negative, so\n\t\t * we don't check tv_sec. The value of the timeval/timespec\n\t\t * is the sum of its fields,but *NOTE*:\n\t\t * The field tv_usec/tv_nsec must always be non-negative and\n\t\t * we can't have more nanoseconds/microseconds than a second.\n\t\t */\n\t\tif (txc->time.tv_usec < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (txc->modes & ADJ_NANO) {\n\t\t\tif (txc->time.tv_usec >= NSEC_PER_SEC)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (txc->time.tv_usec >= USEC_PER_SEC)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Check for potential multiplication overflows that can\n\t * only happen on 64-bit systems:\n\t */\n\tif ((txc->modes & ADJ_FREQUENCY) && (BITS_PER_LONG == 64)) {\n\t\tif (LLONG_MIN / PPM_SCALE > txc->freq)\n\t\t\treturn -EINVAL;\n\t\tif (LLONG_MAX / PPM_SCALE < txc->freq)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ktime_get_update_offsets_now",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "2287-2316",
    "snippet": "ktime_t ktime_get_update_offsets_now(unsigned int *cwsseq, ktime_t *offs_real,\n\t\t\t\t     ktime_t *offs_boot, ktime_t *offs_tai)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tbase = tk->tkr_mono.base;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\t\tbase = ktime_add_ns(base, nsecs);\n\n\t\tif (*cwsseq != tk->clock_was_set_seq) {\n\t\t\t*cwsseq = tk->clock_was_set_seq;\n\t\t\t*offs_real = tk->offs_real;\n\t\t\t*offs_boot = tk->offs_boot;\n\t\t\t*offs_tai = tk->offs_tai;\n\t\t}\n\n\t\t/* Handle leapsecond insertion adjustments */\n\t\tif (unlikely(base >= tk->next_leap_ktime))\n\t\t\t*offs_real = ktime_sub(tk->offs_real, ktime_set(1, 0));\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn base;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "tk->offs_real",
            "ktime_set(1, 0)"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_set",
          "args": [
            "1",
            "0"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "base >= tk->next_leap_ktime"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base",
            "nsecs"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_get_ns",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_get_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "382-388",
          "snippet": "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nktime_t ktime_get_update_offsets_now(unsigned int *cwsseq, ktime_t *offs_real,\n\t\t\t\t     ktime_t *offs_boot, ktime_t *offs_tai)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tbase = tk->tkr_mono.base;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\t\tbase = ktime_add_ns(base, nsecs);\n\n\t\tif (*cwsseq != tk->clock_was_set_seq) {\n\t\t\t*cwsseq = tk->clock_was_set_seq;\n\t\t\t*offs_real = tk->offs_real;\n\t\t\t*offs_boot = tk->offs_boot;\n\t\t\t*offs_tai = tk->offs_tai;\n\t\t}\n\n\t\t/* Handle leapsecond insertion adjustments */\n\t\tif (unlikely(base >= tk->next_leap_ktime))\n\t\t\t*offs_real = ktime_sub(tk->offs_real, ktime_set(1, 0));\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn base;\n}"
  },
  {
    "function_name": "do_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "2268-2272",
    "snippet": "void do_timer(unsigned long ticks)\n{\n\tjiffies_64 += ticks;\n\tcalc_global_load();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calc_global_load",
          "args": [],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "calc_global_load",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/loadavg.c",
          "lines": "350-380",
          "snippet": "void calc_global_load(void)\n{\n\tunsigned long sample_window;\n\tlong active, delta;\n\n\tsample_window = READ_ONCE(calc_load_update);\n\tif (time_before(jiffies, sample_window + 10))\n\t\treturn;\n\n\t/*\n\t * Fold the 'old' NO_HZ-delta to include all NO_HZ CPUs.\n\t */\n\tdelta = calc_load_nohz_read();\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n\n\tactive = atomic_long_read(&calc_load_tasks);\n\tactive = active > 0 ? active * FIXED_1 : 0;\n\n\tavenrun[0] = calc_load(avenrun[0], EXP_1, active);\n\tavenrun[1] = calc_load(avenrun[1], EXP_5, active);\n\tavenrun[2] = calc_load(avenrun[2], EXP_15, active);\n\n\tWRITE_ONCE(calc_load_update, sample_window + LOAD_FREQ);\n\n\t/*\n\t * In case we went to NO_HZ for multiple LOAD_FREQ intervals\n\t * catch up in bulk.\n\t */\n\tcalc_global_nohz();\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_long_t calc_load_tasks;",
            "unsigned long calc_load_update;",
            "unsigned long avenrun[3];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\natomic_long_t calc_load_tasks;\nunsigned long calc_load_update;\nunsigned long avenrun[3];\n\nvoid calc_global_load(void)\n{\n\tunsigned long sample_window;\n\tlong active, delta;\n\n\tsample_window = READ_ONCE(calc_load_update);\n\tif (time_before(jiffies, sample_window + 10))\n\t\treturn;\n\n\t/*\n\t * Fold the 'old' NO_HZ-delta to include all NO_HZ CPUs.\n\t */\n\tdelta = calc_load_nohz_read();\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n\n\tactive = atomic_long_read(&calc_load_tasks);\n\tactive = active > 0 ? active * FIXED_1 : 0;\n\n\tavenrun[0] = calc_load(avenrun[0], EXP_1, active);\n\tavenrun[1] = calc_load(avenrun[1], EXP_5, active);\n\tavenrun[2] = calc_load(avenrun[2], EXP_15, active);\n\n\tWRITE_ONCE(calc_load_update, sample_window + LOAD_FREQ);\n\n\t/*\n\t * In case we went to NO_HZ for multiple LOAD_FREQ intervals\n\t * catch up in bulk.\n\t */\n\tcalc_global_nohz();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid do_timer(unsigned long ticks)\n{\n\tjiffies_64 += ticks;\n\tcalc_global_load();\n}"
  },
  {
    "function_name": "ktime_get_coarse_ts64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "2247-2262",
    "snippet": "void ktime_get_coarse_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 now, mono;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tnow = tk_xtime(tk);\n\t\tmono = tk->wall_to_monotonic;\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tset_normalized_timespec64(ts, now.tv_sec + mono.tv_sec,\n\t\t\t\tnow.tv_nsec + mono.tv_nsec);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_normalized_timespec64",
          "args": [
            "ts",
            "now.tv_sec + mono.tv_sec",
            "now.tv_nsec + mono.tv_nsec"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "set_normalized_timespec64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "478-497",
          "snippet": "void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)\n{\n\twhile (nsec >= NSEC_PER_SEC) {\n\t\t/*\n\t\t * The following asm() prevents the compiler from\n\t\t * optimising this loop into a modulo operation. See\n\t\t * also __iter_div_u64_rem() in include/linux/time.h\n\t\t */\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec -= NSEC_PER_SEC;\n\t\t++sec;\n\t}\n\twhile (nsec < 0) {\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec += NSEC_PER_SEC;\n\t\t--sec;\n\t}\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)\n{\n\twhile (nsec >= NSEC_PER_SEC) {\n\t\t/*\n\t\t * The following asm() prevents the compiler from\n\t\t * optimising this loop into a modulo operation. See\n\t\t * also __iter_div_u64_rem() in include/linux/time.h\n\t\t */\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec -= NSEC_PER_SEC;\n\t\t++sec;\n\t}\n\twhile (nsec < 0) {\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec += NSEC_PER_SEC;\n\t\t--sec;\n\t}\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_xtime",
          "args": [
            "tk"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "tk_xtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "127-134",
          "snippet": "static inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_coarse_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 now, mono;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tnow = tk_xtime(tk);\n\t\tmono = tk->wall_to_monotonic;\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tset_normalized_timespec64(ts, now.tv_sec + mono.tv_sec,\n\t\t\t\tnow.tv_nsec + mono.tv_nsec);\n}"
  },
  {
    "function_name": "ktime_get_coarse_real_ts64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "2234-2244",
    "snippet": "void ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_xtime",
          "args": [
            "tk"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "tk_xtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "127-134",
          "snippet": "static inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}"
  },
  {
    "function_name": "getboottime64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "2225-2231",
    "snippet": "void getboottime64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tktime_t t = ktime_sub(tk->offs_real, tk->offs_boot);\n\n\t*ts = ktime_to_timespec64(t);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "t"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "tk->offs_real",
            "tk->offs_boot"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid getboottime64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tktime_t t = ktime_sub(tk->offs_real, tk->offs_boot);\n\n\t*ts = ktime_to_timespec64(t);\n}"
  },
  {
    "function_name": "update_wall_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "2208-2212",
    "snippet": "void update_wall_time(void)\n{\n\tif (timekeeping_advance(TK_ADV_TICK))\n\t\tclock_was_set_delayed();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clock_was_set_delayed",
          "args": [],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "clock_was_set_delayed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "994-997",
          "snippet": "void clock_was_set_delayed(void)\n{\n\tschedule_work(&hrtimer_work);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid clock_was_set_delayed(void)\n{\n\tschedule_work(&hrtimer_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_advance",
          "args": [
            "TK_ADV_TICK"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_advance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "2129-2202",
          "snippet": "static bool timekeeping_advance(enum timekeeping_adv_mode mode)\n{\n\tstruct timekeeper *real_tk = &tk_core.timekeeper;\n\tstruct timekeeper *tk = &shadow_timekeeper;\n\tu64 offset;\n\tint shift = 0, maxshift;\n\tunsigned int clock_set = 0;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\n\t/* Make sure we're fully resumed: */\n\tif (unlikely(timekeeping_suspended))\n\t\tgoto out;\n\n\toffset = clocksource_delta(tk_clock_read(&tk->tkr_mono),\n\t\t\t\t   tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\n\t/* Check if there's really nothing to do */\n\tif (offset < real_tk->cycle_interval && mode == TK_ADV_TICK)\n\t\tgoto out;\n\n\t/* Do some additional sanity checking */\n\ttimekeeping_check_update(tk, offset);\n\n\t/*\n\t * With NO_HZ we may have to accumulate many cycle_intervals\n\t * (think \"ticks\") worth of time at once. To do this efficiently,\n\t * we calculate the largest doubling multiple of cycle_intervals\n\t * that is smaller than the offset.  We then accumulate that\n\t * chunk in one go, and then try to consume the next smaller\n\t * doubled multiple.\n\t */\n\tshift = ilog2(offset) - ilog2(tk->cycle_interval);\n\tshift = max(0, shift);\n\t/* Bound shift to one less than what overflows tick_length */\n\tmaxshift = (64 - (ilog2(ntp_tick_length())+1)) - 1;\n\tshift = min(shift, maxshift);\n\twhile (offset >= tk->cycle_interval) {\n\t\toffset = logarithmic_accumulation(tk, offset, shift,\n\t\t\t\t\t\t\t&clock_set);\n\t\tif (offset < tk->cycle_interval<<shift)\n\t\t\tshift--;\n\t}\n\n\t/* Adjust the multiplier to correct NTP error */\n\ttimekeeping_adjust(tk, offset);\n\n\t/*\n\t * Finally, make sure that after the rounding\n\t * xtime_nsec isn't larger than NSEC_PER_SEC\n\t */\n\tclock_set |= accumulate_nsecs_to_secs(tk);\n\n\twrite_seqcount_begin(&tk_core.seq);\n\t/*\n\t * Update the real timekeeper.\n\t *\n\t * We could avoid this memcpy by switching pointers, but that\n\t * requires changes to all other timekeeper usage sites as\n\t * well, i.e. move the timekeeper pointer getter into the\n\t * spinlocked/seqcount protected sections. And we trade this\n\t * memcpy under the tk_core.seq against one before we start\n\t * updating.\n\t */\n\ttimekeeping_update(tk, clock_set);\n\tmemcpy(real_tk, tk, sizeof(*tk));\n\t/* The memcpy must come last. Do not put anything here! */\n\twrite_seqcount_end(&tk_core.seq);\nout:\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\treturn !!clock_set;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic bool timekeeping_advance(enum timekeeping_adv_mode mode)\n{\n\tstruct timekeeper *real_tk = &tk_core.timekeeper;\n\tstruct timekeeper *tk = &shadow_timekeeper;\n\tu64 offset;\n\tint shift = 0, maxshift;\n\tunsigned int clock_set = 0;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\n\t/* Make sure we're fully resumed: */\n\tif (unlikely(timekeeping_suspended))\n\t\tgoto out;\n\n\toffset = clocksource_delta(tk_clock_read(&tk->tkr_mono),\n\t\t\t\t   tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\n\t/* Check if there's really nothing to do */\n\tif (offset < real_tk->cycle_interval && mode == TK_ADV_TICK)\n\t\tgoto out;\n\n\t/* Do some additional sanity checking */\n\ttimekeeping_check_update(tk, offset);\n\n\t/*\n\t * With NO_HZ we may have to accumulate many cycle_intervals\n\t * (think \"ticks\") worth of time at once. To do this efficiently,\n\t * we calculate the largest doubling multiple of cycle_intervals\n\t * that is smaller than the offset.  We then accumulate that\n\t * chunk in one go, and then try to consume the next smaller\n\t * doubled multiple.\n\t */\n\tshift = ilog2(offset) - ilog2(tk->cycle_interval);\n\tshift = max(0, shift);\n\t/* Bound shift to one less than what overflows tick_length */\n\tmaxshift = (64 - (ilog2(ntp_tick_length())+1)) - 1;\n\tshift = min(shift, maxshift);\n\twhile (offset >= tk->cycle_interval) {\n\t\toffset = logarithmic_accumulation(tk, offset, shift,\n\t\t\t\t\t\t\t&clock_set);\n\t\tif (offset < tk->cycle_interval<<shift)\n\t\t\tshift--;\n\t}\n\n\t/* Adjust the multiplier to correct NTP error */\n\ttimekeeping_adjust(tk, offset);\n\n\t/*\n\t * Finally, make sure that after the rounding\n\t * xtime_nsec isn't larger than NSEC_PER_SEC\n\t */\n\tclock_set |= accumulate_nsecs_to_secs(tk);\n\n\twrite_seqcount_begin(&tk_core.seq);\n\t/*\n\t * Update the real timekeeper.\n\t *\n\t * We could avoid this memcpy by switching pointers, but that\n\t * requires changes to all other timekeeper usage sites as\n\t * well, i.e. move the timekeeper pointer getter into the\n\t * spinlocked/seqcount protected sections. And we trade this\n\t * memcpy under the tk_core.seq against one before we start\n\t * updating.\n\t */\n\ttimekeeping_update(tk, clock_set);\n\tmemcpy(real_tk, tk, sizeof(*tk));\n\t/* The memcpy must come last. Do not put anything here! */\n\twrite_seqcount_end(&tk_core.seq);\nout:\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\treturn !!clock_set;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid update_wall_time(void)\n{\n\tif (timekeeping_advance(TK_ADV_TICK))\n\t\tclock_was_set_delayed();\n}"
  },
  {
    "function_name": "timekeeping_advance",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "2129-2202",
    "snippet": "static bool timekeeping_advance(enum timekeeping_adv_mode mode)\n{\n\tstruct timekeeper *real_tk = &tk_core.timekeeper;\n\tstruct timekeeper *tk = &shadow_timekeeper;\n\tu64 offset;\n\tint shift = 0, maxshift;\n\tunsigned int clock_set = 0;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\n\t/* Make sure we're fully resumed: */\n\tif (unlikely(timekeeping_suspended))\n\t\tgoto out;\n\n\toffset = clocksource_delta(tk_clock_read(&tk->tkr_mono),\n\t\t\t\t   tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\n\t/* Check if there's really nothing to do */\n\tif (offset < real_tk->cycle_interval && mode == TK_ADV_TICK)\n\t\tgoto out;\n\n\t/* Do some additional sanity checking */\n\ttimekeeping_check_update(tk, offset);\n\n\t/*\n\t * With NO_HZ we may have to accumulate many cycle_intervals\n\t * (think \"ticks\") worth of time at once. To do this efficiently,\n\t * we calculate the largest doubling multiple of cycle_intervals\n\t * that is smaller than the offset.  We then accumulate that\n\t * chunk in one go, and then try to consume the next smaller\n\t * doubled multiple.\n\t */\n\tshift = ilog2(offset) - ilog2(tk->cycle_interval);\n\tshift = max(0, shift);\n\t/* Bound shift to one less than what overflows tick_length */\n\tmaxshift = (64 - (ilog2(ntp_tick_length())+1)) - 1;\n\tshift = min(shift, maxshift);\n\twhile (offset >= tk->cycle_interval) {\n\t\toffset = logarithmic_accumulation(tk, offset, shift,\n\t\t\t\t\t\t\t&clock_set);\n\t\tif (offset < tk->cycle_interval<<shift)\n\t\t\tshift--;\n\t}\n\n\t/* Adjust the multiplier to correct NTP error */\n\ttimekeeping_adjust(tk, offset);\n\n\t/*\n\t * Finally, make sure that after the rounding\n\t * xtime_nsec isn't larger than NSEC_PER_SEC\n\t */\n\tclock_set |= accumulate_nsecs_to_secs(tk);\n\n\twrite_seqcount_begin(&tk_core.seq);\n\t/*\n\t * Update the real timekeeper.\n\t *\n\t * We could avoid this memcpy by switching pointers, but that\n\t * requires changes to all other timekeeper usage sites as\n\t * well, i.e. move the timekeeper pointer getter into the\n\t * spinlocked/seqcount protected sections. And we trade this\n\t * memcpy under the tk_core.seq against one before we start\n\t * updating.\n\t */\n\ttimekeeping_update(tk, clock_set);\n\tmemcpy(real_tk, tk, sizeof(*tk));\n\t/* The memcpy must come last. Do not put anything here! */\n\twrite_seqcount_end(&tk_core.seq);\nout:\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\treturn !!clock_set;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct timekeeper shadow_timekeeper;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "real_tk",
            "tk",
            "sizeof(*tk)"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "clock_set"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "738-765",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accumulate_nsecs_to_secs",
          "args": [
            "tk"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "accumulate_nsecs_to_secs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "2042-2080",
          "snippet": "static inline unsigned int accumulate_nsecs_to_secs(struct timekeeper *tk)\n{\n\tu64 nsecps = (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\tunsigned int clock_set = 0;\n\n\twhile (tk->tkr_mono.xtime_nsec >= nsecps) {\n\t\tint leap;\n\n\t\ttk->tkr_mono.xtime_nsec -= nsecps;\n\t\ttk->xtime_sec++;\n\n\t\t/*\n\t\t * Skip NTP update if this second was accumulated before,\n\t\t * i.e. xtime_nsec underflowed in timekeeping_adjust()\n\t\t */\n\t\tif (unlikely(tk->skip_second_overflow)) {\n\t\t\ttk->skip_second_overflow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Figure out if its a leap sec and apply if needed */\n\t\tleap = second_overflow(tk->xtime_sec);\n\t\tif (unlikely(leap)) {\n\t\t\tstruct timespec64 ts;\n\n\t\t\ttk->xtime_sec += leap;\n\n\t\t\tts.tv_sec = leap;\n\t\t\tts.tv_nsec = 0;\n\t\t\ttk_set_wall_to_mono(tk,\n\t\t\t\ttimespec64_sub(tk->wall_to_monotonic, ts));\n\n\t\t\t__timekeeping_set_tai_offset(tk, tk->tai_offset - leap);\n\n\t\t\tclock_set = TK_CLOCK_WAS_SET;\n\t\t}\n\t}\n\treturn clock_set;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n\nstatic inline unsigned int accumulate_nsecs_to_secs(struct timekeeper *tk)\n{\n\tu64 nsecps = (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\tunsigned int clock_set = 0;\n\n\twhile (tk->tkr_mono.xtime_nsec >= nsecps) {\n\t\tint leap;\n\n\t\ttk->tkr_mono.xtime_nsec -= nsecps;\n\t\ttk->xtime_sec++;\n\n\t\t/*\n\t\t * Skip NTP update if this second was accumulated before,\n\t\t * i.e. xtime_nsec underflowed in timekeeping_adjust()\n\t\t */\n\t\tif (unlikely(tk->skip_second_overflow)) {\n\t\t\ttk->skip_second_overflow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Figure out if its a leap sec and apply if needed */\n\t\tleap = second_overflow(tk->xtime_sec);\n\t\tif (unlikely(leap)) {\n\t\t\tstruct timespec64 ts;\n\n\t\t\ttk->xtime_sec += leap;\n\n\t\t\tts.tv_sec = leap;\n\t\t\tts.tv_nsec = 0;\n\t\t\ttk_set_wall_to_mono(tk,\n\t\t\t\ttimespec64_sub(tk->wall_to_monotonic, ts));\n\n\t\t\t__timekeeping_set_tai_offset(tk, tk->tai_offset - leap);\n\n\t\t\tclock_set = TK_CLOCK_WAS_SET;\n\t\t}\n\t}\n\treturn clock_set;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_adjust",
          "args": [
            "tk",
            "offset"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_adjust",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1981-2033",
          "snippet": "static void timekeeping_adjust(struct timekeeper *tk, s64 offset)\n{\n\tu32 mult;\n\n\t/*\n\t * Determine the multiplier from the current NTP tick length.\n\t * Avoid expensive division when the tick length doesn't change.\n\t */\n\tif (likely(tk->ntp_tick == ntp_tick_length())) {\n\t\tmult = tk->tkr_mono.mult - tk->ntp_err_mult;\n\t} else {\n\t\ttk->ntp_tick = ntp_tick_length();\n\t\tmult = div64_u64((tk->ntp_tick >> tk->ntp_error_shift) -\n\t\t\t\t tk->xtime_remainder, tk->cycle_interval);\n\t}\n\n\t/*\n\t * If the clock is behind the NTP time, increase the multiplier by 1\n\t * to catch up with it. If it's ahead and there was a remainder in the\n\t * tick division, the clock will slow down. Otherwise it will stay\n\t * ahead until the tick length changes to a non-divisible value.\n\t */\n\ttk->ntp_err_mult = tk->ntp_error > 0 ? 1 : 0;\n\tmult += tk->ntp_err_mult;\n\n\ttimekeeping_apply_adjustment(tk, offset, mult - tk->tkr_mono.mult);\n\n\tif (unlikely(tk->tkr_mono.clock->maxadj &&\n\t\t(abs(tk->tkr_mono.mult - tk->tkr_mono.clock->mult)\n\t\t\t> tk->tkr_mono.clock->maxadj))) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\"Adjusting %s more than 11%% (%ld vs %ld)\\n\",\n\t\t\ttk->tkr_mono.clock->name, (long)tk->tkr_mono.mult,\n\t\t\t(long)tk->tkr_mono.clock->mult + tk->tkr_mono.clock->maxadj);\n\t}\n\n\t/*\n\t * It may be possible that when we entered this function, xtime_nsec\n\t * was very small.  Further, if we're slightly speeding the clocksource\n\t * in the code above, its possible the required corrective factor to\n\t * xtime_nsec could cause it to underflow.\n\t *\n\t * Now, since we have already accumulated the second and the NTP\n\t * subsystem has been notified via second_overflow(), we need to skip\n\t * the next update.\n\t */\n\tif (unlikely((s64)tk->tkr_mono.xtime_nsec < 0)) {\n\t\ttk->tkr_mono.xtime_nsec += (u64)NSEC_PER_SEC <<\n\t\t\t\t\t\t\ttk->tkr_mono.shift;\n\t\ttk->xtime_sec--;\n\t\ttk->skip_second_overflow = 1;\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void timekeeping_adjust(struct timekeeper *tk, s64 offset)\n{\n\tu32 mult;\n\n\t/*\n\t * Determine the multiplier from the current NTP tick length.\n\t * Avoid expensive division when the tick length doesn't change.\n\t */\n\tif (likely(tk->ntp_tick == ntp_tick_length())) {\n\t\tmult = tk->tkr_mono.mult - tk->ntp_err_mult;\n\t} else {\n\t\ttk->ntp_tick = ntp_tick_length();\n\t\tmult = div64_u64((tk->ntp_tick >> tk->ntp_error_shift) -\n\t\t\t\t tk->xtime_remainder, tk->cycle_interval);\n\t}\n\n\t/*\n\t * If the clock is behind the NTP time, increase the multiplier by 1\n\t * to catch up with it. If it's ahead and there was a remainder in the\n\t * tick division, the clock will slow down. Otherwise it will stay\n\t * ahead until the tick length changes to a non-divisible value.\n\t */\n\ttk->ntp_err_mult = tk->ntp_error > 0 ? 1 : 0;\n\tmult += tk->ntp_err_mult;\n\n\ttimekeeping_apply_adjustment(tk, offset, mult - tk->tkr_mono.mult);\n\n\tif (unlikely(tk->tkr_mono.clock->maxadj &&\n\t\t(abs(tk->tkr_mono.mult - tk->tkr_mono.clock->mult)\n\t\t\t> tk->tkr_mono.clock->maxadj))) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\"Adjusting %s more than 11%% (%ld vs %ld)\\n\",\n\t\t\ttk->tkr_mono.clock->name, (long)tk->tkr_mono.mult,\n\t\t\t(long)tk->tkr_mono.clock->mult + tk->tkr_mono.clock->maxadj);\n\t}\n\n\t/*\n\t * It may be possible that when we entered this function, xtime_nsec\n\t * was very small.  Further, if we're slightly speeding the clocksource\n\t * in the code above, its possible the required corrective factor to\n\t * xtime_nsec could cause it to underflow.\n\t *\n\t * Now, since we have already accumulated the second and the NTP\n\t * subsystem has been notified via second_overflow(), we need to skip\n\t * the next update.\n\t */\n\tif (unlikely((s64)tk->tkr_mono.xtime_nsec < 0)) {\n\t\ttk->tkr_mono.xtime_nsec += (u64)NSEC_PER_SEC <<\n\t\t\t\t\t\t\ttk->tkr_mono.shift;\n\t\ttk->xtime_sec--;\n\t\ttk->skip_second_overflow = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logarithmic_accumulation",
          "args": [
            "tk",
            "offset",
            "shift",
            "&clock_set"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "logarithmic_accumulation",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "2091-2123",
          "snippet": "static u64 logarithmic_accumulation(struct timekeeper *tk, u64 offset,\n\t\t\t\t    u32 shift, unsigned int *clock_set)\n{\n\tu64 interval = tk->cycle_interval << shift;\n\tu64 snsec_per_sec;\n\n\t/* If the offset is smaller than a shifted interval, do nothing */\n\tif (offset < interval)\n\t\treturn offset;\n\n\t/* Accumulate one shifted interval */\n\toffset -= interval;\n\ttk->tkr_mono.cycle_last += interval;\n\ttk->tkr_raw.cycle_last  += interval;\n\n\ttk->tkr_mono.xtime_nsec += tk->xtime_interval << shift;\n\t*clock_set |= accumulate_nsecs_to_secs(tk);\n\n\t/* Accumulate raw time */\n\ttk->tkr_raw.xtime_nsec += tk->raw_interval << shift;\n\tsnsec_per_sec = (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\twhile (tk->tkr_raw.xtime_nsec >= snsec_per_sec) {\n\t\ttk->tkr_raw.xtime_nsec -= snsec_per_sec;\n\t\ttk->raw_sec++;\n\t}\n\n\t/* Accumulate error between NTP and clock interval */\n\ttk->ntp_error += tk->ntp_tick << shift;\n\ttk->ntp_error -= (tk->xtime_interval + tk->xtime_remainder) <<\n\t\t\t\t\t\t(tk->ntp_error_shift + shift);\n\n\treturn offset;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic u64 logarithmic_accumulation(struct timekeeper *tk, u64 offset,\n\t\t\t\t    u32 shift, unsigned int *clock_set)\n{\n\tu64 interval = tk->cycle_interval << shift;\n\tu64 snsec_per_sec;\n\n\t/* If the offset is smaller than a shifted interval, do nothing */\n\tif (offset < interval)\n\t\treturn offset;\n\n\t/* Accumulate one shifted interval */\n\toffset -= interval;\n\ttk->tkr_mono.cycle_last += interval;\n\ttk->tkr_raw.cycle_last  += interval;\n\n\ttk->tkr_mono.xtime_nsec += tk->xtime_interval << shift;\n\t*clock_set |= accumulate_nsecs_to_secs(tk);\n\n\t/* Accumulate raw time */\n\ttk->tkr_raw.xtime_nsec += tk->raw_interval << shift;\n\tsnsec_per_sec = (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\twhile (tk->tkr_raw.xtime_nsec >= snsec_per_sec) {\n\t\ttk->tkr_raw.xtime_nsec -= snsec_per_sec;\n\t\ttk->raw_sec++;\n\t}\n\n\t/* Accumulate error between NTP and clock interval */\n\ttk->ntp_error += tk->ntp_tick << shift;\n\ttk->ntp_error -= (tk->xtime_interval + tk->xtime_remainder) <<\n\t\t\t\t\t\t(tk->ntp_error_shift + shift);\n\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "shift",
            "maxshift"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_stop_suspend_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "776-808",
          "snippet": "u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static u64 suspend_start;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nu64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "ntp_tick_length()"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntp_tick_length",
          "args": [],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_tick_length",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "369-372",
          "snippet": "u64 ntp_tick_length(void)\n{\n\treturn tick_length;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64\t\t\ttick_length;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic u64\t\t\ttick_length;\n\nu64 ntp_tick_length(void)\n{\n\treturn tick_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "0",
            "shift"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "tk->cycle_interval"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "offset"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_check_update",
          "args": [
            "tk",
            "offset"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_check_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "279-281",
          "snippet": "static inline void timekeeping_check_update(struct timekeeper *tk, u64 offset)\n{\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void timekeeping_check_update(struct timekeeper *tk, u64 offset)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "tk_clock_read(&tk->tkr_mono)",
            "tk->tkr_mono.cycle_last",
            "tk->tkr_mono.mask"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping_internal.h",
          "lines": "30-33",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/spinlock.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "189-194",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic bool timekeeping_advance(enum timekeeping_adv_mode mode)\n{\n\tstruct timekeeper *real_tk = &tk_core.timekeeper;\n\tstruct timekeeper *tk = &shadow_timekeeper;\n\tu64 offset;\n\tint shift = 0, maxshift;\n\tunsigned int clock_set = 0;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\n\t/* Make sure we're fully resumed: */\n\tif (unlikely(timekeeping_suspended))\n\t\tgoto out;\n\n\toffset = clocksource_delta(tk_clock_read(&tk->tkr_mono),\n\t\t\t\t   tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\n\t/* Check if there's really nothing to do */\n\tif (offset < real_tk->cycle_interval && mode == TK_ADV_TICK)\n\t\tgoto out;\n\n\t/* Do some additional sanity checking */\n\ttimekeeping_check_update(tk, offset);\n\n\t/*\n\t * With NO_HZ we may have to accumulate many cycle_intervals\n\t * (think \"ticks\") worth of time at once. To do this efficiently,\n\t * we calculate the largest doubling multiple of cycle_intervals\n\t * that is smaller than the offset.  We then accumulate that\n\t * chunk in one go, and then try to consume the next smaller\n\t * doubled multiple.\n\t */\n\tshift = ilog2(offset) - ilog2(tk->cycle_interval);\n\tshift = max(0, shift);\n\t/* Bound shift to one less than what overflows tick_length */\n\tmaxshift = (64 - (ilog2(ntp_tick_length())+1)) - 1;\n\tshift = min(shift, maxshift);\n\twhile (offset >= tk->cycle_interval) {\n\t\toffset = logarithmic_accumulation(tk, offset, shift,\n\t\t\t\t\t\t\t&clock_set);\n\t\tif (offset < tk->cycle_interval<<shift)\n\t\t\tshift--;\n\t}\n\n\t/* Adjust the multiplier to correct NTP error */\n\ttimekeeping_adjust(tk, offset);\n\n\t/*\n\t * Finally, make sure that after the rounding\n\t * xtime_nsec isn't larger than NSEC_PER_SEC\n\t */\n\tclock_set |= accumulate_nsecs_to_secs(tk);\n\n\twrite_seqcount_begin(&tk_core.seq);\n\t/*\n\t * Update the real timekeeper.\n\t *\n\t * We could avoid this memcpy by switching pointers, but that\n\t * requires changes to all other timekeeper usage sites as\n\t * well, i.e. move the timekeeper pointer getter into the\n\t * spinlocked/seqcount protected sections. And we trade this\n\t * memcpy under the tk_core.seq against one before we start\n\t * updating.\n\t */\n\ttimekeeping_update(tk, clock_set);\n\tmemcpy(real_tk, tk, sizeof(*tk));\n\t/* The memcpy must come last. Do not put anything here! */\n\twrite_seqcount_end(&tk_core.seq);\nout:\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\treturn !!clock_set;\n}"
  },
  {
    "function_name": "logarithmic_accumulation",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "2091-2123",
    "snippet": "static u64 logarithmic_accumulation(struct timekeeper *tk, u64 offset,\n\t\t\t\t    u32 shift, unsigned int *clock_set)\n{\n\tu64 interval = tk->cycle_interval << shift;\n\tu64 snsec_per_sec;\n\n\t/* If the offset is smaller than a shifted interval, do nothing */\n\tif (offset < interval)\n\t\treturn offset;\n\n\t/* Accumulate one shifted interval */\n\toffset -= interval;\n\ttk->tkr_mono.cycle_last += interval;\n\ttk->tkr_raw.cycle_last  += interval;\n\n\ttk->tkr_mono.xtime_nsec += tk->xtime_interval << shift;\n\t*clock_set |= accumulate_nsecs_to_secs(tk);\n\n\t/* Accumulate raw time */\n\ttk->tkr_raw.xtime_nsec += tk->raw_interval << shift;\n\tsnsec_per_sec = (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\twhile (tk->tkr_raw.xtime_nsec >= snsec_per_sec) {\n\t\ttk->tkr_raw.xtime_nsec -= snsec_per_sec;\n\t\ttk->raw_sec++;\n\t}\n\n\t/* Accumulate error between NTP and clock interval */\n\ttk->ntp_error += tk->ntp_tick << shift;\n\ttk->ntp_error -= (tk->xtime_interval + tk->xtime_remainder) <<\n\t\t\t\t\t\t(tk->ntp_error_shift + shift);\n\n\treturn offset;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "accumulate_nsecs_to_secs",
          "args": [
            "tk"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "accumulate_nsecs_to_secs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "2042-2080",
          "snippet": "static inline unsigned int accumulate_nsecs_to_secs(struct timekeeper *tk)\n{\n\tu64 nsecps = (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\tunsigned int clock_set = 0;\n\n\twhile (tk->tkr_mono.xtime_nsec >= nsecps) {\n\t\tint leap;\n\n\t\ttk->tkr_mono.xtime_nsec -= nsecps;\n\t\ttk->xtime_sec++;\n\n\t\t/*\n\t\t * Skip NTP update if this second was accumulated before,\n\t\t * i.e. xtime_nsec underflowed in timekeeping_adjust()\n\t\t */\n\t\tif (unlikely(tk->skip_second_overflow)) {\n\t\t\ttk->skip_second_overflow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Figure out if its a leap sec and apply if needed */\n\t\tleap = second_overflow(tk->xtime_sec);\n\t\tif (unlikely(leap)) {\n\t\t\tstruct timespec64 ts;\n\n\t\t\ttk->xtime_sec += leap;\n\n\t\t\tts.tv_sec = leap;\n\t\t\tts.tv_nsec = 0;\n\t\t\ttk_set_wall_to_mono(tk,\n\t\t\t\ttimespec64_sub(tk->wall_to_monotonic, ts));\n\n\t\t\t__timekeeping_set_tai_offset(tk, tk->tai_offset - leap);\n\n\t\t\tclock_set = TK_CLOCK_WAS_SET;\n\t\t}\n\t}\n\treturn clock_set;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n\nstatic inline unsigned int accumulate_nsecs_to_secs(struct timekeeper *tk)\n{\n\tu64 nsecps = (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\tunsigned int clock_set = 0;\n\n\twhile (tk->tkr_mono.xtime_nsec >= nsecps) {\n\t\tint leap;\n\n\t\ttk->tkr_mono.xtime_nsec -= nsecps;\n\t\ttk->xtime_sec++;\n\n\t\t/*\n\t\t * Skip NTP update if this second was accumulated before,\n\t\t * i.e. xtime_nsec underflowed in timekeeping_adjust()\n\t\t */\n\t\tif (unlikely(tk->skip_second_overflow)) {\n\t\t\ttk->skip_second_overflow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Figure out if its a leap sec and apply if needed */\n\t\tleap = second_overflow(tk->xtime_sec);\n\t\tif (unlikely(leap)) {\n\t\t\tstruct timespec64 ts;\n\n\t\t\ttk->xtime_sec += leap;\n\n\t\t\tts.tv_sec = leap;\n\t\t\tts.tv_nsec = 0;\n\t\t\ttk_set_wall_to_mono(tk,\n\t\t\t\ttimespec64_sub(tk->wall_to_monotonic, ts));\n\n\t\t\t__timekeeping_set_tai_offset(tk, tk->tai_offset - leap);\n\n\t\t\tclock_set = TK_CLOCK_WAS_SET;\n\t\t}\n\t}\n\treturn clock_set;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic u64 logarithmic_accumulation(struct timekeeper *tk, u64 offset,\n\t\t\t\t    u32 shift, unsigned int *clock_set)\n{\n\tu64 interval = tk->cycle_interval << shift;\n\tu64 snsec_per_sec;\n\n\t/* If the offset is smaller than a shifted interval, do nothing */\n\tif (offset < interval)\n\t\treturn offset;\n\n\t/* Accumulate one shifted interval */\n\toffset -= interval;\n\ttk->tkr_mono.cycle_last += interval;\n\ttk->tkr_raw.cycle_last  += interval;\n\n\ttk->tkr_mono.xtime_nsec += tk->xtime_interval << shift;\n\t*clock_set |= accumulate_nsecs_to_secs(tk);\n\n\t/* Accumulate raw time */\n\ttk->tkr_raw.xtime_nsec += tk->raw_interval << shift;\n\tsnsec_per_sec = (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\twhile (tk->tkr_raw.xtime_nsec >= snsec_per_sec) {\n\t\ttk->tkr_raw.xtime_nsec -= snsec_per_sec;\n\t\ttk->raw_sec++;\n\t}\n\n\t/* Accumulate error between NTP and clock interval */\n\ttk->ntp_error += tk->ntp_tick << shift;\n\ttk->ntp_error -= (tk->xtime_interval + tk->xtime_remainder) <<\n\t\t\t\t\t\t(tk->ntp_error_shift + shift);\n\n\treturn offset;\n}"
  },
  {
    "function_name": "accumulate_nsecs_to_secs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "2042-2080",
    "snippet": "static inline unsigned int accumulate_nsecs_to_secs(struct timekeeper *tk)\n{\n\tu64 nsecps = (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\tunsigned int clock_set = 0;\n\n\twhile (tk->tkr_mono.xtime_nsec >= nsecps) {\n\t\tint leap;\n\n\t\ttk->tkr_mono.xtime_nsec -= nsecps;\n\t\ttk->xtime_sec++;\n\n\t\t/*\n\t\t * Skip NTP update if this second was accumulated before,\n\t\t * i.e. xtime_nsec underflowed in timekeeping_adjust()\n\t\t */\n\t\tif (unlikely(tk->skip_second_overflow)) {\n\t\t\ttk->skip_second_overflow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Figure out if its a leap sec and apply if needed */\n\t\tleap = second_overflow(tk->xtime_sec);\n\t\tif (unlikely(leap)) {\n\t\t\tstruct timespec64 ts;\n\n\t\t\ttk->xtime_sec += leap;\n\n\t\t\tts.tv_sec = leap;\n\t\t\tts.tv_nsec = 0;\n\t\t\ttk_set_wall_to_mono(tk,\n\t\t\t\ttimespec64_sub(tk->wall_to_monotonic, ts));\n\n\t\t\t__timekeeping_set_tai_offset(tk, tk->tai_offset - leap);\n\n\t\t\tclock_set = TK_CLOCK_WAS_SET;\n\t\t}\n\t}\n\treturn clock_set;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__timekeeping_set_tai_offset",
          "args": [
            "tk",
            "tk->tai_offset - leap"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "__timekeeping_set_tai_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1416-1420",
          "snippet": "static void __timekeeping_set_tai_offset(struct timekeeper *tk, s32 tai_offset)\n{\n\ttk->tai_offset = tai_offset;\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tai_offset, 0));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void __timekeeping_set_tai_offset(struct timekeeper *tk, s32 tai_offset)\n{\n\ttk->tai_offset = tai_offset;\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tai_offset, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_set_wall_to_mono",
          "args": [
            "tk",
            "timespec64_sub(tk->wall_to_monotonic, ts)"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "tk_set_wall_to_mono",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "149-164",
          "snippet": "static void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "tk->wall_to_monotonic",
            "ts"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "leap"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "second_overflow",
          "args": [
            "tk->xtime_sec"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "second_overflow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "400-495",
          "snippet": "int second_overflow(time64_t secs)\n{\n\ts64 delta;\n\tint leap = 0;\n\ts32 rem;\n\n\t/*\n\t * Leap second processing. If in leap-insert state at the end of the\n\t * day, the system clock is set back one second; if in leap-delete\n\t * state, the system clock is set ahead one second.\n\t */\n\tswitch (time_state) {\n\tcase TIME_OK:\n\t\tif (time_status & STA_INS) {\n\t\t\ttime_state = TIME_INS;\n\t\t\tdiv_s64_rem(secs, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t} else if (time_status & STA_DEL) {\n\t\t\ttime_state = TIME_DEL;\n\t\t\tdiv_s64_rem(secs + 1, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t}\n\t\tbreak;\n\tcase TIME_INS:\n\t\tif (!(time_status & STA_INS)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = -1;\n\t\t\ttime_state = TIME_OOP;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: inserting leap second 23:59:60 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_DEL:\n\t\tif (!(time_status & STA_DEL)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = 1;\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_WAIT;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: deleting leap second 23:59:59 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_OOP:\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\ttime_state = TIME_WAIT;\n\t\tbreak;\n\tcase TIME_WAIT:\n\t\tif (!(time_status & (STA_INS | STA_DEL)))\n\t\t\ttime_state = TIME_OK;\n\t\tbreak;\n\t}\n\n\n\t/* Bump the maxerror field */\n\ttime_maxerror += MAXFREQ / NSEC_PER_USEC;\n\tif (time_maxerror > NTP_PHASE_LIMIT) {\n\t\ttime_maxerror = NTP_PHASE_LIMIT;\n\t\ttime_status |= STA_UNSYNC;\n\t}\n\n\t/* Compute the phase adjustment for the next second */\n\ttick_length\t = tick_length_base;\n\n\tdelta\t\t = ntp_offset_chunk(time_offset);\n\ttime_offset\t-= delta;\n\ttick_length\t+= delta;\n\n\t/* Check PPS signal */\n\tpps_dec_valid();\n\n\tif (!time_adjust)\n\t\tgoto out;\n\n\tif (time_adjust > MAX_TICKADJ) {\n\t\ttime_adjust -= MAX_TICKADJ;\n\t\ttick_length += MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\tif (time_adjust < -MAX_TICKADJ) {\n\t\ttime_adjust += MAX_TICKADJ;\n\t\ttick_length -= MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\ttick_length += (s64)(time_adjust * NSEC_PER_USEC / NTP_INTERVAL_FREQ)\n\t\t\t\t\t\t\t << NTP_SCALE_SHIFT;\n\ttime_adjust = 0;\n\nout:\n\treturn leap;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define MAX_TICKADJ_SCALED \\\n\t(((MAX_TICKADJ * NSEC_PER_USEC) << NTP_SCALE_SHIFT) / NTP_INTERVAL_FREQ)",
            "#define MAX_TICKADJ\t\t500LL\t\t/* usecs */",
            "#define SECS_PER_DAY\t\t86400"
          ],
          "globals_used": [
            "static u64\t\t\ttick_length;",
            "static u64\t\t\ttick_length_base;",
            "static int\t\t\ttime_state = TIME_OK;",
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static s64\t\t\ttime_offset;",
            "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
            "static long\t\t\ttime_adjust;",
            "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define MAX_TICKADJ_SCALED \\\n\t(((MAX_TICKADJ * NSEC_PER_USEC) << NTP_SCALE_SHIFT) / NTP_INTERVAL_FREQ)\n#define MAX_TICKADJ\t\t500LL\t\t/* usecs */\n#define SECS_PER_DAY\t\t86400\n\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic int\t\t\ttime_state = TIME_OK;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_adjust;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nint second_overflow(time64_t secs)\n{\n\ts64 delta;\n\tint leap = 0;\n\ts32 rem;\n\n\t/*\n\t * Leap second processing. If in leap-insert state at the end of the\n\t * day, the system clock is set back one second; if in leap-delete\n\t * state, the system clock is set ahead one second.\n\t */\n\tswitch (time_state) {\n\tcase TIME_OK:\n\t\tif (time_status & STA_INS) {\n\t\t\ttime_state = TIME_INS;\n\t\t\tdiv_s64_rem(secs, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t} else if (time_status & STA_DEL) {\n\t\t\ttime_state = TIME_DEL;\n\t\t\tdiv_s64_rem(secs + 1, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t}\n\t\tbreak;\n\tcase TIME_INS:\n\t\tif (!(time_status & STA_INS)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = -1;\n\t\t\ttime_state = TIME_OOP;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: inserting leap second 23:59:60 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_DEL:\n\t\tif (!(time_status & STA_DEL)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = 1;\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_WAIT;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: deleting leap second 23:59:59 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_OOP:\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\ttime_state = TIME_WAIT;\n\t\tbreak;\n\tcase TIME_WAIT:\n\t\tif (!(time_status & (STA_INS | STA_DEL)))\n\t\t\ttime_state = TIME_OK;\n\t\tbreak;\n\t}\n\n\n\t/* Bump the maxerror field */\n\ttime_maxerror += MAXFREQ / NSEC_PER_USEC;\n\tif (time_maxerror > NTP_PHASE_LIMIT) {\n\t\ttime_maxerror = NTP_PHASE_LIMIT;\n\t\ttime_status |= STA_UNSYNC;\n\t}\n\n\t/* Compute the phase adjustment for the next second */\n\ttick_length\t = tick_length_base;\n\n\tdelta\t\t = ntp_offset_chunk(time_offset);\n\ttime_offset\t-= delta;\n\ttick_length\t+= delta;\n\n\t/* Check PPS signal */\n\tpps_dec_valid();\n\n\tif (!time_adjust)\n\t\tgoto out;\n\n\tif (time_adjust > MAX_TICKADJ) {\n\t\ttime_adjust -= MAX_TICKADJ;\n\t\ttick_length += MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\tif (time_adjust < -MAX_TICKADJ) {\n\t\ttime_adjust += MAX_TICKADJ;\n\t\ttick_length -= MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\ttick_length += (s64)(time_adjust * NSEC_PER_USEC / NTP_INTERVAL_FREQ)\n\t\t\t\t\t\t\t << NTP_SCALE_SHIFT;\n\ttime_adjust = 0;\n\nout:\n\treturn leap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tk->skip_second_overflow"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n\nstatic inline unsigned int accumulate_nsecs_to_secs(struct timekeeper *tk)\n{\n\tu64 nsecps = (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\tunsigned int clock_set = 0;\n\n\twhile (tk->tkr_mono.xtime_nsec >= nsecps) {\n\t\tint leap;\n\n\t\ttk->tkr_mono.xtime_nsec -= nsecps;\n\t\ttk->xtime_sec++;\n\n\t\t/*\n\t\t * Skip NTP update if this second was accumulated before,\n\t\t * i.e. xtime_nsec underflowed in timekeeping_adjust()\n\t\t */\n\t\tif (unlikely(tk->skip_second_overflow)) {\n\t\t\ttk->skip_second_overflow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Figure out if its a leap sec and apply if needed */\n\t\tleap = second_overflow(tk->xtime_sec);\n\t\tif (unlikely(leap)) {\n\t\t\tstruct timespec64 ts;\n\n\t\t\ttk->xtime_sec += leap;\n\n\t\t\tts.tv_sec = leap;\n\t\t\tts.tv_nsec = 0;\n\t\t\ttk_set_wall_to_mono(tk,\n\t\t\t\ttimespec64_sub(tk->wall_to_monotonic, ts));\n\n\t\t\t__timekeeping_set_tai_offset(tk, tk->tai_offset - leap);\n\n\t\t\tclock_set = TK_CLOCK_WAS_SET;\n\t\t}\n\t}\n\treturn clock_set;\n}"
  },
  {
    "function_name": "timekeeping_adjust",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1981-2033",
    "snippet": "static void timekeeping_adjust(struct timekeeper *tk, s64 offset)\n{\n\tu32 mult;\n\n\t/*\n\t * Determine the multiplier from the current NTP tick length.\n\t * Avoid expensive division when the tick length doesn't change.\n\t */\n\tif (likely(tk->ntp_tick == ntp_tick_length())) {\n\t\tmult = tk->tkr_mono.mult - tk->ntp_err_mult;\n\t} else {\n\t\ttk->ntp_tick = ntp_tick_length();\n\t\tmult = div64_u64((tk->ntp_tick >> tk->ntp_error_shift) -\n\t\t\t\t tk->xtime_remainder, tk->cycle_interval);\n\t}\n\n\t/*\n\t * If the clock is behind the NTP time, increase the multiplier by 1\n\t * to catch up with it. If it's ahead and there was a remainder in the\n\t * tick division, the clock will slow down. Otherwise it will stay\n\t * ahead until the tick length changes to a non-divisible value.\n\t */\n\ttk->ntp_err_mult = tk->ntp_error > 0 ? 1 : 0;\n\tmult += tk->ntp_err_mult;\n\n\ttimekeeping_apply_adjustment(tk, offset, mult - tk->tkr_mono.mult);\n\n\tif (unlikely(tk->tkr_mono.clock->maxadj &&\n\t\t(abs(tk->tkr_mono.mult - tk->tkr_mono.clock->mult)\n\t\t\t> tk->tkr_mono.clock->maxadj))) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\"Adjusting %s more than 11%% (%ld vs %ld)\\n\",\n\t\t\ttk->tkr_mono.clock->name, (long)tk->tkr_mono.mult,\n\t\t\t(long)tk->tkr_mono.clock->mult + tk->tkr_mono.clock->maxadj);\n\t}\n\n\t/*\n\t * It may be possible that when we entered this function, xtime_nsec\n\t * was very small.  Further, if we're slightly speeding the clocksource\n\t * in the code above, its possible the required corrective factor to\n\t * xtime_nsec could cause it to underflow.\n\t *\n\t * Now, since we have already accumulated the second and the NTP\n\t * subsystem has been notified via second_overflow(), we need to skip\n\t * the next update.\n\t */\n\tif (unlikely((s64)tk->tkr_mono.xtime_nsec < 0)) {\n\t\ttk->tkr_mono.xtime_nsec += (u64)NSEC_PER_SEC <<\n\t\t\t\t\t\t\ttk->tkr_mono.shift;\n\t\ttk->xtime_sec--;\n\t\ttk->skip_second_overflow = 1;\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(s64)tk->tkr_mono.xtime_nsec < 0"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING\n\t\t\t\"Adjusting %s more than 11%% (%ld vs %ld)\\n\"",
            "tk->tkr_mono.clock->name",
            "(long)tk->tkr_mono.mult",
            "(long)tk->tkr_mono.clock->mult + tk->tkr_mono.clock->maxadj"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tk->tkr_mono.clock->maxadj &&\n\t\t(abs(tk->tkr_mono.mult - tk->tkr_mono.clock->mult)\n\t\t\t> tk->tkr_mono.clock->maxadj)"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "tk->tkr_mono.mult - tk->tkr_mono.clock->mult"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "608-615",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_apply_adjustment",
          "args": [
            "tk",
            "offset",
            "mult - tk->tkr_mono.mult"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_apply_adjustment",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1903-1975",
          "snippet": "static __always_inline void timekeeping_apply_adjustment(struct timekeeper *tk,\n\t\t\t\t\t\t\t s64 offset,\n\t\t\t\t\t\t\t s32 mult_adj)\n{\n\ts64 interval = tk->cycle_interval;\n\n\tif (mult_adj == 0) {\n\t\treturn;\n\t} else if (mult_adj == -1) {\n\t\tinterval = -interval;\n\t\toffset = -offset;\n\t} else if (mult_adj != 1) {\n\t\tinterval *= mult_adj;\n\t\toffset *= mult_adj;\n\t}\n\n\t/*\n\t * So the following can be confusing.\n\t *\n\t * To keep things simple, lets assume mult_adj == 1 for now.\n\t *\n\t * When mult_adj != 1, remember that the interval and offset values\n\t * have been appropriately scaled so the math is the same.\n\t *\n\t * The basic idea here is that we're increasing the multiplier\n\t * by one, this causes the xtime_interval to be incremented by\n\t * one cycle_interval. This is because:\n\t *\txtime_interval = cycle_interval * mult\n\t * So if mult is being incremented by one:\n\t *\txtime_interval = cycle_interval * (mult + 1)\n\t * Its the same as:\n\t *\txtime_interval = (cycle_interval * mult) + cycle_interval\n\t * Which can be shortened to:\n\t *\txtime_interval += cycle_interval\n\t *\n\t * So offset stores the non-accumulated cycles. Thus the current\n\t * time (in shifted nanoseconds) is:\n\t *\tnow = (offset * adj) + xtime_nsec\n\t * Now, even though we're adjusting the clock frequency, we have\n\t * to keep time consistent. In other words, we can't jump back\n\t * in time, and we also want to avoid jumping forward in time.\n\t *\n\t * So given the same offset value, we need the time to be the same\n\t * both before and after the freq adjustment.\n\t *\tnow = (offset * adj_1) + xtime_nsec_1\n\t *\tnow = (offset * adj_2) + xtime_nsec_2\n\t * So:\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * adj_2) + xtime_nsec_2\n\t * And we know:\n\t *\tadj_2 = adj_1 + 1\n\t * So:\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * (adj_1+1)) + xtime_nsec_2\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * adj_1) + offset + xtime_nsec_2\n\t * Canceling the sides:\n\t *\txtime_nsec_1 = offset + xtime_nsec_2\n\t * Which gives us:\n\t *\txtime_nsec_2 = xtime_nsec_1 - offset\n\t * Which simplifies to:\n\t *\txtime_nsec -= offset\n\t */\n\tif ((mult_adj > 0) && (tk->tkr_mono.mult + mult_adj < mult_adj)) {\n\t\t/* NTP adjustment caused clocksource mult overflow */\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\ttk->tkr_mono.mult += mult_adj;\n\ttk->xtime_interval += interval;\n\ttk->tkr_mono.xtime_nsec -= offset;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic __always_inline void timekeeping_apply_adjustment(struct timekeeper *tk,\n\t\t\t\t\t\t\t s64 offset,\n\t\t\t\t\t\t\t s32 mult_adj)\n{\n\ts64 interval = tk->cycle_interval;\n\n\tif (mult_adj == 0) {\n\t\treturn;\n\t} else if (mult_adj == -1) {\n\t\tinterval = -interval;\n\t\toffset = -offset;\n\t} else if (mult_adj != 1) {\n\t\tinterval *= mult_adj;\n\t\toffset *= mult_adj;\n\t}\n\n\t/*\n\t * So the following can be confusing.\n\t *\n\t * To keep things simple, lets assume mult_adj == 1 for now.\n\t *\n\t * When mult_adj != 1, remember that the interval and offset values\n\t * have been appropriately scaled so the math is the same.\n\t *\n\t * The basic idea here is that we're increasing the multiplier\n\t * by one, this causes the xtime_interval to be incremented by\n\t * one cycle_interval. This is because:\n\t *\txtime_interval = cycle_interval * mult\n\t * So if mult is being incremented by one:\n\t *\txtime_interval = cycle_interval * (mult + 1)\n\t * Its the same as:\n\t *\txtime_interval = (cycle_interval * mult) + cycle_interval\n\t * Which can be shortened to:\n\t *\txtime_interval += cycle_interval\n\t *\n\t * So offset stores the non-accumulated cycles. Thus the current\n\t * time (in shifted nanoseconds) is:\n\t *\tnow = (offset * adj) + xtime_nsec\n\t * Now, even though we're adjusting the clock frequency, we have\n\t * to keep time consistent. In other words, we can't jump back\n\t * in time, and we also want to avoid jumping forward in time.\n\t *\n\t * So given the same offset value, we need the time to be the same\n\t * both before and after the freq adjustment.\n\t *\tnow = (offset * adj_1) + xtime_nsec_1\n\t *\tnow = (offset * adj_2) + xtime_nsec_2\n\t * So:\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * adj_2) + xtime_nsec_2\n\t * And we know:\n\t *\tadj_2 = adj_1 + 1\n\t * So:\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * (adj_1+1)) + xtime_nsec_2\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * adj_1) + offset + xtime_nsec_2\n\t * Canceling the sides:\n\t *\txtime_nsec_1 = offset + xtime_nsec_2\n\t * Which gives us:\n\t *\txtime_nsec_2 = xtime_nsec_1 - offset\n\t * Which simplifies to:\n\t *\txtime_nsec -= offset\n\t */\n\tif ((mult_adj > 0) && (tk->tkr_mono.mult + mult_adj < mult_adj)) {\n\t\t/* NTP adjustment caused clocksource mult overflow */\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\ttk->tkr_mono.mult += mult_adj;\n\ttk->xtime_interval += interval;\n\ttk->tkr_mono.xtime_nsec -= offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "(tk->ntp_tick >> tk->ntp_error_shift) -\n\t\t\t\t tk->xtime_remainder",
            "tk->cycle_interval"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntp_tick_length",
          "args": [],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_tick_length",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "369-372",
          "snippet": "u64 ntp_tick_length(void)\n{\n\treturn tick_length;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64\t\t\ttick_length;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic u64\t\t\ttick_length;\n\nu64 ntp_tick_length(void)\n{\n\treturn tick_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "tk->ntp_tick == ntp_tick_length()"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void timekeeping_adjust(struct timekeeper *tk, s64 offset)\n{\n\tu32 mult;\n\n\t/*\n\t * Determine the multiplier from the current NTP tick length.\n\t * Avoid expensive division when the tick length doesn't change.\n\t */\n\tif (likely(tk->ntp_tick == ntp_tick_length())) {\n\t\tmult = tk->tkr_mono.mult - tk->ntp_err_mult;\n\t} else {\n\t\ttk->ntp_tick = ntp_tick_length();\n\t\tmult = div64_u64((tk->ntp_tick >> tk->ntp_error_shift) -\n\t\t\t\t tk->xtime_remainder, tk->cycle_interval);\n\t}\n\n\t/*\n\t * If the clock is behind the NTP time, increase the multiplier by 1\n\t * to catch up with it. If it's ahead and there was a remainder in the\n\t * tick division, the clock will slow down. Otherwise it will stay\n\t * ahead until the tick length changes to a non-divisible value.\n\t */\n\ttk->ntp_err_mult = tk->ntp_error > 0 ? 1 : 0;\n\tmult += tk->ntp_err_mult;\n\n\ttimekeeping_apply_adjustment(tk, offset, mult - tk->tkr_mono.mult);\n\n\tif (unlikely(tk->tkr_mono.clock->maxadj &&\n\t\t(abs(tk->tkr_mono.mult - tk->tkr_mono.clock->mult)\n\t\t\t> tk->tkr_mono.clock->maxadj))) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\"Adjusting %s more than 11%% (%ld vs %ld)\\n\",\n\t\t\ttk->tkr_mono.clock->name, (long)tk->tkr_mono.mult,\n\t\t\t(long)tk->tkr_mono.clock->mult + tk->tkr_mono.clock->maxadj);\n\t}\n\n\t/*\n\t * It may be possible that when we entered this function, xtime_nsec\n\t * was very small.  Further, if we're slightly speeding the clocksource\n\t * in the code above, its possible the required corrective factor to\n\t * xtime_nsec could cause it to underflow.\n\t *\n\t * Now, since we have already accumulated the second and the NTP\n\t * subsystem has been notified via second_overflow(), we need to skip\n\t * the next update.\n\t */\n\tif (unlikely((s64)tk->tkr_mono.xtime_nsec < 0)) {\n\t\ttk->tkr_mono.xtime_nsec += (u64)NSEC_PER_SEC <<\n\t\t\t\t\t\t\ttk->tkr_mono.shift;\n\t\ttk->xtime_sec--;\n\t\ttk->skip_second_overflow = 1;\n\t}\n}"
  },
  {
    "function_name": "timekeeping_apply_adjustment",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1903-1975",
    "snippet": "static __always_inline void timekeeping_apply_adjustment(struct timekeeper *tk,\n\t\t\t\t\t\t\t s64 offset,\n\t\t\t\t\t\t\t s32 mult_adj)\n{\n\ts64 interval = tk->cycle_interval;\n\n\tif (mult_adj == 0) {\n\t\treturn;\n\t} else if (mult_adj == -1) {\n\t\tinterval = -interval;\n\t\toffset = -offset;\n\t} else if (mult_adj != 1) {\n\t\tinterval *= mult_adj;\n\t\toffset *= mult_adj;\n\t}\n\n\t/*\n\t * So the following can be confusing.\n\t *\n\t * To keep things simple, lets assume mult_adj == 1 for now.\n\t *\n\t * When mult_adj != 1, remember that the interval and offset values\n\t * have been appropriately scaled so the math is the same.\n\t *\n\t * The basic idea here is that we're increasing the multiplier\n\t * by one, this causes the xtime_interval to be incremented by\n\t * one cycle_interval. This is because:\n\t *\txtime_interval = cycle_interval * mult\n\t * So if mult is being incremented by one:\n\t *\txtime_interval = cycle_interval * (mult + 1)\n\t * Its the same as:\n\t *\txtime_interval = (cycle_interval * mult) + cycle_interval\n\t * Which can be shortened to:\n\t *\txtime_interval += cycle_interval\n\t *\n\t * So offset stores the non-accumulated cycles. Thus the current\n\t * time (in shifted nanoseconds) is:\n\t *\tnow = (offset * adj) + xtime_nsec\n\t * Now, even though we're adjusting the clock frequency, we have\n\t * to keep time consistent. In other words, we can't jump back\n\t * in time, and we also want to avoid jumping forward in time.\n\t *\n\t * So given the same offset value, we need the time to be the same\n\t * both before and after the freq adjustment.\n\t *\tnow = (offset * adj_1) + xtime_nsec_1\n\t *\tnow = (offset * adj_2) + xtime_nsec_2\n\t * So:\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * adj_2) + xtime_nsec_2\n\t * And we know:\n\t *\tadj_2 = adj_1 + 1\n\t * So:\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * (adj_1+1)) + xtime_nsec_2\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * adj_1) + offset + xtime_nsec_2\n\t * Canceling the sides:\n\t *\txtime_nsec_1 = offset + xtime_nsec_2\n\t * Which gives us:\n\t *\txtime_nsec_2 = xtime_nsec_1 - offset\n\t * Which simplifies to:\n\t *\txtime_nsec -= offset\n\t */\n\tif ((mult_adj > 0) && (tk->tkr_mono.mult + mult_adj < mult_adj)) {\n\t\t/* NTP adjustment caused clocksource mult overflow */\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\ttk->tkr_mono.mult += mult_adj;\n\ttk->xtime_interval += interval;\n\ttk->tkr_mono.xtime_nsec -= offset;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic __always_inline void timekeeping_apply_adjustment(struct timekeeper *tk,\n\t\t\t\t\t\t\t s64 offset,\n\t\t\t\t\t\t\t s32 mult_adj)\n{\n\ts64 interval = tk->cycle_interval;\n\n\tif (mult_adj == 0) {\n\t\treturn;\n\t} else if (mult_adj == -1) {\n\t\tinterval = -interval;\n\t\toffset = -offset;\n\t} else if (mult_adj != 1) {\n\t\tinterval *= mult_adj;\n\t\toffset *= mult_adj;\n\t}\n\n\t/*\n\t * So the following can be confusing.\n\t *\n\t * To keep things simple, lets assume mult_adj == 1 for now.\n\t *\n\t * When mult_adj != 1, remember that the interval and offset values\n\t * have been appropriately scaled so the math is the same.\n\t *\n\t * The basic idea here is that we're increasing the multiplier\n\t * by one, this causes the xtime_interval to be incremented by\n\t * one cycle_interval. This is because:\n\t *\txtime_interval = cycle_interval * mult\n\t * So if mult is being incremented by one:\n\t *\txtime_interval = cycle_interval * (mult + 1)\n\t * Its the same as:\n\t *\txtime_interval = (cycle_interval * mult) + cycle_interval\n\t * Which can be shortened to:\n\t *\txtime_interval += cycle_interval\n\t *\n\t * So offset stores the non-accumulated cycles. Thus the current\n\t * time (in shifted nanoseconds) is:\n\t *\tnow = (offset * adj) + xtime_nsec\n\t * Now, even though we're adjusting the clock frequency, we have\n\t * to keep time consistent. In other words, we can't jump back\n\t * in time, and we also want to avoid jumping forward in time.\n\t *\n\t * So given the same offset value, we need the time to be the same\n\t * both before and after the freq adjustment.\n\t *\tnow = (offset * adj_1) + xtime_nsec_1\n\t *\tnow = (offset * adj_2) + xtime_nsec_2\n\t * So:\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * adj_2) + xtime_nsec_2\n\t * And we know:\n\t *\tadj_2 = adj_1 + 1\n\t * So:\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * (adj_1+1)) + xtime_nsec_2\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * adj_1) + offset + xtime_nsec_2\n\t * Canceling the sides:\n\t *\txtime_nsec_1 = offset + xtime_nsec_2\n\t * Which gives us:\n\t *\txtime_nsec_2 = xtime_nsec_1 - offset\n\t * Which simplifies to:\n\t *\txtime_nsec -= offset\n\t */\n\tif ((mult_adj > 0) && (tk->tkr_mono.mult + mult_adj < mult_adj)) {\n\t\t/* NTP adjustment caused clocksource mult overflow */\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\ttk->tkr_mono.mult += mult_adj;\n\ttk->xtime_interval += interval;\n\ttk->tkr_mono.xtime_nsec -= offset;\n}"
  },
  {
    "function_name": "timekeeping_init_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1893-1897",
    "snippet": "static int __init timekeeping_init_ops(void)\n{\n\tregister_syscore_ops(&timekeeping_syscore_ops);\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct syscore_ops timekeeping_syscore_ops = {\n\t.resume\t\t= timekeeping_resume,\n\t.suspend\t= timekeeping_suspend,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_syscore_ops",
          "args": [
            "&timekeeping_syscore_ops"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic struct syscore_ops timekeeping_syscore_ops = {\n\t.resume\t\t= timekeeping_resume,\n\t.suspend\t= timekeeping_suspend,\n};\n\nstatic int __init timekeeping_init_ops(void)\n{\n\tregister_syscore_ops(&timekeeping_syscore_ops);\n\treturn 0;\n}"
  },
  {
    "function_name": "timekeeping_suspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1818-1885",
    "snippet": "int timekeeping_suspend(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64\t\tdelta, delta_delta;\n\tstatic struct timespec64\told_delta;\n\tstruct clocksource *curr_clock;\n\tu64 cycle_now;\n\n\tread_persistent_clock64(&timekeeping_suspend_time);\n\n\t/*\n\t * On some systems the persistent_clock can not be detected at\n\t * timekeeping_init by its return value, so if we see a valid\n\t * value returned, update the persistent_clock_exists flag.\n\t */\n\tif (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)\n\t\tpersistent_clock_exists = true;\n\n\tsuspend_timing_needed = true;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\ttimekeeping_forward_now(tk);\n\ttimekeeping_suspended = 1;\n\n\t/*\n\t * Since we've called forward_now, cycle_last stores the value\n\t * just read from the current clocksource. Save this to potentially\n\t * use in suspend timing.\n\t */\n\tcurr_clock = tk->tkr_mono.clock;\n\tcycle_now = tk->tkr_mono.cycle_last;\n\tclocksource_start_suspend_timing(curr_clock, cycle_now);\n\n\tif (persistent_clock_exists) {\n\t\t/*\n\t\t * To avoid drift caused by repeated suspend/resumes,\n\t\t * which each can add ~1 second drift error,\n\t\t * try to compensate so the difference in system time\n\t\t * and persistent_clock time stays close to constant.\n\t\t */\n\t\tdelta = timespec64_sub(tk_xtime(tk), timekeeping_suspend_time);\n\t\tdelta_delta = timespec64_sub(delta, old_delta);\n\t\tif (abs(delta_delta.tv_sec) >= 2) {\n\t\t\t/*\n\t\t\t * if delta_delta is too large, assume time correction\n\t\t\t * has occurred and set old_delta to the current delta.\n\t\t\t */\n\t\t\told_delta = delta;\n\t\t} else {\n\t\t\t/* Otherwise try to adjust old_system to compensate */\n\t\t\ttimekeeping_suspend_time =\n\t\t\t\ttimespec64_add(timekeeping_suspend_time, delta_delta);\n\t\t}\n\t}\n\n\ttimekeeping_update(tk, TK_MIRROR);\n\thalt_fast_timekeeper(tk);\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\ttick_suspend();\n\tclocksource_suspend();\n\tclockevents_suspend();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_MIRROR\t\t(1 << 1)"
    ],
    "globals_used": [
      "static bool suspend_timing_needed;",
      "static bool persistent_clock_exists;",
      "static struct timespec64 timekeeping_suspend_time;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_suspend",
          "args": [],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_suspend",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "590-597",
          "snippet": "void clockevents_suspend(void)\n{\n\tstruct clock_event_device *dev;\n\n\tlist_for_each_entry_reverse(dev, &clockevent_devices, list)\n\t\tif (dev->suspend && !clockevent_state_detached(dev))\n\t\t\tdev->suspend(dev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevent_devices);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\n\nvoid clockevents_suspend(void)\n{\n\tstruct clock_event_device *dev;\n\n\tlist_for_each_entry_reverse(dev, &clockevent_devices, list)\n\t\tif (dev->suspend && !clockevent_state_detached(dev))\n\t\t\tdev->suspend(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_suspend",
          "args": [],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_suspend",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "813-820",
          "snippet": "void clocksource_suspend(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry_reverse(cs, &clocksource_list, list)\n\t\tif (cs->suspend)\n\t\t\tcs->suspend(cs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clocksource_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\n\nvoid clocksource_suspend(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry_reverse(cs, &clocksource_list, list)\n\t\tif (cs->suspend)\n\t\t\tcs->suspend(cs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_suspend",
          "args": [],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "tick_suspend_broadcast",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "548-560",
          "snippet": "void tick_suspend_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\tclockevents_shutdown(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_suspend_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\tclockevents_shutdown(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "halt_fast_timekeeper",
          "args": [
            "tk"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "halt_fast_timekeeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "632-647",
          "snippet": "static void halt_fast_timekeeper(const struct timekeeper *tk)\n{\n\tstatic struct tk_read_base tkr_dummy;\n\tconst struct tk_read_base *tkr = &tk->tkr_mono;\n\n\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));\n\tcycles_at_suspend = tk_clock_read(tkr);\n\ttkr_dummy.clock = &dummy_clock;\n\ttkr_dummy.base_real = tkr->base + tk->offs_real;\n\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_mono);\n\n\ttkr = &tk->tkr_raw;\n\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));\n\ttkr_dummy.clock = &dummy_clock;\n\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_raw);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 cycles_at_suspend;",
            "static struct clocksource dummy_clock = {\n\t.read = dummy_clock_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic u64 cycles_at_suspend;\nstatic struct clocksource dummy_clock = {\n\t.read = dummy_clock_read,\n};\n\nstatic void halt_fast_timekeeper(const struct timekeeper *tk)\n{\n\tstatic struct tk_read_base tkr_dummy;\n\tconst struct tk_read_base *tkr = &tk->tkr_mono;\n\n\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));\n\tcycles_at_suspend = tk_clock_read(tkr);\n\ttkr_dummy.clock = &dummy_clock;\n\ttkr_dummy.base_real = tkr->base + tk->offs_real;\n\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_mono);\n\n\ttkr = &tk->tkr_raw;\n\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));\n\ttkr_dummy.clock = &dummy_clock;\n\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_raw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "TK_MIRROR"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "738-765",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_add",
          "args": [
            "timekeeping_suspend_time",
            "delta_delta"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "timespec64_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "765-779",
          "snippet": "struct timespec64 timespec64_add_safe(const struct timespec64 lhs,\n\t\t\t\tconst struct timespec64 rhs)\n{\n\tstruct timespec64 res;\n\n\tset_normalized_timespec64(&res, (timeu64_t) lhs.tv_sec + rhs.tv_sec,\n\t\t\tlhs.tv_nsec + rhs.tv_nsec);\n\n\tif (unlikely(res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)) {\n\t\tres.tv_sec = TIME64_MAX;\n\t\tres.tv_nsec = 0;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 timespec64_add_safe(const struct timespec64 lhs,\n\t\t\t\tconst struct timespec64 rhs)\n{\n\tstruct timespec64 res;\n\n\tset_normalized_timespec64(&res, (timeu64_t) lhs.tv_sec + rhs.tv_sec,\n\t\t\tlhs.tv_nsec + rhs.tv_nsec);\n\n\tif (unlikely(res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)) {\n\t\tres.tv_sec = TIME64_MAX;\n\t\tres.tv_nsec = 0;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "delta_delta.tv_sec"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "608-615",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "delta",
            "old_delta"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "tk_xtime(tk)",
            "timekeeping_suspend_time"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_xtime",
          "args": [
            "tk"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "tk_xtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "127-134",
          "snippet": "static inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_start_suspend_timing",
          "args": [
            "curr_clock",
            "cycle_now"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_start_suspend_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "738-760",
          "snippet": "void clocksource_start_suspend_timing(struct clocksource *cs, u64 start_cycles)\n{\n\tif (!suspend_clocksource)\n\t\treturn;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value as suspend_start to avoid same reading\n\t * from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs)) {\n\t\tsuspend_start = start_cycles;\n\t\treturn;\n\t}\n\n\tif (suspend_clocksource->enable &&\n\t    suspend_clocksource->enable(suspend_clocksource)) {\n\t\tpr_warn_once(\"Failed to enable the non-suspend-able clocksource.\\n\");\n\t\treturn;\n\t}\n\n\tsuspend_start = suspend_clocksource->read(suspend_clocksource);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static u64 suspend_start;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nvoid clocksource_start_suspend_timing(struct clocksource *cs, u64 start_cycles)\n{\n\tif (!suspend_clocksource)\n\t\treturn;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value as suspend_start to avoid same reading\n\t * from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs)) {\n\t\tsuspend_start = start_cycles;\n\t\treturn;\n\t}\n\n\tif (suspend_clocksource->enable &&\n\t    suspend_clocksource->enable(suspend_clocksource)) {\n\t\tpr_warn_once(\"Failed to enable the non-suspend-able clocksource.\\n\");\n\t\treturn;\n\t}\n\n\tsuspend_start = suspend_clocksource->read(suspend_clocksource);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_forward_now",
          "args": [
            "tk"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_forward_now",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "775-788",
          "snippet": "static void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\ttk_normalize_xtime(tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\ttk_normalize_xtime(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_persistent_clock64",
          "args": [
            "&timekeeping_suspend_time"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "read_persistent_clock64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1563-1567",
          "snippet": "void __weak read_persistent_clock64(struct timespec64 *ts)\n{\n\tts->tv_sec = 0;\n\tts->tv_nsec = 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid __weak;\n\nvoid __weak read_persistent_clock64(struct timespec64 *ts)\n{\n\tts->tv_sec = 0;\n\tts->tv_nsec = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_MIRROR\t\t(1 << 1)\n\nstatic bool suspend_timing_needed;\nstatic bool persistent_clock_exists;\nstatic struct timespec64 timekeeping_suspend_time;\n\nint timekeeping_suspend(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64\t\tdelta, delta_delta;\n\tstatic struct timespec64\told_delta;\n\tstruct clocksource *curr_clock;\n\tu64 cycle_now;\n\n\tread_persistent_clock64(&timekeeping_suspend_time);\n\n\t/*\n\t * On some systems the persistent_clock can not be detected at\n\t * timekeeping_init by its return value, so if we see a valid\n\t * value returned, update the persistent_clock_exists flag.\n\t */\n\tif (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)\n\t\tpersistent_clock_exists = true;\n\n\tsuspend_timing_needed = true;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\ttimekeeping_forward_now(tk);\n\ttimekeeping_suspended = 1;\n\n\t/*\n\t * Since we've called forward_now, cycle_last stores the value\n\t * just read from the current clocksource. Save this to potentially\n\t * use in suspend timing.\n\t */\n\tcurr_clock = tk->tkr_mono.clock;\n\tcycle_now = tk->tkr_mono.cycle_last;\n\tclocksource_start_suspend_timing(curr_clock, cycle_now);\n\n\tif (persistent_clock_exists) {\n\t\t/*\n\t\t * To avoid drift caused by repeated suspend/resumes,\n\t\t * which each can add ~1 second drift error,\n\t\t * try to compensate so the difference in system time\n\t\t * and persistent_clock time stays close to constant.\n\t\t */\n\t\tdelta = timespec64_sub(tk_xtime(tk), timekeeping_suspend_time);\n\t\tdelta_delta = timespec64_sub(delta, old_delta);\n\t\tif (abs(delta_delta.tv_sec) >= 2) {\n\t\t\t/*\n\t\t\t * if delta_delta is too large, assume time correction\n\t\t\t * has occurred and set old_delta to the current delta.\n\t\t\t */\n\t\t\told_delta = delta;\n\t\t} else {\n\t\t\t/* Otherwise try to adjust old_system to compensate */\n\t\t\ttimekeeping_suspend_time =\n\t\t\t\ttimespec64_add(timekeeping_suspend_time, delta_delta);\n\t\t}\n\t}\n\n\ttimekeeping_update(tk, TK_MIRROR);\n\thalt_fast_timekeeper(tk);\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\ttick_suspend();\n\tclocksource_suspend();\n\tclockevents_suspend();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "timekeeping_resume",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1756-1816",
    "snippet": "void timekeeping_resume(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct clocksource *clock = tk->tkr_mono.clock;\n\tunsigned long flags;\n\tstruct timespec64 ts_new, ts_delta;\n\tu64 cycle_now, nsec;\n\tbool inject_sleeptime = false;\n\n\tread_persistent_clock64(&ts_new);\n\n\tclockevents_resume();\n\tclocksource_resume();\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\t/*\n\t * After system resumes, we need to calculate the suspended time and\n\t * compensate it for the OS time. There are 3 sources that could be\n\t * used: Nonstop clocksource during suspend, persistent clock and rtc\n\t * device.\n\t *\n\t * One specific platform may have 1 or 2 or all of them, and the\n\t * preference will be:\n\t *\tsuspend-nonstop clocksource -> persistent clock -> rtc\n\t * The less preferred source will only be tried if there is no better\n\t * usable source. The rtc part is handled separately in rtc core code.\n\t */\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tnsec = clocksource_stop_suspend_timing(clock, cycle_now);\n\tif (nsec > 0) {\n\t\tts_delta = ns_to_timespec64(nsec);\n\t\tinject_sleeptime = true;\n\t} else if (timespec64_compare(&ts_new, &timekeeping_suspend_time) > 0) {\n\t\tts_delta = timespec64_sub(ts_new, timekeeping_suspend_time);\n\t\tinject_sleeptime = true;\n\t}\n\n\tif (inject_sleeptime) {\n\t\tsuspend_timing_needed = false;\n\t\t__timekeeping_inject_sleeptime(tk, &ts_delta);\n\t}\n\n\t/* Re-base the last cycle value */\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->ntp_error = 0;\n\ttimekeeping_suspended = 0;\n\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\ttouch_softlockup_watchdog();\n\n\t/* Resume the clockevent device(s) and hrtimers */\n\ttick_resume();\n\t/* Notify timerfd as resume is equivalent to clock_was_set() */\n\ttimerfd_resume();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)",
      "#define TK_MIRROR\t\t(1 << 1)"
    ],
    "globals_used": [
      "static bool suspend_timing_needed;",
      "static struct timespec64 timekeeping_suspend_time;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timerfd_resume",
          "args": [],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_resume",
          "args": [],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "tick_resume_oneshot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-oneshot.c",
          "lines": "50-56",
          "snippet": "void tick_resume_oneshot(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\tclockevents_program_event(dev, ktime_get(), true);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_resume_oneshot(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\tclockevents_program_event(dev, ktime_get(), true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog",
          "args": [],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "299-303",
          "snippet": "void touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX\n\nvoid touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "TK_MIRROR | TK_CLOCK_WAS_SET"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "738-765",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__timekeeping_inject_sleeptime",
          "args": [
            "tk",
            "&ts_delta"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "__timekeeping_inject_sleeptime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1667-1680",
          "snippet": "static void __timekeeping_inject_sleeptime(struct timekeeper *tk,\n\t\t\t\t\t   const struct timespec64 *delta)\n{\n\tif (!timespec64_valid_strict(delta)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"\n\t\t\t\t\"sleep delta value!\\n\");\n\t\treturn;\n\t}\n\ttk_xtime_add(tk, delta);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *delta));\n\ttk_update_sleep_time(tk, timespec64_to_ktime(*delta));\n\ttk_debug_account_sleep_time(delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void __timekeeping_inject_sleeptime(struct timekeeper *tk,\n\t\t\t\t\t   const struct timespec64 *delta)\n{\n\tif (!timespec64_valid_strict(delta)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"\n\t\t\t\t\"sleep delta value!\\n\");\n\t\treturn;\n\t}\n\ttk_xtime_add(tk, delta);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *delta));\n\ttk_update_sleep_time(tk, timespec64_to_ktime(*delta));\n\ttk_debug_account_sleep_time(delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "ts_new",
            "timekeeping_suspend_time"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_compare",
          "args": [
            "&ts_new",
            "&timekeeping_suspend_time"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_timespec64",
          "args": [
            "nsec"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timespec64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "506-525",
          "snippet": "struct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_stop_suspend_timing",
          "args": [
            "clock",
            "cycle_now"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_stop_suspend_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "776-808",
          "snippet": "u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static u64 suspend_start;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nu64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "189-194",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_resume",
          "args": [],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_resume",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "825-834",
          "snippet": "void clocksource_resume(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &clocksource_list, list)\n\t\tif (cs->resume)\n\t\t\tcs->resume(cs);\n\n\tclocksource_resume_watchdog();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clocksource_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\n\nvoid clocksource_resume(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &clocksource_list, list)\n\t\tif (cs->resume)\n\t\t\tcs->resume(cs);\n\n\tclocksource_resume_watchdog();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_resume",
          "args": [],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_resume",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "602-609",
          "snippet": "void clockevents_resume(void)\n{\n\tstruct clock_event_device *dev;\n\n\tlist_for_each_entry(dev, &clockevent_devices, list)\n\t\tif (dev->resume && !clockevent_state_detached(dev))\n\t\t\tdev->resume(dev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevent_devices);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\n\nvoid clockevents_resume(void)\n{\n\tstruct clock_event_device *dev;\n\n\tlist_for_each_entry(dev, &clockevent_devices, list)\n\t\tif (dev->resume && !clockevent_state_detached(dev))\n\t\t\tdev->resume(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_persistent_clock64",
          "args": [
            "&ts_new"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "read_persistent_clock64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1563-1567",
          "snippet": "void __weak read_persistent_clock64(struct timespec64 *ts)\n{\n\tts->tv_sec = 0;\n\tts->tv_nsec = 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid __weak;\n\nvoid __weak read_persistent_clock64(struct timespec64 *ts)\n{\n\tts->tv_sec = 0;\n\tts->tv_nsec = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n\nstatic bool suspend_timing_needed;\nstatic struct timespec64 timekeeping_suspend_time;\n\nvoid timekeeping_resume(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct clocksource *clock = tk->tkr_mono.clock;\n\tunsigned long flags;\n\tstruct timespec64 ts_new, ts_delta;\n\tu64 cycle_now, nsec;\n\tbool inject_sleeptime = false;\n\n\tread_persistent_clock64(&ts_new);\n\n\tclockevents_resume();\n\tclocksource_resume();\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\t/*\n\t * After system resumes, we need to calculate the suspended time and\n\t * compensate it for the OS time. There are 3 sources that could be\n\t * used: Nonstop clocksource during suspend, persistent clock and rtc\n\t * device.\n\t *\n\t * One specific platform may have 1 or 2 or all of them, and the\n\t * preference will be:\n\t *\tsuspend-nonstop clocksource -> persistent clock -> rtc\n\t * The less preferred source will only be tried if there is no better\n\t * usable source. The rtc part is handled separately in rtc core code.\n\t */\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tnsec = clocksource_stop_suspend_timing(clock, cycle_now);\n\tif (nsec > 0) {\n\t\tts_delta = ns_to_timespec64(nsec);\n\t\tinject_sleeptime = true;\n\t} else if (timespec64_compare(&ts_new, &timekeeping_suspend_time) > 0) {\n\t\tts_delta = timespec64_sub(ts_new, timekeeping_suspend_time);\n\t\tinject_sleeptime = true;\n\t}\n\n\tif (inject_sleeptime) {\n\t\tsuspend_timing_needed = false;\n\t\t__timekeeping_inject_sleeptime(tk, &ts_delta);\n\t}\n\n\t/* Re-base the last cycle value */\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->ntp_error = 0;\n\ttimekeeping_suspended = 0;\n\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\ttouch_softlockup_watchdog();\n\n\t/* Resume the clockevent device(s) and hrtimers */\n\ttick_resume();\n\t/* Notify timerfd as resume is equivalent to clock_was_set() */\n\ttimerfd_resume();\n}"
  },
  {
    "function_name": "timekeeping_inject_sleeptime64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1729-1750",
    "snippet": "void timekeeping_inject_sleeptime64(const struct timespec64 *delta)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\tsuspend_timing_needed = false;\n\n\ttimekeeping_forward_now(tk);\n\n\t__timekeeping_inject_sleeptime(tk, delta);\n\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* Signal hrtimers about time change */\n\tclock_was_set(CLOCK_SET_WALL | CLOCK_SET_BOOT);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)",
      "#define TK_MIRROR\t\t(1 << 1)",
      "#define TK_CLEAR_NTP\t\t(1 << 0)"
    ],
    "globals_used": [
      "static bool suspend_timing_needed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clock_was_set",
          "args": [
            "CLOCK_SET_WALL | CLOCK_SET_BOOT"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "clock_was_set_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "983-986",
          "snippet": "static void clock_was_set_work(struct work_struct *work)\n{\n\tclock_was_set(CLOCK_SET_WALL);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WORK(hrtimer_work, clock_was_set_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic DECLARE_WORK(hrtimer_work, clock_was_set_work);\n\nstatic void clock_was_set_work(struct work_struct *work)\n{\n\tclock_was_set(CLOCK_SET_WALL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "738-765",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__timekeeping_inject_sleeptime",
          "args": [
            "tk",
            "delta"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "__timekeeping_inject_sleeptime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1667-1680",
          "snippet": "static void __timekeeping_inject_sleeptime(struct timekeeper *tk,\n\t\t\t\t\t   const struct timespec64 *delta)\n{\n\tif (!timespec64_valid_strict(delta)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"\n\t\t\t\t\"sleep delta value!\\n\");\n\t\treturn;\n\t}\n\ttk_xtime_add(tk, delta);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *delta));\n\ttk_update_sleep_time(tk, timespec64_to_ktime(*delta));\n\ttk_debug_account_sleep_time(delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void __timekeeping_inject_sleeptime(struct timekeeper *tk,\n\t\t\t\t\t   const struct timespec64 *delta)\n{\n\tif (!timespec64_valid_strict(delta)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"\n\t\t\t\t\"sleep delta value!\\n\");\n\t\treturn;\n\t}\n\ttk_xtime_add(tk, delta);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *delta));\n\ttk_update_sleep_time(tk, timespec64_to_ktime(*delta));\n\ttk_debug_account_sleep_time(delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_forward_now",
          "args": [
            "tk"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_forward_now",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "775-788",
          "snippet": "static void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\ttk_normalize_xtime(tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\ttk_normalize_xtime(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic bool suspend_timing_needed;\n\nvoid timekeeping_inject_sleeptime64(const struct timespec64 *delta)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\tsuspend_timing_needed = false;\n\n\ttimekeeping_forward_now(tk);\n\n\t__timekeeping_inject_sleeptime(tk, delta);\n\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* Signal hrtimers about time change */\n\tclock_was_set(CLOCK_SET_WALL | CLOCK_SET_BOOT);\n}"
  },
  {
    "function_name": "timekeeping_rtc_skipsuspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1713-1716",
    "snippet": "bool timekeeping_rtc_skipsuspend(void)\n{\n\treturn persistent_clock_exists;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool persistent_clock_exists;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic bool persistent_clock_exists;\n\nbool timekeeping_rtc_skipsuspend(void)\n{\n\treturn persistent_clock_exists;\n}"
  },
  {
    "function_name": "timekeeping_rtc_skipresume",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1699-1702",
    "snippet": "bool timekeeping_rtc_skipresume(void)\n{\n\treturn !suspend_timing_needed;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool suspend_timing_needed;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic bool suspend_timing_needed;\n\nbool timekeeping_rtc_skipresume(void)\n{\n\treturn !suspend_timing_needed;\n}"
  },
  {
    "function_name": "__timekeeping_inject_sleeptime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1667-1680",
    "snippet": "static void __timekeeping_inject_sleeptime(struct timekeeper *tk,\n\t\t\t\t\t   const struct timespec64 *delta)\n{\n\tif (!timespec64_valid_strict(delta)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"\n\t\t\t\t\"sleep delta value!\\n\");\n\t\treturn;\n\t}\n\ttk_xtime_add(tk, delta);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *delta));\n\ttk_update_sleep_time(tk, timespec64_to_ktime(*delta));\n\ttk_debug_account_sleep_time(delta);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tk_debug_account_sleep_time",
          "args": [
            "delta"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "tk_debug_account_sleep_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping_debug.c",
          "lines": "46-54",
          "snippet": "void tk_debug_account_sleep_time(const struct timespec64 *t)\n{\n\t/* Cap bin index so we don't overflow the array */\n\tint bin = min(fls(t->tv_sec), NUM_BINS-1);\n\n\tsleep_time_bin[bin]++;\n\tpm_deferred_pr_dbg(\"Timekeeping suspended for %lld.%03lu seconds\\n\",\n\t\t\t   (s64)t->tv_sec, t->tv_nsec / NSEC_PER_MSEC);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include <linux/time.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [
            "#define NUM_BINS 32"
          ],
          "globals_used": [
            "static unsigned int sleep_time_bin[NUM_BINS] = {0};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include <linux/time.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/debugfs.h>\n\n#define NUM_BINS 32\n\nstatic unsigned int sleep_time_bin[NUM_BINS] = {0};\n\nvoid tk_debug_account_sleep_time(const struct timespec64 *t)\n{\n\t/* Cap bin index so we don't overflow the array */\n\tint bin = min(fls(t->tv_sec), NUM_BINS-1);\n\n\tsleep_time_bin[bin]++;\n\tpm_deferred_pr_dbg(\"Timekeeping suspended for %lld.%03lu seconds\\n\",\n\t\t\t   (s64)t->tv_sec, t->tv_nsec / NSEC_PER_MSEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_update_sleep_time",
          "args": [
            "tk",
            "timespec64_to_ktime(*delta)"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "tk_update_sleep_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "166-174",
          "snippet": "static inline void tk_update_sleep_time(struct timekeeper *tk, ktime_t delta)\n{\n\ttk->offs_boot = ktime_add(tk->offs_boot, delta);\n\t/*\n\t * Timespec representation for VDSO update to avoid 64bit division\n\t * on every update.\n\t */\n\ttk->monotonic_to_boot = ktime_to_timespec64(tk->offs_boot);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_update_sleep_time(struct timekeeper *tk, ktime_t delta)\n{\n\ttk->offs_boot = ktime_add(tk->offs_boot, delta);\n\t/*\n\t * Timespec representation for VDSO update to avoid 64bit division\n\t * on every update.\n\t */\n\ttk->monotonic_to_boot = ktime_to_timespec64(tk->offs_boot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "*delta"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_set_wall_to_mono",
          "args": [
            "tk",
            "timespec64_sub(tk->wall_to_monotonic, *delta)"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "tk_set_wall_to_mono",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "149-164",
          "snippet": "static void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "tk->wall_to_monotonic",
            "*delta"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_xtime_add",
          "args": [
            "tk",
            "delta"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "tk_xtime_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "142-147",
          "snippet": "static void tk_xtime_add(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec += ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec += (u64)ts->tv_nsec << tk->tkr_mono.shift;\n\ttk_normalize_xtime(tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_xtime_add(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec += ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec += (u64)ts->tv_nsec << tk->tkr_mono.shift;\n\ttk_normalize_xtime(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "KERN_WARNING\n\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"\n\t\t\t\t\"sleep delta value!\\n\""
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "_printk_deferred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3285-3295",
          "snippet": "int _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_valid_strict",
          "args": [
            "delta"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void __timekeeping_inject_sleeptime(struct timekeeper *tk,\n\t\t\t\t\t   const struct timespec64 *delta)\n{\n\tif (!timespec64_valid_strict(delta)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"\n\t\t\t\t\"sleep delta value!\\n\");\n\t\treturn;\n\t}\n\ttk_xtime_add(tk, delta);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *delta));\n\ttk_update_sleep_time(tk, timespec64_to_ktime(*delta));\n\ttk_debug_account_sleep_time(delta);\n}"
  },
  {
    "function_name": "timekeeping_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1611-1654",
    "snippet": "void __init timekeeping_init(void)\n{\n\tstruct timespec64 wall_time, boot_offset, wall_to_mono;\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct clocksource *clock;\n\tunsigned long flags;\n\n\tread_persistent_wall_and_boot_offset(&wall_time, &boot_offset);\n\tif (timespec64_valid_settod(&wall_time) &&\n\t    timespec64_to_ns(&wall_time) > 0) {\n\t\tpersistent_clock_exists = true;\n\t} else if (timespec64_to_ns(&wall_time) != 0) {\n\t\tpr_warn(\"Persistent clock returned invalid value\");\n\t\twall_time = (struct timespec64){0};\n\t}\n\n\tif (timespec64_compare(&wall_time, &boot_offset) < 0)\n\t\tboot_offset = (struct timespec64){0};\n\n\t/*\n\t * We want set wall_to_mono, so the following is true:\n\t * wall time + wall_to_mono = boot time\n\t */\n\twall_to_mono = timespec64_sub(boot_offset, wall_time);\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\tntp_init();\n\n\tclock = clocksource_default_clock();\n\tif (clock->enable)\n\t\tclock->enable(clock);\n\ttk_setup_internals(tk, clock);\n\n\ttk_set_xtime(tk, &wall_time);\n\ttk->raw_sec = 0;\n\n\ttk_set_wall_to_mono(tk, wall_to_mono);\n\n\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)",
      "#define TK_MIRROR\t\t(1 << 1)"
    ],
    "globals_used": [
      "static bool persistent_clock_exists;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "TK_MIRROR | TK_CLOCK_WAS_SET"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "738-765",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_set_wall_to_mono",
          "args": [
            "tk",
            "wall_to_mono"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "tk_set_wall_to_mono",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "149-164",
          "snippet": "static void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_set_xtime",
          "args": [
            "tk",
            "&wall_time"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "tk_set_xtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "136-140",
          "snippet": "static void tk_set_xtime(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec = ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec = (u64)ts->tv_nsec << tk->tkr_mono.shift;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_xtime(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec = ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec = (u64)ts->tv_nsec << tk->tkr_mono.shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_setup_internals",
          "args": [
            "tk",
            "clock"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "tk_setup_internals",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "307-368",
          "snippet": "static void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)\n{\n\tu64 interval;\n\tu64 tmp, ntpinterval;\n\tstruct clocksource *old_clock;\n\n\t++tk->cs_was_changed_seq;\n\told_clock = tk->tkr_mono.clock;\n\ttk->tkr_mono.clock = clock;\n\ttk->tkr_mono.mask = clock->mask;\n\ttk->tkr_mono.cycle_last = tk_clock_read(&tk->tkr_mono);\n\n\ttk->tkr_raw.clock = clock;\n\ttk->tkr_raw.mask = clock->mask;\n\ttk->tkr_raw.cycle_last = tk->tkr_mono.cycle_last;\n\n\t/* Do the ns -> cycle conversion first, using original mult */\n\ttmp = NTP_INTERVAL_LENGTH;\n\ttmp <<= clock->shift;\n\tntpinterval = tmp;\n\ttmp += clock->mult/2;\n\tdo_div(tmp, clock->mult);\n\tif (tmp == 0)\n\t\ttmp = 1;\n\n\tinterval = (u64) tmp;\n\ttk->cycle_interval = interval;\n\n\t/* Go back from cycles -> shifted ns */\n\ttk->xtime_interval = interval * clock->mult;\n\ttk->xtime_remainder = ntpinterval - tk->xtime_interval;\n\ttk->raw_interval = interval * clock->mult;\n\n\t /* if changing clocks, convert xtime_nsec shift units */\n\tif (old_clock) {\n\t\tint shift_change = clock->shift - old_clock->shift;\n\t\tif (shift_change < 0) {\n\t\t\ttk->tkr_mono.xtime_nsec >>= -shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec >>= -shift_change;\n\t\t} else {\n\t\t\ttk->tkr_mono.xtime_nsec <<= shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec <<= shift_change;\n\t\t}\n\t}\n\n\ttk->tkr_mono.shift = clock->shift;\n\ttk->tkr_raw.shift = clock->shift;\n\n\ttk->ntp_error = 0;\n\ttk->ntp_error_shift = NTP_SCALE_SHIFT - clock->shift;\n\ttk->ntp_tick = ntpinterval << tk->ntp_error_shift;\n\n\t/*\n\t * The timekeeper keeps its own mult values for the currently\n\t * active clocksource. These value will be adjusted via NTP\n\t * to counteract clock drifting.\n\t */\n\ttk->tkr_mono.mult = clock->mult;\n\ttk->tkr_raw.mult = clock->mult;\n\ttk->ntp_err_mult = 0;\n\ttk->skip_second_overflow = 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)\n{\n\tu64 interval;\n\tu64 tmp, ntpinterval;\n\tstruct clocksource *old_clock;\n\n\t++tk->cs_was_changed_seq;\n\told_clock = tk->tkr_mono.clock;\n\ttk->tkr_mono.clock = clock;\n\ttk->tkr_mono.mask = clock->mask;\n\ttk->tkr_mono.cycle_last = tk_clock_read(&tk->tkr_mono);\n\n\ttk->tkr_raw.clock = clock;\n\ttk->tkr_raw.mask = clock->mask;\n\ttk->tkr_raw.cycle_last = tk->tkr_mono.cycle_last;\n\n\t/* Do the ns -> cycle conversion first, using original mult */\n\ttmp = NTP_INTERVAL_LENGTH;\n\ttmp <<= clock->shift;\n\tntpinterval = tmp;\n\ttmp += clock->mult/2;\n\tdo_div(tmp, clock->mult);\n\tif (tmp == 0)\n\t\ttmp = 1;\n\n\tinterval = (u64) tmp;\n\ttk->cycle_interval = interval;\n\n\t/* Go back from cycles -> shifted ns */\n\ttk->xtime_interval = interval * clock->mult;\n\ttk->xtime_remainder = ntpinterval - tk->xtime_interval;\n\ttk->raw_interval = interval * clock->mult;\n\n\t /* if changing clocks, convert xtime_nsec shift units */\n\tif (old_clock) {\n\t\tint shift_change = clock->shift - old_clock->shift;\n\t\tif (shift_change < 0) {\n\t\t\ttk->tkr_mono.xtime_nsec >>= -shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec >>= -shift_change;\n\t\t} else {\n\t\t\ttk->tkr_mono.xtime_nsec <<= shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec <<= shift_change;\n\t\t}\n\t}\n\n\ttk->tkr_mono.shift = clock->shift;\n\ttk->tkr_raw.shift = clock->shift;\n\n\ttk->ntp_error = 0;\n\ttk->ntp_error_shift = NTP_SCALE_SHIFT - clock->shift;\n\ttk->ntp_tick = ntpinterval << tk->ntp_error_shift;\n\n\t/*\n\t * The timekeeper keeps its own mult values for the currently\n\t * active clocksource. These value will be adjusted via NTP\n\t * to counteract clock drifting.\n\t */\n\ttk->tkr_mono.mult = clock->mult;\n\ttk->tkr_raw.mult = clock->mult;\n\ttk->ntp_err_mult = 0;\n\ttk->skip_second_overflow = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clock->enable",
          "args": [
            "clock"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_default_clock",
          "args": [],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_default_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/jiffies.c",
          "lines": "71-74",
          "snippet": "__weak clocksource_default_clock(void)\n{\n\treturn &clocksource_jiffies;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource clocksource_jiffies = {\n\t.name\t\t\t= \"jiffies\",\n\t.rating\t\t\t= 1, /* lowest valid rating*/\n\t.uncertainty_margin\t= 32 * NSEC_PER_MSEC,\n\t.read\t\t\t= jiffies_read,\n\t.mask\t\t\t= CLOCKSOURCE_MASK(32),\n\t.mult\t\t\t= TICK_NSEC << JIFFIES_SHIFT, /* details above */\n\t.shift\t\t\t= JIFFIES_SHIFT,\n\t.max_cycles\t\t= 10,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include \"timekeeping.h\"\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n\nstatic struct clocksource clocksource_jiffies = {\n\t.name\t\t\t= \"jiffies\",\n\t.rating\t\t\t= 1, /* lowest valid rating*/\n\t.uncertainty_margin\t= 32 * NSEC_PER_MSEC,\n\t.read\t\t\t= jiffies_read,\n\t.mask\t\t\t= CLOCKSOURCE_MASK(32),\n\t.mult\t\t\t= TICK_NSEC << JIFFIES_SHIFT, /* details above */\n\t.shift\t\t\t= JIFFIES_SHIFT,\n\t.max_cycles\t\t= 10,\n};\n\n__weak clocksource_default_clock(void)\n{\n\treturn &clocksource_jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntp_init",
          "args": [],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "1092-1096",
          "snippet": "void __init ntp_init(void)\n{\n\tntp_clear();\n\tntp_init_cmos_sync();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nvoid __init ntp_init(void)\n{\n\tntp_clear();\n\tntp_init_cmos_sync();\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "boot_offset",
            "wall_time"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_compare",
          "args": [
            "&wall_time",
            "&boot_offset"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Persistent clock returned invalid value\""
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ns",
          "args": [
            "&wall_time"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ns",
          "args": [
            "&wall_time"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_valid_settod",
          "args": [
            "&wall_time"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_persistent_wall_and_boot_offset",
          "args": [
            "&wall_time",
            "&boot_offset"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "read_persistent_wall_and_boot_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1582-1588",
          "snippet": "__init\nread_persistent_wall_and_boot_offset(struct timespec64 *wall_time,\n\t\t\t\t     struct timespec64 *boot_offset)\n{\n\tread_persistent_clock64(wall_time);\n\t*boot_offset = ns_to_timespec64(local_clock());\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n__init\nread_persistent_wall_and_boot_offset(struct timespec64 *wall_time,\n\t\t\t\t     struct timespec64 *boot_offset)\n{\n\tread_persistent_clock64(wall_time);\n\t*boot_offset = ns_to_timespec64(local_clock());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n\nstatic bool persistent_clock_exists;\n\nvoid __init timekeeping_init(void)\n{\n\tstruct timespec64 wall_time, boot_offset, wall_to_mono;\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct clocksource *clock;\n\tunsigned long flags;\n\n\tread_persistent_wall_and_boot_offset(&wall_time, &boot_offset);\n\tif (timespec64_valid_settod(&wall_time) &&\n\t    timespec64_to_ns(&wall_time) > 0) {\n\t\tpersistent_clock_exists = true;\n\t} else if (timespec64_to_ns(&wall_time) != 0) {\n\t\tpr_warn(\"Persistent clock returned invalid value\");\n\t\twall_time = (struct timespec64){0};\n\t}\n\n\tif (timespec64_compare(&wall_time, &boot_offset) < 0)\n\t\tboot_offset = (struct timespec64){0};\n\n\t/*\n\t * We want set wall_to_mono, so the following is true:\n\t * wall time + wall_to_mono = boot time\n\t */\n\twall_to_mono = timespec64_sub(boot_offset, wall_time);\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\tntp_init();\n\n\tclock = clocksource_default_clock();\n\tif (clock->enable)\n\t\tclock->enable(clock);\n\ttk_setup_internals(tk, clock);\n\n\ttk_set_xtime(tk, &wall_time);\n\ttk->raw_sec = 0;\n\n\ttk_set_wall_to_mono(tk, wall_to_mono);\n\n\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n}"
  },
  {
    "function_name": "read_persistent_wall_and_boot_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1582-1588",
    "snippet": "__init\nread_persistent_wall_and_boot_offset(struct timespec64 *wall_time,\n\t\t\t\t     struct timespec64 *boot_offset)\n{\n\tread_persistent_clock64(wall_time);\n\t*boot_offset = ns_to_timespec64(local_clock());\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_timespec64",
          "args": [
            "local_clock()"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timespec64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "506-525",
          "snippet": "struct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts = { 0, 0 };\n\ts32 rem;\n\n\tif (likely(nsec > 0)) {\n\t\tts.tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\t\tts.tv_nsec = rem;\n\t} else if (nsec < 0) {\n\t\t/*\n\t\t * With negative times, tv_sec points to the earlier\n\t\t * second, and tv_nsec counts the nanoseconds since\n\t\t * then, so tv_nsec is always a positive number.\n\t\t */\n\t\tts.tv_sec = -div_u64_rem(-nsec - 1, NSEC_PER_SEC, &rem) - 1;\n\t\tts.tv_nsec = NSEC_PER_SEC - rem - 1;\n\t}\n\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_clock",
          "args": [],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_persistent_clock64",
          "args": [
            "wall_time"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "read_persistent_clock64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1563-1567",
          "snippet": "void __weak read_persistent_clock64(struct timespec64 *ts)\n{\n\tts->tv_sec = 0;\n\tts->tv_nsec = 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid __weak;\n\nvoid __weak read_persistent_clock64(struct timespec64 *ts)\n{\n\tts->tv_sec = 0;\n\tts->tv_nsec = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n__init\nread_persistent_wall_and_boot_offset(struct timespec64 *wall_time,\n\t\t\t\t     struct timespec64 *boot_offset)\n{\n\tread_persistent_clock64(wall_time);\n\t*boot_offset = ns_to_timespec64(local_clock());\n}"
  },
  {
    "function_name": "read_persistent_clock64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1563-1567",
    "snippet": "void __weak read_persistent_clock64(struct timespec64 *ts)\n{\n\tts->tv_sec = 0;\n\tts->tv_nsec = 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void __weak"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid __weak;\n\nvoid __weak read_persistent_clock64(struct timespec64 *ts)\n{\n\tts->tv_sec = 0;\n\tts->tv_nsec = 0;\n}"
  },
  {
    "function_name": "timekeeping_max_deferment",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1537-1551",
    "snippet": "u64 timekeeping_max_deferment(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->max_idle_ns;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 timekeeping_max_deferment(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->max_idle_ns;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "timekeeping_valid_for_hres",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1518-1532",
    "snippet": "int timekeeping_valid_for_hres(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tint ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->flags & CLOCK_SOURCE_VALID_FOR_HRES;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nint timekeeping_valid_for_hres(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tint ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->flags & CLOCK_SOURCE_VALID_FOR_HRES;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ktime_get_raw_ts64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1496-1511",
    "snippet": "void ktime_get_raw_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->raw_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_raw);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec64_add_ns",
          "args": [
            "ts",
            "nsecs"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_get_ns",
          "args": [
            "&tk->tkr_raw"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_get_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "382-388",
          "snippet": "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_raw_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->raw_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_raw);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
  },
  {
    "function_name": "timekeeping_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1479-1488",
    "snippet": "int timekeeping_notify(struct clocksource *clock)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tif (tk->tkr_mono.clock == clock)\n\t\treturn 0;\n\tstop_machine(change_clocksource, clock, NULL);\n\ttick_clock_notify();\n\treturn tk->tkr_mono.clock == clock ? 0 : -1;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_clock_notify",
          "args": [],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "tick_clock_notify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1499-1505",
          "snippet": "void tick_clock_notify(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_clock_notify(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_machine",
          "args": [
            "change_clocksource",
            "clock",
            "NULL"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "stop_machine_from_inactive_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "658-687",
          "snippet": "int stop_machine_from_inactive_cpu(cpu_stop_fn_t fn, void *data,\n\t\t\t\t  const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = { .fn = fn, .data = data,\n\t\t\t\t\t    .active_cpus = cpus };\n\tstruct cpu_stop_done done;\n\tint ret;\n\n\t/* Local CPU must be inactive and CPU hotplug in progress. */\n\tBUG_ON(cpu_active(raw_smp_processor_id()));\n\tmsdata.num_threads = num_active_cpus() + 1;\t/* +1 for local */\n\n\t/* No proper task established and can't sleep - busy wait for lock. */\n\twhile (!mutex_trylock(&stop_cpus_mutex))\n\t\tcpu_relax();\n\n\t/* Schedule work on other CPUs and execute directly for local CPU */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\tcpu_stop_init_done(&done, num_active_cpus());\n\tqueue_stop_cpus_work(cpu_active_mask, multi_cpu_stop, &msdata,\n\t\t\t     &done);\n\tret = multi_cpu_stop(&msdata);\n\n\t/* Busy wait for completion. */\n\twhile (!completion_done(&done.completion))\n\t\tcpu_relax();\n\n\tmutex_unlock(&stop_cpus_mutex);\n\treturn ret ?: done.ret;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(stop_cpus_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_MUTEX(stop_cpus_mutex);\n\nint stop_machine_from_inactive_cpu(cpu_stop_fn_t fn, void *data,\n\t\t\t\t  const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = { .fn = fn, .data = data,\n\t\t\t\t\t    .active_cpus = cpus };\n\tstruct cpu_stop_done done;\n\tint ret;\n\n\t/* Local CPU must be inactive and CPU hotplug in progress. */\n\tBUG_ON(cpu_active(raw_smp_processor_id()));\n\tmsdata.num_threads = num_active_cpus() + 1;\t/* +1 for local */\n\n\t/* No proper task established and can't sleep - busy wait for lock. */\n\twhile (!mutex_trylock(&stop_cpus_mutex))\n\t\tcpu_relax();\n\n\t/* Schedule work on other CPUs and execute directly for local CPU */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\tcpu_stop_init_done(&done, num_active_cpus());\n\tqueue_stop_cpus_work(cpu_active_mask, multi_cpu_stop, &msdata,\n\t\t\t     &done);\n\tret = multi_cpu_stop(&msdata);\n\n\t/* Busy wait for completion. */\n\twhile (!completion_done(&done.completion))\n\t\tcpu_relax();\n\n\tmutex_unlock(&stop_cpus_mutex);\n\treturn ret ?: done.ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nint timekeeping_notify(struct clocksource *clock)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tif (tk->tkr_mono.clock == clock)\n\t\treturn 0;\n\tstop_machine(change_clocksource, clock, NULL);\n\ttick_clock_notify();\n\treturn tk->tkr_mono.clock == clock ? 0 : -1;\n}"
  },
  {
    "function_name": "change_clocksource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1427-1470",
    "snippet": "static int change_clocksource(void *data)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct clocksource *new, *old = NULL;\n\tunsigned long flags;\n\tbool change = false;\n\n\tnew = (struct clocksource *) data;\n\n\t/*\n\t * If the cs is in module, get a module reference. Succeeds\n\t * for built-in code (owner == NULL) as well.\n\t */\n\tif (try_module_get(new->owner)) {\n\t\tif (!new->enable || new->enable(new) == 0)\n\t\t\tchange = true;\n\t\telse\n\t\t\tmodule_put(new->owner);\n\t}\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\tif (change) {\n\t\told = tk->tkr_mono.clock;\n\t\ttk_setup_internals(tk, new);\n\t}\n\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\tif (old) {\n\t\tif (old->disable)\n\t\t\told->disable(old);\n\n\t\tmodule_put(old->owner);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)",
      "#define TK_MIRROR\t\t(1 << 1)",
      "#define TK_CLEAR_NTP\t\t(1 << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "old->owner"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1087-1098",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "old->disable",
          "args": [
            "old"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "738-765",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_setup_internals",
          "args": [
            "tk",
            "new"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "tk_setup_internals",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "307-368",
          "snippet": "static void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)\n{\n\tu64 interval;\n\tu64 tmp, ntpinterval;\n\tstruct clocksource *old_clock;\n\n\t++tk->cs_was_changed_seq;\n\told_clock = tk->tkr_mono.clock;\n\ttk->tkr_mono.clock = clock;\n\ttk->tkr_mono.mask = clock->mask;\n\ttk->tkr_mono.cycle_last = tk_clock_read(&tk->tkr_mono);\n\n\ttk->tkr_raw.clock = clock;\n\ttk->tkr_raw.mask = clock->mask;\n\ttk->tkr_raw.cycle_last = tk->tkr_mono.cycle_last;\n\n\t/* Do the ns -> cycle conversion first, using original mult */\n\ttmp = NTP_INTERVAL_LENGTH;\n\ttmp <<= clock->shift;\n\tntpinterval = tmp;\n\ttmp += clock->mult/2;\n\tdo_div(tmp, clock->mult);\n\tif (tmp == 0)\n\t\ttmp = 1;\n\n\tinterval = (u64) tmp;\n\ttk->cycle_interval = interval;\n\n\t/* Go back from cycles -> shifted ns */\n\ttk->xtime_interval = interval * clock->mult;\n\ttk->xtime_remainder = ntpinterval - tk->xtime_interval;\n\ttk->raw_interval = interval * clock->mult;\n\n\t /* if changing clocks, convert xtime_nsec shift units */\n\tif (old_clock) {\n\t\tint shift_change = clock->shift - old_clock->shift;\n\t\tif (shift_change < 0) {\n\t\t\ttk->tkr_mono.xtime_nsec >>= -shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec >>= -shift_change;\n\t\t} else {\n\t\t\ttk->tkr_mono.xtime_nsec <<= shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec <<= shift_change;\n\t\t}\n\t}\n\n\ttk->tkr_mono.shift = clock->shift;\n\ttk->tkr_raw.shift = clock->shift;\n\n\ttk->ntp_error = 0;\n\ttk->ntp_error_shift = NTP_SCALE_SHIFT - clock->shift;\n\ttk->ntp_tick = ntpinterval << tk->ntp_error_shift;\n\n\t/*\n\t * The timekeeper keeps its own mult values for the currently\n\t * active clocksource. These value will be adjusted via NTP\n\t * to counteract clock drifting.\n\t */\n\ttk->tkr_mono.mult = clock->mult;\n\ttk->tkr_raw.mult = clock->mult;\n\ttk->ntp_err_mult = 0;\n\ttk->skip_second_overflow = 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)\n{\n\tu64 interval;\n\tu64 tmp, ntpinterval;\n\tstruct clocksource *old_clock;\n\n\t++tk->cs_was_changed_seq;\n\told_clock = tk->tkr_mono.clock;\n\ttk->tkr_mono.clock = clock;\n\ttk->tkr_mono.mask = clock->mask;\n\ttk->tkr_mono.cycle_last = tk_clock_read(&tk->tkr_mono);\n\n\ttk->tkr_raw.clock = clock;\n\ttk->tkr_raw.mask = clock->mask;\n\ttk->tkr_raw.cycle_last = tk->tkr_mono.cycle_last;\n\n\t/* Do the ns -> cycle conversion first, using original mult */\n\ttmp = NTP_INTERVAL_LENGTH;\n\ttmp <<= clock->shift;\n\tntpinterval = tmp;\n\ttmp += clock->mult/2;\n\tdo_div(tmp, clock->mult);\n\tif (tmp == 0)\n\t\ttmp = 1;\n\n\tinterval = (u64) tmp;\n\ttk->cycle_interval = interval;\n\n\t/* Go back from cycles -> shifted ns */\n\ttk->xtime_interval = interval * clock->mult;\n\ttk->xtime_remainder = ntpinterval - tk->xtime_interval;\n\ttk->raw_interval = interval * clock->mult;\n\n\t /* if changing clocks, convert xtime_nsec shift units */\n\tif (old_clock) {\n\t\tint shift_change = clock->shift - old_clock->shift;\n\t\tif (shift_change < 0) {\n\t\t\ttk->tkr_mono.xtime_nsec >>= -shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec >>= -shift_change;\n\t\t} else {\n\t\t\ttk->tkr_mono.xtime_nsec <<= shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec <<= shift_change;\n\t\t}\n\t}\n\n\ttk->tkr_mono.shift = clock->shift;\n\ttk->tkr_raw.shift = clock->shift;\n\n\ttk->ntp_error = 0;\n\ttk->ntp_error_shift = NTP_SCALE_SHIFT - clock->shift;\n\ttk->ntp_tick = ntpinterval << tk->ntp_error_shift;\n\n\t/*\n\t * The timekeeper keeps its own mult values for the currently\n\t * active clocksource. These value will be adjusted via NTP\n\t * to counteract clock drifting.\n\t */\n\ttk->tkr_mono.mult = clock->mult;\n\ttk->tkr_raw.mult = clock->mult;\n\ttk->ntp_err_mult = 0;\n\ttk->skip_second_overflow = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_forward_now",
          "args": [
            "tk"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_forward_now",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "775-788",
          "snippet": "static void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\ttk_normalize_xtime(tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\ttk_normalize_xtime(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new->enable",
          "args": [
            "new"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "new->owner"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1068-1084",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic int change_clocksource(void *data)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct clocksource *new, *old = NULL;\n\tunsigned long flags;\n\tbool change = false;\n\n\tnew = (struct clocksource *) data;\n\n\t/*\n\t * If the cs is in module, get a module reference. Succeeds\n\t * for built-in code (owner == NULL) as well.\n\t */\n\tif (try_module_get(new->owner)) {\n\t\tif (!new->enable || new->enable(new) == 0)\n\t\t\tchange = true;\n\t\telse\n\t\t\tmodule_put(new->owner);\n\t}\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\tif (change) {\n\t\told = tk->tkr_mono.clock;\n\t\ttk_setup_internals(tk, new);\n\t}\n\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\tif (old) {\n\t\tif (old->disable)\n\t\t\told->disable(old);\n\n\t\tmodule_put(old->owner);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__timekeeping_set_tai_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1416-1420",
    "snippet": "static void __timekeeping_set_tai_offset(struct timekeeper *tk, s32 tai_offset)\n{\n\ttk->tai_offset = tai_offset;\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tai_offset, 0));\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tk->offs_real",
            "ktime_set(tai_offset, 0)"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_set",
          "args": [
            "tai_offset",
            "0"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void __timekeeping_set_tai_offset(struct timekeeper *tk, s32 tai_offset)\n{\n\ttk->tai_offset = tai_offset;\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tai_offset, 0));\n}"
  },
  {
    "function_name": "timekeeping_warp_clock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1401-1411",
    "snippet": "void timekeeping_warp_clock(void)\n{\n\tif (sys_tz.tz_minuteswest != 0) {\n\t\tstruct timespec64 adjust;\n\n\t\tpersistent_clock_is_local = 1;\n\t\tadjust.tv_sec = sys_tz.tz_minuteswest * 60;\n\t\tadjust.tv_nsec = 0;\n\t\ttimekeeping_inject_offset(&adjust);\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int persistent_clock_is_local;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timekeeping_inject_offset",
          "args": [
            "&adjust"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_inject_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1341-1377",
          "snippet": "static int timekeeping_inject_offset(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64 tmp;\n\tint ret = 0;\n\n\tif (ts->tv_nsec < 0 || ts->tv_nsec >= NSEC_PER_SEC)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\t/* Make sure the proposed value is valid */\n\ttmp = timespec64_add(tk_xtime(tk), *ts);\n\tif (timespec64_compare(&tk->wall_to_monotonic, ts) > 0 ||\n\t    !timespec64_valid_settod(&tmp)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk_xtime_add(tk, ts);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *ts));\n\nerror: /* even if we error out, we forwarded the time, so call update */\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* Signal hrtimers about time change */\n\tclock_was_set(CLOCK_SET_WALL);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic int timekeeping_inject_offset(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64 tmp;\n\tint ret = 0;\n\n\tif (ts->tv_nsec < 0 || ts->tv_nsec >= NSEC_PER_SEC)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\t/* Make sure the proposed value is valid */\n\ttmp = timespec64_add(tk_xtime(tk), *ts);\n\tif (timespec64_compare(&tk->wall_to_monotonic, ts) > 0 ||\n\t    !timespec64_valid_settod(&tmp)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk_xtime_add(tk, ts);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *ts));\n\nerror: /* even if we error out, we forwarded the time, so call update */\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* Signal hrtimers about time change */\n\tclock_was_set(CLOCK_SET_WALL);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nint persistent_clock_is_local;\n\nvoid timekeeping_warp_clock(void)\n{\n\tif (sys_tz.tz_minuteswest != 0) {\n\t\tstruct timespec64 adjust;\n\n\t\tpersistent_clock_is_local = 1;\n\t\tadjust.tv_sec = sys_tz.tz_minuteswest * 60;\n\t\tadjust.tv_nsec = 0;\n\t\ttimekeeping_inject_offset(&adjust);\n\t}\n}"
  },
  {
    "function_name": "timekeeping_inject_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1341-1377",
    "snippet": "static int timekeeping_inject_offset(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64 tmp;\n\tint ret = 0;\n\n\tif (ts->tv_nsec < 0 || ts->tv_nsec >= NSEC_PER_SEC)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\t/* Make sure the proposed value is valid */\n\ttmp = timespec64_add(tk_xtime(tk), *ts);\n\tif (timespec64_compare(&tk->wall_to_monotonic, ts) > 0 ||\n\t    !timespec64_valid_settod(&tmp)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk_xtime_add(tk, ts);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *ts));\n\nerror: /* even if we error out, we forwarded the time, so call update */\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* Signal hrtimers about time change */\n\tclock_was_set(CLOCK_SET_WALL);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)",
      "#define TK_MIRROR\t\t(1 << 1)",
      "#define TK_CLEAR_NTP\t\t(1 << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clock_was_set",
          "args": [
            "CLOCK_SET_WALL"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "clock_was_set_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "983-986",
          "snippet": "static void clock_was_set_work(struct work_struct *work)\n{\n\tclock_was_set(CLOCK_SET_WALL);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WORK(hrtimer_work, clock_was_set_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic DECLARE_WORK(hrtimer_work, clock_was_set_work);\n\nstatic void clock_was_set_work(struct work_struct *work)\n{\n\tclock_was_set(CLOCK_SET_WALL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "738-765",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_set_wall_to_mono",
          "args": [
            "tk",
            "timespec64_sub(tk->wall_to_monotonic, *ts)"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "tk_set_wall_to_mono",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "149-164",
          "snippet": "static void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "tk->wall_to_monotonic",
            "*ts"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_xtime_add",
          "args": [
            "tk",
            "ts"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "tk_xtime_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "142-147",
          "snippet": "static void tk_xtime_add(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec += ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec += (u64)ts->tv_nsec << tk->tkr_mono.shift;\n\ttk_normalize_xtime(tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_xtime_add(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec += ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec += (u64)ts->tv_nsec << tk->tkr_mono.shift;\n\ttk_normalize_xtime(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_valid_settod",
          "args": [
            "&tmp"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_compare",
          "args": [
            "&tk->wall_to_monotonic",
            "ts"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_add",
          "args": [
            "tk_xtime(tk)",
            "*ts"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "timespec64_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "765-779",
          "snippet": "struct timespec64 timespec64_add_safe(const struct timespec64 lhs,\n\t\t\t\tconst struct timespec64 rhs)\n{\n\tstruct timespec64 res;\n\n\tset_normalized_timespec64(&res, (timeu64_t) lhs.tv_sec + rhs.tv_sec,\n\t\t\tlhs.tv_nsec + rhs.tv_nsec);\n\n\tif (unlikely(res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)) {\n\t\tres.tv_sec = TIME64_MAX;\n\t\tres.tv_nsec = 0;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 timespec64_add_safe(const struct timespec64 lhs,\n\t\t\t\tconst struct timespec64 rhs)\n{\n\tstruct timespec64 res;\n\n\tset_normalized_timespec64(&res, (timeu64_t) lhs.tv_sec + rhs.tv_sec,\n\t\t\tlhs.tv_nsec + rhs.tv_nsec);\n\n\tif (unlikely(res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)) {\n\t\tres.tv_sec = TIME64_MAX;\n\t\tres.tv_nsec = 0;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_xtime",
          "args": [
            "tk"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "tk_xtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "127-134",
          "snippet": "static inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_forward_now",
          "args": [
            "tk"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_forward_now",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "775-788",
          "snippet": "static void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\ttk_normalize_xtime(tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\ttk_normalize_xtime(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic int timekeeping_inject_offset(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64 tmp;\n\tint ret = 0;\n\n\tif (ts->tv_nsec < 0 || ts->tv_nsec >= NSEC_PER_SEC)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\t/* Make sure the proposed value is valid */\n\ttmp = timespec64_add(tk_xtime(tk), *ts);\n\tif (timespec64_compare(&tk->wall_to_monotonic, ts) > 0 ||\n\t    !timespec64_valid_settod(&tmp)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk_xtime_add(tk, ts);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *ts));\n\nerror: /* even if we error out, we forwarded the time, so call update */\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* Signal hrtimers about time change */\n\tclock_was_set(CLOCK_SET_WALL);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_settimeofday64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1293-1332",
    "snippet": "int do_settimeofday64(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 ts_delta, xt;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!timespec64_valid_settod(ts))\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\txt = tk_xtime(tk);\n\tts_delta = timespec64_sub(*ts, xt);\n\n\tif (timespec64_compare(&tk->wall_to_monotonic, &ts_delta) > 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, ts_delta));\n\n\ttk_set_xtime(tk, ts);\nout:\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* Signal hrtimers about time change */\n\tclock_was_set(CLOCK_SET_WALL);\n\n\tif (!ret)\n\t\taudit_tk_injoffset(ts_delta);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)",
      "#define TK_MIRROR\t\t(1 << 1)",
      "#define TK_CLEAR_NTP\t\t(1 << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_tk_injoffset",
          "args": [
            "ts_delta"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "__audit_tk_injoffset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditsc.c",
          "lines": "2850-2855",
          "snippet": "void __audit_tk_injoffset(struct timespec64 offset)\n{\n\taudit_log(audit_context(), GFP_KERNEL, AUDIT_TIME_INJOFFSET,\n\t\t  \"sec=%lli nsec=%li\",\n\t\t  (long long)offset.tv_sec, offset.tv_nsec);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/openat2.h> // struct open_how",
            "#include <uapi/linux/netfilter/nf_tables.h>",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/openat2.h> // struct open_how\n#include <uapi/linux/netfilter/nf_tables.h>\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_tk_injoffset(struct timespec64 offset)\n{\n\taudit_log(audit_context(), GFP_KERNEL, AUDIT_TIME_INJOFFSET,\n\t\t  \"sec=%lli nsec=%li\",\n\t\t  (long long)offset.tv_sec, offset.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clock_was_set",
          "args": [
            "CLOCK_SET_WALL"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "clock_was_set_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "983-986",
          "snippet": "static void clock_was_set_work(struct work_struct *work)\n{\n\tclock_was_set(CLOCK_SET_WALL);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WORK(hrtimer_work, clock_was_set_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nstatic DECLARE_WORK(hrtimer_work, clock_was_set_work);\n\nstatic void clock_was_set_work(struct work_struct *work)\n{\n\tclock_was_set(CLOCK_SET_WALL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "738-765",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_set_xtime",
          "args": [
            "tk",
            "ts"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "tk_set_xtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "136-140",
          "snippet": "static void tk_set_xtime(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec = ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec = (u64)ts->tv_nsec << tk->tkr_mono.shift;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_xtime(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec = ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec = (u64)ts->tv_nsec << tk->tkr_mono.shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_set_wall_to_mono",
          "args": [
            "tk",
            "timespec64_sub(tk->wall_to_monotonic, ts_delta)"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "tk_set_wall_to_mono",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "149-164",
          "snippet": "static void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "tk->wall_to_monotonic",
            "ts_delta"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_compare",
          "args": [
            "&tk->wall_to_monotonic",
            "&ts_delta"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "*ts",
            "xt"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_xtime",
          "args": [
            "tk"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "tk_xtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "127-134",
          "snippet": "static inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_forward_now",
          "args": [
            "tk"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_forward_now",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "775-788",
          "snippet": "static void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\ttk_normalize_xtime(tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\ttk_normalize_xtime(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_valid_settod",
          "args": [
            "ts"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nint do_settimeofday64(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 ts_delta, xt;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!timespec64_valid_settod(ts))\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\txt = tk_xtime(tk);\n\tts_delta = timespec64_sub(*ts, xt);\n\n\tif (timespec64_compare(&tk->wall_to_monotonic, &ts_delta) > 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, ts_delta));\n\n\ttk_set_xtime(tk, ts);\nout:\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* Signal hrtimers about time change */\n\tclock_was_set(CLOCK_SET_WALL);\n\n\tif (!ret)\n\t\taudit_tk_injoffset(ts_delta);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "get_device_system_crosststamp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1186-1284",
    "snippet": "int get_device_system_crosststamp(int (*get_time_fn)\n\t\t\t\t  (ktime_t *device_time,\n\t\t\t\t   struct system_counterval_t *sys_counterval,\n\t\t\t\t   void *ctx),\n\t\t\t\t  void *ctx,\n\t\t\t\t  struct system_time_snapshot *history_begin,\n\t\t\t\t  struct system_device_crosststamp *xtstamp)\n{\n\tstruct system_counterval_t system_counterval;\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tu64 cycles, now, interval_start;\n\tunsigned int clock_was_set_seq = 0;\n\tktime_t base_real, base_raw;\n\tu64 nsec_real, nsec_raw;\n\tu8 cs_was_changed_seq;\n\tunsigned int seq;\n\tbool do_interp;\n\tint ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\t/*\n\t\t * Try to synchronously capture device time and a system\n\t\t * counter value calling back into the device driver\n\t\t */\n\t\tret = get_time_fn(&xtstamp->device, &system_counterval, ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * Verify that the clocksource associated with the captured\n\t\t * system counter value is the same as the currently installed\n\t\t * timekeeper clocksource\n\t\t */\n\t\tif (tk->tkr_mono.clock != system_counterval.cs)\n\t\t\treturn -ENODEV;\n\t\tcycles = system_counterval.cycles;\n\n\t\t/*\n\t\t * Check whether the system counter value provided by the\n\t\t * device driver is on the current timekeeping interval.\n\t\t */\n\t\tnow = tk_clock_read(&tk->tkr_mono);\n\t\tinterval_start = tk->tkr_mono.cycle_last;\n\t\tif (!cycle_between(interval_start, cycles, now)) {\n\t\t\tclock_was_set_seq = tk->clock_was_set_seq;\n\t\t\tcs_was_changed_seq = tk->cs_was_changed_seq;\n\t\t\tcycles = interval_start;\n\t\t\tdo_interp = true;\n\t\t} else {\n\t\t\tdo_interp = false;\n\t\t}\n\n\t\tbase_real = ktime_add(tk->tkr_mono.base,\n\t\t\t\t      tk_core.timekeeper.offs_real);\n\t\tbase_raw = tk->tkr_raw.base;\n\n\t\tnsec_real = timekeeping_cycles_to_ns(&tk->tkr_mono,\n\t\t\t\t\t\t     system_counterval.cycles);\n\t\tnsec_raw = timekeeping_cycles_to_ns(&tk->tkr_raw,\n\t\t\t\t\t\t    system_counterval.cycles);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\txtstamp->sys_realtime = ktime_add_ns(base_real, nsec_real);\n\txtstamp->sys_monoraw = ktime_add_ns(base_raw, nsec_raw);\n\n\t/*\n\t * Interpolate if necessary, adjusting back from the start of the\n\t * current interval\n\t */\n\tif (do_interp) {\n\t\tu64 partial_history_cycles, total_history_cycles;\n\t\tbool discontinuity;\n\n\t\t/*\n\t\t * Check that the counter value occurs after the provided\n\t\t * history reference and that the history doesn't cross a\n\t\t * clocksource change\n\t\t */\n\t\tif (!history_begin ||\n\t\t    !cycle_between(history_begin->cycles,\n\t\t\t\t   system_counterval.cycles, cycles) ||\n\t\t    history_begin->cs_was_changed_seq != cs_was_changed_seq)\n\t\t\treturn -EINVAL;\n\t\tpartial_history_cycles = cycles - system_counterval.cycles;\n\t\ttotal_history_cycles = cycles - history_begin->cycles;\n\t\tdiscontinuity =\n\t\t\thistory_begin->clock_was_set_seq != clock_was_set_seq;\n\n\t\tret = adjust_historical_crosststamp(history_begin,\n\t\t\t\t\t\t    partial_history_cycles,\n\t\t\t\t\t\t    total_history_cycles,\n\t\t\t\t\t\t    discontinuity, xtstamp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "adjust_historical_crosststamp",
          "args": [
            "history_begin",
            "partial_history_cycles",
            "total_history_cycles",
            "discontinuity",
            "xtstamp"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_historical_crosststamp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1101-1161",
          "snippet": "static int adjust_historical_crosststamp(struct system_time_snapshot *history,\n\t\t\t\t\t u64 partial_history_cycles,\n\t\t\t\t\t u64 total_history_cycles,\n\t\t\t\t\t bool discontinuity,\n\t\t\t\t\t struct system_device_crosststamp *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tu64 corr_raw, corr_real;\n\tbool interp_forward;\n\tint ret;\n\n\tif (total_history_cycles == 0 || partial_history_cycles == 0)\n\t\treturn 0;\n\n\t/* Interpolate shortest distance from beginning or end of history */\n\tinterp_forward = partial_history_cycles > total_history_cycles / 2;\n\tpartial_history_cycles = interp_forward ?\n\t\ttotal_history_cycles - partial_history_cycles :\n\t\tpartial_history_cycles;\n\n\t/*\n\t * Scale the monotonic raw time delta by:\n\t *\tpartial_history_cycles / total_history_cycles\n\t */\n\tcorr_raw = (u64)ktime_to_ns(\n\t\tktime_sub(ts->sys_monoraw, history->raw));\n\tret = scale64_check_overflow(partial_history_cycles,\n\t\t\t\t     total_history_cycles, &corr_raw);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If there is a discontinuity in the history, scale monotonic raw\n\t *\tcorrection by:\n\t *\tmult(real)/mult(raw) yielding the realtime correction\n\t * Otherwise, calculate the realtime correction similar to monotonic\n\t *\traw calculation\n\t */\n\tif (discontinuity) {\n\t\tcorr_real = mul_u64_u32_div\n\t\t\t(corr_raw, tk->tkr_mono.mult, tk->tkr_raw.mult);\n\t} else {\n\t\tcorr_real = (u64)ktime_to_ns(\n\t\t\tktime_sub(ts->sys_realtime, history->real));\n\t\tret = scale64_check_overflow(partial_history_cycles,\n\t\t\t\t\t     total_history_cycles, &corr_real);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Fixup monotonic raw and real time time values */\n\tif (interp_forward) {\n\t\tts->sys_monoraw = ktime_add_ns(history->raw, corr_raw);\n\t\tts->sys_realtime = ktime_add_ns(history->real, corr_real);\n\t} else {\n\t\tts->sys_monoraw = ktime_sub_ns(ts->sys_monoraw, corr_raw);\n\t\tts->sys_realtime = ktime_sub_ns(ts->sys_realtime, corr_real);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic int adjust_historical_crosststamp(struct system_time_snapshot *history,\n\t\t\t\t\t u64 partial_history_cycles,\n\t\t\t\t\t u64 total_history_cycles,\n\t\t\t\t\t bool discontinuity,\n\t\t\t\t\t struct system_device_crosststamp *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tu64 corr_raw, corr_real;\n\tbool interp_forward;\n\tint ret;\n\n\tif (total_history_cycles == 0 || partial_history_cycles == 0)\n\t\treturn 0;\n\n\t/* Interpolate shortest distance from beginning or end of history */\n\tinterp_forward = partial_history_cycles > total_history_cycles / 2;\n\tpartial_history_cycles = interp_forward ?\n\t\ttotal_history_cycles - partial_history_cycles :\n\t\tpartial_history_cycles;\n\n\t/*\n\t * Scale the monotonic raw time delta by:\n\t *\tpartial_history_cycles / total_history_cycles\n\t */\n\tcorr_raw = (u64)ktime_to_ns(\n\t\tktime_sub(ts->sys_monoraw, history->raw));\n\tret = scale64_check_overflow(partial_history_cycles,\n\t\t\t\t     total_history_cycles, &corr_raw);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If there is a discontinuity in the history, scale monotonic raw\n\t *\tcorrection by:\n\t *\tmult(real)/mult(raw) yielding the realtime correction\n\t * Otherwise, calculate the realtime correction similar to monotonic\n\t *\traw calculation\n\t */\n\tif (discontinuity) {\n\t\tcorr_real = mul_u64_u32_div\n\t\t\t(corr_raw, tk->tkr_mono.mult, tk->tkr_raw.mult);\n\t} else {\n\t\tcorr_real = (u64)ktime_to_ns(\n\t\t\tktime_sub(ts->sys_realtime, history->real));\n\t\tret = scale64_check_overflow(partial_history_cycles,\n\t\t\t\t\t     total_history_cycles, &corr_real);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Fixup monotonic raw and real time time values */\n\tif (interp_forward) {\n\t\tts->sys_monoraw = ktime_add_ns(history->raw, corr_raw);\n\t\tts->sys_realtime = ktime_add_ns(history->real, corr_real);\n\t} else {\n\t\tts->sys_monoraw = ktime_sub_ns(ts->sys_monoraw, corr_raw);\n\t\tts->sys_realtime = ktime_sub_ns(ts->sys_realtime, corr_real);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cycle_between",
          "args": [
            "history_begin->cycles",
            "system_counterval.cycles",
            "cycles"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "cycle_between",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1166-1173",
          "snippet": "static bool cycle_between(u64 before, u64 test, u64 after)\n{\n\tif (test > before && test < after)\n\t\treturn true;\n\tif (test < before && before > after)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic bool cycle_between(u64 before, u64 test, u64 after)\n{\n\tif (test > before && test < after)\n\t\treturn true;\n\tif (test < before && before > after)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base_raw",
            "nsec_raw"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base_real",
            "nsec_real"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_cycles_to_ns",
          "args": [
            "&tk->tkr_raw",
            "system_counterval.cycles"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_cycles_to_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "390-397",
          "snippet": "static inline u64 timekeeping_cycles_to_ns(const struct tk_read_base *tkr, u64 cycles)\n{\n\tu64 delta;\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycles, tkr->cycle_last, tkr->mask);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_cycles_to_ns(const struct tk_read_base *tkr, u64 cycles)\n{\n\tu64 delta;\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycles, tkr->cycle_last, tkr->mask);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tk->tkr_mono.base",
            "tk_core.timekeeper.offs_real"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "189-194",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_time_fn",
          "args": [
            "&xtstamp->device",
            "&system_counterval",
            "ctx"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nint get_device_system_crosststamp(int (*get_time_fn)\n\t\t\t\t  (ktime_t *device_time,\n\t\t\t\t   struct system_counterval_t *sys_counterval,\n\t\t\t\t   void *ctx),\n\t\t\t\t  void *ctx,\n\t\t\t\t  struct system_time_snapshot *history_begin,\n\t\t\t\t  struct system_device_crosststamp *xtstamp)\n{\n\tstruct system_counterval_t system_counterval;\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tu64 cycles, now, interval_start;\n\tunsigned int clock_was_set_seq = 0;\n\tktime_t base_real, base_raw;\n\tu64 nsec_real, nsec_raw;\n\tu8 cs_was_changed_seq;\n\tunsigned int seq;\n\tbool do_interp;\n\tint ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\t/*\n\t\t * Try to synchronously capture device time and a system\n\t\t * counter value calling back into the device driver\n\t\t */\n\t\tret = get_time_fn(&xtstamp->device, &system_counterval, ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * Verify that the clocksource associated with the captured\n\t\t * system counter value is the same as the currently installed\n\t\t * timekeeper clocksource\n\t\t */\n\t\tif (tk->tkr_mono.clock != system_counterval.cs)\n\t\t\treturn -ENODEV;\n\t\tcycles = system_counterval.cycles;\n\n\t\t/*\n\t\t * Check whether the system counter value provided by the\n\t\t * device driver is on the current timekeeping interval.\n\t\t */\n\t\tnow = tk_clock_read(&tk->tkr_mono);\n\t\tinterval_start = tk->tkr_mono.cycle_last;\n\t\tif (!cycle_between(interval_start, cycles, now)) {\n\t\t\tclock_was_set_seq = tk->clock_was_set_seq;\n\t\t\tcs_was_changed_seq = tk->cs_was_changed_seq;\n\t\t\tcycles = interval_start;\n\t\t\tdo_interp = true;\n\t\t} else {\n\t\t\tdo_interp = false;\n\t\t}\n\n\t\tbase_real = ktime_add(tk->tkr_mono.base,\n\t\t\t\t      tk_core.timekeeper.offs_real);\n\t\tbase_raw = tk->tkr_raw.base;\n\n\t\tnsec_real = timekeeping_cycles_to_ns(&tk->tkr_mono,\n\t\t\t\t\t\t     system_counterval.cycles);\n\t\tnsec_raw = timekeeping_cycles_to_ns(&tk->tkr_raw,\n\t\t\t\t\t\t    system_counterval.cycles);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\txtstamp->sys_realtime = ktime_add_ns(base_real, nsec_real);\n\txtstamp->sys_monoraw = ktime_add_ns(base_raw, nsec_raw);\n\n\t/*\n\t * Interpolate if necessary, adjusting back from the start of the\n\t * current interval\n\t */\n\tif (do_interp) {\n\t\tu64 partial_history_cycles, total_history_cycles;\n\t\tbool discontinuity;\n\n\t\t/*\n\t\t * Check that the counter value occurs after the provided\n\t\t * history reference and that the history doesn't cross a\n\t\t * clocksource change\n\t\t */\n\t\tif (!history_begin ||\n\t\t    !cycle_between(history_begin->cycles,\n\t\t\t\t   system_counterval.cycles, cycles) ||\n\t\t    history_begin->cs_was_changed_seq != cs_was_changed_seq)\n\t\t\treturn -EINVAL;\n\t\tpartial_history_cycles = cycles - system_counterval.cycles;\n\t\ttotal_history_cycles = cycles - history_begin->cycles;\n\t\tdiscontinuity =\n\t\t\thistory_begin->clock_was_set_seq != clock_was_set_seq;\n\n\t\tret = adjust_historical_crosststamp(history_begin,\n\t\t\t\t\t\t    partial_history_cycles,\n\t\t\t\t\t\t    total_history_cycles,\n\t\t\t\t\t\t    discontinuity, xtstamp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cycle_between",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1166-1173",
    "snippet": "static bool cycle_between(u64 before, u64 test, u64 after)\n{\n\tif (test > before && test < after)\n\t\treturn true;\n\tif (test < before && before > after)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic bool cycle_between(u64 before, u64 test, u64 after)\n{\n\tif (test > before && test < after)\n\t\treturn true;\n\tif (test < before && before > after)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "adjust_historical_crosststamp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1101-1161",
    "snippet": "static int adjust_historical_crosststamp(struct system_time_snapshot *history,\n\t\t\t\t\t u64 partial_history_cycles,\n\t\t\t\t\t u64 total_history_cycles,\n\t\t\t\t\t bool discontinuity,\n\t\t\t\t\t struct system_device_crosststamp *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tu64 corr_raw, corr_real;\n\tbool interp_forward;\n\tint ret;\n\n\tif (total_history_cycles == 0 || partial_history_cycles == 0)\n\t\treturn 0;\n\n\t/* Interpolate shortest distance from beginning or end of history */\n\tinterp_forward = partial_history_cycles > total_history_cycles / 2;\n\tpartial_history_cycles = interp_forward ?\n\t\ttotal_history_cycles - partial_history_cycles :\n\t\tpartial_history_cycles;\n\n\t/*\n\t * Scale the monotonic raw time delta by:\n\t *\tpartial_history_cycles / total_history_cycles\n\t */\n\tcorr_raw = (u64)ktime_to_ns(\n\t\tktime_sub(ts->sys_monoraw, history->raw));\n\tret = scale64_check_overflow(partial_history_cycles,\n\t\t\t\t     total_history_cycles, &corr_raw);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If there is a discontinuity in the history, scale monotonic raw\n\t *\tcorrection by:\n\t *\tmult(real)/mult(raw) yielding the realtime correction\n\t * Otherwise, calculate the realtime correction similar to monotonic\n\t *\traw calculation\n\t */\n\tif (discontinuity) {\n\t\tcorr_real = mul_u64_u32_div\n\t\t\t(corr_raw, tk->tkr_mono.mult, tk->tkr_raw.mult);\n\t} else {\n\t\tcorr_real = (u64)ktime_to_ns(\n\t\t\tktime_sub(ts->sys_realtime, history->real));\n\t\tret = scale64_check_overflow(partial_history_cycles,\n\t\t\t\t\t     total_history_cycles, &corr_real);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Fixup monotonic raw and real time time values */\n\tif (interp_forward) {\n\t\tts->sys_monoraw = ktime_add_ns(history->raw, corr_raw);\n\t\tts->sys_realtime = ktime_add_ns(history->real, corr_real);\n\t} else {\n\t\tts->sys_monoraw = ktime_sub_ns(ts->sys_monoraw, corr_raw);\n\t\tts->sys_realtime = ktime_sub_ns(ts->sys_realtime, corr_real);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_sub_ns",
          "args": [
            "ts->sys_realtime",
            "corr_real"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub_ns",
          "args": [
            "ts->sys_monoraw",
            "corr_raw"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "history->real",
            "corr_real"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "history->raw",
            "corr_raw"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scale64_check_overflow",
          "args": [
            "partial_history_cycles",
            "total_history_cycles",
            "&corr_real"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "scale64_check_overflow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1068-1082",
          "snippet": "static int scale64_check_overflow(u64 mult, u64 div, u64 *base)\n{\n\tu64 tmp, rem;\n\n\ttmp = div64_u64_rem(*base, div, &rem);\n\n\tif (((int)sizeof(u64)*8 - fls64(mult) < fls64(tmp)) ||\n\t    ((int)sizeof(u64)*8 - fls64(mult) < fls64(rem)))\n\t\treturn -EOVERFLOW;\n\ttmp *= mult;\n\n\trem = div64_u64(rem * mult, div);\n\t*base = tmp + rem;\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic int scale64_check_overflow(u64 mult, u64 div, u64 *base)\n{\n\tu64 tmp, rem;\n\n\ttmp = div64_u64_rem(*base, div, &rem);\n\n\tif (((int)sizeof(u64)*8 - fls64(mult) < fls64(tmp)) ||\n\t    ((int)sizeof(u64)*8 - fls64(mult) < fls64(rem)))\n\t\treturn -EOVERFLOW;\n\ttmp *= mult;\n\n\trem = div64_u64(rem * mult, div);\n\t*base = tmp + rem;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(ts->sys_realtime, history->real)"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ts->sys_realtime",
            "history->real"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mul_u64_u32_div",
          "args": [
            "corr_raw",
            "tk->tkr_mono.mult",
            "tk->tkr_raw.mult"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(ts->sys_monoraw, history->raw)"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ts->sys_monoraw",
            "history->raw"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic int adjust_historical_crosststamp(struct system_time_snapshot *history,\n\t\t\t\t\t u64 partial_history_cycles,\n\t\t\t\t\t u64 total_history_cycles,\n\t\t\t\t\t bool discontinuity,\n\t\t\t\t\t struct system_device_crosststamp *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tu64 corr_raw, corr_real;\n\tbool interp_forward;\n\tint ret;\n\n\tif (total_history_cycles == 0 || partial_history_cycles == 0)\n\t\treturn 0;\n\n\t/* Interpolate shortest distance from beginning or end of history */\n\tinterp_forward = partial_history_cycles > total_history_cycles / 2;\n\tpartial_history_cycles = interp_forward ?\n\t\ttotal_history_cycles - partial_history_cycles :\n\t\tpartial_history_cycles;\n\n\t/*\n\t * Scale the monotonic raw time delta by:\n\t *\tpartial_history_cycles / total_history_cycles\n\t */\n\tcorr_raw = (u64)ktime_to_ns(\n\t\tktime_sub(ts->sys_monoraw, history->raw));\n\tret = scale64_check_overflow(partial_history_cycles,\n\t\t\t\t     total_history_cycles, &corr_raw);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If there is a discontinuity in the history, scale monotonic raw\n\t *\tcorrection by:\n\t *\tmult(real)/mult(raw) yielding the realtime correction\n\t * Otherwise, calculate the realtime correction similar to monotonic\n\t *\traw calculation\n\t */\n\tif (discontinuity) {\n\t\tcorr_real = mul_u64_u32_div\n\t\t\t(corr_raw, tk->tkr_mono.mult, tk->tkr_raw.mult);\n\t} else {\n\t\tcorr_real = (u64)ktime_to_ns(\n\t\t\tktime_sub(ts->sys_realtime, history->real));\n\t\tret = scale64_check_overflow(partial_history_cycles,\n\t\t\t\t\t     total_history_cycles, &corr_real);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Fixup monotonic raw and real time time values */\n\tif (interp_forward) {\n\t\tts->sys_monoraw = ktime_add_ns(history->raw, corr_raw);\n\t\tts->sys_realtime = ktime_add_ns(history->real, corr_real);\n\t} else {\n\t\tts->sys_monoraw = ktime_sub_ns(ts->sys_monoraw, corr_raw);\n\t\tts->sys_realtime = ktime_sub_ns(ts->sys_realtime, corr_real);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "scale64_check_overflow",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1068-1082",
    "snippet": "static int scale64_check_overflow(u64 mult, u64 div, u64 *base)\n{\n\tu64 tmp, rem;\n\n\ttmp = div64_u64_rem(*base, div, &rem);\n\n\tif (((int)sizeof(u64)*8 - fls64(mult) < fls64(tmp)) ||\n\t    ((int)sizeof(u64)*8 - fls64(mult) < fls64(rem)))\n\t\treturn -EOVERFLOW;\n\ttmp *= mult;\n\n\trem = div64_u64(rem * mult, div);\n\t*base = tmp + rem;\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "rem * mult",
            "div"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls64",
          "args": [
            "rem"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls64",
          "args": [
            "mult"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls64",
          "args": [
            "tmp"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls64",
          "args": [
            "mult"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64_rem",
          "args": [
            "*base",
            "div",
            "&rem"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic int scale64_check_overflow(u64 mult, u64 div, u64 *base)\n{\n\tu64 tmp, rem;\n\n\ttmp = div64_u64_rem(*base, div, &rem);\n\n\tif (((int)sizeof(u64)*8 - fls64(mult) < fls64(tmp)) ||\n\t    ((int)sizeof(u64)*8 - fls64(mult) < fls64(rem)))\n\t\treturn -EOVERFLOW;\n\ttmp *= mult;\n\n\trem = div64_u64(rem * mult, div);\n\t*base = tmp + rem;\n\treturn 0;\n}"
  },
  {
    "function_name": "ktime_get_snapshot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1036-1064",
    "snippet": "void ktime_get_snapshot(struct system_time_snapshot *systime_snapshot)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base_raw;\n\tktime_t base_real;\n\tu64 nsec_raw;\n\tu64 nsec_real;\n\tu64 now;\n\n\tWARN_ON_ONCE(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tnow = tk_clock_read(&tk->tkr_mono);\n\t\tsystime_snapshot->cs_id = tk->tkr_mono.clock->id;\n\t\tsystime_snapshot->cs_was_changed_seq = tk->cs_was_changed_seq;\n\t\tsystime_snapshot->clock_was_set_seq = tk->clock_was_set_seq;\n\t\tbase_real = ktime_add(tk->tkr_mono.base,\n\t\t\t\t      tk_core.timekeeper.offs_real);\n\t\tbase_raw = tk->tkr_raw.base;\n\t\tnsec_real = timekeeping_cycles_to_ns(&tk->tkr_mono, now);\n\t\tnsec_raw  = timekeeping_cycles_to_ns(&tk->tkr_raw, now);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tsystime_snapshot->cycles = now;\n\tsystime_snapshot->real = ktime_add_ns(base_real, nsec_real);\n\tsystime_snapshot->raw = ktime_add_ns(base_raw, nsec_raw);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base_raw",
            "nsec_raw"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base_real",
            "nsec_real"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_cycles_to_ns",
          "args": [
            "&tk->tkr_raw",
            "now"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_cycles_to_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "390-397",
          "snippet": "static inline u64 timekeeping_cycles_to_ns(const struct tk_read_base *tkr, u64 cycles)\n{\n\tu64 delta;\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycles, tkr->cycle_last, tkr->mask);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_cycles_to_ns(const struct tk_read_base *tkr, u64 cycles)\n{\n\tu64 delta;\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycles, tkr->cycle_last, tkr->mask);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tk->tkr_mono.base",
            "tk_core.timekeeper.offs_real"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "189-194",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_snapshot(struct system_time_snapshot *systime_snapshot)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base_raw;\n\tktime_t base_real;\n\tu64 nsec_raw;\n\tu64 nsec_real;\n\tu64 now;\n\n\tWARN_ON_ONCE(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tnow = tk_clock_read(&tk->tkr_mono);\n\t\tsystime_snapshot->cs_id = tk->tkr_mono.clock->id;\n\t\tsystime_snapshot->cs_was_changed_seq = tk->cs_was_changed_seq;\n\t\tsystime_snapshot->clock_was_set_seq = tk->clock_was_set_seq;\n\t\tbase_real = ktime_add(tk->tkr_mono.base,\n\t\t\t\t      tk_core.timekeeper.offs_real);\n\t\tbase_raw = tk->tkr_raw.base;\n\t\tnsec_real = timekeeping_cycles_to_ns(&tk->tkr_mono, now);\n\t\tnsec_raw  = timekeeping_cycles_to_ns(&tk->tkr_raw, now);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tsystime_snapshot->cycles = now;\n\tsystime_snapshot->real = ktime_add_ns(base_real, nsec_real);\n\tsystime_snapshot->raw = ktime_add_ns(base_raw, nsec_raw);\n}"
  },
  {
    "function_name": "__ktime_get_real_seconds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1025-1030",
    "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
  },
  {
    "function_name": "ktime_get_real_seconds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "1001-1017",
    "snippet": "time64_t ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\ttime64_t seconds;\n\tunsigned int seq;\n\n\tif (IS_ENABLED(CONFIG_64BIT))\n\t\treturn tk->xtime_sec;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tseconds = tk->xtime_sec;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn seconds;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_64BIT"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\ttime64_t seconds;\n\tunsigned int seq;\n\n\tif (IS_ENABLED(CONFIG_64BIT))\n\t\treturn tk->xtime_sec;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tseconds = tk->xtime_sec;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn seconds;\n}"
  },
  {
    "function_name": "ktime_get_seconds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "982-988",
    "snippet": "time64_t ktime_get_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tWARN_ON(timekeeping_suspended);\n\treturn tk->ktime_sec;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t ktime_get_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tWARN_ON(timekeeping_suspended);\n\treturn tk->ktime_sec;\n}"
  },
  {
    "function_name": "ktime_get_ts64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "950-970",
    "snippet": "void ktime_get_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 tomono;\n\tunsigned int seq;\n\tu64 nsec;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsec = timekeeping_get_ns(&tk->tkr_mono);\n\t\ttomono = tk->wall_to_monotonic;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_sec += tomono.tv_sec;\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsec + tomono.tv_nsec);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec64_add_ns",
          "args": [
            "ts",
            "nsec + tomono.tv_nsec"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_get_ns",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_get_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "382-388",
          "snippet": "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 tomono;\n\tunsigned int seq;\n\tu64 nsec;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsec = timekeeping_get_ns(&tk->tkr_mono);\n\t\ttomono = tk->wall_to_monotonic;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_sec += tomono.tv_sec;\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsec + tomono.tv_nsec);\n}"
  },
  {
    "function_name": "ktime_get_raw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "924-939",
    "snippet": "ktime_t ktime_get_raw(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tbase = tk->tkr_raw.base;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_raw);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ktime_add_ns(base, nsecs);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base",
            "nsecs"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_get_ns",
          "args": [
            "&tk->tkr_raw"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_get_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "382-388",
          "snippet": "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nktime_t ktime_get_raw(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tbase = tk->tkr_raw.base;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_raw);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ktime_add_ns(base, nsecs);\n}"
  },
  {
    "function_name": "ktime_mono_to_any",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "906-918",
    "snippet": "ktime_t ktime_mono_to_any(ktime_t tmono, enum tk_offsets offs)\n{\n\tktime_t *offset = offsets[offs];\n\tunsigned int seq;\n\tktime_t tconv;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\ttconv = ktime_add(tmono, *offset);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn tconv;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ktime_t *offsets[TK_OFFS_MAX] = {\n\t[TK_OFFS_REAL]\t= &tk_core.timekeeper.offs_real,\n\t[TK_OFFS_BOOT]\t= &tk_core.timekeeper.offs_boot,\n\t[TK_OFFS_TAI]\t= &tk_core.timekeeper.offs_tai,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tmono",
            "*offset"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic ktime_t *offsets[TK_OFFS_MAX] = {\n\t[TK_OFFS_REAL]\t= &tk_core.timekeeper.offs_real,\n\t[TK_OFFS_BOOT]\t= &tk_core.timekeeper.offs_boot,\n\t[TK_OFFS_TAI]\t= &tk_core.timekeeper.offs_tai,\n};\n\nktime_t ktime_mono_to_any(ktime_t tmono, enum tk_offsets offs)\n{\n\tktime_t *offset = offsets[offs];\n\tunsigned int seq;\n\tktime_t tconv;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\ttconv = ktime_add(tmono, *offset);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn tconv;\n}"
  },
  {
    "function_name": "ktime_get_coarse_with_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "881-898",
    "snippet": "ktime_t ktime_get_coarse_with_offset(enum tk_offsets offs)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base, *offset = offsets[offs];\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tbase = ktime_add(tk->tkr_mono.base, *offset);\n\t\tnsecs = tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ktime_add_ns(base, nsecs);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ktime_t *offsets[TK_OFFS_MAX] = {\n\t[TK_OFFS_REAL]\t= &tk_core.timekeeper.offs_real,\n\t[TK_OFFS_BOOT]\t= &tk_core.timekeeper.offs_boot,\n\t[TK_OFFS_TAI]\t= &tk_core.timekeeper.offs_tai,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base",
            "nsecs"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tk->tkr_mono.base",
            "*offset"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic ktime_t *offsets[TK_OFFS_MAX] = {\n\t[TK_OFFS_REAL]\t= &tk_core.timekeeper.offs_real,\n\t[TK_OFFS_BOOT]\t= &tk_core.timekeeper.offs_boot,\n\t[TK_OFFS_TAI]\t= &tk_core.timekeeper.offs_tai,\n};\n\nktime_t ktime_get_coarse_with_offset(enum tk_offsets offs)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base, *offset = offsets[offs];\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tbase = ktime_add(tk->tkr_mono.base, *offset);\n\t\tnsecs = tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ktime_add_ns(base, nsecs);\n}"
  },
  {
    "function_name": "ktime_get_with_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "860-878",
    "snippet": "ktime_t ktime_get_with_offset(enum tk_offsets offs)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base, *offset = offsets[offs];\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tbase = ktime_add(tk->tkr_mono.base, *offset);\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ktime_add_ns(base, nsecs);\n\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ktime_t *offsets[TK_OFFS_MAX] = {\n\t[TK_OFFS_REAL]\t= &tk_core.timekeeper.offs_real,\n\t[TK_OFFS_BOOT]\t= &tk_core.timekeeper.offs_boot,\n\t[TK_OFFS_TAI]\t= &tk_core.timekeeper.offs_tai,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base",
            "nsecs"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_get_ns",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_get_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "382-388",
          "snippet": "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tk->tkr_mono.base",
            "*offset"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic ktime_t *offsets[TK_OFFS_MAX] = {\n\t[TK_OFFS_REAL]\t= &tk_core.timekeeper.offs_real,\n\t[TK_OFFS_BOOT]\t= &tk_core.timekeeper.offs_boot,\n\t[TK_OFFS_TAI]\t= &tk_core.timekeeper.offs_tai,\n};\n\nktime_t ktime_get_with_offset(enum tk_offsets offs)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base, *offset = offsets[offs];\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tbase = ktime_add(tk->tkr_mono.base, *offset);\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ktime_add_ns(base, nsecs);\n\n}"
  },
  {
    "function_name": "ktime_get_resolution_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "837-851",
    "snippet": "u32 ktime_get_resolution_ns(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu32 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tnsecs = tk->tkr_mono.mult >> tk->tkr_mono.shift;\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn nsecs;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu32 ktime_get_resolution_ns(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu32 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tnsecs = tk->tkr_mono.mult >> tk->tkr_mono.shift;\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn nsecs;\n}"
  },
  {
    "function_name": "ktime_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "817-834",
    "snippet": "ktime_t ktime_get(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tbase = tk->tkr_mono.base;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ktime_add_ns(base, nsecs);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base",
            "nsecs"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_get_ns",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_get_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "382-388",
          "snippet": "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nktime_t ktime_get(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tbase = tk->tkr_mono.base;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ktime_add_ns(base, nsecs);\n}"
  },
  {
    "function_name": "ktime_get_real_ts64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "796-814",
    "snippet": "void ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec64_add_ns",
          "args": [
            "ts",
            "nsecs"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_get_ns",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_get_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "382-388",
          "snippet": "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
  },
  {
    "function_name": "timekeeping_forward_now",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "775-788",
    "snippet": "static void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\ttk_normalize_xtime(tk);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tk_normalize_xtime",
          "args": [
            "tk"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "tk_normalize_xtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "115-125",
          "snippet": "static inline void tk_normalize_xtime(struct timekeeper *tk)\n{\n\twhile (tk->tkr_mono.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_mono.shift)) {\n\t\ttk->tkr_mono.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\t\ttk->xtime_sec++;\n\t}\n\twhile (tk->tkr_raw.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_raw.shift)) {\n\t\ttk->tkr_raw.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\t\ttk->raw_sec++;\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_normalize_xtime(struct timekeeper *tk)\n{\n\twhile (tk->tkr_mono.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_mono.shift)) {\n\t\ttk->tkr_mono.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\t\ttk->xtime_sec++;\n\t}\n\twhile (tk->tkr_raw.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_raw.shift)) {\n\t\ttk->tkr_raw.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\t\ttk->raw_sec++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "cycle_now",
            "tk->tkr_mono.cycle_last",
            "tk->tkr_mono.mask"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping_internal.h",
          "lines": "30-33",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/spinlock.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "189-194",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\ttk_normalize_xtime(tk);\n}"
  },
  {
    "function_name": "timekeeping_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "738-765",
    "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)",
      "#define TK_MIRROR\t\t(1 << 1)",
      "#define TK_CLEAR_NTP\t\t(1 << 0)"
    ],
    "globals_used": [
      "static struct timekeeper shadow_timekeeper;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&shadow_timekeeper",
            "&tk_core.timekeeper",
            "sizeof(tk_core.timekeeper)"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_fast_timekeeper",
          "args": [
            "&tk->tkr_raw",
            "&tk_fast_raw"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "update_fast_timekeeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "414-430",
          "snippet": "static void update_fast_timekeeper(const struct tk_read_base *tkr,\n\t\t\t\t   struct tk_fast *tkf)\n{\n\tstruct tk_read_base *base = tkf->base;\n\n\t/* Force readers off to base[1] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[0] */\n\tmemcpy(base, tkr, sizeof(*base));\n\n\t/* Force readers back to base[0] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[1] */\n\tmemcpy(base + 1, base, sizeof(*base));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void update_fast_timekeeper(const struct tk_read_base *tkr,\n\t\t\t\t   struct tk_fast *tkf)\n{\n\tstruct tk_read_base *base = tkf->base;\n\n\t/* Force readers off to base[1] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[0] */\n\tmemcpy(base, tkr, sizeof(*base));\n\n\t/* Force readers back to base[0] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[1] */\n\tmemcpy(base + 1, base, sizeof(*base));\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pvclock_gtod",
          "args": [
            "tk",
            "action & TK_CLOCK_WAS_SET"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "update_pvclock_gtod",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "651-654",
          "snippet": "static void update_pvclock_gtod(struct timekeeper *tk, bool was_set)\n{\n\traw_notifier_call_chain(&pvclock_gtod_chain, was_set, tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RAW_NOTIFIER_HEAD(pvclock_gtod_chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic RAW_NOTIFIER_HEAD(pvclock_gtod_chain);\n\nstatic void update_pvclock_gtod(struct timekeeper *tk, bool was_set)\n{\n\traw_notifier_call_chain(&pvclock_gtod_chain, was_set, tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_vsyscall",
          "args": [
            "tk"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "update_vsyscall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/vsyscall.c",
          "lines": "72-121",
          "snippet": "void update_vsyscall(struct timekeeper *tk)\n{\n\tstruct vdso_data *vdata = __arch_get_k_vdso_data();\n\tstruct vdso_timestamp *vdso_ts;\n\ts32 clock_mode;\n\tu64 nsec;\n\n\t/* copy vsyscall data */\n\tvdso_write_begin(vdata);\n\n\tclock_mode = tk->tkr_mono.clock->vdso_clock_mode;\n\tvdata[CS_HRES_COARSE].clock_mode\t= clock_mode;\n\tvdata[CS_RAW].clock_mode\t\t= clock_mode;\n\n\t/* CLOCK_REALTIME also required for time() */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_REALTIME];\n\tvdso_ts->sec\t= tk->xtime_sec;\n\tvdso_ts->nsec\t= tk->tkr_mono.xtime_nsec;\n\n\t/* CLOCK_REALTIME_COARSE */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_REALTIME_COARSE];\n\tvdso_ts->sec\t= tk->xtime_sec;\n\tvdso_ts->nsec\t= tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift;\n\n\t/* CLOCK_MONOTONIC_COARSE */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_MONOTONIC_COARSE];\n\tvdso_ts->sec\t= tk->xtime_sec + tk->wall_to_monotonic.tv_sec;\n\tnsec\t\t= tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift;\n\tnsec\t\t= nsec + tk->wall_to_monotonic.tv_nsec;\n\tvdso_ts->sec\t+= __iter_div_u64_rem(nsec, NSEC_PER_SEC, &vdso_ts->nsec);\n\n\t/*\n\t * Read without the seqlock held by clock_getres().\n\t * Note: No need to have a second copy.\n\t */\n\tWRITE_ONCE(vdata[CS_HRES_COARSE].hrtimer_res, hrtimer_resolution);\n\n\t/*\n\t * If the current clocksource is not VDSO capable, then spare the\n\t * update of the high resolution parts.\n\t */\n\tif (clock_mode != VDSO_CLOCKMODE_NONE)\n\t\tupdate_vdso_data(vdata, tk);\n\n\t__arch_update_vsyscall(vdata, tk);\n\n\tvdso_write_end(vdata);\n\n\t__arch_sync_vdso_data(vdata);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include <vdso/vsyscall.h>",
            "#include <vdso/helpers.h>",
            "#include <vdso/datapage.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include <vdso/vsyscall.h>\n#include <vdso/helpers.h>\n#include <vdso/datapage.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/hrtimer.h>\n\nvoid update_vsyscall(struct timekeeper *tk)\n{\n\tstruct vdso_data *vdata = __arch_get_k_vdso_data();\n\tstruct vdso_timestamp *vdso_ts;\n\ts32 clock_mode;\n\tu64 nsec;\n\n\t/* copy vsyscall data */\n\tvdso_write_begin(vdata);\n\n\tclock_mode = tk->tkr_mono.clock->vdso_clock_mode;\n\tvdata[CS_HRES_COARSE].clock_mode\t= clock_mode;\n\tvdata[CS_RAW].clock_mode\t\t= clock_mode;\n\n\t/* CLOCK_REALTIME also required for time() */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_REALTIME];\n\tvdso_ts->sec\t= tk->xtime_sec;\n\tvdso_ts->nsec\t= tk->tkr_mono.xtime_nsec;\n\n\t/* CLOCK_REALTIME_COARSE */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_REALTIME_COARSE];\n\tvdso_ts->sec\t= tk->xtime_sec;\n\tvdso_ts->nsec\t= tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift;\n\n\t/* CLOCK_MONOTONIC_COARSE */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_MONOTONIC_COARSE];\n\tvdso_ts->sec\t= tk->xtime_sec + tk->wall_to_monotonic.tv_sec;\n\tnsec\t\t= tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift;\n\tnsec\t\t= nsec + tk->wall_to_monotonic.tv_nsec;\n\tvdso_ts->sec\t+= __iter_div_u64_rem(nsec, NSEC_PER_SEC, &vdso_ts->nsec);\n\n\t/*\n\t * Read without the seqlock held by clock_getres().\n\t * Note: No need to have a second copy.\n\t */\n\tWRITE_ONCE(vdata[CS_HRES_COARSE].hrtimer_res, hrtimer_resolution);\n\n\t/*\n\t * If the current clocksource is not VDSO capable, then spare the\n\t * update of the high resolution parts.\n\t */\n\tif (clock_mode != VDSO_CLOCKMODE_NONE)\n\t\tupdate_vdso_data(vdata, tk);\n\n\t__arch_update_vsyscall(vdata, tk);\n\n\tvdso_write_end(vdata);\n\n\t__arch_sync_vdso_data(vdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_update_ktime_data",
          "args": [
            "tk"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "tk_update_ktime_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "707-735",
          "snippet": "static inline void tk_update_ktime_data(struct timekeeper *tk)\n{\n\tu64 seconds;\n\tu32 nsec;\n\n\t/*\n\t * The xtime based monotonic readout is:\n\t *\tnsec = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec + now();\n\t * The ktime based monotonic readout is:\n\t *\tnsec = base_mono + now();\n\t * ==> base_mono = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec\n\t */\n\tseconds = (u64)(tk->xtime_sec + tk->wall_to_monotonic.tv_sec);\n\tnsec = (u32) tk->wall_to_monotonic.tv_nsec;\n\ttk->tkr_mono.base = ns_to_ktime(seconds * NSEC_PER_SEC + nsec);\n\n\t/*\n\t * The sum of the nanoseconds portions of xtime and\n\t * wall_to_monotonic can be greater/equal one second. Take\n\t * this into account before updating tk->ktime_sec.\n\t */\n\tnsec += (u32)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\tif (nsec >= NSEC_PER_SEC)\n\t\tseconds++;\n\ttk->ktime_sec = seconds;\n\n\t/* Update the monotonic raw base */\n\ttk->tkr_raw.base = ns_to_ktime(tk->raw_sec * NSEC_PER_SEC);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_update_ktime_data(struct timekeeper *tk)\n{\n\tu64 seconds;\n\tu32 nsec;\n\n\t/*\n\t * The xtime based monotonic readout is:\n\t *\tnsec = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec + now();\n\t * The ktime based monotonic readout is:\n\t *\tnsec = base_mono + now();\n\t * ==> base_mono = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec\n\t */\n\tseconds = (u64)(tk->xtime_sec + tk->wall_to_monotonic.tv_sec);\n\tnsec = (u32) tk->wall_to_monotonic.tv_nsec;\n\ttk->tkr_mono.base = ns_to_ktime(seconds * NSEC_PER_SEC + nsec);\n\n\t/*\n\t * The sum of the nanoseconds portions of xtime and\n\t * wall_to_monotonic can be greater/equal one second. Take\n\t * this into account before updating tk->ktime_sec.\n\t */\n\tnsec += (u32)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\tif (nsec >= NSEC_PER_SEC)\n\t\tseconds++;\n\ttk->ktime_sec = seconds;\n\n\t/* Update the monotonic raw base */\n\ttk->tkr_raw.base = ns_to_ktime(tk->raw_sec * NSEC_PER_SEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_update_leap_state",
          "args": [
            "tk"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "tk_update_leap_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "696-702",
          "snippet": "static inline void tk_update_leap_state(struct timekeeper *tk)\n{\n\ttk->next_leap_ktime = ntp_get_next_leap();\n\tif (tk->next_leap_ktime != KTIME_MAX)\n\t\t/* Convert to monotonic time */\n\t\ttk->next_leap_ktime = ktime_sub(tk->next_leap_ktime, tk->offs_real);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_update_leap_state(struct timekeeper *tk)\n{\n\ttk->next_leap_ktime = ntp_get_next_leap();\n\tif (tk->next_leap_ktime != KTIME_MAX)\n\t\t/* Convert to monotonic time */\n\t\ttk->next_leap_ktime = ktime_sub(tk->next_leap_ktime, tk->offs_real);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntp_clear",
          "args": [],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "351-366",
          "snippet": "void ntp_clear(void)\n{\n\ttime_adjust\t= 0;\t\t/* stop active adjtime() */\n\ttime_status\t|= STA_UNSYNC;\n\ttime_maxerror\t= NTP_PHASE_LIMIT;\n\ttime_esterror\t= NTP_PHASE_LIMIT;\n\n\tntp_update_frequency();\n\n\ttick_length\t= tick_length_base;\n\ttime_offset\t= 0;\n\n\tntp_next_leap_sec = TIME64_MAX;\n\t/* Clear PPS state variables */\n\tpps_clear();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64\t\t\ttick_length;",
            "static u64\t\t\ttick_length_base;",
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static s64\t\t\ttime_offset;",
            "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
            "static long\t\t\ttime_esterror = NTP_PHASE_LIMIT;",
            "static long\t\t\ttime_adjust;",
            "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_esterror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_adjust;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nvoid ntp_clear(void)\n{\n\ttime_adjust\t= 0;\t\t/* stop active adjtime() */\n\ttime_status\t|= STA_UNSYNC;\n\ttime_maxerror\t= NTP_PHASE_LIMIT;\n\ttime_esterror\t= NTP_PHASE_LIMIT;\n\n\tntp_update_frequency();\n\n\ttick_length\t= tick_length_base;\n\ttime_offset\t= 0;\n\n\tntp_next_leap_sec = TIME64_MAX;\n\t/* Clear PPS state variables */\n\tpps_clear();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
  },
  {
    "function_name": "tk_update_ktime_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "707-735",
    "snippet": "static inline void tk_update_ktime_data(struct timekeeper *tk)\n{\n\tu64 seconds;\n\tu32 nsec;\n\n\t/*\n\t * The xtime based monotonic readout is:\n\t *\tnsec = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec + now();\n\t * The ktime based monotonic readout is:\n\t *\tnsec = base_mono + now();\n\t * ==> base_mono = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec\n\t */\n\tseconds = (u64)(tk->xtime_sec + tk->wall_to_monotonic.tv_sec);\n\tnsec = (u32) tk->wall_to_monotonic.tv_nsec;\n\ttk->tkr_mono.base = ns_to_ktime(seconds * NSEC_PER_SEC + nsec);\n\n\t/*\n\t * The sum of the nanoseconds portions of xtime and\n\t * wall_to_monotonic can be greater/equal one second. Take\n\t * this into account before updating tk->ktime_sec.\n\t */\n\tnsec += (u32)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\tif (nsec >= NSEC_PER_SEC)\n\t\tseconds++;\n\ttk->ktime_sec = seconds;\n\n\t/* Update the monotonic raw base */\n\ttk->tkr_raw.base = ns_to_ktime(tk->raw_sec * NSEC_PER_SEC);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "tk->raw_sec * NSEC_PER_SEC"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "seconds * NSEC_PER_SEC + nsec"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tk->xtime_sec + tk->wall_to_monotonic.tv_sec"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_update_ktime_data(struct timekeeper *tk)\n{\n\tu64 seconds;\n\tu32 nsec;\n\n\t/*\n\t * The xtime based monotonic readout is:\n\t *\tnsec = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec + now();\n\t * The ktime based monotonic readout is:\n\t *\tnsec = base_mono + now();\n\t * ==> base_mono = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec\n\t */\n\tseconds = (u64)(tk->xtime_sec + tk->wall_to_monotonic.tv_sec);\n\tnsec = (u32) tk->wall_to_monotonic.tv_nsec;\n\ttk->tkr_mono.base = ns_to_ktime(seconds * NSEC_PER_SEC + nsec);\n\n\t/*\n\t * The sum of the nanoseconds portions of xtime and\n\t * wall_to_monotonic can be greater/equal one second. Take\n\t * this into account before updating tk->ktime_sec.\n\t */\n\tnsec += (u32)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\tif (nsec >= NSEC_PER_SEC)\n\t\tseconds++;\n\ttk->ktime_sec = seconds;\n\n\t/* Update the monotonic raw base */\n\ttk->tkr_raw.base = ns_to_ktime(tk->raw_sec * NSEC_PER_SEC);\n}"
  },
  {
    "function_name": "tk_update_leap_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "696-702",
    "snippet": "static inline void tk_update_leap_state(struct timekeeper *tk)\n{\n\ttk->next_leap_ktime = ntp_get_next_leap();\n\tif (tk->next_leap_ktime != KTIME_MAX)\n\t\t/* Convert to monotonic time */\n\t\ttk->next_leap_ktime = ktime_sub(tk->next_leap_ktime, tk->offs_real);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "tk->next_leap_ktime",
            "tk->offs_real"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntp_get_next_leap",
          "args": [],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_get_next_leap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "380-388",
          "snippet": "ktime_t ntp_get_next_leap(void)\n{\n\tktime_t ret;\n\n\tif ((time_state == TIME_INS) && (time_status & STA_INS))\n\t\treturn ktime_set(ntp_next_leap_sec, 0);\n\tret = KTIME_MAX;\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\ttime_state = TIME_OK;",
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_state = TIME_OK;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nktime_t ntp_get_next_leap(void)\n{\n\tktime_t ret;\n\n\tif ((time_state == TIME_INS) && (time_status & STA_INS))\n\t\treturn ktime_set(ntp_next_leap_sec, 0);\n\tret = KTIME_MAX;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_update_leap_state(struct timekeeper *tk)\n{\n\ttk->next_leap_ktime = ntp_get_next_leap();\n\tif (tk->next_leap_ktime != KTIME_MAX)\n\t\t/* Convert to monotonic time */\n\t\ttk->next_leap_ktime = ktime_sub(tk->next_leap_ktime, tk->offs_real);\n}"
  },
  {
    "function_name": "pvclock_gtod_unregister_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "680-690",
    "snippet": "int pvclock_gtod_unregister_notifier(struct notifier_block *nb)\n{\n\tunsigned long flags;\n\tint ret;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\tret = raw_notifier_chain_unregister(&pvclock_gtod_chain, nb);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static RAW_NOTIFIER_HEAD(pvclock_gtod_chain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_notifier_chain_unregister",
          "args": [
            "&pvclock_gtod_chain",
            "nb"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "raw_notifier_chain_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "358-362",
          "snippet": "int raw_notifier_chain_unregister(struct raw_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\treturn notifier_chain_unregister(&nh->head, n);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint raw_notifier_chain_unregister(struct raw_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\treturn notifier_chain_unregister(&nh->head, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic RAW_NOTIFIER_HEAD(pvclock_gtod_chain);\n\nint pvclock_gtod_unregister_notifier(struct notifier_block *nb)\n{\n\tunsigned long flags;\n\tint ret;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\tret = raw_notifier_chain_unregister(&pvclock_gtod_chain, nb);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pvclock_gtod_register_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "660-672",
    "snippet": "int pvclock_gtod_register_notifier(struct notifier_block *nb)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tint ret;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\tret = raw_notifier_chain_register(&pvclock_gtod_chain, nb);\n\tupdate_pvclock_gtod(tk, true);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static RAW_NOTIFIER_HEAD(pvclock_gtod_chain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pvclock_gtod",
          "args": [
            "tk",
            "true"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "update_pvclock_gtod",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "651-654",
          "snippet": "static void update_pvclock_gtod(struct timekeeper *tk, bool was_set)\n{\n\traw_notifier_call_chain(&pvclock_gtod_chain, was_set, tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RAW_NOTIFIER_HEAD(pvclock_gtod_chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic RAW_NOTIFIER_HEAD(pvclock_gtod_chain);\n\nstatic void update_pvclock_gtod(struct timekeeper *tk, bool was_set)\n{\n\traw_notifier_call_chain(&pvclock_gtod_chain, was_set, tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_notifier_chain_register",
          "args": [
            "&pvclock_gtod_chain",
            "nb"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "raw_notifier_chain_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "341-345",
          "snippet": "int raw_notifier_chain_register(struct raw_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\treturn notifier_chain_register(&nh->head, n);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint raw_notifier_chain_register(struct raw_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\treturn notifier_chain_register(&nh->head, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic RAW_NOTIFIER_HEAD(pvclock_gtod_chain);\n\nint pvclock_gtod_register_notifier(struct notifier_block *nb)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tint ret;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\tret = raw_notifier_chain_register(&pvclock_gtod_chain, nb);\n\tupdate_pvclock_gtod(tk, true);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "update_pvclock_gtod",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "651-654",
    "snippet": "static void update_pvclock_gtod(struct timekeeper *tk, bool was_set)\n{\n\traw_notifier_call_chain(&pvclock_gtod_chain, was_set, tk);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static RAW_NOTIFIER_HEAD(pvclock_gtod_chain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_notifier_call_chain",
          "args": [
            "&pvclock_gtod_chain",
            "was_set",
            "tk"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "raw_notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "389-393",
          "snippet": "int raw_notifier_call_chain(struct raw_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn notifier_call_chain(&nh->head, val, v, -1, NULL);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint raw_notifier_call_chain(struct raw_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn notifier_call_chain(&nh->head, val, v, -1, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic RAW_NOTIFIER_HEAD(pvclock_gtod_chain);\n\nstatic void update_pvclock_gtod(struct timekeeper *tk, bool was_set)\n{\n\traw_notifier_call_chain(&pvclock_gtod_chain, was_set, tk);\n}"
  },
  {
    "function_name": "halt_fast_timekeeper",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "632-647",
    "snippet": "static void halt_fast_timekeeper(const struct timekeeper *tk)\n{\n\tstatic struct tk_read_base tkr_dummy;\n\tconst struct tk_read_base *tkr = &tk->tkr_mono;\n\n\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));\n\tcycles_at_suspend = tk_clock_read(tkr);\n\ttkr_dummy.clock = &dummy_clock;\n\ttkr_dummy.base_real = tkr->base + tk->offs_real;\n\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_mono);\n\n\ttkr = &tk->tkr_raw;\n\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));\n\ttkr_dummy.clock = &dummy_clock;\n\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_raw);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 cycles_at_suspend;",
      "static struct clocksource dummy_clock = {\n\t.read = dummy_clock_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_fast_timekeeper",
          "args": [
            "&tkr_dummy",
            "&tk_fast_raw"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "update_fast_timekeeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "414-430",
          "snippet": "static void update_fast_timekeeper(const struct tk_read_base *tkr,\n\t\t\t\t   struct tk_fast *tkf)\n{\n\tstruct tk_read_base *base = tkf->base;\n\n\t/* Force readers off to base[1] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[0] */\n\tmemcpy(base, tkr, sizeof(*base));\n\n\t/* Force readers back to base[0] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[1] */\n\tmemcpy(base + 1, base, sizeof(*base));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void update_fast_timekeeper(const struct tk_read_base *tkr,\n\t\t\t\t   struct tk_fast *tkf)\n{\n\tstruct tk_read_base *base = tkf->base;\n\n\t/* Force readers off to base[1] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[0] */\n\tmemcpy(base, tkr, sizeof(*base));\n\n\t/* Force readers back to base[0] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[1] */\n\tmemcpy(base + 1, base, sizeof(*base));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tkr_dummy",
            "tkr",
            "sizeof(tkr_dummy)"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "tkr"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "189-194",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic u64 cycles_at_suspend;\nstatic struct clocksource dummy_clock = {\n\t.read = dummy_clock_read,\n};\n\nstatic void halt_fast_timekeeper(const struct timekeeper *tk)\n{\n\tstatic struct tk_read_base tkr_dummy;\n\tconst struct tk_read_base *tkr = &tk->tkr_mono;\n\n\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));\n\tcycles_at_suspend = tk_clock_read(tkr);\n\ttkr_dummy.clock = &dummy_clock;\n\ttkr_dummy.base_real = tkr->base + tk->offs_real;\n\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_mono);\n\n\ttkr = &tk->tkr_raw;\n\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));\n\ttkr_dummy.clock = &dummy_clock;\n\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_raw);\n}"
  },
  {
    "function_name": "ktime_get_fast_timestamps",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "614-620",
    "snippet": "void ktime_get_fast_timestamps(struct ktime_timestamps *snapshot)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tsnapshot->real = __ktime_get_real_fast(&tk_fast_mono, &snapshot->mono);\n\tsnapshot->boot = snapshot->mono + ktime_to_ns(data_race(tk->offs_boot));\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "data_race(tk->offs_boot)"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_race",
          "args": [
            "tk->offs_boot"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_race",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "998-1008",
          "snippet": "__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ktime_get_real_fast",
          "args": [
            "&tk_fast_mono",
            "&snapshot->mono"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_fast",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "535-555",
          "snippet": "static __always_inline u64 __ktime_get_real_fast(struct tk_fast *tkf, u64 *mono)\n{\n\tstruct tk_read_base *tkr;\n\tu64 basem, baser, delta;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tbasem = ktime_to_ns(tkr->base);\n\t\tbaser = ktime_to_ns(tkr->base_real);\n\n\t\tdelta = timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(tk_clock_read(tkr),\n\t\t\t\ttkr->cycle_last, tkr->mask));\n\t} while (read_seqcount_latch_retry(&tkf->seq, seq));\n\n\tif (mono)\n\t\t*mono = basem + delta;\n\treturn baser + delta;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic __always_inline u64 __ktime_get_real_fast(struct tk_fast *tkf, u64 *mono)\n{\n\tstruct tk_read_base *tkr;\n\tu64 basem, baser, delta;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tbasem = ktime_to_ns(tkr->base);\n\t\tbaser = ktime_to_ns(tkr->base_real);\n\n\t\tdelta = timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(tk_clock_read(tkr),\n\t\t\t\ttkr->cycle_last, tkr->mask));\n\t} while (read_seqcount_latch_retry(&tkf->seq, seq));\n\n\tif (mono)\n\t\t*mono = basem + delta;\n\treturn baser + delta;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_fast_timestamps(struct ktime_timestamps *snapshot)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tsnapshot->real = __ktime_get_real_fast(&tk_fast_mono, &snapshot->mono);\n\tsnapshot->boot = snapshot->mono + ktime_to_ns(data_race(tk->offs_boot));\n}"
  },
  {
    "function_name": "ktime_get_real_fast_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "562-565",
    "snippet": "u64 ktime_get_real_fast_ns(void)\n{\n\treturn __ktime_get_real_fast(&tk_fast_mono, NULL);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ktime_get_real_fast",
          "args": [
            "&tk_fast_mono",
            "NULL"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_fast",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "535-555",
          "snippet": "static __always_inline u64 __ktime_get_real_fast(struct tk_fast *tkf, u64 *mono)\n{\n\tstruct tk_read_base *tkr;\n\tu64 basem, baser, delta;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tbasem = ktime_to_ns(tkr->base);\n\t\tbaser = ktime_to_ns(tkr->base_real);\n\n\t\tdelta = timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(tk_clock_read(tkr),\n\t\t\t\ttkr->cycle_last, tkr->mask));\n\t} while (read_seqcount_latch_retry(&tkf->seq, seq));\n\n\tif (mono)\n\t\t*mono = basem + delta;\n\treturn baser + delta;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic __always_inline u64 __ktime_get_real_fast(struct tk_fast *tkf, u64 *mono)\n{\n\tstruct tk_read_base *tkr;\n\tu64 basem, baser, delta;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tbasem = ktime_to_ns(tkr->base);\n\t\tbaser = ktime_to_ns(tkr->base_real);\n\n\t\tdelta = timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(tk_clock_read(tkr),\n\t\t\t\ttkr->cycle_last, tkr->mask));\n\t} while (read_seqcount_latch_retry(&tkf->seq, seq));\n\n\tif (mono)\n\t\t*mono = basem + delta;\n\treturn baser + delta;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_real_fast_ns(void)\n{\n\treturn __ktime_get_real_fast(&tk_fast_mono, NULL);\n}"
  },
  {
    "function_name": "__ktime_get_real_fast",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "535-555",
    "snippet": "static __always_inline u64 __ktime_get_real_fast(struct tk_fast *tkf, u64 *mono)\n{\n\tstruct tk_read_base *tkr;\n\tu64 basem, baser, delta;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tbasem = ktime_to_ns(tkr->base);\n\t\tbaser = ktime_to_ns(tkr->base_real);\n\n\t\tdelta = timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(tk_clock_read(tkr),\n\t\t\t\ttkr->cycle_last, tkr->mask));\n\t} while (read_seqcount_latch_retry(&tkf->seq, seq));\n\n\tif (mono)\n\t\t*mono = basem + delta;\n\treturn baser + delta;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_latch_retry",
          "args": [
            "&tkf->seq",
            "seq"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_delta_to_ns",
          "args": [
            "tkr",
            "clocksource_delta(tk_clock_read(tkr),\n\t\t\t\ttkr->cycle_last, tkr->mask)"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_delta_to_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "372-380",
          "snippet": "static inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\treturn nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "tk_clock_read(tkr)",
            "tkr->cycle_last",
            "tkr->mask"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping_internal.h",
          "lines": "30-33",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/spinlock.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "tkr"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "189-194",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "tkr->base_real"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "tkr->base"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_read_seqcount_latch",
          "args": [
            "&tkf->seq"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic __always_inline u64 __ktime_get_real_fast(struct tk_fast *tkf, u64 *mono)\n{\n\tstruct tk_read_base *tkr;\n\tu64 basem, baser, delta;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tbasem = ktime_to_ns(tkr->base);\n\t\tbaser = ktime_to_ns(tkr->base_real);\n\n\t\tdelta = timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(tk_clock_read(tkr),\n\t\t\t\ttkr->cycle_last, tkr->mask));\n\t} while (read_seqcount_latch_retry(&tkf->seq, seq));\n\n\tif (mono)\n\t\t*mono = basem + delta;\n\treturn baser + delta;\n}"
  },
  {
    "function_name": "ktime_get_boot_fast_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "527-532",
    "snippet": "u64 notrace ktime_get_boot_fast_ns(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn (ktime_get_mono_fast_ns() + ktime_to_ns(tk->offs_boot));\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "tk->offs_boot"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_mono_fast_ns",
          "args": [],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_mono_fast_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "485-488",
          "snippet": "u64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 notrace ktime_get_boot_fast_ns(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn (ktime_get_mono_fast_ns() + ktime_to_ns(tk->offs_boot));\n}"
  },
  {
    "function_name": "ktime_get_raw_fast_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "497-500",
    "snippet": "u64 ktime_get_raw_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_raw);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ktime_get_fast_ns",
          "args": [
            "&tk_fast_raw"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_fast_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "432-451",
          "snippet": "static __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)\n{\n\tstruct tk_read_base *tkr;\n\tunsigned int seq;\n\tu64 now;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tnow = ktime_to_ns(tkr->base);\n\n\t\tnow += timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask));\n\t} while (read_seqcount_latch_retry(&tkf->seq, seq));\n\n\treturn now;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)\n{\n\tstruct tk_read_base *tkr;\n\tunsigned int seq;\n\tu64 now;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tnow = ktime_to_ns(tkr->base);\n\n\t\tnow += timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask));\n\t} while (read_seqcount_latch_retry(&tkf->seq, seq));\n\n\treturn now;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_raw_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_raw);\n}"
  },
  {
    "function_name": "ktime_get_mono_fast_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "485-488",
    "snippet": "u64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ktime_get_fast_ns",
          "args": [
            "&tk_fast_mono"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_fast_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "432-451",
          "snippet": "static __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)\n{\n\tstruct tk_read_base *tkr;\n\tunsigned int seq;\n\tu64 now;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tnow = ktime_to_ns(tkr->base);\n\n\t\tnow += timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask));\n\t} while (read_seqcount_latch_retry(&tkf->seq, seq));\n\n\treturn now;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)\n{\n\tstruct tk_read_base *tkr;\n\tunsigned int seq;\n\tu64 now;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tnow = ktime_to_ns(tkr->base);\n\n\t\tnow += timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask));\n\t} while (read_seqcount_latch_retry(&tkf->seq, seq));\n\n\treturn now;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}"
  },
  {
    "function_name": "__ktime_get_fast_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "432-451",
    "snippet": "static __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)\n{\n\tstruct tk_read_base *tkr;\n\tunsigned int seq;\n\tu64 now;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tnow = ktime_to_ns(tkr->base);\n\n\t\tnow += timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask));\n\t} while (read_seqcount_latch_retry(&tkf->seq, seq));\n\n\treturn now;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_latch_retry",
          "args": [
            "&tkf->seq",
            "seq"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_delta_to_ns",
          "args": [
            "tkr",
            "clocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask)"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_delta_to_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "372-380",
          "snippet": "static inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\treturn nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "tk_clock_read(tkr)",
            "tkr->cycle_last",
            "tkr->mask"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping_internal.h",
          "lines": "30-33",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/spinlock.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "tkr"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "189-194",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "tkr->base"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_read_seqcount_latch",
          "args": [
            "&tkf->seq"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)\n{\n\tstruct tk_read_base *tkr;\n\tunsigned int seq;\n\tu64 now;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tnow = ktime_to_ns(tkr->base);\n\n\t\tnow += timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask));\n\t} while (read_seqcount_latch_retry(&tkf->seq, seq));\n\n\treturn now;\n}"
  },
  {
    "function_name": "update_fast_timekeeper",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "414-430",
    "snippet": "static void update_fast_timekeeper(const struct tk_read_base *tkr,\n\t\t\t\t   struct tk_fast *tkf)\n{\n\tstruct tk_read_base *base = tkf->base;\n\n\t/* Force readers off to base[1] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[0] */\n\tmemcpy(base, tkr, sizeof(*base));\n\n\t/* Force readers back to base[0] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[1] */\n\tmemcpy(base + 1, base, sizeof(*base));\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "base + 1",
            "base",
            "sizeof(*base)"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_latch",
          "args": [
            "&tkf->seq"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_latch",
          "args": [
            "&tkf->seq"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void update_fast_timekeeper(const struct tk_read_base *tkr,\n\t\t\t\t   struct tk_fast *tkf)\n{\n\tstruct tk_read_base *base = tkf->base;\n\n\t/* Force readers off to base[1] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[0] */\n\tmemcpy(base, tkr, sizeof(*base));\n\n\t/* Force readers back to base[0] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[1] */\n\tmemcpy(base + 1, base, sizeof(*base));\n}"
  },
  {
    "function_name": "timekeeping_cycles_to_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "390-397",
    "snippet": "static inline u64 timekeeping_cycles_to_ns(const struct tk_read_base *tkr, u64 cycles)\n{\n\tu64 delta;\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycles, tkr->cycle_last, tkr->mask);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timekeeping_delta_to_ns",
          "args": [
            "tkr",
            "delta"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_delta_to_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "372-380",
          "snippet": "static inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\treturn nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "cycles",
            "tkr->cycle_last",
            "tkr->mask"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping_internal.h",
          "lines": "30-33",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/spinlock.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_cycles_to_ns(const struct tk_read_base *tkr, u64 cycles)\n{\n\tu64 delta;\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycles, tkr->cycle_last, tkr->mask);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
  },
  {
    "function_name": "timekeeping_get_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "382-388",
    "snippet": "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timekeeping_delta_to_ns",
          "args": [
            "tkr",
            "delta"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_delta_to_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "372-380",
          "snippet": "static inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\treturn nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_get_delta",
          "args": [
            "tkr"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_get_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "282-293",
          "snippet": "static inline u64 timekeeping_get_delta(const struct tk_read_base *tkr)\n{\n\tu64 cycle_now, delta;\n\n\t/* read clocksource */\n\tcycle_now = tk_clock_read(tkr);\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycle_now, tkr->cycle_last, tkr->mask);\n\n\treturn delta;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_delta(const struct tk_read_base *tkr)\n{\n\tu64 cycle_now, delta;\n\n\t/* read clocksource */\n\tcycle_now = tk_clock_read(tkr);\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycle_now, tkr->cycle_last, tkr->mask);\n\n\treturn delta;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
  },
  {
    "function_name": "timekeeping_delta_to_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "372-380",
    "snippet": "static inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\treturn nsec;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\treturn nsec;\n}"
  },
  {
    "function_name": "tk_setup_internals",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "307-368",
    "snippet": "static void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)\n{\n\tu64 interval;\n\tu64 tmp, ntpinterval;\n\tstruct clocksource *old_clock;\n\n\t++tk->cs_was_changed_seq;\n\told_clock = tk->tkr_mono.clock;\n\ttk->tkr_mono.clock = clock;\n\ttk->tkr_mono.mask = clock->mask;\n\ttk->tkr_mono.cycle_last = tk_clock_read(&tk->tkr_mono);\n\n\ttk->tkr_raw.clock = clock;\n\ttk->tkr_raw.mask = clock->mask;\n\ttk->tkr_raw.cycle_last = tk->tkr_mono.cycle_last;\n\n\t/* Do the ns -> cycle conversion first, using original mult */\n\ttmp = NTP_INTERVAL_LENGTH;\n\ttmp <<= clock->shift;\n\tntpinterval = tmp;\n\ttmp += clock->mult/2;\n\tdo_div(tmp, clock->mult);\n\tif (tmp == 0)\n\t\ttmp = 1;\n\n\tinterval = (u64) tmp;\n\ttk->cycle_interval = interval;\n\n\t/* Go back from cycles -> shifted ns */\n\ttk->xtime_interval = interval * clock->mult;\n\ttk->xtime_remainder = ntpinterval - tk->xtime_interval;\n\ttk->raw_interval = interval * clock->mult;\n\n\t /* if changing clocks, convert xtime_nsec shift units */\n\tif (old_clock) {\n\t\tint shift_change = clock->shift - old_clock->shift;\n\t\tif (shift_change < 0) {\n\t\t\ttk->tkr_mono.xtime_nsec >>= -shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec >>= -shift_change;\n\t\t} else {\n\t\t\ttk->tkr_mono.xtime_nsec <<= shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec <<= shift_change;\n\t\t}\n\t}\n\n\ttk->tkr_mono.shift = clock->shift;\n\ttk->tkr_raw.shift = clock->shift;\n\n\ttk->ntp_error = 0;\n\ttk->ntp_error_shift = NTP_SCALE_SHIFT - clock->shift;\n\ttk->ntp_tick = ntpinterval << tk->ntp_error_shift;\n\n\t/*\n\t * The timekeeper keeps its own mult values for the currently\n\t * active clocksource. These value will be adjusted via NTP\n\t * to counteract clock drifting.\n\t */\n\ttk->tkr_mono.mult = clock->mult;\n\ttk->tkr_raw.mult = clock->mult;\n\ttk->ntp_err_mult = 0;\n\ttk->skip_second_overflow = 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "clock->mult"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "189-194",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)\n{\n\tu64 interval;\n\tu64 tmp, ntpinterval;\n\tstruct clocksource *old_clock;\n\n\t++tk->cs_was_changed_seq;\n\told_clock = tk->tkr_mono.clock;\n\ttk->tkr_mono.clock = clock;\n\ttk->tkr_mono.mask = clock->mask;\n\ttk->tkr_mono.cycle_last = tk_clock_read(&tk->tkr_mono);\n\n\ttk->tkr_raw.clock = clock;\n\ttk->tkr_raw.mask = clock->mask;\n\ttk->tkr_raw.cycle_last = tk->tkr_mono.cycle_last;\n\n\t/* Do the ns -> cycle conversion first, using original mult */\n\ttmp = NTP_INTERVAL_LENGTH;\n\ttmp <<= clock->shift;\n\tntpinterval = tmp;\n\ttmp += clock->mult/2;\n\tdo_div(tmp, clock->mult);\n\tif (tmp == 0)\n\t\ttmp = 1;\n\n\tinterval = (u64) tmp;\n\ttk->cycle_interval = interval;\n\n\t/* Go back from cycles -> shifted ns */\n\ttk->xtime_interval = interval * clock->mult;\n\ttk->xtime_remainder = ntpinterval - tk->xtime_interval;\n\ttk->raw_interval = interval * clock->mult;\n\n\t /* if changing clocks, convert xtime_nsec shift units */\n\tif (old_clock) {\n\t\tint shift_change = clock->shift - old_clock->shift;\n\t\tif (shift_change < 0) {\n\t\t\ttk->tkr_mono.xtime_nsec >>= -shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec >>= -shift_change;\n\t\t} else {\n\t\t\ttk->tkr_mono.xtime_nsec <<= shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec <<= shift_change;\n\t\t}\n\t}\n\n\ttk->tkr_mono.shift = clock->shift;\n\ttk->tkr_raw.shift = clock->shift;\n\n\ttk->ntp_error = 0;\n\ttk->ntp_error_shift = NTP_SCALE_SHIFT - clock->shift;\n\ttk->ntp_tick = ntpinterval << tk->ntp_error_shift;\n\n\t/*\n\t * The timekeeper keeps its own mult values for the currently\n\t * active clocksource. These value will be adjusted via NTP\n\t * to counteract clock drifting.\n\t */\n\ttk->tkr_mono.mult = clock->mult;\n\ttk->tkr_raw.mult = clock->mult;\n\ttk->ntp_err_mult = 0;\n\ttk->skip_second_overflow = 0;\n}"
  },
  {
    "function_name": "timekeeping_get_delta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "282-293",
    "snippet": "static inline u64 timekeeping_get_delta(const struct tk_read_base *tkr)\n{\n\tu64 cycle_now, delta;\n\n\t/* read clocksource */\n\tcycle_now = tk_clock_read(tkr);\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycle_now, tkr->cycle_last, tkr->mask);\n\n\treturn delta;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "cycle_now",
            "tkr->cycle_last",
            "tkr->mask"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping_internal.h",
          "lines": "30-33",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/spinlock.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "tkr"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "189-194",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_delta(const struct tk_read_base *tkr)\n{\n\tu64 cycle_now, delta;\n\n\t/* read clocksource */\n\tcycle_now = tk_clock_read(tkr);\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycle_now, tkr->cycle_last, tkr->mask);\n\n\treturn delta;\n}"
  },
  {
    "function_name": "timekeeping_check_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "279-281",
    "snippet": "static inline void timekeeping_check_update(struct timekeeper *tk, u64 offset)\n{\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void timekeeping_check_update(struct timekeeper *tk, u64 offset)\n{\n}"
  },
  {
    "function_name": "timekeeping_get_delta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "238-277",
    "snippet": "static inline u64 timekeeping_get_delta(const struct tk_read_base *tkr)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tu64 now, last, mask, max, delta;\n\tunsigned int seq;\n\n\t/*\n\t * Since we're called holding a seqcount, the data may shift\n\t * under us while we're doing the calculation. This can cause\n\t * false positives, since we'd note a problem but throw the\n\t * results away. So nest another seqcount here to atomically\n\t * grab the points we are checking with.\n\t */\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tnow = tk_clock_read(tkr);\n\t\tlast = tkr->cycle_last;\n\t\tmask = tkr->mask;\n\t\tmax = tkr->clock->max_cycles;\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tdelta = clocksource_delta(now, last, mask);\n\n\t/*\n\t * Try to catch underflows by checking if we are seeing small\n\t * mask-relative negative values.\n\t */\n\tif (unlikely((~delta & mask) < (mask >> 3))) {\n\t\ttk->underflow_seen = 1;\n\t\tdelta = 0;\n\t}\n\n\t/* Cap delta value to the max_cycles values to avoid mult overflows */\n\tif (unlikely(delta > max)) {\n\t\ttk->overflow_seen = 1;\n\t\tdelta = tkr->clock->max_cycles;\n\t}\n\n\treturn delta;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "delta > max"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(~delta & mask) < (mask >> 3)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "now",
            "last",
            "mask"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping_internal.h",
          "lines": "30-33",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/spinlock.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "tkr"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "189-194",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_delta(const struct tk_read_base *tkr)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tu64 now, last, mask, max, delta;\n\tunsigned int seq;\n\n\t/*\n\t * Since we're called holding a seqcount, the data may shift\n\t * under us while we're doing the calculation. This can cause\n\t * false positives, since we'd note a problem but throw the\n\t * results away. So nest another seqcount here to atomically\n\t * grab the points we are checking with.\n\t */\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tnow = tk_clock_read(tkr);\n\t\tlast = tkr->cycle_last;\n\t\tmask = tkr->mask;\n\t\tmax = tkr->clock->max_cycles;\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tdelta = clocksource_delta(now, last, mask);\n\n\t/*\n\t * Try to catch underflows by checking if we are seeing small\n\t * mask-relative negative values.\n\t */\n\tif (unlikely((~delta & mask) < (mask >> 3))) {\n\t\ttk->underflow_seen = 1;\n\t\tdelta = 0;\n\t}\n\n\t/* Cap delta value to the max_cycles values to avoid mult overflows */\n\tif (unlikely(delta > max)) {\n\t\ttk->overflow_seen = 1;\n\t\tdelta = tkr->clock->max_cycles;\n\t}\n\n\treturn delta;\n}"
  },
  {
    "function_name": "timekeeping_check_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "199-236",
    "snippet": "static void timekeeping_check_update(struct timekeeper *tk, u64 offset)\n{\n\n\tu64 max_cycles = tk->tkr_mono.clock->max_cycles;\n\tconst char *name = tk->tkr_mono.clock->name;\n\n\tif (offset > max_cycles) {\n\t\tprintk_deferred(\"WARNING: timekeeping: Cycle offset (%lld) is larger than allowed by the '%s' clock's max_cycles value (%lld): time overflow danger\\n\",\n\t\t\t\toffset, name, max_cycles);\n\t\tprintk_deferred(\"         timekeeping: Your kernel is sick, but tries to cope by capping time updates\\n\");\n\t} else {\n\t\tif (offset > (max_cycles >> 1)) {\n\t\t\tprintk_deferred(\"INFO: timekeeping: Cycle offset (%lld) is larger than the '%s' clock's 50%% safety margin (%lld)\\n\",\n\t\t\t\t\toffset, name, max_cycles >> 1);\n\t\t\tprintk_deferred(\"      timekeeping: Your kernel is still fine, but is feeling a bit nervous\\n\");\n\t\t}\n\t}\n\n\tif (tk->underflow_seen) {\n\t\tif (jiffies - tk->last_warning > WARNING_FREQ) {\n\t\t\tprintk_deferred(\"WARNING: Underflow in clocksource '%s' observed, time update ignored.\\n\", name);\n\t\t\tprintk_deferred(\"         Please report this, consider using a different clocksource, if possible.\\n\");\n\t\t\tprintk_deferred(\"         Your kernel is probably still fine.\\n\");\n\t\t\ttk->last_warning = jiffies;\n\t\t}\n\t\ttk->underflow_seen = 0;\n\t}\n\n\tif (tk->overflow_seen) {\n\t\tif (jiffies - tk->last_warning > WARNING_FREQ) {\n\t\t\tprintk_deferred(\"WARNING: Overflow in clocksource '%s' observed, time update capped.\\n\", name);\n\t\t\tprintk_deferred(\"         Please report this, consider using a different clocksource, if possible.\\n\");\n\t\t\tprintk_deferred(\"         Your kernel is probably still fine.\\n\");\n\t\t\ttk->last_warning = jiffies;\n\t\t}\n\t\ttk->overflow_seen = 0;\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define WARNING_FREQ (HZ*300) /* 5 minute rate-limiting */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "\"         Your kernel is probably still fine.\\n\""
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "_printk_deferred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3285-3295",
          "snippet": "int _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define WARNING_FREQ (HZ*300) /* 5 minute rate-limiting */\n\nstatic void timekeeping_check_update(struct timekeeper *tk, u64 offset)\n{\n\n\tu64 max_cycles = tk->tkr_mono.clock->max_cycles;\n\tconst char *name = tk->tkr_mono.clock->name;\n\n\tif (offset > max_cycles) {\n\t\tprintk_deferred(\"WARNING: timekeeping: Cycle offset (%lld) is larger than allowed by the '%s' clock's max_cycles value (%lld): time overflow danger\\n\",\n\t\t\t\toffset, name, max_cycles);\n\t\tprintk_deferred(\"         timekeeping: Your kernel is sick, but tries to cope by capping time updates\\n\");\n\t} else {\n\t\tif (offset > (max_cycles >> 1)) {\n\t\t\tprintk_deferred(\"INFO: timekeeping: Cycle offset (%lld) is larger than the '%s' clock's 50%% safety margin (%lld)\\n\",\n\t\t\t\t\toffset, name, max_cycles >> 1);\n\t\t\tprintk_deferred(\"      timekeeping: Your kernel is still fine, but is feeling a bit nervous\\n\");\n\t\t}\n\t}\n\n\tif (tk->underflow_seen) {\n\t\tif (jiffies - tk->last_warning > WARNING_FREQ) {\n\t\t\tprintk_deferred(\"WARNING: Underflow in clocksource '%s' observed, time update ignored.\\n\", name);\n\t\t\tprintk_deferred(\"         Please report this, consider using a different clocksource, if possible.\\n\");\n\t\t\tprintk_deferred(\"         Your kernel is probably still fine.\\n\");\n\t\t\ttk->last_warning = jiffies;\n\t\t}\n\t\ttk->underflow_seen = 0;\n\t}\n\n\tif (tk->overflow_seen) {\n\t\tif (jiffies - tk->last_warning > WARNING_FREQ) {\n\t\t\tprintk_deferred(\"WARNING: Overflow in clocksource '%s' observed, time update capped.\\n\", name);\n\t\t\tprintk_deferred(\"         Please report this, consider using a different clocksource, if possible.\\n\");\n\t\t\tprintk_deferred(\"         Your kernel is probably still fine.\\n\");\n\t\t\ttk->last_warning = jiffies;\n\t\t}\n\t\ttk->overflow_seen = 0;\n\t}\n}"
  },
  {
    "function_name": "tk_clock_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "189-194",
    "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clock->read",
          "args": [
            "clock"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "tkr->clock"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
  },
  {
    "function_name": "tk_update_sleep_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "166-174",
    "snippet": "static inline void tk_update_sleep_time(struct timekeeper *tk, ktime_t delta)\n{\n\ttk->offs_boot = ktime_add(tk->offs_boot, delta);\n\t/*\n\t * Timespec representation for VDSO update to avoid 64bit division\n\t * on every update.\n\t */\n\ttk->monotonic_to_boot = ktime_to_timespec64(tk->offs_boot);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "tk->offs_boot"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tk->offs_boot",
            "delta"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_update_sleep_time(struct timekeeper *tk, ktime_t delta)\n{\n\ttk->offs_boot = ktime_add(tk->offs_boot, delta);\n\t/*\n\t * Timespec representation for VDSO update to avoid 64bit division\n\t * on every update.\n\t */\n\ttk->monotonic_to_boot = ktime_to_timespec64(tk->offs_boot);\n}"
  },
  {
    "function_name": "tk_set_wall_to_mono",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "149-164",
    "snippet": "static void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tk->offs_real",
            "ktime_set(tk->tai_offset, 0)"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_set",
          "args": [
            "tk->tai_offset",
            "0"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "tmp"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_normalized_timespec64",
          "args": [
            "&tmp",
            "-wtm.tv_sec",
            "-wtm.tv_nsec"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "set_normalized_timespec64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "478-497",
          "snippet": "void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)\n{\n\twhile (nsec >= NSEC_PER_SEC) {\n\t\t/*\n\t\t * The following asm() prevents the compiler from\n\t\t * optimising this loop into a modulo operation. See\n\t\t * also __iter_div_u64_rem() in include/linux/time.h\n\t\t */\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec -= NSEC_PER_SEC;\n\t\t++sec;\n\t}\n\twhile (nsec < 0) {\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec += NSEC_PER_SEC;\n\t\t--sec;\n\t}\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)\n{\n\twhile (nsec >= NSEC_PER_SEC) {\n\t\t/*\n\t\t * The following asm() prevents the compiler from\n\t\t * optimising this loop into a modulo operation. See\n\t\t * also __iter_div_u64_rem() in include/linux/time.h\n\t\t */\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec -= NSEC_PER_SEC;\n\t\t++sec;\n\t}\n\twhile (nsec < 0) {\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec += NSEC_PER_SEC;\n\t\t--sec;\n\t}\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tk->offs_real != timespec64_to_ktime(tmp)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "tmp"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}"
  },
  {
    "function_name": "tk_xtime_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "142-147",
    "snippet": "static void tk_xtime_add(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec += ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec += (u64)ts->tv_nsec << tk->tkr_mono.shift;\n\ttk_normalize_xtime(tk);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tk_normalize_xtime",
          "args": [
            "tk"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "tk_normalize_xtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "115-125",
          "snippet": "static inline void tk_normalize_xtime(struct timekeeper *tk)\n{\n\twhile (tk->tkr_mono.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_mono.shift)) {\n\t\ttk->tkr_mono.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\t\ttk->xtime_sec++;\n\t}\n\twhile (tk->tkr_raw.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_raw.shift)) {\n\t\ttk->tkr_raw.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\t\ttk->raw_sec++;\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_normalize_xtime(struct timekeeper *tk)\n{\n\twhile (tk->tkr_mono.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_mono.shift)) {\n\t\ttk->tkr_mono.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\t\ttk->xtime_sec++;\n\t}\n\twhile (tk->tkr_raw.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_raw.shift)) {\n\t\ttk->tkr_raw.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\t\ttk->raw_sec++;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_xtime_add(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec += ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec += (u64)ts->tv_nsec << tk->tkr_mono.shift;\n\ttk_normalize_xtime(tk);\n}"
  },
  {
    "function_name": "tk_set_xtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "136-140",
    "snippet": "static void tk_set_xtime(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec = ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec = (u64)ts->tv_nsec << tk->tkr_mono.shift;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_xtime(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec = ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec = (u64)ts->tv_nsec << tk->tkr_mono.shift;\n}"
  },
  {
    "function_name": "tk_xtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "127-134",
    "snippet": "static inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}"
  },
  {
    "function_name": "tk_normalize_xtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "115-125",
    "snippet": "static inline void tk_normalize_xtime(struct timekeeper *tk)\n{\n\twhile (tk->tkr_mono.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_mono.shift)) {\n\t\ttk->tkr_mono.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\t\ttk->xtime_sec++;\n\t}\n\twhile (tk->tkr_raw.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_raw.shift)) {\n\t\ttk->tkr_raw.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\t\ttk->raw_sec++;\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_normalize_xtime(struct timekeeper *tk)\n{\n\twhile (tk->tkr_mono.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_mono.shift)) {\n\t\ttk->tkr_mono.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\t\ttk->xtime_sec++;\n\t}\n\twhile (tk->tkr_raw.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_raw.shift)) {\n\t\ttk->tkr_raw.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\t\ttk->raw_sec++;\n\t}\n}"
  },
  {
    "function_name": "dummy_clock_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
    "lines": "77-82",
    "snippet": "static u64 dummy_clock_read(struct clocksource *cs)\n{\n\tif (timekeeping_suspended)\n\t\treturn cycles_at_suspend;\n\treturn local_clock();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 cycles_at_suspend;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_clock",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic u64 cycles_at_suspend;\n\nstatic u64 dummy_clock_read(struct clocksource *cs)\n{\n\tif (timekeeping_suspended)\n\t\treturn cycles_at_suspend;\n\treturn local_clock();\n}"
  }
]