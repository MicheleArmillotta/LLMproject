[
  {
    "function_name": "fork_usermode_driver",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/usermode_driver.c",
    "lines": "169-188",
    "snippet": "int fork_usermode_driver(struct umd_info *info)\n{\n\tstruct subprocess_info *sub_info;\n\tconst char *argv[] = { info->driver_name, NULL };\n\tint err;\n\n\tif (WARN_ON_ONCE(info->tgid))\n\t\treturn -EBUSY;\n\n\terr = -ENOMEM;\n\tsub_info = call_usermodehelper_setup(info->driver_name,\n\t\t\t\t\t     (char **)argv, NULL, GFP_KERNEL,\n\t\t\t\t\t     umd_setup, umd_cleanup, info);\n\tif (!sub_info)\n\t\tgoto out;\n\n\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);\nout:\n\treturn err;\n}",
    "includes": [
      "#include <linux/usermode_driver.h>",
      "#include <linux/task_work.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/mount.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_usermodehelper_exec",
          "args": [
            "sub_info",
            "UMH_WAIT_EXEC"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper_exec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "404-458",
          "snippet": "int call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint retval = 0;\n\n\tif (!sub_info->path) {\n\t\tcall_usermodehelper_freeinfo(sub_info);\n\t\treturn -EINVAL;\n\t}\n\thelper_lock();\n\tif (usermodehelper_disabled) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is no binary for us to call, then just return and get out of\n\t * here.  This allows us to set STATIC_USERMODEHELPER_PATH to \"\" and\n\t * disable all call_usermodehelper() calls.\n\t */\n\tif (strlen(sub_info->path) == 0)\n\t\tgoto out;\n\n\t/*\n\t * Set the completion pointer only if there is a waiter.\n\t * This makes it possible to use umh_complete to free\n\t * the data structure in case of UMH_NO_WAIT.\n\t */\n\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;\n\tsub_info->wait = wait;\n\n\tqueue_work(system_unbound_wq, &sub_info->work);\n\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */\n\t\tgoto unlock;\n\n\tif (wait & UMH_KILLABLE) {\n\t\tretval = wait_for_completion_killable(&done);\n\t\tif (!retval)\n\t\t\tgoto wait_done;\n\n\t\t/* umh_complete() will see NULL and free sub_info */\n\t\tif (xchg(&sub_info->complete, NULL))\n\t\t\tgoto unlock;\n\t\t/* fallthrough, umh_complete() was already called */\n\t}\n\n\twait_for_completion(&done);\nwait_done:\n\tretval = sub_info->retval;\nout:\n\tcall_usermodehelper_freeinfo(sub_info);\nunlock:\n\thelper_unlock();\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\n\nint call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint retval = 0;\n\n\tif (!sub_info->path) {\n\t\tcall_usermodehelper_freeinfo(sub_info);\n\t\treturn -EINVAL;\n\t}\n\thelper_lock();\n\tif (usermodehelper_disabled) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is no binary for us to call, then just return and get out of\n\t * here.  This allows us to set STATIC_USERMODEHELPER_PATH to \"\" and\n\t * disable all call_usermodehelper() calls.\n\t */\n\tif (strlen(sub_info->path) == 0)\n\t\tgoto out;\n\n\t/*\n\t * Set the completion pointer only if there is a waiter.\n\t * This makes it possible to use umh_complete to free\n\t * the data structure in case of UMH_NO_WAIT.\n\t */\n\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;\n\tsub_info->wait = wait;\n\n\tqueue_work(system_unbound_wq, &sub_info->work);\n\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */\n\t\tgoto unlock;\n\n\tif (wait & UMH_KILLABLE) {\n\t\tretval = wait_for_completion_killable(&done);\n\t\tif (!retval)\n\t\t\tgoto wait_done;\n\n\t\t/* umh_complete() will see NULL and free sub_info */\n\t\tif (xchg(&sub_info->complete, NULL))\n\t\t\tgoto unlock;\n\t\t/* fallthrough, umh_complete() was already called */\n\t}\n\n\twait_for_completion(&done);\nwait_done:\n\tretval = sub_info->retval;\nout:\n\tcall_usermodehelper_freeinfo(sub_info);\nunlock:\n\thelper_unlock();\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_usermodehelper_setup",
          "args": [
            "info->driver_name",
            "(char **)argv",
            "NULL",
            "GFP_KERNEL",
            "umd_setup",
            "umd_cleanup",
            "info"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "358-384",
          "snippet": "struct subprocess_info *call_usermodehelper_setup(const char *path, char **argv,\n\t\tchar **envp, gfp_t gfp_mask,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info),\n\t\tvoid *data)\n{\n\tstruct subprocess_info *sub_info;\n\tsub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);\n\tif (!sub_info)\n\t\tgoto out;\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\n#ifdef CONFIG_STATIC_USERMODEHELPER\n\tsub_info->path = CONFIG_STATIC_USERMODEHELPER_PATH;\n#else\n\tsub_info->path = path;\n#endif\n\tsub_info->argv = argv;\n\tsub_info->envp = envp;\n\n\tsub_info->cleanup = cleanup;\n\tsub_info->init = init;\n\tsub_info->data = data;\n  out:\n\treturn sub_info;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct subprocess_info *call_usermodehelper_setup(const char *path, char **argv,\n\t\tchar **envp, gfp_t gfp_mask,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info),\n\t\tvoid *data)\n{\n\tstruct subprocess_info *sub_info;\n\tsub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);\n\tif (!sub_info)\n\t\tgoto out;\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\n#ifdef CONFIG_STATIC_USERMODEHELPER\n\tsub_info->path = CONFIG_STATIC_USERMODEHELPER_PATH;\n#else\n\tsub_info->path = path;\n#endif\n\tsub_info->argv = argv;\n\tsub_info->envp = envp;\n\n\tsub_info->cleanup = cleanup;\n\tsub_info->init = init;\n\tsub_info->data = data;\n  out:\n\treturn sub_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "info->tgid"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/usermode_driver.h>\n#include <linux/task_work.h>\n#include <linux/fs_struct.h>\n#include <linux/mount.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n\nint fork_usermode_driver(struct umd_info *info)\n{\n\tstruct subprocess_info *sub_info;\n\tconst char *argv[] = { info->driver_name, NULL };\n\tint err;\n\n\tif (WARN_ON_ONCE(info->tgid))\n\t\treturn -EBUSY;\n\n\terr = -ENOMEM;\n\tsub_info = call_usermodehelper_setup(info->driver_name,\n\t\t\t\t\t     (char **)argv, NULL, GFP_KERNEL,\n\t\t\t\t\t     umd_setup, umd_cleanup, info);\n\tif (!sub_info)\n\t\tgoto out;\n\n\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "umd_cleanup_helper",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/usermode_driver.c",
    "lines": "150-156",
    "snippet": "void umd_cleanup_helper(struct umd_info *info)\n{\n\tfput(info->pipe_to_umh);\n\tfput(info->pipe_from_umh);\n\tput_pid(info->tgid);\n\tinfo->tgid = NULL;\n}",
    "includes": [
      "#include <linux/usermode_driver.h>",
      "#include <linux/task_work.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/mount.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "info->tgid"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "120-124",
          "snippet": "static void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "info->pipe_from_umh"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "info->pipe_to_umh"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/usermode_driver.h>\n#include <linux/task_work.h>\n#include <linux/fs_struct.h>\n#include <linux/mount.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n\nvoid umd_cleanup_helper(struct umd_info *info)\n{\n\tfput(info->pipe_to_umh);\n\tfput(info->pipe_from_umh);\n\tput_pid(info->tgid);\n\tinfo->tgid = NULL;\n}"
  },
  {
    "function_name": "umd_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/usermode_driver.c",
    "lines": "137-144",
    "snippet": "static void umd_cleanup(struct subprocess_info *info)\n{\n\tstruct umd_info *umd_info = info->data;\n\n\t/* cleanup if umh_setup() was successful but exec failed */\n\tif (info->retval)\n\t\tumd_cleanup_helper(umd_info);\n}",
    "includes": [
      "#include <linux/usermode_driver.h>",
      "#include <linux/task_work.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/mount.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umd_cleanup_helper",
          "args": [
            "umd_info"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "umd_cleanup_helper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/usermode_driver.c",
          "lines": "150-156",
          "snippet": "void umd_cleanup_helper(struct umd_info *info)\n{\n\tfput(info->pipe_to_umh);\n\tfput(info->pipe_from_umh);\n\tput_pid(info->tgid);\n\tinfo->tgid = NULL;\n}",
          "includes": [
            "#include <linux/usermode_driver.h>",
            "#include <linux/task_work.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mount.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/usermode_driver.h>\n#include <linux/task_work.h>\n#include <linux/fs_struct.h>\n#include <linux/mount.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n\nvoid umd_cleanup_helper(struct umd_info *info)\n{\n\tfput(info->pipe_to_umh);\n\tfput(info->pipe_from_umh);\n\tput_pid(info->tgid);\n\tinfo->tgid = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/usermode_driver.h>\n#include <linux/task_work.h>\n#include <linux/fs_struct.h>\n#include <linux/mount.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n\nstatic void umd_cleanup(struct subprocess_info *info)\n{\n\tstruct umd_info *umd_info = info->data;\n\n\t/* cleanup if umh_setup() was successful but exec failed */\n\tif (info->retval)\n\t\tumd_cleanup_helper(umd_info);\n}"
  },
  {
    "function_name": "umd_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/usermode_driver.c",
    "lines": "96-135",
    "snippet": "static int umd_setup(struct subprocess_info *info, struct cred *new)\n{\n\tstruct umd_info *umd_info = info->data;\n\tstruct file *from_umh[2];\n\tstruct file *to_umh[2];\n\tint err;\n\n\t/* create pipe to send data to umh */\n\terr = create_pipe_files(to_umh, 0);\n\tif (err)\n\t\treturn err;\n\terr = replace_fd(0, to_umh[0], 0);\n\tfput(to_umh[0]);\n\tif (err < 0) {\n\t\tfput(to_umh[1]);\n\t\treturn err;\n\t}\n\n\t/* create pipe to receive data from umh */\n\terr = create_pipe_files(from_umh, 0);\n\tif (err) {\n\t\tfput(to_umh[1]);\n\t\treplace_fd(0, NULL, 0);\n\t\treturn err;\n\t}\n\terr = replace_fd(1, from_umh[1], 0);\n\tfput(from_umh[1]);\n\tif (err < 0) {\n\t\tfput(to_umh[1]);\n\t\treplace_fd(0, NULL, 0);\n\t\tfput(from_umh[0]);\n\t\treturn err;\n\t}\n\n\tset_fs_pwd(current->fs, &umd_info->wd);\n\tumd_info->pipe_to_umh = to_umh[1];\n\tumd_info->pipe_from_umh = from_umh[0];\n\tumd_info->tgid = get_pid(task_tgid(current));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/usermode_driver.h>",
      "#include <linux/task_work.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/mount.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_pid",
          "args": [
            "task_tgid(current)"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "460-469",
          "snippet": "struct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "current"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs_pwd",
          "args": [
            "current->fs",
            "&umd_info->wd"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "from_umh[0]"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_fd",
          "args": [
            "0",
            "NULL",
            "0"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "to_umh[1]"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "from_umh[1]"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_fd",
          "args": [
            "1",
            "from_umh[1]",
            "0"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_fd",
          "args": [
            "0",
            "NULL",
            "0"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "to_umh[1]"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_pipe_files",
          "args": [
            "from_umh",
            "0"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "to_umh[1]"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "to_umh[0]"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_fd",
          "args": [
            "0",
            "to_umh[0]",
            "0"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_pipe_files",
          "args": [
            "to_umh",
            "0"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/usermode_driver.h>\n#include <linux/task_work.h>\n#include <linux/fs_struct.h>\n#include <linux/mount.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n\nstatic int umd_setup(struct subprocess_info *info, struct cred *new)\n{\n\tstruct umd_info *umd_info = info->data;\n\tstruct file *from_umh[2];\n\tstruct file *to_umh[2];\n\tint err;\n\n\t/* create pipe to send data to umh */\n\terr = create_pipe_files(to_umh, 0);\n\tif (err)\n\t\treturn err;\n\terr = replace_fd(0, to_umh[0], 0);\n\tfput(to_umh[0]);\n\tif (err < 0) {\n\t\tfput(to_umh[1]);\n\t\treturn err;\n\t}\n\n\t/* create pipe to receive data from umh */\n\terr = create_pipe_files(from_umh, 0);\n\tif (err) {\n\t\tfput(to_umh[1]);\n\t\treplace_fd(0, NULL, 0);\n\t\treturn err;\n\t}\n\terr = replace_fd(1, from_umh[1], 0);\n\tfput(from_umh[1]);\n\tif (err < 0) {\n\t\tfput(to_umh[1]);\n\t\treplace_fd(0, NULL, 0);\n\t\tfput(from_umh[0]);\n\t\treturn err;\n\t}\n\n\tset_fs_pwd(current->fs, &umd_info->wd);\n\tumd_info->pipe_to_umh = to_umh[1];\n\tumd_info->pipe_from_umh = from_umh[0];\n\tumd_info->tgid = get_pid(task_tgid(current));\n\treturn 0;\n}"
  },
  {
    "function_name": "umd_unload_blob",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/usermode_driver.c",
    "lines": "82-93",
    "snippet": "int umd_unload_blob(struct umd_info *info)\n{\n\tif (WARN_ON_ONCE(!info->wd.mnt ||\n\t\t\t !info->wd.dentry ||\n\t\t\t info->wd.mnt->mnt_root != info->wd.dentry))\n\t\treturn -EINVAL;\n\n\tkern_unmount(info->wd.mnt);\n\tinfo->wd.mnt = NULL;\n\tinfo->wd.dentry = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/usermode_driver.h>",
      "#include <linux/task_work.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/mount.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kern_unmount",
          "args": [
            "info->wd.mnt"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!info->wd.mnt ||\n\t\t\t !info->wd.dentry ||\n\t\t\t info->wd.mnt->mnt_root != info->wd.dentry"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/usermode_driver.h>\n#include <linux/task_work.h>\n#include <linux/fs_struct.h>\n#include <linux/mount.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n\nint umd_unload_blob(struct umd_info *info)\n{\n\tif (WARN_ON_ONCE(!info->wd.mnt ||\n\t\t\t !info->wd.dentry ||\n\t\t\t info->wd.mnt->mnt_root != info->wd.dentry))\n\t\treturn -EINVAL;\n\n\tkern_unmount(info->wd.mnt);\n\tinfo->wd.mnt = NULL;\n\tinfo->wd.dentry = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "umd_load_blob",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/usermode_driver.c",
    "lines": "60-74",
    "snippet": "int umd_load_blob(struct umd_info *info, const void *data, size_t len)\n{\n\tstruct vfsmount *mnt;\n\n\tif (WARN_ON_ONCE(info->wd.dentry || info->wd.mnt))\n\t\treturn -EBUSY;\n\n\tmnt = blob_to_mnt(data, len, info->driver_name);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\tinfo->wd.mnt = mnt;\n\tinfo->wd.dentry = mnt->mnt_root;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/usermode_driver.h>",
      "#include <linux/task_work.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/mount.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mnt"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blob_to_mnt",
          "args": [
            "data",
            "len",
            "info->driver_name"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "blob_to_mnt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/usermode_driver.c",
          "lines": "12-51",
          "snippet": "static struct vfsmount *blob_to_mnt(const void *data, size_t len, const char *name)\n{\n\tstruct file_system_type *type;\n\tstruct vfsmount *mnt;\n\tstruct file *file;\n\tssize_t written;\n\tloff_t pos = 0;\n\n\ttype = get_fs_type(\"tmpfs\");\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = kern_mount(type);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn mnt;\n\n\tfile = file_open_root_mnt(mnt, name, O_CREAT | O_WRONLY, 0700);\n\tif (IS_ERR(file)) {\n\t\tmntput(mnt);\n\t\treturn ERR_CAST(file);\n\t}\n\n\twritten = kernel_write(file, data, len, &pos);\n\tif (written != len) {\n\t\tint err = written;\n\t\tif (err >= 0)\n\t\t\terr = -ENOMEM;\n\t\tfilp_close(file, NULL);\n\t\tmntput(mnt);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tfput(file);\n\n\t/* Flush delayed fput so exec can open the file read-only */\n\tflush_delayed_fput();\n\ttask_work_run();\n\treturn mnt;\n}",
          "includes": [
            "#include <linux/usermode_driver.h>",
            "#include <linux/task_work.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mount.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/usermode_driver.h>\n#include <linux/task_work.h>\n#include <linux/fs_struct.h>\n#include <linux/mount.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n\nstatic struct vfsmount *blob_to_mnt(const void *data, size_t len, const char *name)\n{\n\tstruct file_system_type *type;\n\tstruct vfsmount *mnt;\n\tstruct file *file;\n\tssize_t written;\n\tloff_t pos = 0;\n\n\ttype = get_fs_type(\"tmpfs\");\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = kern_mount(type);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn mnt;\n\n\tfile = file_open_root_mnt(mnt, name, O_CREAT | O_WRONLY, 0700);\n\tif (IS_ERR(file)) {\n\t\tmntput(mnt);\n\t\treturn ERR_CAST(file);\n\t}\n\n\twritten = kernel_write(file, data, len, &pos);\n\tif (written != len) {\n\t\tint err = written;\n\t\tif (err >= 0)\n\t\t\terr = -ENOMEM;\n\t\tfilp_close(file, NULL);\n\t\tmntput(mnt);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tfput(file);\n\n\t/* Flush delayed fput so exec can open the file read-only */\n\tflush_delayed_fput();\n\ttask_work_run();\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "info->wd.dentry || info->wd.mnt"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/usermode_driver.h>\n#include <linux/task_work.h>\n#include <linux/fs_struct.h>\n#include <linux/mount.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n\nint umd_load_blob(struct umd_info *info, const void *data, size_t len)\n{\n\tstruct vfsmount *mnt;\n\n\tif (WARN_ON_ONCE(info->wd.dentry || info->wd.mnt))\n\t\treturn -EBUSY;\n\n\tmnt = blob_to_mnt(data, len, info->driver_name);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\tinfo->wd.mnt = mnt;\n\tinfo->wd.dentry = mnt->mnt_root;\n\treturn 0;\n}"
  },
  {
    "function_name": "blob_to_mnt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/usermode_driver.c",
    "lines": "12-51",
    "snippet": "static struct vfsmount *blob_to_mnt(const void *data, size_t len, const char *name)\n{\n\tstruct file_system_type *type;\n\tstruct vfsmount *mnt;\n\tstruct file *file;\n\tssize_t written;\n\tloff_t pos = 0;\n\n\ttype = get_fs_type(\"tmpfs\");\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = kern_mount(type);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn mnt;\n\n\tfile = file_open_root_mnt(mnt, name, O_CREAT | O_WRONLY, 0700);\n\tif (IS_ERR(file)) {\n\t\tmntput(mnt);\n\t\treturn ERR_CAST(file);\n\t}\n\n\twritten = kernel_write(file, data, len, &pos);\n\tif (written != len) {\n\t\tint err = written;\n\t\tif (err >= 0)\n\t\t\terr = -ENOMEM;\n\t\tfilp_close(file, NULL);\n\t\tmntput(mnt);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tfput(file);\n\n\t/* Flush delayed fput so exec can open the file read-only */\n\tflush_delayed_fput();\n\ttask_work_run();\n\treturn mnt;\n}",
    "includes": [
      "#include <linux/usermode_driver.h>",
      "#include <linux/task_work.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/mount.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/shmem_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_work_run",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "task_work_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/task_work.c",
          "lines": "131-169",
          "snippet": "void task_work_run(void)\n{\n\tstruct task_struct *task = current;\n\tstruct callback_head *work, *head, *next;\n\n\tfor (;;) {\n\t\t/*\n\t\t * work->func() can do task_work_add(), do not set\n\t\t * work_exited unless the list is empty.\n\t\t */\n\t\tdo {\n\t\t\thead = NULL;\n\t\t\twork = READ_ONCE(task->task_works);\n\t\t\tif (!work) {\n\t\t\t\tif (task->flags & PF_EXITING)\n\t\t\t\t\thead = &work_exited;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (cmpxchg(&task->task_works, work, head) != work);\n\n\t\tif (!work)\n\t\t\tbreak;\n\t\t/*\n\t\t * Synchronize with task_work_cancel(). It can not remove\n\t\t * the first entry == work, cmpxchg(task_works) must fail.\n\t\t * But it can remove another entry from the ->next list.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tdo {\n\t\t\tnext = work->next;\n\t\t\twork->func(work);\n\t\t\twork = next;\n\t\t\tcond_resched();\n\t\t} while (work);\n\t}\n}",
          "includes": [
            "#include <linux/resume_user_mode.h>",
            "#include <linux/task_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct callback_head work_exited;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/resume_user_mode.h>\n#include <linux/task_work.h>\n#include <linux/spinlock.h>\n\nstatic struct callback_head work_exited;\n\nvoid task_work_run(void)\n{\n\tstruct task_struct *task = current;\n\tstruct callback_head *work, *head, *next;\n\n\tfor (;;) {\n\t\t/*\n\t\t * work->func() can do task_work_add(), do not set\n\t\t * work_exited unless the list is empty.\n\t\t */\n\t\tdo {\n\t\t\thead = NULL;\n\t\t\twork = READ_ONCE(task->task_works);\n\t\t\tif (!work) {\n\t\t\t\tif (task->flags & PF_EXITING)\n\t\t\t\t\thead = &work_exited;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (cmpxchg(&task->task_works, work, head) != work);\n\n\t\tif (!work)\n\t\t\tbreak;\n\t\t/*\n\t\t * Synchronize with task_work_cancel(). It can not remove\n\t\t * the first entry == work, cmpxchg(task_works) must fail.\n\t\t * But it can remove another entry from the ->next list.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tdo {\n\t\t\tnext = work->next;\n\t\t\twork->func(work);\n\t\t\twork = next;\n\t\t\tcond_resched();\n\t\t} while (work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_delayed_fput",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "mnt"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "file",
            "NULL"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_write",
          "args": [
            "file",
            "data",
            "len",
            "&pos"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "file"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "mnt"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_open_root_mnt",
          "args": [
            "mnt",
            "name",
            "O_CREAT | O_WRONLY",
            "0700"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_filesystem",
          "args": [
            "type"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_mount",
          "args": [
            "type"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODEV"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs_type",
          "args": [
            "\"tmpfs\""
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/usermode_driver.h>\n#include <linux/task_work.h>\n#include <linux/fs_struct.h>\n#include <linux/mount.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n\nstatic struct vfsmount *blob_to_mnt(const void *data, size_t len, const char *name)\n{\n\tstruct file_system_type *type;\n\tstruct vfsmount *mnt;\n\tstruct file *file;\n\tssize_t written;\n\tloff_t pos = 0;\n\n\ttype = get_fs_type(\"tmpfs\");\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = kern_mount(type);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn mnt;\n\n\tfile = file_open_root_mnt(mnt, name, O_CREAT | O_WRONLY, 0700);\n\tif (IS_ERR(file)) {\n\t\tmntput(mnt);\n\t\treturn ERR_CAST(file);\n\t}\n\n\twritten = kernel_write(file, data, len, &pos);\n\tif (written != len) {\n\t\tint err = written;\n\t\tif (err >= 0)\n\t\t\terr = -ENOMEM;\n\t\tfilp_close(file, NULL);\n\t\tmntput(mnt);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tfput(file);\n\n\t/* Flush delayed fput so exec can open the file read-only */\n\tflush_delayed_fput();\n\ttask_work_run();\n\treturn mnt;\n}"
  }
]