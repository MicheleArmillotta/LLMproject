[
  {
    "function_name": "scs_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scs.c",
    "lines": "143-154",
    "snippet": "void scs_release(struct task_struct *tsk)\n{\n\tvoid *s = task_scs(tsk);\n\n\tif (!s)\n\t\treturn;\n\n\tWARN(task_scs_end_corrupted(tsk),\n\t     \"corrupted shadow stack detected when freeing task\\n\");\n\tscs_check_usage(tsk);\n\tscs_free(s);\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/scs.h>",
      "#include <linux/mm.h>",
      "#include <linux/kasan.h>",
      "#include <linux/cpuhotplug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scs_free",
          "args": [
            "s"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "scs_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/scs.c",
          "lines": "65-83",
          "snippet": "void scs_free(void *s)\n{\n\tint i;\n\n\t__scs_account(s, -1);\n\n\t/*\n\t * We cannot sleep as this can be called in interrupt context,\n\t * so use this_cpu_cmpxchg to update the cache, and vfree_atomic\n\t * to free the stack.\n\t */\n\n\tfor (i = 0; i < NR_CACHED_SCS; i++)\n\t\tif (this_cpu_cmpxchg(scs_cache[i], 0, s) == NULL)\n\t\t\treturn;\n\n\tkasan_unpoison_vmalloc(s, SCS_SIZE);\n\tvfree_atomic(s);\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/scs.h>",
            "#include <linux/mm.h>",
            "#include <linux/kasan.h>",
            "#include <linux/cpuhotplug.h>"
          ],
          "macros_used": [
            "#define NR_CACHED_SCS 2"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(void *, scs_cache[NR_CACHED_SCS]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/scs.h>\n#include <linux/mm.h>\n#include <linux/kasan.h>\n#include <linux/cpuhotplug.h>\n\n#define NR_CACHED_SCS 2\n\nstatic DEFINE_PER_CPU(void *, scs_cache[NR_CACHED_SCS]);\n\nvoid scs_free(void *s)\n{\n\tint i;\n\n\t__scs_account(s, -1);\n\n\t/*\n\t * We cannot sleep as this can be called in interrupt context,\n\t * so use this_cpu_cmpxchg to update the cache, and vfree_atomic\n\t * to free the stack.\n\t */\n\n\tfor (i = 0; i < NR_CACHED_SCS; i++)\n\t\tif (this_cpu_cmpxchg(scs_cache[i], 0, s) == NULL)\n\t\t\treturn;\n\n\tkasan_unpoison_vmalloc(s, SCS_SIZE);\n\tvfree_atomic(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scs_check_usage",
          "args": [
            "tsk"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "scs_check_usage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/scs.c",
          "lines": "115-141",
          "snippet": "static void scs_check_usage(struct task_struct *tsk)\n{\n\tstatic unsigned long highest;\n\n\tunsigned long *p, prev, curr = highest, used = 0;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_STACK_USAGE))\n\t\treturn;\n\n\tfor (p = task_scs(tsk); p < __scs_magic(tsk); ++p) {\n\t\tif (!READ_ONCE_NOCHECK(*p))\n\t\t\tbreak;\n\t\tused += sizeof(*p);\n\t}\n\n\twhile (used > curr) {\n\t\tprev = cmpxchg_relaxed(&highest, curr, used);\n\n\t\tif (prev == curr) {\n\t\t\tpr_info(\"%s (%d): highest shadow stack usage: %lu bytes\\n\",\n\t\t\t\ttsk->comm, task_pid_nr(tsk), used);\n\t\t\tbreak;\n\t\t}\n\n\t\tcurr = prev;\n\t}\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/scs.h>",
            "#include <linux/mm.h>",
            "#include <linux/kasan.h>",
            "#include <linux/cpuhotplug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/scs.h>\n#include <linux/mm.h>\n#include <linux/kasan.h>\n#include <linux/cpuhotplug.h>\n\nstatic void scs_check_usage(struct task_struct *tsk)\n{\n\tstatic unsigned long highest;\n\n\tunsigned long *p, prev, curr = highest, used = 0;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_STACK_USAGE))\n\t\treturn;\n\n\tfor (p = task_scs(tsk); p < __scs_magic(tsk); ++p) {\n\t\tif (!READ_ONCE_NOCHECK(*p))\n\t\t\tbreak;\n\t\tused += sizeof(*p);\n\t}\n\n\twhile (used > curr) {\n\t\tprev = cmpxchg_relaxed(&highest, curr, used);\n\n\t\tif (prev == curr) {\n\t\t\tpr_info(\"%s (%d): highest shadow stack usage: %lu bytes\\n\",\n\t\t\t\ttsk->comm, task_pid_nr(tsk), used);\n\t\t\tbreak;\n\t\t}\n\n\t\tcurr = prev;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "task_scs_end_corrupted(tsk)",
            "\"corrupted shadow stack detected when freeing task\\n\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_scs_end_corrupted",
          "args": [
            "tsk"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_scs",
          "args": [
            "tsk"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/scs.h>\n#include <linux/mm.h>\n#include <linux/kasan.h>\n#include <linux/cpuhotplug.h>\n\nvoid scs_release(struct task_struct *tsk)\n{\n\tvoid *s = task_scs(tsk);\n\n\tif (!s)\n\t\treturn;\n\n\tWARN(task_scs_end_corrupted(tsk),\n\t     \"corrupted shadow stack detected when freeing task\\n\");\n\tscs_check_usage(tsk);\n\tscs_free(s);\n}"
  },
  {
    "function_name": "scs_check_usage",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scs.c",
    "lines": "115-141",
    "snippet": "static void scs_check_usage(struct task_struct *tsk)\n{\n\tstatic unsigned long highest;\n\n\tunsigned long *p, prev, curr = highest, used = 0;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_STACK_USAGE))\n\t\treturn;\n\n\tfor (p = task_scs(tsk); p < __scs_magic(tsk); ++p) {\n\t\tif (!READ_ONCE_NOCHECK(*p))\n\t\t\tbreak;\n\t\tused += sizeof(*p);\n\t}\n\n\twhile (used > curr) {\n\t\tprev = cmpxchg_relaxed(&highest, curr, used);\n\n\t\tif (prev == curr) {\n\t\t\tpr_info(\"%s (%d): highest shadow stack usage: %lu bytes\\n\",\n\t\t\t\ttsk->comm, task_pid_nr(tsk), used);\n\t\t\tbreak;\n\t\t}\n\n\t\tcurr = prev;\n\t}\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/scs.h>",
      "#include <linux/mm.h>",
      "#include <linux/kasan.h>",
      "#include <linux/cpuhotplug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s (%d): highest shadow stack usage: %lu bytes\\n\"",
            "tsk->comm",
            "task_pid_nr(tsk)",
            "used"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "tsk"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg_relaxed",
          "args": [
            "&highest",
            "curr",
            "used"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE_NOCHECK",
          "args": [
            "*p"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__scs_magic",
          "args": [
            "tsk"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_scs",
          "args": [
            "tsk"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DEBUG_STACK_USAGE"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/scs.h>\n#include <linux/mm.h>\n#include <linux/kasan.h>\n#include <linux/cpuhotplug.h>\n\nstatic void scs_check_usage(struct task_struct *tsk)\n{\n\tstatic unsigned long highest;\n\n\tunsigned long *p, prev, curr = highest, used = 0;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_STACK_USAGE))\n\t\treturn;\n\n\tfor (p = task_scs(tsk); p < __scs_magic(tsk); ++p) {\n\t\tif (!READ_ONCE_NOCHECK(*p))\n\t\t\tbreak;\n\t\tused += sizeof(*p);\n\t}\n\n\twhile (used > curr) {\n\t\tprev = cmpxchg_relaxed(&highest, curr, used);\n\n\t\tif (prev == curr) {\n\t\t\tpr_info(\"%s (%d): highest shadow stack usage: %lu bytes\\n\",\n\t\t\t\ttsk->comm, task_pid_nr(tsk), used);\n\t\t\tbreak;\n\t\t}\n\n\t\tcurr = prev;\n\t}\n}"
  },
  {
    "function_name": "scs_prepare",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scs.c",
    "lines": "104-113",
    "snippet": "int scs_prepare(struct task_struct *tsk, int node)\n{\n\tvoid *s = scs_alloc(node);\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ttask_scs(tsk) = task_scs_sp(tsk) = s;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/scs.h>",
      "#include <linux/mm.h>",
      "#include <linux/kasan.h>",
      "#include <linux/cpuhotplug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_scs_sp",
          "args": [
            "tsk"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_scs",
          "args": [
            "tsk"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scs_alloc",
          "args": [
            "node"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "scs_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/scs.c",
          "lines": "46-63",
          "snippet": "void *scs_alloc(int node)\n{\n\tvoid *s;\n\n\ts = __scs_alloc(node);\n\tif (!s)\n\t\treturn NULL;\n\n\t*__scs_magic(s) = SCS_END_MAGIC;\n\n\t/*\n\t * Poison the allocation to catch unintentional accesses to\n\t * the shadow stack when KASAN is enabled.\n\t */\n\tkasan_poison_vmalloc(s, SCS_SIZE);\n\t__scs_account(s, 1);\n\treturn s;\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/scs.h>",
            "#include <linux/mm.h>",
            "#include <linux/kasan.h>",
            "#include <linux/cpuhotplug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/scs.h>\n#include <linux/mm.h>\n#include <linux/kasan.h>\n#include <linux/cpuhotplug.h>\n\nvoid *scs_alloc(int node)\n{\n\tvoid *s;\n\n\ts = __scs_alloc(node);\n\tif (!s)\n\t\treturn NULL;\n\n\t*__scs_magic(s) = SCS_END_MAGIC;\n\n\t/*\n\t * Poison the allocation to catch unintentional accesses to\n\t * the shadow stack when KASAN is enabled.\n\t */\n\tkasan_poison_vmalloc(s, SCS_SIZE);\n\t__scs_account(s, 1);\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/scs.h>\n#include <linux/mm.h>\n#include <linux/kasan.h>\n#include <linux/cpuhotplug.h>\n\nint scs_prepare(struct task_struct *tsk, int node)\n{\n\tvoid *s = scs_alloc(node);\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ttask_scs(tsk) = task_scs_sp(tsk) = s;\n\treturn 0;\n}"
  },
  {
    "function_name": "scs_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scs.c",
    "lines": "98-102",
    "snippet": "void __init scs_init(void)\n{\n\tcpuhp_setup_state(CPUHP_BP_PREPARE_DYN, \"scs:scs_cache\", NULL,\n\t\t\t  scs_cleanup);\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/scs.h>",
      "#include <linux/mm.h>",
      "#include <linux/kasan.h>",
      "#include <linux/cpuhotplug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(void *, scs_cache[NR_CACHED_SCS]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuhp_setup_state",
          "args": [
            "CPUHP_BP_PREPARE_DYN",
            "\"scs:scs_cache\"",
            "NULL",
            "scs_cleanup"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/scs.h>\n#include <linux/mm.h>\n#include <linux/kasan.h>\n#include <linux/cpuhotplug.h>\n\nstatic DEFINE_PER_CPU(void *, scs_cache[NR_CACHED_SCS]);\n\nvoid __init scs_init(void)\n{\n\tcpuhp_setup_state(CPUHP_BP_PREPARE_DYN, \"scs:scs_cache\", NULL,\n\t\t\t  scs_cleanup);\n}"
  },
  {
    "function_name": "scs_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scs.c",
    "lines": "85-96",
    "snippet": "static int scs_cleanup(unsigned int cpu)\n{\n\tint i;\n\tvoid **cache = per_cpu_ptr(scs_cache, cpu);\n\n\tfor (i = 0; i < NR_CACHED_SCS; i++) {\n\t\tvfree(cache[i]);\n\t\tcache[i] = NULL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/scs.h>",
      "#include <linux/mm.h>",
      "#include <linux/kasan.h>",
      "#include <linux/cpuhotplug.h>"
    ],
    "macros_used": [
      "#define NR_CACHED_SCS 2"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(void *, scs_cache[NR_CACHED_SCS]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "cache[i]"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "scs_cache",
            "cpu"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/scs.h>\n#include <linux/mm.h>\n#include <linux/kasan.h>\n#include <linux/cpuhotplug.h>\n\n#define NR_CACHED_SCS 2\n\nstatic DEFINE_PER_CPU(void *, scs_cache[NR_CACHED_SCS]);\n\nstatic int scs_cleanup(unsigned int cpu)\n{\n\tint i;\n\tvoid **cache = per_cpu_ptr(scs_cache, cpu);\n\n\tfor (i = 0; i < NR_CACHED_SCS; i++) {\n\t\tvfree(cache[i]);\n\t\tcache[i] = NULL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "scs_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scs.c",
    "lines": "65-83",
    "snippet": "void scs_free(void *s)\n{\n\tint i;\n\n\t__scs_account(s, -1);\n\n\t/*\n\t * We cannot sleep as this can be called in interrupt context,\n\t * so use this_cpu_cmpxchg to update the cache, and vfree_atomic\n\t * to free the stack.\n\t */\n\n\tfor (i = 0; i < NR_CACHED_SCS; i++)\n\t\tif (this_cpu_cmpxchg(scs_cache[i], 0, s) == NULL)\n\t\t\treturn;\n\n\tkasan_unpoison_vmalloc(s, SCS_SIZE);\n\tvfree_atomic(s);\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/scs.h>",
      "#include <linux/mm.h>",
      "#include <linux/kasan.h>",
      "#include <linux/cpuhotplug.h>"
    ],
    "macros_used": [
      "#define NR_CACHED_SCS 2"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(void *, scs_cache[NR_CACHED_SCS]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree_atomic",
          "args": [
            "s"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_unpoison_vmalloc",
          "args": [
            "s",
            "SCS_SIZE"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_cmpxchg",
          "args": [
            "scs_cache[i]",
            "0",
            "s"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__scs_account",
          "args": [
            "s",
            "-1"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "__scs_account",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/scs.c",
          "lines": "15-21",
          "snippet": "static void __scs_account(void *s, int account)\n{\n\tstruct page *scs_page = vmalloc_to_page(s);\n\n\tmod_node_page_state(page_pgdat(scs_page), NR_KERNEL_SCS_KB,\n\t\t\t    account * (SCS_SIZE / SZ_1K));\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/scs.h>",
            "#include <linux/mm.h>",
            "#include <linux/kasan.h>",
            "#include <linux/cpuhotplug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/scs.h>\n#include <linux/mm.h>\n#include <linux/kasan.h>\n#include <linux/cpuhotplug.h>\n\nstatic void __scs_account(void *s, int account)\n{\n\tstruct page *scs_page = vmalloc_to_page(s);\n\n\tmod_node_page_state(page_pgdat(scs_page), NR_KERNEL_SCS_KB,\n\t\t\t    account * (SCS_SIZE / SZ_1K));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/scs.h>\n#include <linux/mm.h>\n#include <linux/kasan.h>\n#include <linux/cpuhotplug.h>\n\n#define NR_CACHED_SCS 2\n\nstatic DEFINE_PER_CPU(void *, scs_cache[NR_CACHED_SCS]);\n\nvoid scs_free(void *s)\n{\n\tint i;\n\n\t__scs_account(s, -1);\n\n\t/*\n\t * We cannot sleep as this can be called in interrupt context,\n\t * so use this_cpu_cmpxchg to update the cache, and vfree_atomic\n\t * to free the stack.\n\t */\n\n\tfor (i = 0; i < NR_CACHED_SCS; i++)\n\t\tif (this_cpu_cmpxchg(scs_cache[i], 0, s) == NULL)\n\t\t\treturn;\n\n\tkasan_unpoison_vmalloc(s, SCS_SIZE);\n\tvfree_atomic(s);\n}"
  },
  {
    "function_name": "scs_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scs.c",
    "lines": "46-63",
    "snippet": "void *scs_alloc(int node)\n{\n\tvoid *s;\n\n\ts = __scs_alloc(node);\n\tif (!s)\n\t\treturn NULL;\n\n\t*__scs_magic(s) = SCS_END_MAGIC;\n\n\t/*\n\t * Poison the allocation to catch unintentional accesses to\n\t * the shadow stack when KASAN is enabled.\n\t */\n\tkasan_poison_vmalloc(s, SCS_SIZE);\n\t__scs_account(s, 1);\n\treturn s;\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/scs.h>",
      "#include <linux/mm.h>",
      "#include <linux/kasan.h>",
      "#include <linux/cpuhotplug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__scs_account",
          "args": [
            "s",
            "1"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "__scs_account",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/scs.c",
          "lines": "15-21",
          "snippet": "static void __scs_account(void *s, int account)\n{\n\tstruct page *scs_page = vmalloc_to_page(s);\n\n\tmod_node_page_state(page_pgdat(scs_page), NR_KERNEL_SCS_KB,\n\t\t\t    account * (SCS_SIZE / SZ_1K));\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/scs.h>",
            "#include <linux/mm.h>",
            "#include <linux/kasan.h>",
            "#include <linux/cpuhotplug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/scs.h>\n#include <linux/mm.h>\n#include <linux/kasan.h>\n#include <linux/cpuhotplug.h>\n\nstatic void __scs_account(void *s, int account)\n{\n\tstruct page *scs_page = vmalloc_to_page(s);\n\n\tmod_node_page_state(page_pgdat(scs_page), NR_KERNEL_SCS_KB,\n\t\t\t    account * (SCS_SIZE / SZ_1K));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_poison_vmalloc",
          "args": [
            "s",
            "SCS_SIZE"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__scs_magic",
          "args": [
            "s"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__scs_alloc",
          "args": [
            "node"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "__scs_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/scs.c",
          "lines": "27-44",
          "snippet": "static void *__scs_alloc(int node)\n{\n\tint i;\n\tvoid *s;\n\n\tfor (i = 0; i < NR_CACHED_SCS; i++) {\n\t\ts = this_cpu_xchg(scs_cache[i], NULL);\n\t\tif (s) {\n\t\t\tkasan_unpoison_vmalloc(s, SCS_SIZE);\n\t\t\tmemset(s, 0, SCS_SIZE);\n\t\t\treturn s;\n\t\t}\n\t}\n\n\treturn __vmalloc_node_range(SCS_SIZE, 1, VMALLOC_START, VMALLOC_END,\n\t\t\t\t    GFP_SCS, PAGE_KERNEL, 0, node,\n\t\t\t\t    __builtin_return_address(0));\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/scs.h>",
            "#include <linux/mm.h>",
            "#include <linux/kasan.h>",
            "#include <linux/cpuhotplug.h>"
          ],
          "macros_used": [
            "#define NR_CACHED_SCS 2"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(void *, scs_cache[NR_CACHED_SCS]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/scs.h>\n#include <linux/mm.h>\n#include <linux/kasan.h>\n#include <linux/cpuhotplug.h>\n\n#define NR_CACHED_SCS 2\n\nstatic DEFINE_PER_CPU(void *, scs_cache[NR_CACHED_SCS]);\n\nstatic void *__scs_alloc(int node)\n{\n\tint i;\n\tvoid *s;\n\n\tfor (i = 0; i < NR_CACHED_SCS; i++) {\n\t\ts = this_cpu_xchg(scs_cache[i], NULL);\n\t\tif (s) {\n\t\t\tkasan_unpoison_vmalloc(s, SCS_SIZE);\n\t\t\tmemset(s, 0, SCS_SIZE);\n\t\t\treturn s;\n\t\t}\n\t}\n\n\treturn __vmalloc_node_range(SCS_SIZE, 1, VMALLOC_START, VMALLOC_END,\n\t\t\t\t    GFP_SCS, PAGE_KERNEL, 0, node,\n\t\t\t\t    __builtin_return_address(0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/scs.h>\n#include <linux/mm.h>\n#include <linux/kasan.h>\n#include <linux/cpuhotplug.h>\n\nvoid *scs_alloc(int node)\n{\n\tvoid *s;\n\n\ts = __scs_alloc(node);\n\tif (!s)\n\t\treturn NULL;\n\n\t*__scs_magic(s) = SCS_END_MAGIC;\n\n\t/*\n\t * Poison the allocation to catch unintentional accesses to\n\t * the shadow stack when KASAN is enabled.\n\t */\n\tkasan_poison_vmalloc(s, SCS_SIZE);\n\t__scs_account(s, 1);\n\treturn s;\n}"
  },
  {
    "function_name": "__scs_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scs.c",
    "lines": "27-44",
    "snippet": "static void *__scs_alloc(int node)\n{\n\tint i;\n\tvoid *s;\n\n\tfor (i = 0; i < NR_CACHED_SCS; i++) {\n\t\ts = this_cpu_xchg(scs_cache[i], NULL);\n\t\tif (s) {\n\t\t\tkasan_unpoison_vmalloc(s, SCS_SIZE);\n\t\t\tmemset(s, 0, SCS_SIZE);\n\t\t\treturn s;\n\t\t}\n\t}\n\n\treturn __vmalloc_node_range(SCS_SIZE, 1, VMALLOC_START, VMALLOC_END,\n\t\t\t\t    GFP_SCS, PAGE_KERNEL, 0, node,\n\t\t\t\t    __builtin_return_address(0));\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/scs.h>",
      "#include <linux/mm.h>",
      "#include <linux/kasan.h>",
      "#include <linux/cpuhotplug.h>"
    ],
    "macros_used": [
      "#define NR_CACHED_SCS 2"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(void *, scs_cache[NR_CACHED_SCS]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc_node_range",
          "args": [
            "SCS_SIZE",
            "1",
            "VMALLOC_START",
            "VMALLOC_END",
            "GFP_SCS",
            "PAGE_KERNEL",
            "0",
            "node",
            "__builtin_return_address(0)"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "s",
            "0",
            "SCS_SIZE"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasan_unpoison_vmalloc",
          "args": [
            "s",
            "SCS_SIZE"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_xchg",
          "args": [
            "scs_cache[i]",
            "NULL"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/scs.h>\n#include <linux/mm.h>\n#include <linux/kasan.h>\n#include <linux/cpuhotplug.h>\n\n#define NR_CACHED_SCS 2\n\nstatic DEFINE_PER_CPU(void *, scs_cache[NR_CACHED_SCS]);\n\nstatic void *__scs_alloc(int node)\n{\n\tint i;\n\tvoid *s;\n\n\tfor (i = 0; i < NR_CACHED_SCS; i++) {\n\t\ts = this_cpu_xchg(scs_cache[i], NULL);\n\t\tif (s) {\n\t\t\tkasan_unpoison_vmalloc(s, SCS_SIZE);\n\t\t\tmemset(s, 0, SCS_SIZE);\n\t\t\treturn s;\n\t\t}\n\t}\n\n\treturn __vmalloc_node_range(SCS_SIZE, 1, VMALLOC_START, VMALLOC_END,\n\t\t\t\t    GFP_SCS, PAGE_KERNEL, 0, node,\n\t\t\t\t    __builtin_return_address(0));\n}"
  },
  {
    "function_name": "__scs_account",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scs.c",
    "lines": "15-21",
    "snippet": "static void __scs_account(void *s, int account)\n{\n\tstruct page *scs_page = vmalloc_to_page(s);\n\n\tmod_node_page_state(page_pgdat(scs_page), NR_KERNEL_SCS_KB,\n\t\t\t    account * (SCS_SIZE / SZ_1K));\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/scs.h>",
      "#include <linux/mm.h>",
      "#include <linux/kasan.h>",
      "#include <linux/cpuhotplug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_node_page_state",
          "args": [
            "page_pgdat(scs_page)",
            "NR_KERNEL_SCS_KB",
            "account * (SCS_SIZE / SZ_1K)"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "scs_page"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "s"
          ],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/scs.h>\n#include <linux/mm.h>\n#include <linux/kasan.h>\n#include <linux/cpuhotplug.h>\n\nstatic void __scs_account(void *s, int account)\n{\n\tstruct page *scs_page = vmalloc_to_page(s);\n\n\tmod_node_page_state(page_pgdat(scs_page), NR_KERNEL_SCS_KB,\n\t\t\t    account * (SCS_SIZE / SZ_1K));\n}"
  }
]