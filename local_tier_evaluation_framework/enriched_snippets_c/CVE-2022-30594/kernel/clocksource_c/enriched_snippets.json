[
  {
    "function_name": "boot_override_clock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1461-1469",
    "snippet": "static int __init boot_override_clock(char* str)\n{\n\tif (!strcmp(str, \"pmtmr\")) {\n\t\tpr_warn(\"clock=pmtmr is deprecated - use clocksource=acpi_pm\\n\");\n\t\treturn boot_override_clocksource(\"acpi_pm\");\n\t}\n\tpr_warn(\"clock= boot option is deprecated - use clocksource=xyz\\n\");\n\treturn boot_override_clocksource(str);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "boot_override_clocksource",
          "args": [
            "str"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "boot_override_clocksource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1443-1450",
          "snippet": "static int __init boot_override_clocksource(char* str)\n{\n\tmutex_lock(&clocksource_mutex);\n\tif (str)\n\t\tstrlcpy(override_name, str, sizeof(override_name));\n\tmutex_unlock(&clocksource_mutex);\n\treturn 1;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(clocksource_mutex);",
            "static char override_name[CS_NAME_LEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(clocksource_mutex);\nstatic char override_name[CS_NAME_LEN];\n\nstatic int __init boot_override_clocksource(char* str)\n{\n\tmutex_lock(&clocksource_mutex);\n\tif (str)\n\t\tstrlcpy(override_name, str, sizeof(override_name));\n\tmutex_unlock(&clocksource_mutex);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"clock= boot option is deprecated - use clocksource=xyz\\n\""
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"clock=pmtmr is deprecated - use clocksource=acpi_pm\\n\""
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"pmtmr\""
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic int __init boot_override_clock(char* str)\n{\n\tif (!strcmp(str, \"pmtmr\")) {\n\t\tpr_warn(\"clock=pmtmr is deprecated - use clocksource=acpi_pm\\n\");\n\t\treturn boot_override_clocksource(\"acpi_pm\");\n\t}\n\tpr_warn(\"clock= boot option is deprecated - use clocksource=xyz\\n\");\n\treturn boot_override_clocksource(str);\n}"
  },
  {
    "function_name": "boot_override_clocksource",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1443-1450",
    "snippet": "static int __init boot_override_clocksource(char* str)\n{\n\tmutex_lock(&clocksource_mutex);\n\tif (str)\n\t\tstrlcpy(override_name, str, sizeof(override_name));\n\tmutex_unlock(&clocksource_mutex);\n\treturn 1;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(clocksource_mutex);",
      "static char override_name[CS_NAME_LEN];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "override_name",
            "str",
            "sizeof(override_name)"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(clocksource_mutex);\nstatic char override_name[CS_NAME_LEN];\n\nstatic int __init boot_override_clocksource(char* str)\n{\n\tmutex_lock(&clocksource_mutex);\n\tif (str)\n\t\tstrlcpy(override_name, str, sizeof(override_name));\n\tmutex_unlock(&clocksource_mutex);\n\treturn 1;\n}"
  },
  {
    "function_name": "init_clocksource_sysfs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1423-1431",
    "snippet": "static int __init init_clocksource_sysfs(void)\n{\n\tint error = subsys_system_register(&clocksource_subsys, NULL);\n\n\tif (!error)\n\t\terror = device_register(&device_clocksource);\n\n\treturn error;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_register",
          "args": [
            "&device_clocksource"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "subsys_system_register",
          "args": [
            "&clocksource_subsys",
            "NULL"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic int __init init_clocksource_sysfs(void)\n{\n\tint error = subsys_system_register(&clocksource_subsys, NULL);\n\n\tif (!error)\n\t\terror = device_register(&device_clocksource);\n\n\treturn error;\n}"
  },
  {
    "function_name": "available_clocksource_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1376-1401",
    "snippet": "static ssize_t available_clocksource_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct clocksource *src;\n\tssize_t count = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tlist_for_each_entry(src, &clocksource_list, list) {\n\t\t/*\n\t\t * Don't show non-HRES clocksource if the tick code is\n\t\t * in one shot mode (highres=on or nohz=on)\n\t\t */\n\t\tif (!tick_oneshot_mode_active() ||\n\t\t    (src->flags & CLOCK_SOURCE_VALID_FOR_HRES))\n\t\t\tcount += snprintf(buf + count,\n\t\t\t\t  max((ssize_t)PAGE_SIZE - count, (ssize_t)0),\n\t\t\t\t  \"%s \", src->name);\n\t}\n\tmutex_unlock(&clocksource_mutex);\n\n\tcount += snprintf(buf + count,\n\t\t\t  max((ssize_t)PAGE_SIZE - count, (ssize_t)0), \"\\n\");\n\n\treturn count;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clocksource_list);",
      "static DEFINE_MUTEX(clocksource_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + count",
            "max((ssize_t)PAGE_SIZE - count, (ssize_t)0)",
            "\"\\n\""
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "btf_snprintf_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5972-5992",
          "snippet": "static void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "(ssize_t)PAGE_SIZE - count",
            "(ssize_t)0"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + count",
            "max((ssize_t)PAGE_SIZE - count, (ssize_t)0)",
            "\"%s \"",
            "src->name"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_oneshot_mode_active",
          "args": [],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "tick_oneshot_mode_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-oneshot.c",
          "lines": "106-116",
          "snippet": "int tick_oneshot_mode_active(void)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = __this_cpu_read(tick_cpu_device.mode) == TICKDEV_MODE_ONESHOT;\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_oneshot_mode_active(void)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = __this_cpu_read(tick_cpu_device.mode) == TICKDEV_MODE_ONESHOT;\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "src",
            "&clocksource_list",
            "list"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\nstatic DEFINE_MUTEX(clocksource_mutex);\n\nstatic ssize_t available_clocksource_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct clocksource *src;\n\tssize_t count = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tlist_for_each_entry(src, &clocksource_list, list) {\n\t\t/*\n\t\t * Don't show non-HRES clocksource if the tick code is\n\t\t * in one shot mode (highres=on or nohz=on)\n\t\t */\n\t\tif (!tick_oneshot_mode_active() ||\n\t\t    (src->flags & CLOCK_SOURCE_VALID_FOR_HRES))\n\t\t\tcount += snprintf(buf + count,\n\t\t\t\t  max((ssize_t)PAGE_SIZE - count, (ssize_t)0),\n\t\t\t\t  \"%s \", src->name);\n\t}\n\tmutex_unlock(&clocksource_mutex);\n\n\tcount += snprintf(buf + count,\n\t\t\t  max((ssize_t)PAGE_SIZE - count, (ssize_t)0), \"\\n\");\n\n\treturn count;\n}"
  },
  {
    "function_name": "unbind_clocksource_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1342-1365",
    "snippet": "static ssize_t unbind_clocksource_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct clocksource *cs;\n\tchar name[CS_NAME_LEN];\n\tssize_t ret;\n\n\tret = sysfs_get_uname(buf, name, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = -ENODEV;\n\tmutex_lock(&clocksource_mutex);\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (strcmp(cs->name, name))\n\t\t\tcontinue;\n\t\tret = clocksource_unbind(cs);\n\t\tbreak;\n\t}\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn ret ? ret : count;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clocksource_list);",
      "static DEFINE_MUTEX(clocksource_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_unbind",
          "args": [
            "cs"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_unbind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1215-1248",
          "snippet": "static int clocksource_unbind(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tif (clocksource_is_watchdog(cs)) {\n\t\t/* Select and try to install a replacement watchdog. */\n\t\tclocksource_select_watchdog(true);\n\t\tif (clocksource_is_watchdog(cs))\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (cs == curr_clocksource) {\n\t\t/* Select and try to install a replacement clock source */\n\t\tclocksource_select_fallback();\n\t\tif (curr_clocksource == cs)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (clocksource_is_suspend(cs)) {\n\t\t/*\n\t\t * Select and try to install a replacement suspend clocksource.\n\t\t * If no replacement suspend clocksource, we will just let the\n\t\t * clocksource go and have no suspend clocksource.\n\t\t */\n\t\tclocksource_suspend_select(true);\n\t}\n\n\tclocksource_watchdog_lock(&flags);\n\tclocksource_dequeue_watchdog(cs);\n\tlist_del_init(&cs->list);\n\tclocksource_watchdog_unlock(&flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *curr_clocksource;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\n\nstatic int clocksource_unbind(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tif (clocksource_is_watchdog(cs)) {\n\t\t/* Select and try to install a replacement watchdog. */\n\t\tclocksource_select_watchdog(true);\n\t\tif (clocksource_is_watchdog(cs))\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (cs == curr_clocksource) {\n\t\t/* Select and try to install a replacement clock source */\n\t\tclocksource_select_fallback();\n\t\tif (curr_clocksource == cs)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (clocksource_is_suspend(cs)) {\n\t\t/*\n\t\t * Select and try to install a replacement suspend clocksource.\n\t\t * If no replacement suspend clocksource, we will just let the\n\t\t * clocksource go and have no suspend clocksource.\n\t\t */\n\t\tclocksource_suspend_select(true);\n\t}\n\n\tclocksource_watchdog_lock(&flags);\n\tclocksource_dequeue_watchdog(cs);\n\tlist_del_init(&cs->list);\n\tclocksource_watchdog_unlock(&flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cs->name",
            "name"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cs",
            "&clocksource_list",
            "list"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_get_uname",
          "args": [
            "buf",
            "name",
            "count"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_get_uname",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1288-1303",
          "snippet": "ssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t/* strings from sysfs write are not 0 terminated! */\n\tif (!cnt || cnt >= CS_NAME_LEN)\n\t\treturn -EINVAL;\n\n\t/* strip of \\n: */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t/* strings from sysfs write are not 0 terminated! */\n\tif (!cnt || cnt >= CS_NAME_LEN)\n\t\treturn -EINVAL;\n\n\t/* strip of \\n: */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\nstatic DEFINE_MUTEX(clocksource_mutex);\n\nstatic ssize_t unbind_clocksource_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct clocksource *cs;\n\tchar name[CS_NAME_LEN];\n\tssize_t ret;\n\n\tret = sysfs_get_uname(buf, name, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = -ENODEV;\n\tmutex_lock(&clocksource_mutex);\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (strcmp(cs->name, name))\n\t\t\tcontinue;\n\t\tret = clocksource_unbind(cs);\n\t\tbreak;\n\t}\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn ret ? ret : count;\n}"
  },
  {
    "function_name": "current_clocksource_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1315-1330",
    "snippet": "static ssize_t current_clocksource_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tssize_t ret;\n\n\tmutex_lock(&clocksource_mutex);\n\n\tret = sysfs_get_uname(buf, override_name, count);\n\tif (ret >= 0)\n\t\tclocksource_select();\n\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(clocksource_mutex);",
      "static char override_name[CS_NAME_LEN];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select",
          "args": [],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_fallback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1007-1010",
          "snippet": "static void clocksource_select_fallback(void)\n{\n\t__clocksource_select(true);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select_fallback(void)\n{\n\t__clocksource_select(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_get_uname",
          "args": [
            "buf",
            "override_name",
            "count"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_get_uname",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1288-1303",
          "snippet": "ssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t/* strings from sysfs write are not 0 terminated! */\n\tif (!cnt || cnt >= CS_NAME_LEN)\n\t\treturn -EINVAL;\n\n\t/* strip of \\n: */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t/* strings from sysfs write are not 0 terminated! */\n\tif (!cnt || cnt >= CS_NAME_LEN)\n\t\treturn -EINVAL;\n\n\t/* strip of \\n: */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(clocksource_mutex);\nstatic char override_name[CS_NAME_LEN];\n\nstatic ssize_t current_clocksource_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tssize_t ret;\n\n\tmutex_lock(&clocksource_mutex);\n\n\tret = sysfs_get_uname(buf, override_name, count);\n\tif (ret >= 0)\n\t\tclocksource_select();\n\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "sysfs_get_uname",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1288-1303",
    "snippet": "ssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t/* strings from sysfs write are not 0 terminated! */\n\tif (!cnt || cnt >= CS_NAME_LEN)\n\t\treturn -EINVAL;\n\n\t/* strip of \\n: */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "buf",
            "cnt"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t/* strings from sysfs write are not 0 terminated! */\n\tif (!cnt || cnt >= CS_NAME_LEN)\n\t\treturn -EINVAL;\n\n\t/* strip of \\n: */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "current_clocksource_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1275-1286",
    "snippet": "static ssize_t current_clocksource_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tssize_t count = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tcount = snprintf(buf, PAGE_SIZE, \"%s\\n\", curr_clocksource->name);\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn count;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *curr_clocksource;",
      "static DEFINE_MUTEX(clocksource_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%s\\n\"",
            "curr_clocksource->name"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\nstatic DEFINE_MUTEX(clocksource_mutex);\n\nstatic ssize_t current_clocksource_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tssize_t count = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tcount = snprintf(buf, PAGE_SIZE, \"%s\\n\", curr_clocksource->name);\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn count;\n}"
  },
  {
    "function_name": "clocksource_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1254-1263",
    "snippet": "int clocksource_unregister(struct clocksource *cs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tif (!list_empty(&cs->list))\n\t\tret = clocksource_unbind(cs);\n\tmutex_unlock(&clocksource_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(clocksource_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_unbind",
          "args": [
            "cs"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_unbind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1215-1248",
          "snippet": "static int clocksource_unbind(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tif (clocksource_is_watchdog(cs)) {\n\t\t/* Select and try to install a replacement watchdog. */\n\t\tclocksource_select_watchdog(true);\n\t\tif (clocksource_is_watchdog(cs))\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (cs == curr_clocksource) {\n\t\t/* Select and try to install a replacement clock source */\n\t\tclocksource_select_fallback();\n\t\tif (curr_clocksource == cs)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (clocksource_is_suspend(cs)) {\n\t\t/*\n\t\t * Select and try to install a replacement suspend clocksource.\n\t\t * If no replacement suspend clocksource, we will just let the\n\t\t * clocksource go and have no suspend clocksource.\n\t\t */\n\t\tclocksource_suspend_select(true);\n\t}\n\n\tclocksource_watchdog_lock(&flags);\n\tclocksource_dequeue_watchdog(cs);\n\tlist_del_init(&cs->list);\n\tclocksource_watchdog_unlock(&flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *curr_clocksource;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\n\nstatic int clocksource_unbind(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tif (clocksource_is_watchdog(cs)) {\n\t\t/* Select and try to install a replacement watchdog. */\n\t\tclocksource_select_watchdog(true);\n\t\tif (clocksource_is_watchdog(cs))\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (cs == curr_clocksource) {\n\t\t/* Select and try to install a replacement clock source */\n\t\tclocksource_select_fallback();\n\t\tif (curr_clocksource == cs)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (clocksource_is_suspend(cs)) {\n\t\t/*\n\t\t * Select and try to install a replacement suspend clocksource.\n\t\t * If no replacement suspend clocksource, we will just let the\n\t\t * clocksource go and have no suspend clocksource.\n\t\t */\n\t\tclocksource_suspend_select(true);\n\t}\n\n\tclocksource_watchdog_lock(&flags);\n\tclocksource_dequeue_watchdog(cs);\n\tlist_del_init(&cs->list);\n\tclocksource_watchdog_unlock(&flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cs->list"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(clocksource_mutex);\n\nint clocksource_unregister(struct clocksource *cs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tif (!list_empty(&cs->list))\n\t\tret = clocksource_unbind(cs);\n\tmutex_unlock(&clocksource_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "clocksource_unbind",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1215-1248",
    "snippet": "static int clocksource_unbind(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tif (clocksource_is_watchdog(cs)) {\n\t\t/* Select and try to install a replacement watchdog. */\n\t\tclocksource_select_watchdog(true);\n\t\tif (clocksource_is_watchdog(cs))\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (cs == curr_clocksource) {\n\t\t/* Select and try to install a replacement clock source */\n\t\tclocksource_select_fallback();\n\t\tif (curr_clocksource == cs)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (clocksource_is_suspend(cs)) {\n\t\t/*\n\t\t * Select and try to install a replacement suspend clocksource.\n\t\t * If no replacement suspend clocksource, we will just let the\n\t\t * clocksource go and have no suspend clocksource.\n\t\t */\n\t\tclocksource_suspend_select(true);\n\t}\n\n\tclocksource_watchdog_lock(&flags);\n\tclocksource_dequeue_watchdog(cs);\n\tlist_del_init(&cs->list);\n\tclocksource_watchdog_unlock(&flags);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *curr_clocksource;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocksource_watchdog_unlock",
          "args": [
            "&flags"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_watchdog_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "672-672",
          "snippet": "static inline void clocksource_watchdog_unlock(unsigned long *flags) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_unlock(unsigned long *flags) { }"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cs->list"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_dequeue_watchdog",
          "args": [
            "cs"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_dequeue_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "665-665",
          "snippet": "static inline void clocksource_dequeue_watchdog(struct clocksource *cs) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_dequeue_watchdog(struct clocksource *cs) { }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_watchdog_lock",
          "args": [
            "&flags"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_watchdog_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "671-671",
          "snippet": "static inline void clocksource_watchdog_lock(unsigned long *flags) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_lock(unsigned long *flags) { }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_suspend_select",
          "args": [
            "true"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_suspend_select",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "708-723",
          "snippet": "static void clocksource_suspend_select(bool fallback)\n{\n\tstruct clocksource *cs, *old_suspend;\n\n\told_suspend = suspend_clocksource;\n\tif (fallback)\n\t\tsuspend_clocksource = NULL;\n\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\t/* Skip current if we were requested for a fallback. */\n\t\tif (fallback && cs == old_suspend)\n\t\t\tcontinue;\n\n\t\t__clocksource_suspend_select(cs);\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static LIST_HEAD(clocksource_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic LIST_HEAD(clocksource_list);\n\nstatic void clocksource_suspend_select(bool fallback)\n{\n\tstruct clocksource *cs, *old_suspend;\n\n\told_suspend = suspend_clocksource;\n\tif (fallback)\n\t\tsuspend_clocksource = NULL;\n\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\t/* Skip current if we were requested for a fallback. */\n\t\tif (fallback && cs == old_suspend)\n\t\t\tcontinue;\n\n\t\t__clocksource_suspend_select(cs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_is_suspend",
          "args": [
            "cs"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_is_suspend",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "676-679",
          "snippet": "static bool clocksource_is_suspend(struct clocksource *cs)\n{\n\treturn cs == suspend_clocksource;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\n\nstatic bool clocksource_is_suspend(struct clocksource *cs)\n{\n\treturn cs == suspend_clocksource;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select_fallback",
          "args": [],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_fallback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1007-1010",
          "snippet": "static void clocksource_select_fallback(void)\n{\n\t__clocksource_select(true);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select_fallback(void)\n{\n\t__clocksource_select(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_is_watchdog",
          "args": [
            "cs"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_is_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "668-668",
          "snippet": "static bool clocksource_is_watchdog(struct clocksource *cs) { return false; }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic bool clocksource_is_watchdog(struct clocksource *cs) { return false; }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select_watchdog",
          "args": [
            "true"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "664-664",
          "snippet": "static void clocksource_select_watchdog(bool fallback) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select_watchdog(bool fallback) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\n\nstatic int clocksource_unbind(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tif (clocksource_is_watchdog(cs)) {\n\t\t/* Select and try to install a replacement watchdog. */\n\t\tclocksource_select_watchdog(true);\n\t\tif (clocksource_is_watchdog(cs))\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (cs == curr_clocksource) {\n\t\t/* Select and try to install a replacement clock source */\n\t\tclocksource_select_fallback();\n\t\tif (curr_clocksource == cs)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (clocksource_is_suspend(cs)) {\n\t\t/*\n\t\t * Select and try to install a replacement suspend clocksource.\n\t\t * If no replacement suspend clocksource, we will just let the\n\t\t * clocksource go and have no suspend clocksource.\n\t\t */\n\t\tclocksource_suspend_select(true);\n\t}\n\n\tclocksource_watchdog_lock(&flags);\n\tclocksource_dequeue_watchdog(cs);\n\tlist_del_init(&cs->list);\n\tclocksource_watchdog_unlock(&flags);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "clocksource_change_rating",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1196-1209",
    "snippet": "void clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tunsigned long flags;\n\n\tmutex_lock(&clocksource_mutex);\n\tclocksource_watchdog_lock(&flags);\n\t__clocksource_change_rating(cs, rating);\n\tclocksource_watchdog_unlock(&flags);\n\n\tclocksource_select();\n\tclocksource_select_watchdog(false);\n\tclocksource_suspend_select(false);\n\tmutex_unlock(&clocksource_mutex);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(clocksource_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_suspend_select",
          "args": [
            "false"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_suspend_select",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "708-723",
          "snippet": "static void clocksource_suspend_select(bool fallback)\n{\n\tstruct clocksource *cs, *old_suspend;\n\n\told_suspend = suspend_clocksource;\n\tif (fallback)\n\t\tsuspend_clocksource = NULL;\n\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\t/* Skip current if we were requested for a fallback. */\n\t\tif (fallback && cs == old_suspend)\n\t\t\tcontinue;\n\n\t\t__clocksource_suspend_select(cs);\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static LIST_HEAD(clocksource_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic LIST_HEAD(clocksource_list);\n\nstatic void clocksource_suspend_select(bool fallback)\n{\n\tstruct clocksource *cs, *old_suspend;\n\n\told_suspend = suspend_clocksource;\n\tif (fallback)\n\t\tsuspend_clocksource = NULL;\n\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\t/* Skip current if we were requested for a fallback. */\n\t\tif (fallback && cs == old_suspend)\n\t\t\tcontinue;\n\n\t\t__clocksource_suspend_select(cs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select_watchdog",
          "args": [
            "false"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "664-664",
          "snippet": "static void clocksource_select_watchdog(bool fallback) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select_watchdog(bool fallback) { }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select",
          "args": [],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_fallback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1007-1010",
          "snippet": "static void clocksource_select_fallback(void)\n{\n\t__clocksource_select(true);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select_fallback(void)\n{\n\t__clocksource_select(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_watchdog_unlock",
          "args": [
            "&flags"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_watchdog_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "672-672",
          "snippet": "static inline void clocksource_watchdog_unlock(unsigned long *flags) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_unlock(unsigned long *flags) { }"
        }
      },
      {
        "call_info": {
          "callee": "__clocksource_change_rating",
          "args": [
            "cs",
            "rating"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_change_rating",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1184-1189",
          "snippet": "static void __clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tlist_del(&cs->list);\n\tcs->rating = rating;\n\tclocksource_enqueue(cs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void __clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tlist_del(&cs->list);\n\tcs->rating = rating;\n\tclocksource_enqueue(cs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_watchdog_lock",
          "args": [
            "&flags"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_watchdog_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "671-671",
          "snippet": "static inline void clocksource_watchdog_lock(unsigned long *flags) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_lock(unsigned long *flags) { }"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(clocksource_mutex);\n\nvoid clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tunsigned long flags;\n\n\tmutex_lock(&clocksource_mutex);\n\tclocksource_watchdog_lock(&flags);\n\t__clocksource_change_rating(cs, rating);\n\tclocksource_watchdog_unlock(&flags);\n\n\tclocksource_select();\n\tclocksource_select_watchdog(false);\n\tclocksource_suspend_select(false);\n\tmutex_unlock(&clocksource_mutex);\n}"
  },
  {
    "function_name": "__clocksource_change_rating",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1184-1189",
    "snippet": "static void __clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tlist_del(&cs->list);\n\tcs->rating = rating;\n\tclocksource_enqueue(cs);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocksource_enqueue",
          "args": [
            "cs"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_enqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1037-1049",
          "snippet": "static void clocksource_enqueue(struct clocksource *cs)\n{\n\tstruct list_head *entry = &clocksource_list;\n\tstruct clocksource *tmp;\n\n\tlist_for_each_entry(tmp, &clocksource_list, list) {\n\t\t/* Keep track of the place, where to insert */\n\t\tif (tmp->rating < cs->rating)\n\t\t\tbreak;\n\t\tentry = &tmp->list;\n\t}\n\tlist_add(&cs->list, entry);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clocksource_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\n\nstatic void clocksource_enqueue(struct clocksource *cs)\n{\n\tstruct list_head *entry = &clocksource_list;\n\tstruct clocksource *tmp;\n\n\tlist_for_each_entry(tmp, &clocksource_list, list) {\n\t\t/* Keep track of the place, where to insert */\n\t\tif (tmp->rating < cs->rating)\n\t\t\tbreak;\n\t\tentry = &tmp->list;\n\t}\n\tlist_add(&cs->list, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cs->list"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void __clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tlist_del(&cs->list);\n\tcs->rating = rating;\n\tclocksource_enqueue(cs);\n}"
  },
  {
    "function_name": "__clocksource_register_scale",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1150-1181",
    "snippet": "int __clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq)\n{\n\tunsigned long flags;\n\n\tclocksource_arch_init(cs);\n\n\tif (WARN_ON_ONCE((unsigned int)cs->id >= CSID_MAX))\n\t\tcs->id = CSID_GENERIC;\n\tif (cs->vdso_clock_mode < 0 ||\n\t    cs->vdso_clock_mode >= VDSO_CLOCKMODE_MAX) {\n\t\tpr_warn(\"clocksource %s registered with invalid VDSO mode %d. Disabling VDSO support.\\n\",\n\t\t\tcs->name, cs->vdso_clock_mode);\n\t\tcs->vdso_clock_mode = VDSO_CLOCKMODE_NONE;\n\t}\n\n\t/* Initialize mult/shift and max_idle_ns */\n\t__clocksource_update_freq_scale(cs, scale, freq);\n\n\t/* Add clocksource to the clocksource list */\n\tmutex_lock(&clocksource_mutex);\n\n\tclocksource_watchdog_lock(&flags);\n\tclocksource_enqueue(cs);\n\tclocksource_enqueue_watchdog(cs);\n\tclocksource_watchdog_unlock(&flags);\n\n\tclocksource_select();\n\tclocksource_select_watchdog(false);\n\t__clocksource_suspend_select(cs);\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(clocksource_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clocksource_suspend_select",
          "args": [
            "cs"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_suspend_select",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "681-702",
          "snippet": "static void __clocksource_suspend_select(struct clocksource *cs)\n{\n\t/*\n\t * Skip the clocksource which will be stopped in suspend state.\n\t */\n\tif (!(cs->flags & CLOCK_SOURCE_SUSPEND_NONSTOP))\n\t\treturn;\n\n\t/*\n\t * The nonstop clocksource can be selected as the suspend clocksource to\n\t * calculate the suspend time, so it should not supply suspend/resume\n\t * interfaces to suspend the nonstop clocksource when system suspends.\n\t */\n\tif (cs->suspend || cs->resume) {\n\t\tpr_warn(\"Nonstop clocksource %s should not supply suspend/resume interfaces\\n\",\n\t\t\tcs->name);\n\t}\n\n\t/* Pick the best rating. */\n\tif (!suspend_clocksource || cs->rating > suspend_clocksource->rating)\n\t\tsuspend_clocksource = cs;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\n\nstatic void __clocksource_suspend_select(struct clocksource *cs)\n{\n\t/*\n\t * Skip the clocksource which will be stopped in suspend state.\n\t */\n\tif (!(cs->flags & CLOCK_SOURCE_SUSPEND_NONSTOP))\n\t\treturn;\n\n\t/*\n\t * The nonstop clocksource can be selected as the suspend clocksource to\n\t * calculate the suspend time, so it should not supply suspend/resume\n\t * interfaces to suspend the nonstop clocksource when system suspends.\n\t */\n\tif (cs->suspend || cs->resume) {\n\t\tpr_warn(\"Nonstop clocksource %s should not supply suspend/resume interfaces\\n\",\n\t\t\tcs->name);\n\t}\n\n\t/* Pick the best rating. */\n\tif (!suspend_clocksource || cs->rating > suspend_clocksource->rating)\n\t\tsuspend_clocksource = cs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select_watchdog",
          "args": [
            "false"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "664-664",
          "snippet": "static void clocksource_select_watchdog(bool fallback) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select_watchdog(bool fallback) { }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select",
          "args": [],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_fallback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1007-1010",
          "snippet": "static void clocksource_select_fallback(void)\n{\n\t__clocksource_select(true);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select_fallback(void)\n{\n\t__clocksource_select(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_watchdog_unlock",
          "args": [
            "&flags"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_watchdog_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "672-672",
          "snippet": "static inline void clocksource_watchdog_unlock(unsigned long *flags) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_unlock(unsigned long *flags) { }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_enqueue_watchdog",
          "args": [
            "cs"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_enqueue_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "658-662",
          "snippet": "static void clocksource_enqueue_watchdog(struct clocksource *cs)\n{\n\tif (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS)\n\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_enqueue_watchdog(struct clocksource *cs)\n{\n\tif (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS)\n\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_enqueue",
          "args": [
            "cs"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_enqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1037-1049",
          "snippet": "static void clocksource_enqueue(struct clocksource *cs)\n{\n\tstruct list_head *entry = &clocksource_list;\n\tstruct clocksource *tmp;\n\n\tlist_for_each_entry(tmp, &clocksource_list, list) {\n\t\t/* Keep track of the place, where to insert */\n\t\tif (tmp->rating < cs->rating)\n\t\t\tbreak;\n\t\tentry = &tmp->list;\n\t}\n\tlist_add(&cs->list, entry);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clocksource_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\n\nstatic void clocksource_enqueue(struct clocksource *cs)\n{\n\tstruct list_head *entry = &clocksource_list;\n\tstruct clocksource *tmp;\n\n\tlist_for_each_entry(tmp, &clocksource_list, list) {\n\t\t/* Keep track of the place, where to insert */\n\t\tif (tmp->rating < cs->rating)\n\t\t\tbreak;\n\t\tentry = &tmp->list;\n\t}\n\tlist_add(&cs->list, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_watchdog_lock",
          "args": [
            "&flags"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_watchdog_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "671-671",
          "snippet": "static inline void clocksource_watchdog_lock(unsigned long *flags) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_lock(unsigned long *flags) { }"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clocksource_update_freq_scale",
          "args": [
            "cs",
            "scale",
            "freq"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_update_freq_scale",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1063-1136",
          "snippet": "void __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq)\n{\n\tu64 sec;\n\n\t/*\n\t * Default clocksources are *special* and self-define their mult/shift.\n\t * But, you're not special, so you should specify a freq value.\n\t */\n\tif (freq) {\n\t\t/*\n\t\t * Calc the maximum number of seconds which we can run before\n\t\t * wrapping around. For clocksources which have a mask > 32-bit\n\t\t * we need to limit the max sleep time to have a good\n\t\t * conversion precision. 10 minutes is still a reasonable\n\t\t * amount. That results in a shift value of 24 for a\n\t\t * clocksource with mask >= 40-bit and f >= 4GHz. That maps to\n\t\t * ~ 0.06ppm granularity for NTP.\n\t\t */\n\t\tsec = cs->mask;\n\t\tdo_div(sec, freq);\n\t\tdo_div(sec, scale);\n\t\tif (!sec)\n\t\t\tsec = 1;\n\t\telse if (sec > 600 && cs->mask > UINT_MAX)\n\t\t\tsec = 600;\n\n\t\tclocks_calc_mult_shift(&cs->mult, &cs->shift, freq,\n\t\t\t\t       NSEC_PER_SEC / scale, sec * scale);\n\t}\n\n\t/*\n\t * If the uncertainty margin is not specified, calculate it.\n\t * If both scale and freq are non-zero, calculate the clock\n\t * period, but bound below at 2*WATCHDOG_MAX_SKEW.  However,\n\t * if either of scale or freq is zero, be very conservative and\n\t * take the tens-of-milliseconds WATCHDOG_THRESHOLD value for the\n\t * uncertainty margin.  Allow stupidly small uncertainty margins\n\t * to be specified by the caller for testing purposes, but warn\n\t * to discourage production use of this capability.\n\t */\n\tif (scale && freq && !cs->uncertainty_margin) {\n\t\tcs->uncertainty_margin = NSEC_PER_SEC / (scale * freq);\n\t\tif (cs->uncertainty_margin < 2 * WATCHDOG_MAX_SKEW)\n\t\t\tcs->uncertainty_margin = 2 * WATCHDOG_MAX_SKEW;\n\t} else if (!cs->uncertainty_margin) {\n\t\tcs->uncertainty_margin = WATCHDOG_THRESHOLD;\n\t}\n\tWARN_ON_ONCE(cs->uncertainty_margin < 2 * WATCHDOG_MAX_SKEW);\n\n\t/*\n\t * Ensure clocksources that have large 'mult' values don't overflow\n\t * when adjusted.\n\t */\n\tcs->maxadj = clocksource_max_adjustment(cs);\n\twhile (freq && ((cs->mult + cs->maxadj < cs->mult)\n\t\t|| (cs->mult - cs->maxadj > cs->mult))) {\n\t\tcs->mult >>= 1;\n\t\tcs->shift--;\n\t\tcs->maxadj = clocksource_max_adjustment(cs);\n\t}\n\n\t/*\n\t * Only warn for *special* clocksources that self-define\n\t * their mult/shift values and don't specify a freq.\n\t */\n\tWARN_ONCE(cs->mult + cs->maxadj < cs->mult,\n\t\t\"timekeeping: Clocksource %s might overflow on 11%% adjustment\\n\",\n\t\tcs->name);\n\n\tclocksource_update_max_deferment(cs);\n\n\tpr_info(\"%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\\n\",\n\t\tcs->name, cs->mask, cs->max_cycles, cs->max_idle_ns);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [
            "#define WATCHDOG_MAX_SKEW (100 * NSEC_PER_USEC)",
            "#define WATCHDOG_THRESHOLD (NSEC_PER_SEC >> 5)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\n#define WATCHDOG_MAX_SKEW (100 * NSEC_PER_USEC)\n#define WATCHDOG_THRESHOLD (NSEC_PER_SEC >> 5)\n\nvoid __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq)\n{\n\tu64 sec;\n\n\t/*\n\t * Default clocksources are *special* and self-define their mult/shift.\n\t * But, you're not special, so you should specify a freq value.\n\t */\n\tif (freq) {\n\t\t/*\n\t\t * Calc the maximum number of seconds which we can run before\n\t\t * wrapping around. For clocksources which have a mask > 32-bit\n\t\t * we need to limit the max sleep time to have a good\n\t\t * conversion precision. 10 minutes is still a reasonable\n\t\t * amount. That results in a shift value of 24 for a\n\t\t * clocksource with mask >= 40-bit and f >= 4GHz. That maps to\n\t\t * ~ 0.06ppm granularity for NTP.\n\t\t */\n\t\tsec = cs->mask;\n\t\tdo_div(sec, freq);\n\t\tdo_div(sec, scale);\n\t\tif (!sec)\n\t\t\tsec = 1;\n\t\telse if (sec > 600 && cs->mask > UINT_MAX)\n\t\t\tsec = 600;\n\n\t\tclocks_calc_mult_shift(&cs->mult, &cs->shift, freq,\n\t\t\t\t       NSEC_PER_SEC / scale, sec * scale);\n\t}\n\n\t/*\n\t * If the uncertainty margin is not specified, calculate it.\n\t * If both scale and freq are non-zero, calculate the clock\n\t * period, but bound below at 2*WATCHDOG_MAX_SKEW.  However,\n\t * if either of scale or freq is zero, be very conservative and\n\t * take the tens-of-milliseconds WATCHDOG_THRESHOLD value for the\n\t * uncertainty margin.  Allow stupidly small uncertainty margins\n\t * to be specified by the caller for testing purposes, but warn\n\t * to discourage production use of this capability.\n\t */\n\tif (scale && freq && !cs->uncertainty_margin) {\n\t\tcs->uncertainty_margin = NSEC_PER_SEC / (scale * freq);\n\t\tif (cs->uncertainty_margin < 2 * WATCHDOG_MAX_SKEW)\n\t\t\tcs->uncertainty_margin = 2 * WATCHDOG_MAX_SKEW;\n\t} else if (!cs->uncertainty_margin) {\n\t\tcs->uncertainty_margin = WATCHDOG_THRESHOLD;\n\t}\n\tWARN_ON_ONCE(cs->uncertainty_margin < 2 * WATCHDOG_MAX_SKEW);\n\n\t/*\n\t * Ensure clocksources that have large 'mult' values don't overflow\n\t * when adjusted.\n\t */\n\tcs->maxadj = clocksource_max_adjustment(cs);\n\twhile (freq && ((cs->mult + cs->maxadj < cs->mult)\n\t\t|| (cs->mult - cs->maxadj > cs->mult))) {\n\t\tcs->mult >>= 1;\n\t\tcs->shift--;\n\t\tcs->maxadj = clocksource_max_adjustment(cs);\n\t}\n\n\t/*\n\t * Only warn for *special* clocksources that self-define\n\t * their mult/shift values and don't specify a freq.\n\t */\n\tWARN_ONCE(cs->mult + cs->maxadj < cs->mult,\n\t\t\"timekeeping: Clocksource %s might overflow on 11%% adjustment\\n\",\n\t\tcs->name);\n\n\tclocksource_update_max_deferment(cs);\n\n\tpr_info(\"%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\\n\",\n\t\tcs->name, cs->mask, cs->max_cycles, cs->max_idle_ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"clocksource %s registered with invalid VDSO mode %d. Disabling VDSO support.\\n\"",
            "cs->name",
            "cs->vdso_clock_mode"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(unsigned int)cs->id >= CSID_MAX"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_arch_init",
          "args": [
            "cs"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(clocksource_mutex);\n\nint __clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq)\n{\n\tunsigned long flags;\n\n\tclocksource_arch_init(cs);\n\n\tif (WARN_ON_ONCE((unsigned int)cs->id >= CSID_MAX))\n\t\tcs->id = CSID_GENERIC;\n\tif (cs->vdso_clock_mode < 0 ||\n\t    cs->vdso_clock_mode >= VDSO_CLOCKMODE_MAX) {\n\t\tpr_warn(\"clocksource %s registered with invalid VDSO mode %d. Disabling VDSO support.\\n\",\n\t\t\tcs->name, cs->vdso_clock_mode);\n\t\tcs->vdso_clock_mode = VDSO_CLOCKMODE_NONE;\n\t}\n\n\t/* Initialize mult/shift and max_idle_ns */\n\t__clocksource_update_freq_scale(cs, scale, freq);\n\n\t/* Add clocksource to the clocksource list */\n\tmutex_lock(&clocksource_mutex);\n\n\tclocksource_watchdog_lock(&flags);\n\tclocksource_enqueue(cs);\n\tclocksource_enqueue_watchdog(cs);\n\tclocksource_watchdog_unlock(&flags);\n\n\tclocksource_select();\n\tclocksource_select_watchdog(false);\n\t__clocksource_suspend_select(cs);\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "__clocksource_update_freq_scale",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1063-1136",
    "snippet": "void __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq)\n{\n\tu64 sec;\n\n\t/*\n\t * Default clocksources are *special* and self-define their mult/shift.\n\t * But, you're not special, so you should specify a freq value.\n\t */\n\tif (freq) {\n\t\t/*\n\t\t * Calc the maximum number of seconds which we can run before\n\t\t * wrapping around. For clocksources which have a mask > 32-bit\n\t\t * we need to limit the max sleep time to have a good\n\t\t * conversion precision. 10 minutes is still a reasonable\n\t\t * amount. That results in a shift value of 24 for a\n\t\t * clocksource with mask >= 40-bit and f >= 4GHz. That maps to\n\t\t * ~ 0.06ppm granularity for NTP.\n\t\t */\n\t\tsec = cs->mask;\n\t\tdo_div(sec, freq);\n\t\tdo_div(sec, scale);\n\t\tif (!sec)\n\t\t\tsec = 1;\n\t\telse if (sec > 600 && cs->mask > UINT_MAX)\n\t\t\tsec = 600;\n\n\t\tclocks_calc_mult_shift(&cs->mult, &cs->shift, freq,\n\t\t\t\t       NSEC_PER_SEC / scale, sec * scale);\n\t}\n\n\t/*\n\t * If the uncertainty margin is not specified, calculate it.\n\t * If both scale and freq are non-zero, calculate the clock\n\t * period, but bound below at 2*WATCHDOG_MAX_SKEW.  However,\n\t * if either of scale or freq is zero, be very conservative and\n\t * take the tens-of-milliseconds WATCHDOG_THRESHOLD value for the\n\t * uncertainty margin.  Allow stupidly small uncertainty margins\n\t * to be specified by the caller for testing purposes, but warn\n\t * to discourage production use of this capability.\n\t */\n\tif (scale && freq && !cs->uncertainty_margin) {\n\t\tcs->uncertainty_margin = NSEC_PER_SEC / (scale * freq);\n\t\tif (cs->uncertainty_margin < 2 * WATCHDOG_MAX_SKEW)\n\t\t\tcs->uncertainty_margin = 2 * WATCHDOG_MAX_SKEW;\n\t} else if (!cs->uncertainty_margin) {\n\t\tcs->uncertainty_margin = WATCHDOG_THRESHOLD;\n\t}\n\tWARN_ON_ONCE(cs->uncertainty_margin < 2 * WATCHDOG_MAX_SKEW);\n\n\t/*\n\t * Ensure clocksources that have large 'mult' values don't overflow\n\t * when adjusted.\n\t */\n\tcs->maxadj = clocksource_max_adjustment(cs);\n\twhile (freq && ((cs->mult + cs->maxadj < cs->mult)\n\t\t|| (cs->mult - cs->maxadj > cs->mult))) {\n\t\tcs->mult >>= 1;\n\t\tcs->shift--;\n\t\tcs->maxadj = clocksource_max_adjustment(cs);\n\t}\n\n\t/*\n\t * Only warn for *special* clocksources that self-define\n\t * their mult/shift values and don't specify a freq.\n\t */\n\tWARN_ONCE(cs->mult + cs->maxadj < cs->mult,\n\t\t\"timekeeping: Clocksource %s might overflow on 11%% adjustment\\n\",\n\t\tcs->name);\n\n\tclocksource_update_max_deferment(cs);\n\n\tpr_info(\"%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\\n\",\n\t\tcs->name, cs->mask, cs->max_cycles, cs->max_idle_ns);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [
      "#define WATCHDOG_MAX_SKEW (100 * NSEC_PER_USEC)",
      "#define WATCHDOG_THRESHOLD (NSEC_PER_SEC >> 5)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\\n\"",
            "cs->name",
            "cs->mask",
            "cs->max_cycles",
            "cs->max_idle_ns"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_update_max_deferment",
          "args": [
            "cs"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_update_max_deferment",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "914-919",
          "snippet": "static inline void clocksource_update_max_deferment(struct clocksource *cs)\n{\n\tcs->max_idle_ns = clocks_calc_max_nsecs(cs->mult, cs->shift,\n\t\t\t\t\t\tcs->maxadj, cs->mask,\n\t\t\t\t\t\t&cs->max_cycles);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_update_max_deferment(struct clocksource *cs)\n{\n\tcs->max_idle_ns = clocks_calc_max_nsecs(cs->mult, cs->shift,\n\t\t\t\t\t\tcs->maxadj, cs->mask,\n\t\t\t\t\t\t&cs->max_cycles);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "cs->mult + cs->maxadj < cs->mult",
            "\"timekeeping: Clocksource %s might overflow on 11%% adjustment\\n\"",
            "cs->name"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_max_adjustment",
          "args": [
            "cs"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_max_adjustment",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "853-862",
          "snippet": "static u32 clocksource_max_adjustment(struct clocksource *cs)\n{\n\tu64 ret;\n\t/*\n\t * We won't try to correct for more than 11% adjustments (110,000 ppm),\n\t */\n\tret = (u64)cs->mult * 11;\n\tdo_div(ret,100);\n\treturn (u32)ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic u32 clocksource_max_adjustment(struct clocksource *cs)\n{\n\tu64 ret;\n\t/*\n\t * We won't try to correct for more than 11% adjustments (110,000 ppm),\n\t */\n\tret = (u64)cs->mult * 11;\n\tdo_div(ret,100);\n\treturn (u32)ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cs->uncertainty_margin < 2 * WATCHDOG_MAX_SKEW"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocks_calc_mult_shift",
          "args": [
            "&cs->mult",
            "&cs->shift",
            "freq",
            "NSEC_PER_SEC / scale",
            "sec * scale"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "clocks_calc_mult_shift",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "46-75",
          "snippet": "void\nclocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)\n{\n\tu64 tmp;\n\tu32 sft, sftacc= 32;\n\n\t/*\n\t * Calculate the shift factor which is limiting the conversion\n\t * range:\n\t */\n\ttmp = ((u64)maxsec * from) >> 32;\n\twhile (tmp) {\n\t\ttmp >>=1;\n\t\tsftacc--;\n\t}\n\n\t/*\n\t * Find the conversion shift/mult pair which has the best\n\t * accuracy and fits the maxsec conversion range:\n\t */\n\tfor (sft = 32; sft > 0; sft--) {\n\t\ttmp = (u64) to << sft;\n\t\ttmp += from / 2;\n\t\tdo_div(tmp, from);\n\t\tif ((tmp >> sftacc) == 0)\n\t\t\tbreak;\n\t}\n\t*mult = tmp;\n\t*shift = sft;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid\nclocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)\n{\n\tu64 tmp;\n\tu32 sft, sftacc= 32;\n\n\t/*\n\t * Calculate the shift factor which is limiting the conversion\n\t * range:\n\t */\n\ttmp = ((u64)maxsec * from) >> 32;\n\twhile (tmp) {\n\t\ttmp >>=1;\n\t\tsftacc--;\n\t}\n\n\t/*\n\t * Find the conversion shift/mult pair which has the best\n\t * accuracy and fits the maxsec conversion range:\n\t */\n\tfor (sft = 32; sft > 0; sft--) {\n\t\ttmp = (u64) to << sft;\n\t\ttmp += from / 2;\n\t\tdo_div(tmp, from);\n\t\tif ((tmp >> sftacc) == 0)\n\t\t\tbreak;\n\t}\n\t*mult = tmp;\n\t*shift = sft;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "sec",
            "scale"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "sec",
            "freq"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\n#define WATCHDOG_MAX_SKEW (100 * NSEC_PER_USEC)\n#define WATCHDOG_THRESHOLD (NSEC_PER_SEC >> 5)\n\nvoid __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq)\n{\n\tu64 sec;\n\n\t/*\n\t * Default clocksources are *special* and self-define their mult/shift.\n\t * But, you're not special, so you should specify a freq value.\n\t */\n\tif (freq) {\n\t\t/*\n\t\t * Calc the maximum number of seconds which we can run before\n\t\t * wrapping around. For clocksources which have a mask > 32-bit\n\t\t * we need to limit the max sleep time to have a good\n\t\t * conversion precision. 10 minutes is still a reasonable\n\t\t * amount. That results in a shift value of 24 for a\n\t\t * clocksource with mask >= 40-bit and f >= 4GHz. That maps to\n\t\t * ~ 0.06ppm granularity for NTP.\n\t\t */\n\t\tsec = cs->mask;\n\t\tdo_div(sec, freq);\n\t\tdo_div(sec, scale);\n\t\tif (!sec)\n\t\t\tsec = 1;\n\t\telse if (sec > 600 && cs->mask > UINT_MAX)\n\t\t\tsec = 600;\n\n\t\tclocks_calc_mult_shift(&cs->mult, &cs->shift, freq,\n\t\t\t\t       NSEC_PER_SEC / scale, sec * scale);\n\t}\n\n\t/*\n\t * If the uncertainty margin is not specified, calculate it.\n\t * If both scale and freq are non-zero, calculate the clock\n\t * period, but bound below at 2*WATCHDOG_MAX_SKEW.  However,\n\t * if either of scale or freq is zero, be very conservative and\n\t * take the tens-of-milliseconds WATCHDOG_THRESHOLD value for the\n\t * uncertainty margin.  Allow stupidly small uncertainty margins\n\t * to be specified by the caller for testing purposes, but warn\n\t * to discourage production use of this capability.\n\t */\n\tif (scale && freq && !cs->uncertainty_margin) {\n\t\tcs->uncertainty_margin = NSEC_PER_SEC / (scale * freq);\n\t\tif (cs->uncertainty_margin < 2 * WATCHDOG_MAX_SKEW)\n\t\t\tcs->uncertainty_margin = 2 * WATCHDOG_MAX_SKEW;\n\t} else if (!cs->uncertainty_margin) {\n\t\tcs->uncertainty_margin = WATCHDOG_THRESHOLD;\n\t}\n\tWARN_ON_ONCE(cs->uncertainty_margin < 2 * WATCHDOG_MAX_SKEW);\n\n\t/*\n\t * Ensure clocksources that have large 'mult' values don't overflow\n\t * when adjusted.\n\t */\n\tcs->maxadj = clocksource_max_adjustment(cs);\n\twhile (freq && ((cs->mult + cs->maxadj < cs->mult)\n\t\t|| (cs->mult - cs->maxadj > cs->mult))) {\n\t\tcs->mult >>= 1;\n\t\tcs->shift--;\n\t\tcs->maxadj = clocksource_max_adjustment(cs);\n\t}\n\n\t/*\n\t * Only warn for *special* clocksources that self-define\n\t * their mult/shift values and don't specify a freq.\n\t */\n\tWARN_ONCE(cs->mult + cs->maxadj < cs->mult,\n\t\t\"timekeeping: Clocksource %s might overflow on 11%% adjustment\\n\",\n\t\tcs->name);\n\n\tclocksource_update_max_deferment(cs);\n\n\tpr_info(\"%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\\n\",\n\t\tcs->name, cs->mask, cs->max_cycles, cs->max_idle_ns);\n}"
  },
  {
    "function_name": "clocksource_enqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1037-1049",
    "snippet": "static void clocksource_enqueue(struct clocksource *cs)\n{\n\tstruct list_head *entry = &clocksource_list;\n\tstruct clocksource *tmp;\n\n\tlist_for_each_entry(tmp, &clocksource_list, list) {\n\t\t/* Keep track of the place, where to insert */\n\t\tif (tmp->rating < cs->rating)\n\t\t\tbreak;\n\t\tentry = &tmp->list;\n\t}\n\tlist_add(&cs->list, entry);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clocksource_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cs->list",
            "entry"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&clocksource_list",
            "list"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\n\nstatic void clocksource_enqueue(struct clocksource *cs)\n{\n\tstruct list_head *entry = &clocksource_list;\n\tstruct clocksource *tmp;\n\n\tlist_for_each_entry(tmp, &clocksource_list, list) {\n\t\t/* Keep track of the place, where to insert */\n\t\tif (tmp->rating < cs->rating)\n\t\t\tbreak;\n\t\tentry = &tmp->list;\n\t}\n\tlist_add(&cs->list, entry);\n}"
  },
  {
    "function_name": "clocksource_done_booting",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1019-1031",
    "snippet": "static int __init clocksource_done_booting(void)\n{\n\tmutex_lock(&clocksource_mutex);\n\tcurr_clocksource = clocksource_default_clock();\n\tfinished_booting = 1;\n\t/*\n\t * Run the watchdog first to eliminate unstable clock sources\n\t */\n\t__clocksource_watchdog_kthread();\n\tclocksource_select();\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *curr_clocksource;",
      "static DEFINE_MUTEX(clocksource_mutex);",
      "static int finished_booting;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select",
          "args": [],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_fallback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1007-1010",
          "snippet": "static void clocksource_select_fallback(void)\n{\n\t__clocksource_select(true);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select_fallback(void)\n{\n\t__clocksource_select(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clocksource_watchdog_kthread",
          "args": [],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_watchdog_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "667-667",
          "snippet": "static inline int __clocksource_watchdog_kthread(void) { return 0; }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline int __clocksource_watchdog_kthread(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_default_clock",
          "args": [],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_default_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/jiffies.c",
          "lines": "71-74",
          "snippet": "__weak clocksource_default_clock(void)\n{\n\treturn &clocksource_jiffies;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource clocksource_jiffies = {\n\t.name\t\t\t= \"jiffies\",\n\t.rating\t\t\t= 1, /* lowest valid rating*/\n\t.uncertainty_margin\t= 32 * NSEC_PER_MSEC,\n\t.read\t\t\t= jiffies_read,\n\t.mask\t\t\t= CLOCKSOURCE_MASK(32),\n\t.mult\t\t\t= TICK_NSEC << JIFFIES_SHIFT, /* details above */\n\t.shift\t\t\t= JIFFIES_SHIFT,\n\t.max_cycles\t\t= 10,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include \"timekeeping.h\"\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n\nstatic struct clocksource clocksource_jiffies = {\n\t.name\t\t\t= \"jiffies\",\n\t.rating\t\t\t= 1, /* lowest valid rating*/\n\t.uncertainty_margin\t= 32 * NSEC_PER_MSEC,\n\t.read\t\t\t= jiffies_read,\n\t.mask\t\t\t= CLOCKSOURCE_MASK(32),\n\t.mult\t\t\t= TICK_NSEC << JIFFIES_SHIFT, /* details above */\n\t.shift\t\t\t= JIFFIES_SHIFT,\n\t.max_cycles\t\t= 10,\n};\n\n__weak clocksource_default_clock(void)\n{\n\treturn &clocksource_jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\nstatic DEFINE_MUTEX(clocksource_mutex);\nstatic int finished_booting;\n\nstatic int __init clocksource_done_booting(void)\n{\n\tmutex_lock(&clocksource_mutex);\n\tcurr_clocksource = clocksource_default_clock();\n\tfinished_booting = 1;\n\t/*\n\t * Run the watchdog first to eliminate unstable clock sources\n\t */\n\t__clocksource_watchdog_kthread();\n\tclocksource_select();\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "clocksource_select_fallback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1007-1010",
    "snippet": "static void clocksource_select_fallback(void)\n{\n\t__clocksource_select(true);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clocksource_select",
          "args": [
            "true"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_select",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "943-992",
          "snippet": "static void __clocksource_select(bool skipcur)\n{\n\tbool oneshot = tick_oneshot_mode_active();\n\tstruct clocksource *best, *cs;\n\n\t/* Find the best suitable clocksource */\n\tbest = clocksource_find_best(oneshot, skipcur);\n\tif (!best)\n\t\treturn;\n\n\tif (!strlen(override_name))\n\t\tgoto found;\n\n\t/* Check for the override clocksource. */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (strcmp(cs->name, override_name) != 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check to make sure we don't switch to a non-highres\n\t\t * capable clocksource if the tick code is in oneshot\n\t\t * mode (highres or nohz)\n\t\t */\n\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) && oneshot) {\n\t\t\t/* Override clocksource cannot be used. */\n\t\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\t\tpr_warn(\"Override clocksource %s is unstable and not HRT compatible - cannot switch while in HRT/NOHZ mode\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t\toverride_name[0] = 0;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * The override cannot be currently verified.\n\t\t\t\t * Deferring to let the watchdog check.\n\t\t\t\t */\n\t\t\t\tpr_info(\"Override clocksource %s is not currently HRT compatible - deferring\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t}\n\t\t} else\n\t\t\t/* Override clocksource can be used. */\n\t\t\tbest = cs;\n\t\tbreak;\n\t}\n\nfound:\n\tif (curr_clocksource != best && !timekeeping_notify(best)) {\n\t\tpr_info(\"Switched to clocksource %s\\n\", best->name);\n\t\tcurr_clocksource = best;\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *curr_clocksource;",
            "static LIST_HEAD(clocksource_list);",
            "static char override_name[CS_NAME_LEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\nstatic LIST_HEAD(clocksource_list);\nstatic char override_name[CS_NAME_LEN];\n\nstatic void __clocksource_select(bool skipcur)\n{\n\tbool oneshot = tick_oneshot_mode_active();\n\tstruct clocksource *best, *cs;\n\n\t/* Find the best suitable clocksource */\n\tbest = clocksource_find_best(oneshot, skipcur);\n\tif (!best)\n\t\treturn;\n\n\tif (!strlen(override_name))\n\t\tgoto found;\n\n\t/* Check for the override clocksource. */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (strcmp(cs->name, override_name) != 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check to make sure we don't switch to a non-highres\n\t\t * capable clocksource if the tick code is in oneshot\n\t\t * mode (highres or nohz)\n\t\t */\n\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) && oneshot) {\n\t\t\t/* Override clocksource cannot be used. */\n\t\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\t\tpr_warn(\"Override clocksource %s is unstable and not HRT compatible - cannot switch while in HRT/NOHZ mode\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t\toverride_name[0] = 0;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * The override cannot be currently verified.\n\t\t\t\t * Deferring to let the watchdog check.\n\t\t\t\t */\n\t\t\t\tpr_info(\"Override clocksource %s is not currently HRT compatible - deferring\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t}\n\t\t} else\n\t\t\t/* Override clocksource can be used. */\n\t\t\tbest = cs;\n\t\tbreak;\n\t}\n\nfound:\n\tif (curr_clocksource != best && !timekeeping_notify(best)) {\n\t\tpr_info(\"Switched to clocksource %s\\n\", best->name);\n\t\tcurr_clocksource = best;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select_fallback(void)\n{\n\t__clocksource_select(true);\n}"
  },
  {
    "function_name": "clocksource_select",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "1002-1005",
    "snippet": "static void clocksource_select(void)\n{\n\t__clocksource_select(false);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clocksource_select",
          "args": [
            "false"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_select",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "943-992",
          "snippet": "static void __clocksource_select(bool skipcur)\n{\n\tbool oneshot = tick_oneshot_mode_active();\n\tstruct clocksource *best, *cs;\n\n\t/* Find the best suitable clocksource */\n\tbest = clocksource_find_best(oneshot, skipcur);\n\tif (!best)\n\t\treturn;\n\n\tif (!strlen(override_name))\n\t\tgoto found;\n\n\t/* Check for the override clocksource. */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (strcmp(cs->name, override_name) != 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check to make sure we don't switch to a non-highres\n\t\t * capable clocksource if the tick code is in oneshot\n\t\t * mode (highres or nohz)\n\t\t */\n\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) && oneshot) {\n\t\t\t/* Override clocksource cannot be used. */\n\t\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\t\tpr_warn(\"Override clocksource %s is unstable and not HRT compatible - cannot switch while in HRT/NOHZ mode\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t\toverride_name[0] = 0;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * The override cannot be currently verified.\n\t\t\t\t * Deferring to let the watchdog check.\n\t\t\t\t */\n\t\t\t\tpr_info(\"Override clocksource %s is not currently HRT compatible - deferring\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t}\n\t\t} else\n\t\t\t/* Override clocksource can be used. */\n\t\t\tbest = cs;\n\t\tbreak;\n\t}\n\nfound:\n\tif (curr_clocksource != best && !timekeeping_notify(best)) {\n\t\tpr_info(\"Switched to clocksource %s\\n\", best->name);\n\t\tcurr_clocksource = best;\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *curr_clocksource;",
            "static LIST_HEAD(clocksource_list);",
            "static char override_name[CS_NAME_LEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\nstatic LIST_HEAD(clocksource_list);\nstatic char override_name[CS_NAME_LEN];\n\nstatic void __clocksource_select(bool skipcur)\n{\n\tbool oneshot = tick_oneshot_mode_active();\n\tstruct clocksource *best, *cs;\n\n\t/* Find the best suitable clocksource */\n\tbest = clocksource_find_best(oneshot, skipcur);\n\tif (!best)\n\t\treturn;\n\n\tif (!strlen(override_name))\n\t\tgoto found;\n\n\t/* Check for the override clocksource. */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (strcmp(cs->name, override_name) != 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check to make sure we don't switch to a non-highres\n\t\t * capable clocksource if the tick code is in oneshot\n\t\t * mode (highres or nohz)\n\t\t */\n\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) && oneshot) {\n\t\t\t/* Override clocksource cannot be used. */\n\t\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\t\tpr_warn(\"Override clocksource %s is unstable and not HRT compatible - cannot switch while in HRT/NOHZ mode\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t\toverride_name[0] = 0;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * The override cannot be currently verified.\n\t\t\t\t * Deferring to let the watchdog check.\n\t\t\t\t */\n\t\t\t\tpr_info(\"Override clocksource %s is not currently HRT compatible - deferring\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t}\n\t\t} else\n\t\t\t/* Override clocksource can be used. */\n\t\t\tbest = cs;\n\t\tbreak;\n\t}\n\nfound:\n\tif (curr_clocksource != best && !timekeeping_notify(best)) {\n\t\tpr_info(\"Switched to clocksource %s\\n\", best->name);\n\t\tcurr_clocksource = best;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select(void)\n{\n\t__clocksource_select(false);\n}"
  },
  {
    "function_name": "__clocksource_select",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "943-992",
    "snippet": "static void __clocksource_select(bool skipcur)\n{\n\tbool oneshot = tick_oneshot_mode_active();\n\tstruct clocksource *best, *cs;\n\n\t/* Find the best suitable clocksource */\n\tbest = clocksource_find_best(oneshot, skipcur);\n\tif (!best)\n\t\treturn;\n\n\tif (!strlen(override_name))\n\t\tgoto found;\n\n\t/* Check for the override clocksource. */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (strcmp(cs->name, override_name) != 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check to make sure we don't switch to a non-highres\n\t\t * capable clocksource if the tick code is in oneshot\n\t\t * mode (highres or nohz)\n\t\t */\n\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) && oneshot) {\n\t\t\t/* Override clocksource cannot be used. */\n\t\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\t\tpr_warn(\"Override clocksource %s is unstable and not HRT compatible - cannot switch while in HRT/NOHZ mode\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t\toverride_name[0] = 0;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * The override cannot be currently verified.\n\t\t\t\t * Deferring to let the watchdog check.\n\t\t\t\t */\n\t\t\t\tpr_info(\"Override clocksource %s is not currently HRT compatible - deferring\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t}\n\t\t} else\n\t\t\t/* Override clocksource can be used. */\n\t\t\tbest = cs;\n\t\tbreak;\n\t}\n\nfound:\n\tif (curr_clocksource != best && !timekeeping_notify(best)) {\n\t\tpr_info(\"Switched to clocksource %s\\n\", best->name);\n\t\tcurr_clocksource = best;\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *curr_clocksource;",
      "static LIST_HEAD(clocksource_list);",
      "static char override_name[CS_NAME_LEN];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Switched to clocksource %s\\n\"",
            "best->name"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_notify",
          "args": [
            "best"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_notify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1479-1488",
          "snippet": "int timekeeping_notify(struct clocksource *clock)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tif (tk->tkr_mono.clock == clock)\n\t\treturn 0;\n\tstop_machine(change_clocksource, clock, NULL);\n\ttick_clock_notify();\n\treturn tk->tkr_mono.clock == clock ? 0 : -1;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nint timekeeping_notify(struct clocksource *clock)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tif (tk->tkr_mono.clock == clock)\n\t\treturn 0;\n\tstop_machine(change_clocksource, clock, NULL);\n\ttick_clock_notify();\n\treturn tk->tkr_mono.clock == clock ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Override clocksource %s is not currently HRT compatible - deferring\\n\"",
            "cs->name"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Override clocksource %s is unstable and not HRT compatible - cannot switch while in HRT/NOHZ mode\\n\"",
            "cs->name"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cs->name",
            "override_name"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cs",
            "&clocksource_list",
            "list"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "override_name"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_find_best",
          "args": [
            "oneshot",
            "skipcur"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_find_best",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "921-941",
          "snippet": "static struct clocksource *clocksource_find_best(bool oneshot, bool skipcur)\n{\n\tstruct clocksource *cs;\n\n\tif (!finished_booting || list_empty(&clocksource_list))\n\t\treturn NULL;\n\n\t/*\n\t * We pick the clocksource with the highest rating. If oneshot\n\t * mode is active, we pick the highres valid clocksource with\n\t * the best rating.\n\t */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (oneshot && !(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES))\n\t\t\tcontinue;\n\t\treturn cs;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *curr_clocksource;",
            "static LIST_HEAD(clocksource_list);",
            "static int finished_booting;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\nstatic LIST_HEAD(clocksource_list);\nstatic int finished_booting;\n\nstatic struct clocksource *clocksource_find_best(bool oneshot, bool skipcur)\n{\n\tstruct clocksource *cs;\n\n\tif (!finished_booting || list_empty(&clocksource_list))\n\t\treturn NULL;\n\n\t/*\n\t * We pick the clocksource with the highest rating. If oneshot\n\t * mode is active, we pick the highres valid clocksource with\n\t * the best rating.\n\t */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (oneshot && !(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES))\n\t\t\tcontinue;\n\t\treturn cs;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_oneshot_mode_active",
          "args": [],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "tick_oneshot_mode_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-oneshot.c",
          "lines": "106-116",
          "snippet": "int tick_oneshot_mode_active(void)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = __this_cpu_read(tick_cpu_device.mode) == TICKDEV_MODE_ONESHOT;\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_oneshot_mode_active(void)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = __this_cpu_read(tick_cpu_device.mode) == TICKDEV_MODE_ONESHOT;\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\nstatic LIST_HEAD(clocksource_list);\nstatic char override_name[CS_NAME_LEN];\n\nstatic void __clocksource_select(bool skipcur)\n{\n\tbool oneshot = tick_oneshot_mode_active();\n\tstruct clocksource *best, *cs;\n\n\t/* Find the best suitable clocksource */\n\tbest = clocksource_find_best(oneshot, skipcur);\n\tif (!best)\n\t\treturn;\n\n\tif (!strlen(override_name))\n\t\tgoto found;\n\n\t/* Check for the override clocksource. */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (strcmp(cs->name, override_name) != 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check to make sure we don't switch to a non-highres\n\t\t * capable clocksource if the tick code is in oneshot\n\t\t * mode (highres or nohz)\n\t\t */\n\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) && oneshot) {\n\t\t\t/* Override clocksource cannot be used. */\n\t\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\t\tpr_warn(\"Override clocksource %s is unstable and not HRT compatible - cannot switch while in HRT/NOHZ mode\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t\toverride_name[0] = 0;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * The override cannot be currently verified.\n\t\t\t\t * Deferring to let the watchdog check.\n\t\t\t\t */\n\t\t\t\tpr_info(\"Override clocksource %s is not currently HRT compatible - deferring\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t}\n\t\t} else\n\t\t\t/* Override clocksource can be used. */\n\t\t\tbest = cs;\n\t\tbreak;\n\t}\n\nfound:\n\tif (curr_clocksource != best && !timekeeping_notify(best)) {\n\t\tpr_info(\"Switched to clocksource %s\\n\", best->name);\n\t\tcurr_clocksource = best;\n\t}\n}"
  },
  {
    "function_name": "clocksource_find_best",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "921-941",
    "snippet": "static struct clocksource *clocksource_find_best(bool oneshot, bool skipcur)\n{\n\tstruct clocksource *cs;\n\n\tif (!finished_booting || list_empty(&clocksource_list))\n\t\treturn NULL;\n\n\t/*\n\t * We pick the clocksource with the highest rating. If oneshot\n\t * mode is active, we pick the highres valid clocksource with\n\t * the best rating.\n\t */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (oneshot && !(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES))\n\t\t\tcontinue;\n\t\treturn cs;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *curr_clocksource;",
      "static LIST_HEAD(clocksource_list);",
      "static int finished_booting;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cs",
            "&clocksource_list",
            "list"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clocksource_list"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\nstatic LIST_HEAD(clocksource_list);\nstatic int finished_booting;\n\nstatic struct clocksource *clocksource_find_best(bool oneshot, bool skipcur)\n{\n\tstruct clocksource *cs;\n\n\tif (!finished_booting || list_empty(&clocksource_list))\n\t\treturn NULL;\n\n\t/*\n\t * We pick the clocksource with the highest rating. If oneshot\n\t * mode is active, we pick the highres valid clocksource with\n\t * the best rating.\n\t */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (oneshot && !(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES))\n\t\t\tcontinue;\n\t\treturn cs;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "clocksource_update_max_deferment",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "914-919",
    "snippet": "static inline void clocksource_update_max_deferment(struct clocksource *cs)\n{\n\tcs->max_idle_ns = clocks_calc_max_nsecs(cs->mult, cs->shift,\n\t\t\t\t\t\tcs->maxadj, cs->mask,\n\t\t\t\t\t\t&cs->max_cycles);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocks_calc_max_nsecs",
          "args": [
            "cs->mult",
            "cs->shift",
            "cs->maxadj",
            "cs->mask",
            "&cs->max_cycles"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "clocks_calc_max_nsecs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "879-907",
          "snippet": "u64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cyc)\n{\n\tu64 max_nsecs, max_cycles;\n\n\t/*\n\t * Calculate the maximum number of cycles that we can pass to the\n\t * cyc2ns() function without overflowing a 64-bit result.\n\t */\n\tmax_cycles = ULLONG_MAX;\n\tdo_div(max_cycles, mult+maxadj);\n\n\t/*\n\t * The actual maximum number of cycles we can defer the clocksource is\n\t * determined by the minimum of max_cycles and mask.\n\t * Note: Here we subtract the maxadj to make sure we don't sleep for\n\t * too long if there's a large negative adjustment.\n\t */\n\tmax_cycles = min(max_cycles, mask);\n\tmax_nsecs = clocksource_cyc2ns(max_cycles, mult - maxadj, shift);\n\n\t/* return the max_cycles value as well if requested */\n\tif (max_cyc)\n\t\t*max_cyc = max_cycles;\n\n\t/* Return 50% of the actual maximum, so we can detect bad values */\n\tmax_nsecs >>= 1;\n\n\treturn max_nsecs;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nu64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cyc)\n{\n\tu64 max_nsecs, max_cycles;\n\n\t/*\n\t * Calculate the maximum number of cycles that we can pass to the\n\t * cyc2ns() function without overflowing a 64-bit result.\n\t */\n\tmax_cycles = ULLONG_MAX;\n\tdo_div(max_cycles, mult+maxadj);\n\n\t/*\n\t * The actual maximum number of cycles we can defer the clocksource is\n\t * determined by the minimum of max_cycles and mask.\n\t * Note: Here we subtract the maxadj to make sure we don't sleep for\n\t * too long if there's a large negative adjustment.\n\t */\n\tmax_cycles = min(max_cycles, mask);\n\tmax_nsecs = clocksource_cyc2ns(max_cycles, mult - maxadj, shift);\n\n\t/* return the max_cycles value as well if requested */\n\tif (max_cyc)\n\t\t*max_cyc = max_cycles;\n\n\t/* Return 50% of the actual maximum, so we can detect bad values */\n\tmax_nsecs >>= 1;\n\n\treturn max_nsecs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_update_max_deferment(struct clocksource *cs)\n{\n\tcs->max_idle_ns = clocks_calc_max_nsecs(cs->mult, cs->shift,\n\t\t\t\t\t\tcs->maxadj, cs->mask,\n\t\t\t\t\t\t&cs->max_cycles);\n}"
  },
  {
    "function_name": "clocks_calc_max_nsecs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "879-907",
    "snippet": "u64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cyc)\n{\n\tu64 max_nsecs, max_cycles;\n\n\t/*\n\t * Calculate the maximum number of cycles that we can pass to the\n\t * cyc2ns() function without overflowing a 64-bit result.\n\t */\n\tmax_cycles = ULLONG_MAX;\n\tdo_div(max_cycles, mult+maxadj);\n\n\t/*\n\t * The actual maximum number of cycles we can defer the clocksource is\n\t * determined by the minimum of max_cycles and mask.\n\t * Note: Here we subtract the maxadj to make sure we don't sleep for\n\t * too long if there's a large negative adjustment.\n\t */\n\tmax_cycles = min(max_cycles, mask);\n\tmax_nsecs = clocksource_cyc2ns(max_cycles, mult - maxadj, shift);\n\n\t/* return the max_cycles value as well if requested */\n\tif (max_cyc)\n\t\t*max_cyc = max_cycles;\n\n\t/* Return 50% of the actual maximum, so we can detect bad values */\n\tmax_nsecs >>= 1;\n\n\treturn max_nsecs;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocksource_cyc2ns",
          "args": [
            "max_cycles",
            "mult - maxadj",
            "shift"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "max_cycles",
            "mask"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_stop_suspend_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "776-808",
          "snippet": "u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static u64 suspend_start;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nu64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "max_cycles",
            "mult+maxadj"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nu64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cyc)\n{\n\tu64 max_nsecs, max_cycles;\n\n\t/*\n\t * Calculate the maximum number of cycles that we can pass to the\n\t * cyc2ns() function without overflowing a 64-bit result.\n\t */\n\tmax_cycles = ULLONG_MAX;\n\tdo_div(max_cycles, mult+maxadj);\n\n\t/*\n\t * The actual maximum number of cycles we can defer the clocksource is\n\t * determined by the minimum of max_cycles and mask.\n\t * Note: Here we subtract the maxadj to make sure we don't sleep for\n\t * too long if there's a large negative adjustment.\n\t */\n\tmax_cycles = min(max_cycles, mask);\n\tmax_nsecs = clocksource_cyc2ns(max_cycles, mult - maxadj, shift);\n\n\t/* return the max_cycles value as well if requested */\n\tif (max_cyc)\n\t\t*max_cyc = max_cycles;\n\n\t/* Return 50% of the actual maximum, so we can detect bad values */\n\tmax_nsecs >>= 1;\n\n\treturn max_nsecs;\n}"
  },
  {
    "function_name": "clocksource_max_adjustment",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "853-862",
    "snippet": "static u32 clocksource_max_adjustment(struct clocksource *cs)\n{\n\tu64 ret;\n\t/*\n\t * We won't try to correct for more than 11% adjustments (110,000 ppm),\n\t */\n\tret = (u64)cs->mult * 11;\n\tdo_div(ret,100);\n\treturn (u32)ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ret",
            "100"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic u32 clocksource_max_adjustment(struct clocksource *cs)\n{\n\tu64 ret;\n\t/*\n\t * We won't try to correct for more than 11% adjustments (110,000 ppm),\n\t */\n\tret = (u64)cs->mult * 11;\n\tdo_div(ret,100);\n\treturn (u32)ret;\n}"
  },
  {
    "function_name": "clocksource_touch_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "843-846",
    "snippet": "void clocksource_touch_watchdog(void)\n{\n\tclocksource_resume_watchdog();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocksource_resume_watchdog",
          "args": [],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_resume_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "666-666",
          "snippet": "static inline void clocksource_resume_watchdog(void) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_resume_watchdog(void) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid clocksource_touch_watchdog(void)\n{\n\tclocksource_resume_watchdog();\n}"
  },
  {
    "function_name": "clocksource_resume",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "825-834",
    "snippet": "void clocksource_resume(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &clocksource_list, list)\n\t\tif (cs->resume)\n\t\t\tcs->resume(cs);\n\n\tclocksource_resume_watchdog();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clocksource_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocksource_resume_watchdog",
          "args": [],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_resume_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "666-666",
          "snippet": "static inline void clocksource_resume_watchdog(void) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_resume_watchdog(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "cs->resume",
          "args": [
            "cs"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cs",
            "&clocksource_list",
            "list"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\n\nvoid clocksource_resume(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &clocksource_list, list)\n\t\tif (cs->resume)\n\t\t\tcs->resume(cs);\n\n\tclocksource_resume_watchdog();\n}"
  },
  {
    "function_name": "clocksource_suspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "813-820",
    "snippet": "void clocksource_suspend(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry_reverse(cs, &clocksource_list, list)\n\t\tif (cs->suspend)\n\t\t\tcs->suspend(cs);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clocksource_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cs->suspend",
          "args": [
            "cs"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "cs",
            "&clocksource_list",
            "list"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\n\nvoid clocksource_suspend(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry_reverse(cs, &clocksource_list, list)\n\t\tif (cs->suspend)\n\t\t\tcs->suspend(cs);\n}"
  },
  {
    "function_name": "clocksource_stop_suspend_timing",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "776-808",
    "snippet": "u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *suspend_clocksource;",
      "static u64 suspend_start;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "suspend_clocksource->disable",
          "args": [
            "suspend_clocksource"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_is_suspend",
          "args": [
            "cs"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_is_suspend",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "676-679",
          "snippet": "static bool clocksource_is_suspend(struct clocksource *cs)\n{\n\treturn cs == suspend_clocksource;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\n\nstatic bool clocksource_is_suspend(struct clocksource *cs)\n{\n\treturn cs == suspend_clocksource;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mul_u64_u32_shr",
          "args": [
            "delta",
            "suspend_clocksource->mult",
            "suspend_clocksource->shift"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "now",
            "suspend_start",
            "suspend_clocksource->mask"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping_internal.h",
          "lines": "30-33",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/spinlock.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "suspend_clocksource->read",
          "args": [
            "suspend_clocksource"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nu64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}"
  },
  {
    "function_name": "clocksource_start_suspend_timing",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "738-760",
    "snippet": "void clocksource_start_suspend_timing(struct clocksource *cs, u64 start_cycles)\n{\n\tif (!suspend_clocksource)\n\t\treturn;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value as suspend_start to avoid same reading\n\t * from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs)) {\n\t\tsuspend_start = start_cycles;\n\t\treturn;\n\t}\n\n\tif (suspend_clocksource->enable &&\n\t    suspend_clocksource->enable(suspend_clocksource)) {\n\t\tpr_warn_once(\"Failed to enable the non-suspend-able clocksource.\\n\");\n\t\treturn;\n\t}\n\n\tsuspend_start = suspend_clocksource->read(suspend_clocksource);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *suspend_clocksource;",
      "static u64 suspend_start;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "suspend_clocksource->read",
          "args": [
            "suspend_clocksource"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"Failed to enable the non-suspend-able clocksource.\\n\""
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suspend_clocksource->enable",
          "args": [
            "suspend_clocksource"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_is_suspend",
          "args": [
            "cs"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_is_suspend",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "676-679",
          "snippet": "static bool clocksource_is_suspend(struct clocksource *cs)\n{\n\treturn cs == suspend_clocksource;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\n\nstatic bool clocksource_is_suspend(struct clocksource *cs)\n{\n\treturn cs == suspend_clocksource;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nvoid clocksource_start_suspend_timing(struct clocksource *cs, u64 start_cycles)\n{\n\tif (!suspend_clocksource)\n\t\treturn;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value as suspend_start to avoid same reading\n\t * from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs)) {\n\t\tsuspend_start = start_cycles;\n\t\treturn;\n\t}\n\n\tif (suspend_clocksource->enable &&\n\t    suspend_clocksource->enable(suspend_clocksource)) {\n\t\tpr_warn_once(\"Failed to enable the non-suspend-able clocksource.\\n\");\n\t\treturn;\n\t}\n\n\tsuspend_start = suspend_clocksource->read(suspend_clocksource);\n}"
  },
  {
    "function_name": "clocksource_suspend_select",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "708-723",
    "snippet": "static void clocksource_suspend_select(bool fallback)\n{\n\tstruct clocksource *cs, *old_suspend;\n\n\told_suspend = suspend_clocksource;\n\tif (fallback)\n\t\tsuspend_clocksource = NULL;\n\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\t/* Skip current if we were requested for a fallback. */\n\t\tif (fallback && cs == old_suspend)\n\t\t\tcontinue;\n\n\t\t__clocksource_suspend_select(cs);\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *suspend_clocksource;",
      "static LIST_HEAD(clocksource_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clocksource_suspend_select",
          "args": [
            "cs"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_suspend_select",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "681-702",
          "snippet": "static void __clocksource_suspend_select(struct clocksource *cs)\n{\n\t/*\n\t * Skip the clocksource which will be stopped in suspend state.\n\t */\n\tif (!(cs->flags & CLOCK_SOURCE_SUSPEND_NONSTOP))\n\t\treturn;\n\n\t/*\n\t * The nonstop clocksource can be selected as the suspend clocksource to\n\t * calculate the suspend time, so it should not supply suspend/resume\n\t * interfaces to suspend the nonstop clocksource when system suspends.\n\t */\n\tif (cs->suspend || cs->resume) {\n\t\tpr_warn(\"Nonstop clocksource %s should not supply suspend/resume interfaces\\n\",\n\t\t\tcs->name);\n\t}\n\n\t/* Pick the best rating. */\n\tif (!suspend_clocksource || cs->rating > suspend_clocksource->rating)\n\t\tsuspend_clocksource = cs;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\n\nstatic void __clocksource_suspend_select(struct clocksource *cs)\n{\n\t/*\n\t * Skip the clocksource which will be stopped in suspend state.\n\t */\n\tif (!(cs->flags & CLOCK_SOURCE_SUSPEND_NONSTOP))\n\t\treturn;\n\n\t/*\n\t * The nonstop clocksource can be selected as the suspend clocksource to\n\t * calculate the suspend time, so it should not supply suspend/resume\n\t * interfaces to suspend the nonstop clocksource when system suspends.\n\t */\n\tif (cs->suspend || cs->resume) {\n\t\tpr_warn(\"Nonstop clocksource %s should not supply suspend/resume interfaces\\n\",\n\t\t\tcs->name);\n\t}\n\n\t/* Pick the best rating. */\n\tif (!suspend_clocksource || cs->rating > suspend_clocksource->rating)\n\t\tsuspend_clocksource = cs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cs",
            "&clocksource_list",
            "list"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic LIST_HEAD(clocksource_list);\n\nstatic void clocksource_suspend_select(bool fallback)\n{\n\tstruct clocksource *cs, *old_suspend;\n\n\told_suspend = suspend_clocksource;\n\tif (fallback)\n\t\tsuspend_clocksource = NULL;\n\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\t/* Skip current if we were requested for a fallback. */\n\t\tif (fallback && cs == old_suspend)\n\t\t\tcontinue;\n\n\t\t__clocksource_suspend_select(cs);\n\t}\n}"
  },
  {
    "function_name": "__clocksource_suspend_select",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "681-702",
    "snippet": "static void __clocksource_suspend_select(struct clocksource *cs)\n{\n\t/*\n\t * Skip the clocksource which will be stopped in suspend state.\n\t */\n\tif (!(cs->flags & CLOCK_SOURCE_SUSPEND_NONSTOP))\n\t\treturn;\n\n\t/*\n\t * The nonstop clocksource can be selected as the suspend clocksource to\n\t * calculate the suspend time, so it should not supply suspend/resume\n\t * interfaces to suspend the nonstop clocksource when system suspends.\n\t */\n\tif (cs->suspend || cs->resume) {\n\t\tpr_warn(\"Nonstop clocksource %s should not supply suspend/resume interfaces\\n\",\n\t\t\tcs->name);\n\t}\n\n\t/* Pick the best rating. */\n\tif (!suspend_clocksource || cs->rating > suspend_clocksource->rating)\n\t\tsuspend_clocksource = cs;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *suspend_clocksource;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Nonstop clocksource %s should not supply suspend/resume interfaces\\n\"",
            "cs->name"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\n\nstatic void __clocksource_suspend_select(struct clocksource *cs)\n{\n\t/*\n\t * Skip the clocksource which will be stopped in suspend state.\n\t */\n\tif (!(cs->flags & CLOCK_SOURCE_SUSPEND_NONSTOP))\n\t\treturn;\n\n\t/*\n\t * The nonstop clocksource can be selected as the suspend clocksource to\n\t * calculate the suspend time, so it should not supply suspend/resume\n\t * interfaces to suspend the nonstop clocksource when system suspends.\n\t */\n\tif (cs->suspend || cs->resume) {\n\t\tpr_warn(\"Nonstop clocksource %s should not supply suspend/resume interfaces\\n\",\n\t\t\tcs->name);\n\t}\n\n\t/* Pick the best rating. */\n\tif (!suspend_clocksource || cs->rating > suspend_clocksource->rating)\n\t\tsuspend_clocksource = cs;\n}"
  },
  {
    "function_name": "clocksource_is_suspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "676-679",
    "snippet": "static bool clocksource_is_suspend(struct clocksource *cs)\n{\n\treturn cs == suspend_clocksource;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *suspend_clocksource;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\n\nstatic bool clocksource_is_suspend(struct clocksource *cs)\n{\n\treturn cs == suspend_clocksource;\n}"
  },
  {
    "function_name": "clocksource_watchdog_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "672-672",
    "snippet": "static inline void clocksource_watchdog_unlock(unsigned long *flags) { }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_unlock(unsigned long *flags) { }"
  },
  {
    "function_name": "clocksource_watchdog_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "671-671",
    "snippet": "static inline void clocksource_watchdog_lock(unsigned long *flags) { }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_lock(unsigned long *flags) { }"
  },
  {
    "function_name": "clocksource_mark_unstable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "669-669",
    "snippet": "void clocksource_mark_unstable(struct clocksource *cs) { }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid clocksource_mark_unstable(struct clocksource *cs) { }"
  },
  {
    "function_name": "clocksource_is_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "668-668",
    "snippet": "static bool clocksource_is_watchdog(struct clocksource *cs) { return false; }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic bool clocksource_is_watchdog(struct clocksource *cs) { return false; }"
  },
  {
    "function_name": "__clocksource_watchdog_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "667-667",
    "snippet": "static inline int __clocksource_watchdog_kthread(void) { return 0; }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline int __clocksource_watchdog_kthread(void) { return 0; }"
  },
  {
    "function_name": "clocksource_resume_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "666-666",
    "snippet": "static inline void clocksource_resume_watchdog(void) { }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_resume_watchdog(void) { }"
  },
  {
    "function_name": "clocksource_dequeue_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "665-665",
    "snippet": "static inline void clocksource_dequeue_watchdog(struct clocksource *cs) { }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_dequeue_watchdog(struct clocksource *cs) { }"
  },
  {
    "function_name": "clocksource_select_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "664-664",
    "snippet": "static void clocksource_select_watchdog(bool fallback) { }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select_watchdog(bool fallback) { }"
  },
  {
    "function_name": "clocksource_enqueue_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "658-662",
    "snippet": "static void clocksource_enqueue_watchdog(struct clocksource *cs)\n{\n\tif (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS)\n\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_enqueue_watchdog(struct clocksource *cs)\n{\n\tif (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS)\n\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;\n}"
  },
  {
    "function_name": "clocksource_is_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "651-654",
    "snippet": "static bool clocksource_is_watchdog(struct clocksource *cs)\n{\n\treturn cs == watchdog;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic bool clocksource_is_watchdog(struct clocksource *cs)\n{\n\treturn cs == watchdog;\n}"
  },
  {
    "function_name": "clocksource_watchdog_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "642-649",
    "snippet": "static int clocksource_watchdog_kthread(void *data)\n{\n\tmutex_lock(&clocksource_mutex);\n\tif (__clocksource_watchdog_kthread())\n\t\tclocksource_select();\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(clocksource_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select",
          "args": [],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_fallback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1007-1010",
          "snippet": "static void clocksource_select_fallback(void)\n{\n\t__clocksource_select(true);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select_fallback(void)\n{\n\t__clocksource_select(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clocksource_watchdog_kthread",
          "args": [],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_watchdog_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "667-667",
          "snippet": "static inline int __clocksource_watchdog_kthread(void) { return 0; }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline int __clocksource_watchdog_kthread(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(clocksource_mutex);\n\nstatic int clocksource_watchdog_kthread(void *data)\n{\n\tmutex_lock(&clocksource_mutex);\n\tif (__clocksource_watchdog_kthread())\n\t\tclocksource_select();\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "__clocksource_watchdog_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "611-640",
    "snippet": "static int __clocksource_watchdog_kthread(void)\n{\n\tstruct clocksource *cs, *tmp;\n\tunsigned long flags;\n\tint select = 0;\n\n\t/* Do any required per-CPU skew verification. */\n\tif (curr_clocksource &&\n\t    curr_clocksource->flags & CLOCK_SOURCE_UNSTABLE &&\n\t    curr_clocksource->flags & CLOCK_SOURCE_VERIFY_PERCPU)\n\t\tclocksource_verify_percpu(curr_clocksource);\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\tlist_for_each_entry_safe(cs, tmp, &watchdog_list, wd_list) {\n\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\tlist_del_init(&cs->wd_list);\n\t\t\t__clocksource_change_rating(cs, 0);\n\t\t\tselect = 1;\n\t\t}\n\t\tif (cs->flags & CLOCK_SOURCE_RESELECT) {\n\t\t\tcs->flags &= ~CLOCK_SOURCE_RESELECT;\n\t\t\tselect = 1;\n\t\t}\n\t}\n\t/* Check if the watchdog timer needs to be stopped. */\n\tclocksource_stop_watchdog();\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n\n\treturn select;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *curr_clocksource;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&watchdog_lock",
            "flags"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_stop_watchdog",
          "args": [],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_stop_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "526-532",
          "snippet": "static inline void clocksource_stop_watchdog(void)\n{\n\tif (!watchdog_running || (watchdog && !list_empty(&watchdog_list)))\n\t\treturn;\n\tdel_timer(&watchdog_timer);\n\twatchdog_running = 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_stop_watchdog(void)\n{\n\tif (!watchdog_running || (watchdog && !list_empty(&watchdog_list)))\n\t\treturn;\n\tdel_timer(&watchdog_timer);\n\twatchdog_running = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clocksource_change_rating",
          "args": [
            "cs",
            "0"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_change_rating",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1184-1189",
          "snippet": "static void __clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tlist_del(&cs->list);\n\tcs->rating = rating;\n\tclocksource_enqueue(cs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void __clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tlist_del(&cs->list);\n\tcs->rating = rating;\n\tclocksource_enqueue(cs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cs->wd_list"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "cs",
            "tmp",
            "&watchdog_list",
            "wd_list"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&watchdog_lock",
            "flags"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_verify_percpu",
          "args": [
            "curr_clocksource"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_verify_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "326-378",
          "snippet": "void clocksource_verify_percpu(struct clocksource *cs)\n{\n\tint64_t cs_nsec, cs_nsec_max = 0, cs_nsec_min = LLONG_MAX;\n\tu64 csnow_begin, csnow_end;\n\tint cpu, testcpu;\n\ts64 delta;\n\n\tif (verify_n_cpus == 0)\n\t\treturn;\n\tcpumask_clear(&cpus_ahead);\n\tcpumask_clear(&cpus_behind);\n\tcpus_read_lock();\n\tpreempt_disable();\n\tclocksource_verify_choose_cpus();\n\tif (cpumask_weight(&cpus_chosen) == 0) {\n\t\tpreempt_enable();\n\t\tcpus_read_unlock();\n\t\tpr_warn(\"Not enough CPUs to check clocksource '%s'.\\n\", cs->name);\n\t\treturn;\n\t}\n\ttestcpu = smp_processor_id();\n\tpr_warn(\"Checking clocksource %s synchronization from CPU %d to CPUs %*pbl.\\n\", cs->name, testcpu, cpumask_pr_args(&cpus_chosen));\n\tfor_each_cpu(cpu, &cpus_chosen) {\n\t\tif (cpu == testcpu)\n\t\t\tcontinue;\n\t\tcsnow_begin = cs->read(cs);\n\t\tsmp_call_function_single(cpu, clocksource_verify_one_cpu, cs, 1);\n\t\tcsnow_end = cs->read(cs);\n\t\tdelta = (s64)((csnow_mid - csnow_begin) & cs->mask);\n\t\tif (delta < 0)\n\t\t\tcpumask_set_cpu(cpu, &cpus_behind);\n\t\tdelta = (csnow_end - csnow_mid) & cs->mask;\n\t\tif (delta < 0)\n\t\t\tcpumask_set_cpu(cpu, &cpus_ahead);\n\t\tdelta = clocksource_delta(csnow_end, csnow_begin, cs->mask);\n\t\tcs_nsec = clocksource_cyc2ns(delta, cs->mult, cs->shift);\n\t\tif (cs_nsec > cs_nsec_max)\n\t\t\tcs_nsec_max = cs_nsec;\n\t\tif (cs_nsec < cs_nsec_min)\n\t\t\tcs_nsec_min = cs_nsec;\n\t}\n\tpreempt_enable();\n\tcpus_read_unlock();\n\tif (!cpumask_empty(&cpus_ahead))\n\t\tpr_warn(\"        CPUs %*pbl ahead of CPU %d for clocksource %s.\\n\",\n\t\t\tcpumask_pr_args(&cpus_ahead), testcpu, cs->name);\n\tif (!cpumask_empty(&cpus_behind))\n\t\tpr_warn(\"        CPUs %*pbl behind CPU %d for clocksource %s.\\n\",\n\t\t\tcpumask_pr_args(&cpus_behind), testcpu, cs->name);\n\tif (!cpumask_empty(&cpus_ahead) || !cpumask_empty(&cpus_behind))\n\t\tpr_warn(\"        CPU %d check durations %lldns - %lldns for clocksource %s.\\n\",\n\t\t\ttestcpu, cs_nsec_min, cs_nsec_max, cs->name);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid clocksource_verify_percpu(struct clocksource *cs)\n{\n\tint64_t cs_nsec, cs_nsec_max = 0, cs_nsec_min = LLONG_MAX;\n\tu64 csnow_begin, csnow_end;\n\tint cpu, testcpu;\n\ts64 delta;\n\n\tif (verify_n_cpus == 0)\n\t\treturn;\n\tcpumask_clear(&cpus_ahead);\n\tcpumask_clear(&cpus_behind);\n\tcpus_read_lock();\n\tpreempt_disable();\n\tclocksource_verify_choose_cpus();\n\tif (cpumask_weight(&cpus_chosen) == 0) {\n\t\tpreempt_enable();\n\t\tcpus_read_unlock();\n\t\tpr_warn(\"Not enough CPUs to check clocksource '%s'.\\n\", cs->name);\n\t\treturn;\n\t}\n\ttestcpu = smp_processor_id();\n\tpr_warn(\"Checking clocksource %s synchronization from CPU %d to CPUs %*pbl.\\n\", cs->name, testcpu, cpumask_pr_args(&cpus_chosen));\n\tfor_each_cpu(cpu, &cpus_chosen) {\n\t\tif (cpu == testcpu)\n\t\t\tcontinue;\n\t\tcsnow_begin = cs->read(cs);\n\t\tsmp_call_function_single(cpu, clocksource_verify_one_cpu, cs, 1);\n\t\tcsnow_end = cs->read(cs);\n\t\tdelta = (s64)((csnow_mid - csnow_begin) & cs->mask);\n\t\tif (delta < 0)\n\t\t\tcpumask_set_cpu(cpu, &cpus_behind);\n\t\tdelta = (csnow_end - csnow_mid) & cs->mask;\n\t\tif (delta < 0)\n\t\t\tcpumask_set_cpu(cpu, &cpus_ahead);\n\t\tdelta = clocksource_delta(csnow_end, csnow_begin, cs->mask);\n\t\tcs_nsec = clocksource_cyc2ns(delta, cs->mult, cs->shift);\n\t\tif (cs_nsec > cs_nsec_max)\n\t\t\tcs_nsec_max = cs_nsec;\n\t\tif (cs_nsec < cs_nsec_min)\n\t\t\tcs_nsec_min = cs_nsec;\n\t}\n\tpreempt_enable();\n\tcpus_read_unlock();\n\tif (!cpumask_empty(&cpus_ahead))\n\t\tpr_warn(\"        CPUs %*pbl ahead of CPU %d for clocksource %s.\\n\",\n\t\t\tcpumask_pr_args(&cpus_ahead), testcpu, cs->name);\n\tif (!cpumask_empty(&cpus_behind))\n\t\tpr_warn(\"        CPUs %*pbl behind CPU %d for clocksource %s.\\n\",\n\t\t\tcpumask_pr_args(&cpus_behind), testcpu, cs->name);\n\tif (!cpumask_empty(&cpus_ahead) || !cpumask_empty(&cpus_behind))\n\t\tpr_warn(\"        CPU %d check durations %lldns - %lldns for clocksource %s.\\n\",\n\t\t\ttestcpu, cs_nsec_min, cs_nsec_max, cs->name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\n\nstatic int __clocksource_watchdog_kthread(void)\n{\n\tstruct clocksource *cs, *tmp;\n\tunsigned long flags;\n\tint select = 0;\n\n\t/* Do any required per-CPU skew verification. */\n\tif (curr_clocksource &&\n\t    curr_clocksource->flags & CLOCK_SOURCE_UNSTABLE &&\n\t    curr_clocksource->flags & CLOCK_SOURCE_VERIFY_PERCPU)\n\t\tclocksource_verify_percpu(curr_clocksource);\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\tlist_for_each_entry_safe(cs, tmp, &watchdog_list, wd_list) {\n\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\tlist_del_init(&cs->wd_list);\n\t\t\t__clocksource_change_rating(cs, 0);\n\t\t\tselect = 1;\n\t\t}\n\t\tif (cs->flags & CLOCK_SOURCE_RESELECT) {\n\t\t\tcs->flags &= ~CLOCK_SOURCE_RESELECT;\n\t\t\tselect = 1;\n\t\t}\n\t}\n\t/* Check if the watchdog timer needs to be stopped. */\n\tclocksource_stop_watchdog();\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n\n\treturn select;\n}"
  },
  {
    "function_name": "clocksource_dequeue_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "599-609",
    "snippet": "static void clocksource_dequeue_watchdog(struct clocksource *cs)\n{\n\tif (cs != watchdog) {\n\t\tif (cs->flags & CLOCK_SOURCE_MUST_VERIFY) {\n\t\t\t/* cs is a watched clocksource. */\n\t\t\tlist_del_init(&cs->wd_list);\n\t\t\t/* Check if the watchdog timer needs to be stopped. */\n\t\t\tclocksource_stop_watchdog();\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocksource_stop_watchdog",
          "args": [],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_stop_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "526-532",
          "snippet": "static inline void clocksource_stop_watchdog(void)\n{\n\tif (!watchdog_running || (watchdog && !list_empty(&watchdog_list)))\n\t\treturn;\n\tdel_timer(&watchdog_timer);\n\twatchdog_running = 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_stop_watchdog(void)\n{\n\tif (!watchdog_running || (watchdog && !list_empty(&watchdog_list)))\n\t\treturn;\n\tdel_timer(&watchdog_timer);\n\twatchdog_running = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cs->wd_list"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_dequeue_watchdog(struct clocksource *cs)\n{\n\tif (cs != watchdog) {\n\t\tif (cs->flags & CLOCK_SOURCE_MUST_VERIFY) {\n\t\t\t/* cs is a watched clocksource. */\n\t\t\tlist_del_init(&cs->wd_list);\n\t\t\t/* Check if the watchdog timer needs to be stopped. */\n\t\t\tclocksource_stop_watchdog();\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "clocksource_select_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "562-597",
    "snippet": "static void clocksource_select_watchdog(bool fallback)\n{\n\tstruct clocksource *cs, *old_wd;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\t/* save current watchdog */\n\told_wd = watchdog;\n\tif (fallback)\n\t\twatchdog = NULL;\n\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\t/* cs is a clocksource to be watched. */\n\t\tif (cs->flags & CLOCK_SOURCE_MUST_VERIFY)\n\t\t\tcontinue;\n\n\t\t/* Skip current if we were requested for a fallback. */\n\t\tif (fallback && cs == old_wd)\n\t\t\tcontinue;\n\n\t\t/* Pick the best watchdog. */\n\t\tif (!watchdog || cs->rating > watchdog->rating)\n\t\t\twatchdog = cs;\n\t}\n\t/* If we failed to find a fallback restore the old one. */\n\tif (!watchdog)\n\t\twatchdog = old_wd;\n\n\t/* If we changed the watchdog we need to reset cycles. */\n\tif (watchdog != old_wd)\n\t\tclocksource_reset_watchdog();\n\n\t/* Check if the watchdog timer needs to be started. */\n\tclocksource_start_watchdog();\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clocksource_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&watchdog_lock",
            "flags"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_start_watchdog",
          "args": [],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_start_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "516-524",
          "snippet": "static inline void clocksource_start_watchdog(void)\n{\n\tif (watchdog_running || !watchdog || list_empty(&watchdog_list))\n\t\treturn;\n\ttimer_setup(&watchdog_timer, clocksource_watchdog, 0);\n\twatchdog_timer.expires = jiffies + WATCHDOG_INTERVAL;\n\tadd_timer_on(&watchdog_timer, cpumask_first(cpu_online_mask));\n\twatchdog_running = 1;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [
            "#define WATCHDOG_INTERVAL (HZ >> 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\n#define WATCHDOG_INTERVAL (HZ >> 1)\n\nstatic inline void clocksource_start_watchdog(void)\n{\n\tif (watchdog_running || !watchdog || list_empty(&watchdog_list))\n\t\treturn;\n\ttimer_setup(&watchdog_timer, clocksource_watchdog, 0);\n\twatchdog_timer.expires = jiffies + WATCHDOG_INTERVAL;\n\tadd_timer_on(&watchdog_timer, cpumask_first(cpu_online_mask));\n\twatchdog_running = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_reset_watchdog",
          "args": [],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_reset_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "534-540",
          "snippet": "static inline void clocksource_reset_watchdog(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &watchdog_list, wd_list)\n\t\tcs->flags &= ~CLOCK_SOURCE_WATCHDOG;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_reset_watchdog(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &watchdog_list, wd_list)\n\t\tcs->flags &= ~CLOCK_SOURCE_WATCHDOG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cs",
            "&clocksource_list",
            "list"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&watchdog_lock",
            "flags"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\n\nstatic void clocksource_select_watchdog(bool fallback)\n{\n\tstruct clocksource *cs, *old_wd;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\t/* save current watchdog */\n\told_wd = watchdog;\n\tif (fallback)\n\t\twatchdog = NULL;\n\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\t/* cs is a clocksource to be watched. */\n\t\tif (cs->flags & CLOCK_SOURCE_MUST_VERIFY)\n\t\t\tcontinue;\n\n\t\t/* Skip current if we were requested for a fallback. */\n\t\tif (fallback && cs == old_wd)\n\t\t\tcontinue;\n\n\t\t/* Pick the best watchdog. */\n\t\tif (!watchdog || cs->rating > watchdog->rating)\n\t\t\twatchdog = cs;\n\t}\n\t/* If we failed to find a fallback restore the old one. */\n\tif (!watchdog)\n\t\twatchdog = old_wd;\n\n\t/* If we changed the watchdog we need to reset cycles. */\n\tif (watchdog != old_wd)\n\t\tclocksource_reset_watchdog();\n\n\t/* Check if the watchdog timer needs to be started. */\n\tclocksource_start_watchdog();\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n}"
  },
  {
    "function_name": "clocksource_enqueue_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "547-560",
    "snippet": "static void clocksource_enqueue_watchdog(struct clocksource *cs)\n{\n\tINIT_LIST_HEAD(&cs->wd_list);\n\n\tif (cs->flags & CLOCK_SOURCE_MUST_VERIFY) {\n\t\t/* cs is a clocksource to be watched. */\n\t\tlist_add(&cs->wd_list, &watchdog_list);\n\t\tcs->flags &= ~CLOCK_SOURCE_WATCHDOG;\n\t} else {\n\t\t/* cs is a watchdog. */\n\t\tif (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS)\n\t\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cs->wd_list",
            "&watchdog_list"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cs->wd_list"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_enqueue_watchdog(struct clocksource *cs)\n{\n\tINIT_LIST_HEAD(&cs->wd_list);\n\n\tif (cs->flags & CLOCK_SOURCE_MUST_VERIFY) {\n\t\t/* cs is a clocksource to be watched. */\n\t\tlist_add(&cs->wd_list, &watchdog_list);\n\t\tcs->flags &= ~CLOCK_SOURCE_WATCHDOG;\n\t} else {\n\t\t/* cs is a watchdog. */\n\t\tif (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS)\n\t\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;\n\t}\n}"
  },
  {
    "function_name": "clocksource_resume_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "542-545",
    "snippet": "static void clocksource_resume_watchdog(void)\n{\n\tatomic_inc(&watchdog_reset_pending);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&watchdog_reset_pending"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_resume_watchdog(void)\n{\n\tatomic_inc(&watchdog_reset_pending);\n}"
  },
  {
    "function_name": "clocksource_reset_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "534-540",
    "snippet": "static inline void clocksource_reset_watchdog(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &watchdog_list, wd_list)\n\t\tcs->flags &= ~CLOCK_SOURCE_WATCHDOG;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cs",
            "&watchdog_list",
            "wd_list"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_reset_watchdog(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &watchdog_list, wd_list)\n\t\tcs->flags &= ~CLOCK_SOURCE_WATCHDOG;\n}"
  },
  {
    "function_name": "clocksource_stop_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "526-532",
    "snippet": "static inline void clocksource_stop_watchdog(void)\n{\n\tif (!watchdog_running || (watchdog && !list_empty(&watchdog_list)))\n\t\treturn;\n\tdel_timer(&watchdog_timer);\n\twatchdog_running = 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "del_timer",
          "args": [
            "&watchdog_timer"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1352-1391",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&watchdog_list"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_stop_watchdog(void)\n{\n\tif (!watchdog_running || (watchdog && !list_empty(&watchdog_list)))\n\t\treturn;\n\tdel_timer(&watchdog_timer);\n\twatchdog_running = 0;\n}"
  },
  {
    "function_name": "clocksource_start_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "516-524",
    "snippet": "static inline void clocksource_start_watchdog(void)\n{\n\tif (watchdog_running || !watchdog || list_empty(&watchdog_list))\n\t\treturn;\n\ttimer_setup(&watchdog_timer, clocksource_watchdog, 0);\n\twatchdog_timer.expires = jiffies + WATCHDOG_INTERVAL;\n\tadd_timer_on(&watchdog_timer, cpumask_first(cpu_online_mask));\n\twatchdog_running = 1;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [
      "#define WATCHDOG_INTERVAL (HZ >> 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_timer_on",
          "args": [
            "&watchdog_timer",
            "cpumask_first(cpu_online_mask)"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "add_timer_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1155-1184",
          "snippet": "void add_timer_on(struct timer_list *timer, int cpu)\n{\n\tstruct timer_base *new_base, *base;\n\tunsigned long flags;\n\n\tBUG_ON(timer_pending(timer) || !timer->function);\n\n\tnew_base = get_timer_cpu_base(timer->flags, cpu);\n\n\t/*\n\t * If @timer was on a different CPU, it should be migrated with the\n\t * old base locked to prevent other operations proceeding with the\n\t * wrong base locked.  See lock_timer_base().\n\t */\n\tbase = lock_timer_base(timer, &flags);\n\tif (base != new_base) {\n\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\traw_spin_unlock(&base->lock);\n\t\tbase = new_base;\n\t\traw_spin_lock(&base->lock);\n\t\tWRITE_ONCE(timer->flags,\n\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);\n\t}\n\tforward_timer_base(base);\n\n\tdebug_timer_activate(timer);\n\tinternal_add_timer(base, timer);\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid add_timer_on(struct timer_list *timer, int cpu)\n{\n\tstruct timer_base *new_base, *base;\n\tunsigned long flags;\n\n\tBUG_ON(timer_pending(timer) || !timer->function);\n\n\tnew_base = get_timer_cpu_base(timer->flags, cpu);\n\n\t/*\n\t * If @timer was on a different CPU, it should be migrated with the\n\t * old base locked to prevent other operations proceeding with the\n\t * wrong base locked.  See lock_timer_base().\n\t */\n\tbase = lock_timer_base(timer, &flags);\n\tif (base != new_base) {\n\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\traw_spin_unlock(&base->lock);\n\t\tbase = new_base;\n\t\traw_spin_lock(&base->lock);\n\t\tWRITE_ONCE(timer->flags,\n\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);\n\t}\n\tforward_timer_base(base);\n\n\tdebug_timer_activate(timer);\n\tinternal_add_timer(base, timer);\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "&watchdog_timer",
            "clocksource_watchdog",
            "0"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&watchdog_list"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\n#define WATCHDOG_INTERVAL (HZ >> 1)\n\nstatic inline void clocksource_start_watchdog(void)\n{\n\tif (watchdog_running || !watchdog || list_empty(&watchdog_list))\n\t\treturn;\n\ttimer_setup(&watchdog_timer, clocksource_watchdog, 0);\n\twatchdog_timer.expires = jiffies + WATCHDOG_INTERVAL;\n\tadd_timer_on(&watchdog_timer, cpumask_first(cpu_online_mask));\n\twatchdog_running = 1;\n}"
  },
  {
    "function_name": "clocksource_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "381-514",
    "snippet": "static void clocksource_watchdog(struct timer_list *unused)\n{\n\tu64 csnow, wdnow, cslast, wdlast, delta;\n\tint next_cpu, reset_pending;\n\tint64_t wd_nsec, cs_nsec;\n\tstruct clocksource *cs;\n\tenum wd_read_status read_ret;\n\tu32 md;\n\n\tspin_lock(&watchdog_lock);\n\tif (!watchdog_running)\n\t\tgoto out;\n\n\treset_pending = atomic_read(&watchdog_reset_pending);\n\n\tlist_for_each_entry(cs, &watchdog_list, wd_list) {\n\n\t\t/* Clocksource already marked unstable? */\n\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\tif (finished_booting)\n\t\t\t\tschedule_work(&watchdog_work);\n\t\t\tcontinue;\n\t\t}\n\n\t\tread_ret = cs_watchdog_read(cs, &csnow, &wdnow);\n\n\t\tif (read_ret != WD_READ_SUCCESS) {\n\t\t\tif (read_ret == WD_READ_UNSTABLE)\n\t\t\t\t/* Clock readout unreliable, so give it up. */\n\t\t\t\t__clocksource_unstable(cs);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Clocksource initialized ? */\n\t\tif (!(cs->flags & CLOCK_SOURCE_WATCHDOG) ||\n\t\t    atomic_read(&watchdog_reset_pending)) {\n\t\t\tcs->flags |= CLOCK_SOURCE_WATCHDOG;\n\t\t\tcs->wd_last = wdnow;\n\t\t\tcs->cs_last = csnow;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdelta = clocksource_delta(wdnow, cs->wd_last, watchdog->mask);\n\t\twd_nsec = clocksource_cyc2ns(delta, watchdog->mult,\n\t\t\t\t\t     watchdog->shift);\n\n\t\tdelta = clocksource_delta(csnow, cs->cs_last, cs->mask);\n\t\tcs_nsec = clocksource_cyc2ns(delta, cs->mult, cs->shift);\n\t\twdlast = cs->wd_last; /* save these in case we print them */\n\t\tcslast = cs->cs_last;\n\t\tcs->cs_last = csnow;\n\t\tcs->wd_last = wdnow;\n\n\t\tif (atomic_read(&watchdog_reset_pending))\n\t\t\tcontinue;\n\n\t\t/* Check the deviation from the watchdog clocksource. */\n\t\tmd = cs->uncertainty_margin + watchdog->uncertainty_margin;\n\t\tif (abs(cs_nsec - wd_nsec) > md) {\n\t\t\tpr_warn(\"timekeeping watchdog on CPU%d: Marking clocksource '%s' as unstable because the skew is too large:\\n\",\n\t\t\t\tsmp_processor_id(), cs->name);\n\t\t\tpr_warn(\"                      '%s' wd_nsec: %lld wd_now: %llx wd_last: %llx mask: %llx\\n\",\n\t\t\t\twatchdog->name, wd_nsec, wdnow, wdlast, watchdog->mask);\n\t\t\tpr_warn(\"                      '%s' cs_nsec: %lld cs_now: %llx cs_last: %llx mask: %llx\\n\",\n\t\t\t\tcs->name, cs_nsec, csnow, cslast, cs->mask);\n\t\t\tif (curr_clocksource == cs)\n\t\t\t\tpr_warn(\"                      '%s' is current clocksource.\\n\", cs->name);\n\t\t\telse if (curr_clocksource)\n\t\t\t\tpr_warn(\"                      '%s' (not '%s') is current clocksource.\\n\", curr_clocksource->name, cs->name);\n\t\t\telse\n\t\t\t\tpr_warn(\"                      No current clocksource.\\n\");\n\t\t\t__clocksource_unstable(cs);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cs == curr_clocksource && cs->tick_stable)\n\t\t\tcs->tick_stable(cs);\n\n\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) &&\n\t\t    (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS) &&\n\t\t    (watchdog->flags & CLOCK_SOURCE_IS_CONTINUOUS)) {\n\t\t\t/* Mark it valid for high-res. */\n\t\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;\n\n\t\t\t/*\n\t\t\t * clocksource_done_booting() will sort it if\n\t\t\t * finished_booting is not set yet.\n\t\t\t */\n\t\t\tif (!finished_booting)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If this is not the current clocksource let\n\t\t\t * the watchdog thread reselect it. Due to the\n\t\t\t * change to high res this clocksource might\n\t\t\t * be preferred now. If it is the current\n\t\t\t * clocksource let the tick code know about\n\t\t\t * that change.\n\t\t\t */\n\t\t\tif (cs != curr_clocksource) {\n\t\t\t\tcs->flags |= CLOCK_SOURCE_RESELECT;\n\t\t\t\tschedule_work(&watchdog_work);\n\t\t\t} else {\n\t\t\t\ttick_clock_notify();\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We only clear the watchdog_reset_pending, when we did a\n\t * full cycle through all clocksources.\n\t */\n\tif (reset_pending)\n\t\tatomic_dec(&watchdog_reset_pending);\n\n\t/*\n\t * Cycle through CPUs to check if the CPUs stay synchronized\n\t * to each other.\n\t */\n\tnext_cpu = cpumask_next(raw_smp_processor_id(), cpu_online_mask);\n\tif (next_cpu >= nr_cpu_ids)\n\t\tnext_cpu = cpumask_first(cpu_online_mask);\n\n\t/*\n\t * Arm timer if not already pending: could race with concurrent\n\t * pair clocksource_stop_watchdog() clocksource_start_watchdog().\n\t */\n\tif (!timer_pending(&watchdog_timer)) {\n\t\twatchdog_timer.expires += WATCHDOG_INTERVAL;\n\t\tadd_timer_on(&watchdog_timer, next_cpu);\n\t}\nout:\n\tspin_unlock(&watchdog_lock);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [
      "#define WATCHDOG_INTERVAL (HZ >> 1)"
    ],
    "globals_used": [
      "static struct clocksource *curr_clocksource;",
      "static int finished_booting;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&watchdog_lock"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_timer_on",
          "args": [
            "&watchdog_timer",
            "next_cpu"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "add_timer_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1155-1184",
          "snippet": "void add_timer_on(struct timer_list *timer, int cpu)\n{\n\tstruct timer_base *new_base, *base;\n\tunsigned long flags;\n\n\tBUG_ON(timer_pending(timer) || !timer->function);\n\n\tnew_base = get_timer_cpu_base(timer->flags, cpu);\n\n\t/*\n\t * If @timer was on a different CPU, it should be migrated with the\n\t * old base locked to prevent other operations proceeding with the\n\t * wrong base locked.  See lock_timer_base().\n\t */\n\tbase = lock_timer_base(timer, &flags);\n\tif (base != new_base) {\n\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\traw_spin_unlock(&base->lock);\n\t\tbase = new_base;\n\t\traw_spin_lock(&base->lock);\n\t\tWRITE_ONCE(timer->flags,\n\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);\n\t}\n\tforward_timer_base(base);\n\n\tdebug_timer_activate(timer);\n\tinternal_add_timer(base, timer);\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid add_timer_on(struct timer_list *timer, int cpu)\n{\n\tstruct timer_base *new_base, *base;\n\tunsigned long flags;\n\n\tBUG_ON(timer_pending(timer) || !timer->function);\n\n\tnew_base = get_timer_cpu_base(timer->flags, cpu);\n\n\t/*\n\t * If @timer was on a different CPU, it should be migrated with the\n\t * old base locked to prevent other operations proceeding with the\n\t * wrong base locked.  See lock_timer_base().\n\t */\n\tbase = lock_timer_base(timer, &flags);\n\tif (base != new_base) {\n\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\traw_spin_unlock(&base->lock);\n\t\tbase = new_base;\n\t\traw_spin_lock(&base->lock);\n\t\tWRITE_ONCE(timer->flags,\n\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);\n\t}\n\tforward_timer_base(base);\n\n\tdebug_timer_activate(timer);\n\tinternal_add_timer(base, timer);\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "&watchdog_timer"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "raw_smp_processor_id()",
            "cpu_online_mask"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&watchdog_reset_pending"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_clock_notify",
          "args": [],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "tick_clock_notify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "1499-1505",
          "snippet": "void tick_clock_notify(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_clock_notify(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&watchdog_work"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cs->tick_stable",
          "args": [
            "cs"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clocksource_unstable",
          "args": [
            "cs"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_unstable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "160-180",
          "snippet": "static void __clocksource_unstable(struct clocksource *cs)\n{\n\tcs->flags &= ~(CLOCK_SOURCE_VALID_FOR_HRES | CLOCK_SOURCE_WATCHDOG);\n\tcs->flags |= CLOCK_SOURCE_UNSTABLE;\n\n\t/*\n\t * If the clocksource is registered clocksource_watchdog_kthread() will\n\t * re-rate and re-select.\n\t */\n\tif (list_empty(&cs->list)) {\n\t\tcs->rating = 0;\n\t\treturn;\n\t}\n\n\tif (cs->mark_unstable)\n\t\tcs->mark_unstable(cs);\n\n\t/* kick clocksource_watchdog_kthread() */\n\tif (finished_booting)\n\t\tschedule_work(&watchdog_work);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int finished_booting;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic int finished_booting;\n\nstatic void __clocksource_unstable(struct clocksource *cs)\n{\n\tcs->flags &= ~(CLOCK_SOURCE_VALID_FOR_HRES | CLOCK_SOURCE_WATCHDOG);\n\tcs->flags |= CLOCK_SOURCE_UNSTABLE;\n\n\t/*\n\t * If the clocksource is registered clocksource_watchdog_kthread() will\n\t * re-rate and re-select.\n\t */\n\tif (list_empty(&cs->list)) {\n\t\tcs->rating = 0;\n\t\treturn;\n\t}\n\n\tif (cs->mark_unstable)\n\t\tcs->mark_unstable(cs);\n\n\t/* kick clocksource_watchdog_kthread() */\n\tif (finished_booting)\n\t\tschedule_work(&watchdog_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"                      No current clocksource.\\n\""
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"                      '%s' (not '%s') is current clocksource.\\n\"",
            "curr_clocksource->name",
            "cs->name"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"                      '%s' is current clocksource.\\n\"",
            "cs->name"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"                      '%s' cs_nsec: %lld cs_now: %llx cs_last: %llx mask: %llx\\n\"",
            "cs->name",
            "cs_nsec",
            "csnow",
            "cslast",
            "cs->mask"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"                      '%s' wd_nsec: %lld wd_now: %llx wd_last: %llx mask: %llx\\n\"",
            "watchdog->name",
            "wd_nsec",
            "wdnow",
            "wdlast",
            "watchdog->mask"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"timekeeping watchdog on CPU%d: Marking clocksource '%s' as unstable because the skew is too large:\\n\"",
            "smp_processor_id()",
            "cs->name"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "cs_nsec - wd_nsec"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "608-615",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&watchdog_reset_pending"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_cyc2ns",
          "args": [
            "delta",
            "cs->mult",
            "cs->shift"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "csnow",
            "cs->cs_last",
            "cs->mask"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping_internal.h",
          "lines": "30-33",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/spinlock.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_cyc2ns",
          "args": [
            "delta",
            "watchdog->mult",
            "watchdog->shift"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&watchdog_reset_pending"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cs_watchdog_read",
          "args": [
            "cs",
            "&csnow",
            "&wdnow"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "cs_watchdog_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "214-264",
          "snippet": "static enum wd_read_status cs_watchdog_read(struct clocksource *cs, u64 *csnow, u64 *wdnow)\n{\n\tunsigned int nretries;\n\tu64 wd_end, wd_end2, wd_delta;\n\tint64_t wd_delay, wd_seq_delay;\n\n\tfor (nretries = 0; nretries <= max_cswd_read_retries; nretries++) {\n\t\tlocal_irq_disable();\n\t\t*wdnow = watchdog->read(watchdog);\n\t\t*csnow = cs->read(cs);\n\t\twd_end = watchdog->read(watchdog);\n\t\twd_end2 = watchdog->read(watchdog);\n\t\tlocal_irq_enable();\n\n\t\twd_delta = clocksource_delta(wd_end, *wdnow, watchdog->mask);\n\t\twd_delay = clocksource_cyc2ns(wd_delta, watchdog->mult,\n\t\t\t\t\t      watchdog->shift);\n\t\tif (wd_delay <= WATCHDOG_MAX_SKEW) {\n\t\t\tif (nretries > 1 || nretries >= max_cswd_read_retries) {\n\t\t\t\tpr_warn(\"timekeeping watchdog on CPU%d: %s retried %d times before success\\n\",\n\t\t\t\t\tsmp_processor_id(), watchdog->name, nretries);\n\t\t\t}\n\t\t\treturn WD_READ_SUCCESS;\n\t\t}\n\n\t\t/*\n\t\t * Now compute delay in consecutive watchdog read to see if\n\t\t * there is too much external interferences that cause\n\t\t * significant delay in reading both clocksource and watchdog.\n\t\t *\n\t\t * If consecutive WD read-back delay > WATCHDOG_MAX_SKEW/2,\n\t\t * report system busy, reinit the watchdog and skip the current\n\t\t * watchdog test.\n\t\t */\n\t\twd_delta = clocksource_delta(wd_end2, wd_end, watchdog->mask);\n\t\twd_seq_delay = clocksource_cyc2ns(wd_delta, watchdog->mult, watchdog->shift);\n\t\tif (wd_seq_delay > WATCHDOG_MAX_SKEW/2)\n\t\t\tgoto skip_test;\n\t}\n\n\tpr_warn(\"timekeeping watchdog on CPU%d: %s read-back delay of %lldns, attempt %d, marking unstable\\n\",\n\t\tsmp_processor_id(), watchdog->name, wd_delay, nretries);\n\treturn WD_READ_UNSTABLE;\n\nskip_test:\n\tpr_info(\"timekeeping watchdog on CPU%d: %s wd-wd read-back delay of %lldns\\n\",\n\t\tsmp_processor_id(), watchdog->name, wd_seq_delay);\n\tpr_info(\"wd-%s-wd read-back delay of %lldns, clock-skew test skipped!\\n\",\n\t\tcs->name, wd_delay);\n\treturn WD_READ_SKIP;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [
            "#define WATCHDOG_MAX_SKEW (100 * NSEC_PER_USEC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\n#define WATCHDOG_MAX_SKEW (100 * NSEC_PER_USEC)\n\nstatic enum wd_read_status cs_watchdog_read(struct clocksource *cs, u64 *csnow, u64 *wdnow)\n{\n\tunsigned int nretries;\n\tu64 wd_end, wd_end2, wd_delta;\n\tint64_t wd_delay, wd_seq_delay;\n\n\tfor (nretries = 0; nretries <= max_cswd_read_retries; nretries++) {\n\t\tlocal_irq_disable();\n\t\t*wdnow = watchdog->read(watchdog);\n\t\t*csnow = cs->read(cs);\n\t\twd_end = watchdog->read(watchdog);\n\t\twd_end2 = watchdog->read(watchdog);\n\t\tlocal_irq_enable();\n\n\t\twd_delta = clocksource_delta(wd_end, *wdnow, watchdog->mask);\n\t\twd_delay = clocksource_cyc2ns(wd_delta, watchdog->mult,\n\t\t\t\t\t      watchdog->shift);\n\t\tif (wd_delay <= WATCHDOG_MAX_SKEW) {\n\t\t\tif (nretries > 1 || nretries >= max_cswd_read_retries) {\n\t\t\t\tpr_warn(\"timekeeping watchdog on CPU%d: %s retried %d times before success\\n\",\n\t\t\t\t\tsmp_processor_id(), watchdog->name, nretries);\n\t\t\t}\n\t\t\treturn WD_READ_SUCCESS;\n\t\t}\n\n\t\t/*\n\t\t * Now compute delay in consecutive watchdog read to see if\n\t\t * there is too much external interferences that cause\n\t\t * significant delay in reading both clocksource and watchdog.\n\t\t *\n\t\t * If consecutive WD read-back delay > WATCHDOG_MAX_SKEW/2,\n\t\t * report system busy, reinit the watchdog and skip the current\n\t\t * watchdog test.\n\t\t */\n\t\twd_delta = clocksource_delta(wd_end2, wd_end, watchdog->mask);\n\t\twd_seq_delay = clocksource_cyc2ns(wd_delta, watchdog->mult, watchdog->shift);\n\t\tif (wd_seq_delay > WATCHDOG_MAX_SKEW/2)\n\t\t\tgoto skip_test;\n\t}\n\n\tpr_warn(\"timekeeping watchdog on CPU%d: %s read-back delay of %lldns, attempt %d, marking unstable\\n\",\n\t\tsmp_processor_id(), watchdog->name, wd_delay, nretries);\n\treturn WD_READ_UNSTABLE;\n\nskip_test:\n\tpr_info(\"timekeeping watchdog on CPU%d: %s wd-wd read-back delay of %lldns\\n\",\n\t\tsmp_processor_id(), watchdog->name, wd_seq_delay);\n\tpr_info(\"wd-%s-wd read-back delay of %lldns, clock-skew test skipped!\\n\",\n\t\tcs->name, wd_delay);\n\treturn WD_READ_SKIP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&watchdog_work"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cs",
            "&watchdog_list",
            "wd_list"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&watchdog_reset_pending"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&watchdog_lock"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\n#define WATCHDOG_INTERVAL (HZ >> 1)\n\nstatic struct clocksource *curr_clocksource;\nstatic int finished_booting;\n\nstatic void clocksource_watchdog(struct timer_list *unused)\n{\n\tu64 csnow, wdnow, cslast, wdlast, delta;\n\tint next_cpu, reset_pending;\n\tint64_t wd_nsec, cs_nsec;\n\tstruct clocksource *cs;\n\tenum wd_read_status read_ret;\n\tu32 md;\n\n\tspin_lock(&watchdog_lock);\n\tif (!watchdog_running)\n\t\tgoto out;\n\n\treset_pending = atomic_read(&watchdog_reset_pending);\n\n\tlist_for_each_entry(cs, &watchdog_list, wd_list) {\n\n\t\t/* Clocksource already marked unstable? */\n\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\tif (finished_booting)\n\t\t\t\tschedule_work(&watchdog_work);\n\t\t\tcontinue;\n\t\t}\n\n\t\tread_ret = cs_watchdog_read(cs, &csnow, &wdnow);\n\n\t\tif (read_ret != WD_READ_SUCCESS) {\n\t\t\tif (read_ret == WD_READ_UNSTABLE)\n\t\t\t\t/* Clock readout unreliable, so give it up. */\n\t\t\t\t__clocksource_unstable(cs);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Clocksource initialized ? */\n\t\tif (!(cs->flags & CLOCK_SOURCE_WATCHDOG) ||\n\t\t    atomic_read(&watchdog_reset_pending)) {\n\t\t\tcs->flags |= CLOCK_SOURCE_WATCHDOG;\n\t\t\tcs->wd_last = wdnow;\n\t\t\tcs->cs_last = csnow;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdelta = clocksource_delta(wdnow, cs->wd_last, watchdog->mask);\n\t\twd_nsec = clocksource_cyc2ns(delta, watchdog->mult,\n\t\t\t\t\t     watchdog->shift);\n\n\t\tdelta = clocksource_delta(csnow, cs->cs_last, cs->mask);\n\t\tcs_nsec = clocksource_cyc2ns(delta, cs->mult, cs->shift);\n\t\twdlast = cs->wd_last; /* save these in case we print them */\n\t\tcslast = cs->cs_last;\n\t\tcs->cs_last = csnow;\n\t\tcs->wd_last = wdnow;\n\n\t\tif (atomic_read(&watchdog_reset_pending))\n\t\t\tcontinue;\n\n\t\t/* Check the deviation from the watchdog clocksource. */\n\t\tmd = cs->uncertainty_margin + watchdog->uncertainty_margin;\n\t\tif (abs(cs_nsec - wd_nsec) > md) {\n\t\t\tpr_warn(\"timekeeping watchdog on CPU%d: Marking clocksource '%s' as unstable because the skew is too large:\\n\",\n\t\t\t\tsmp_processor_id(), cs->name);\n\t\t\tpr_warn(\"                      '%s' wd_nsec: %lld wd_now: %llx wd_last: %llx mask: %llx\\n\",\n\t\t\t\twatchdog->name, wd_nsec, wdnow, wdlast, watchdog->mask);\n\t\t\tpr_warn(\"                      '%s' cs_nsec: %lld cs_now: %llx cs_last: %llx mask: %llx\\n\",\n\t\t\t\tcs->name, cs_nsec, csnow, cslast, cs->mask);\n\t\t\tif (curr_clocksource == cs)\n\t\t\t\tpr_warn(\"                      '%s' is current clocksource.\\n\", cs->name);\n\t\t\telse if (curr_clocksource)\n\t\t\t\tpr_warn(\"                      '%s' (not '%s') is current clocksource.\\n\", curr_clocksource->name, cs->name);\n\t\t\telse\n\t\t\t\tpr_warn(\"                      No current clocksource.\\n\");\n\t\t\t__clocksource_unstable(cs);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cs == curr_clocksource && cs->tick_stable)\n\t\t\tcs->tick_stable(cs);\n\n\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) &&\n\t\t    (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS) &&\n\t\t    (watchdog->flags & CLOCK_SOURCE_IS_CONTINUOUS)) {\n\t\t\t/* Mark it valid for high-res. */\n\t\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;\n\n\t\t\t/*\n\t\t\t * clocksource_done_booting() will sort it if\n\t\t\t * finished_booting is not set yet.\n\t\t\t */\n\t\t\tif (!finished_booting)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If this is not the current clocksource let\n\t\t\t * the watchdog thread reselect it. Due to the\n\t\t\t * change to high res this clocksource might\n\t\t\t * be preferred now. If it is the current\n\t\t\t * clocksource let the tick code know about\n\t\t\t * that change.\n\t\t\t */\n\t\t\tif (cs != curr_clocksource) {\n\t\t\t\tcs->flags |= CLOCK_SOURCE_RESELECT;\n\t\t\t\tschedule_work(&watchdog_work);\n\t\t\t} else {\n\t\t\t\ttick_clock_notify();\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We only clear the watchdog_reset_pending, when we did a\n\t * full cycle through all clocksources.\n\t */\n\tif (reset_pending)\n\t\tatomic_dec(&watchdog_reset_pending);\n\n\t/*\n\t * Cycle through CPUs to check if the CPUs stay synchronized\n\t * to each other.\n\t */\n\tnext_cpu = cpumask_next(raw_smp_processor_id(), cpu_online_mask);\n\tif (next_cpu >= nr_cpu_ids)\n\t\tnext_cpu = cpumask_first(cpu_online_mask);\n\n\t/*\n\t * Arm timer if not already pending: could race with concurrent\n\t * pair clocksource_stop_watchdog() clocksource_start_watchdog().\n\t */\n\tif (!timer_pending(&watchdog_timer)) {\n\t\twatchdog_timer.expires += WATCHDOG_INTERVAL;\n\t\tadd_timer_on(&watchdog_timer, next_cpu);\n\t}\nout:\n\tspin_unlock(&watchdog_lock);\n}"
  },
  {
    "function_name": "clocksource_verify_percpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "326-378",
    "snippet": "void clocksource_verify_percpu(struct clocksource *cs)\n{\n\tint64_t cs_nsec, cs_nsec_max = 0, cs_nsec_min = LLONG_MAX;\n\tu64 csnow_begin, csnow_end;\n\tint cpu, testcpu;\n\ts64 delta;\n\n\tif (verify_n_cpus == 0)\n\t\treturn;\n\tcpumask_clear(&cpus_ahead);\n\tcpumask_clear(&cpus_behind);\n\tcpus_read_lock();\n\tpreempt_disable();\n\tclocksource_verify_choose_cpus();\n\tif (cpumask_weight(&cpus_chosen) == 0) {\n\t\tpreempt_enable();\n\t\tcpus_read_unlock();\n\t\tpr_warn(\"Not enough CPUs to check clocksource '%s'.\\n\", cs->name);\n\t\treturn;\n\t}\n\ttestcpu = smp_processor_id();\n\tpr_warn(\"Checking clocksource %s synchronization from CPU %d to CPUs %*pbl.\\n\", cs->name, testcpu, cpumask_pr_args(&cpus_chosen));\n\tfor_each_cpu(cpu, &cpus_chosen) {\n\t\tif (cpu == testcpu)\n\t\t\tcontinue;\n\t\tcsnow_begin = cs->read(cs);\n\t\tsmp_call_function_single(cpu, clocksource_verify_one_cpu, cs, 1);\n\t\tcsnow_end = cs->read(cs);\n\t\tdelta = (s64)((csnow_mid - csnow_begin) & cs->mask);\n\t\tif (delta < 0)\n\t\t\tcpumask_set_cpu(cpu, &cpus_behind);\n\t\tdelta = (csnow_end - csnow_mid) & cs->mask;\n\t\tif (delta < 0)\n\t\t\tcpumask_set_cpu(cpu, &cpus_ahead);\n\t\tdelta = clocksource_delta(csnow_end, csnow_begin, cs->mask);\n\t\tcs_nsec = clocksource_cyc2ns(delta, cs->mult, cs->shift);\n\t\tif (cs_nsec > cs_nsec_max)\n\t\t\tcs_nsec_max = cs_nsec;\n\t\tif (cs_nsec < cs_nsec_min)\n\t\t\tcs_nsec_min = cs_nsec;\n\t}\n\tpreempt_enable();\n\tcpus_read_unlock();\n\tif (!cpumask_empty(&cpus_ahead))\n\t\tpr_warn(\"        CPUs %*pbl ahead of CPU %d for clocksource %s.\\n\",\n\t\t\tcpumask_pr_args(&cpus_ahead), testcpu, cs->name);\n\tif (!cpumask_empty(&cpus_behind))\n\t\tpr_warn(\"        CPUs %*pbl behind CPU %d for clocksource %s.\\n\",\n\t\t\tcpumask_pr_args(&cpus_behind), testcpu, cs->name);\n\tif (!cpumask_empty(&cpus_ahead) || !cpumask_empty(&cpus_behind))\n\t\tpr_warn(\"        CPU %d check durations %lldns - %lldns for clocksource %s.\\n\",\n\t\t\ttestcpu, cs_nsec_min, cs_nsec_max, cs->name);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"        CPU %d check durations %lldns - %lldns for clocksource %s.\\n\"",
            "testcpu",
            "cs_nsec_min",
            "cs_nsec_max",
            "cs->name"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "&cpus_behind"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "&cpus_ahead"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"        CPUs %*pbl behind CPU %d for clocksource %s.\\n\"",
            "cpumask_pr_args(&cpus_behind)",
            "testcpu",
            "cs->name"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "&cpus_behind"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "&cpus_behind"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"        CPUs %*pbl ahead of CPU %d for clocksource %s.\\n\"",
            "cpumask_pr_args(&cpus_ahead)",
            "testcpu",
            "cs->name"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "&cpus_ahead"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "&cpus_ahead"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_cyc2ns",
          "args": [
            "delta",
            "cs->mult",
            "cs->shift"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "csnow_end",
            "csnow_begin",
            "cs->mask"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping_internal.h",
          "lines": "30-33",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/spinlock.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "&cpus_ahead"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "&cpus_behind"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(csnow_mid - csnow_begin) & cs->mask"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cs->read",
          "args": [
            "cs"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "clocksource_verify_one_cpu",
            "cs",
            "1"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/up.c",
          "lines": "12-25",
          "snippet": "int smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cs->read",
          "args": [
            "cs"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "&cpus_chosen"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Checking clocksource %s synchronization from CPU %d to CPUs %*pbl.\\n\"",
            "cs->name",
            "testcpu",
            "cpumask_pr_args(&cpus_chosen)"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "&cpus_chosen"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Not enough CPUs to check clocksource '%s'.\\n\"",
            "cs->name"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "&cpus_chosen"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_verify_choose_cpus",
          "args": [],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_verify_choose_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "271-317",
          "snippet": "static void clocksource_verify_choose_cpus(void)\n{\n\tint cpu, i, n = verify_n_cpus;\n\n\tif (n < 0) {\n\t\t/* Check all of the CPUs. */\n\t\tcpumask_copy(&cpus_chosen, cpu_online_mask);\n\t\tcpumask_clear_cpu(smp_processor_id(), &cpus_chosen);\n\t\treturn;\n\t}\n\n\t/* If no checking desired, or no other CPU to check, leave. */\n\tcpumask_clear(&cpus_chosen);\n\tif (n == 0 || num_online_cpus() <= 1)\n\t\treturn;\n\n\t/* Make sure to select at least one CPU other than the current CPU. */\n\tcpu = cpumask_first(cpu_online_mask);\n\tif (cpu == smp_processor_id())\n\t\tcpu = cpumask_next(cpu, cpu_online_mask);\n\tif (WARN_ON_ONCE(cpu >= nr_cpu_ids))\n\t\treturn;\n\tcpumask_set_cpu(cpu, &cpus_chosen);\n\n\t/* Force a sane value for the boot parameter. */\n\tif (n > nr_cpu_ids)\n\t\tn = nr_cpu_ids;\n\n\t/*\n\t * Randomly select the specified number of CPUs.  If the same\n\t * CPU is selected multiple times, that CPU is checked only once,\n\t * and no replacement CPU is selected.  This gracefully handles\n\t * situations where verify_n_cpus is greater than the number of\n\t * CPUs that are currently online.\n\t */\n\tfor (i = 1; i < n; i++) {\n\t\tcpu = prandom_u32() % nr_cpu_ids;\n\t\tcpu = cpumask_next(cpu - 1, cpu_online_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = cpumask_first(cpu_online_mask);\n\t\tif (!WARN_ON_ONCE(cpu >= nr_cpu_ids))\n\t\t\tcpumask_set_cpu(cpu, &cpus_chosen);\n\t}\n\n\t/* Don't verify ourselves. */\n\tcpumask_clear_cpu(smp_processor_id(), &cpus_chosen);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_verify_choose_cpus(void)\n{\n\tint cpu, i, n = verify_n_cpus;\n\n\tif (n < 0) {\n\t\t/* Check all of the CPUs. */\n\t\tcpumask_copy(&cpus_chosen, cpu_online_mask);\n\t\tcpumask_clear_cpu(smp_processor_id(), &cpus_chosen);\n\t\treturn;\n\t}\n\n\t/* If no checking desired, or no other CPU to check, leave. */\n\tcpumask_clear(&cpus_chosen);\n\tif (n == 0 || num_online_cpus() <= 1)\n\t\treturn;\n\n\t/* Make sure to select at least one CPU other than the current CPU. */\n\tcpu = cpumask_first(cpu_online_mask);\n\tif (cpu == smp_processor_id())\n\t\tcpu = cpumask_next(cpu, cpu_online_mask);\n\tif (WARN_ON_ONCE(cpu >= nr_cpu_ids))\n\t\treturn;\n\tcpumask_set_cpu(cpu, &cpus_chosen);\n\n\t/* Force a sane value for the boot parameter. */\n\tif (n > nr_cpu_ids)\n\t\tn = nr_cpu_ids;\n\n\t/*\n\t * Randomly select the specified number of CPUs.  If the same\n\t * CPU is selected multiple times, that CPU is checked only once,\n\t * and no replacement CPU is selected.  This gracefully handles\n\t * situations where verify_n_cpus is greater than the number of\n\t * CPUs that are currently online.\n\t */\n\tfor (i = 1; i < n; i++) {\n\t\tcpu = prandom_u32() % nr_cpu_ids;\n\t\tcpu = cpumask_next(cpu - 1, cpu_online_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = cpumask_first(cpu_online_mask);\n\t\tif (!WARN_ON_ONCE(cpu >= nr_cpu_ids))\n\t\t\tcpumask_set_cpu(cpu, &cpus_chosen);\n\t}\n\n\t/* Don't verify ourselves. */\n\tcpumask_clear_cpu(smp_processor_id(), &cpus_chosen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "&cpus_behind"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "&cpus_ahead"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid clocksource_verify_percpu(struct clocksource *cs)\n{\n\tint64_t cs_nsec, cs_nsec_max = 0, cs_nsec_min = LLONG_MAX;\n\tu64 csnow_begin, csnow_end;\n\tint cpu, testcpu;\n\ts64 delta;\n\n\tif (verify_n_cpus == 0)\n\t\treturn;\n\tcpumask_clear(&cpus_ahead);\n\tcpumask_clear(&cpus_behind);\n\tcpus_read_lock();\n\tpreempt_disable();\n\tclocksource_verify_choose_cpus();\n\tif (cpumask_weight(&cpus_chosen) == 0) {\n\t\tpreempt_enable();\n\t\tcpus_read_unlock();\n\t\tpr_warn(\"Not enough CPUs to check clocksource '%s'.\\n\", cs->name);\n\t\treturn;\n\t}\n\ttestcpu = smp_processor_id();\n\tpr_warn(\"Checking clocksource %s synchronization from CPU %d to CPUs %*pbl.\\n\", cs->name, testcpu, cpumask_pr_args(&cpus_chosen));\n\tfor_each_cpu(cpu, &cpus_chosen) {\n\t\tif (cpu == testcpu)\n\t\t\tcontinue;\n\t\tcsnow_begin = cs->read(cs);\n\t\tsmp_call_function_single(cpu, clocksource_verify_one_cpu, cs, 1);\n\t\tcsnow_end = cs->read(cs);\n\t\tdelta = (s64)((csnow_mid - csnow_begin) & cs->mask);\n\t\tif (delta < 0)\n\t\t\tcpumask_set_cpu(cpu, &cpus_behind);\n\t\tdelta = (csnow_end - csnow_mid) & cs->mask;\n\t\tif (delta < 0)\n\t\t\tcpumask_set_cpu(cpu, &cpus_ahead);\n\t\tdelta = clocksource_delta(csnow_end, csnow_begin, cs->mask);\n\t\tcs_nsec = clocksource_cyc2ns(delta, cs->mult, cs->shift);\n\t\tif (cs_nsec > cs_nsec_max)\n\t\t\tcs_nsec_max = cs_nsec;\n\t\tif (cs_nsec < cs_nsec_min)\n\t\t\tcs_nsec_min = cs_nsec;\n\t}\n\tpreempt_enable();\n\tcpus_read_unlock();\n\tif (!cpumask_empty(&cpus_ahead))\n\t\tpr_warn(\"        CPUs %*pbl ahead of CPU %d for clocksource %s.\\n\",\n\t\t\tcpumask_pr_args(&cpus_ahead), testcpu, cs->name);\n\tif (!cpumask_empty(&cpus_behind))\n\t\tpr_warn(\"        CPUs %*pbl behind CPU %d for clocksource %s.\\n\",\n\t\t\tcpumask_pr_args(&cpus_behind), testcpu, cs->name);\n\tif (!cpumask_empty(&cpus_ahead) || !cpumask_empty(&cpus_behind))\n\t\tpr_warn(\"        CPU %d check durations %lldns - %lldns for clocksource %s.\\n\",\n\t\t\ttestcpu, cs_nsec_min, cs_nsec_max, cs->name);\n}"
  },
  {
    "function_name": "clocksource_verify_one_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "319-324",
    "snippet": "static void clocksource_verify_one_cpu(void *csin)\n{\n\tstruct clocksource *cs = (struct clocksource *)csin;\n\n\tcsnow_mid = cs->read(cs);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cs->read",
          "args": [
            "cs"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_verify_one_cpu(void *csin)\n{\n\tstruct clocksource *cs = (struct clocksource *)csin;\n\n\tcsnow_mid = cs->read(cs);\n}"
  },
  {
    "function_name": "clocksource_verify_choose_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "271-317",
    "snippet": "static void clocksource_verify_choose_cpus(void)\n{\n\tint cpu, i, n = verify_n_cpus;\n\n\tif (n < 0) {\n\t\t/* Check all of the CPUs. */\n\t\tcpumask_copy(&cpus_chosen, cpu_online_mask);\n\t\tcpumask_clear_cpu(smp_processor_id(), &cpus_chosen);\n\t\treturn;\n\t}\n\n\t/* If no checking desired, or no other CPU to check, leave. */\n\tcpumask_clear(&cpus_chosen);\n\tif (n == 0 || num_online_cpus() <= 1)\n\t\treturn;\n\n\t/* Make sure to select at least one CPU other than the current CPU. */\n\tcpu = cpumask_first(cpu_online_mask);\n\tif (cpu == smp_processor_id())\n\t\tcpu = cpumask_next(cpu, cpu_online_mask);\n\tif (WARN_ON_ONCE(cpu >= nr_cpu_ids))\n\t\treturn;\n\tcpumask_set_cpu(cpu, &cpus_chosen);\n\n\t/* Force a sane value for the boot parameter. */\n\tif (n > nr_cpu_ids)\n\t\tn = nr_cpu_ids;\n\n\t/*\n\t * Randomly select the specified number of CPUs.  If the same\n\t * CPU is selected multiple times, that CPU is checked only once,\n\t * and no replacement CPU is selected.  This gracefully handles\n\t * situations where verify_n_cpus is greater than the number of\n\t * CPUs that are currently online.\n\t */\n\tfor (i = 1; i < n; i++) {\n\t\tcpu = prandom_u32() % nr_cpu_ids;\n\t\tcpu = cpumask_next(cpu - 1, cpu_online_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = cpumask_first(cpu_online_mask);\n\t\tif (!WARN_ON_ONCE(cpu >= nr_cpu_ids))\n\t\t\tcpumask_set_cpu(cpu, &cpus_chosen);\n\t}\n\n\t/* Don't verify ourselves. */\n\tcpumask_clear_cpu(smp_processor_id(), &cpus_chosen);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "smp_processor_id()",
            "&cpus_chosen"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "&cpus_chosen"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu >= nr_cpu_ids"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "cpu - 1",
            "cpu_online_mask"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prandom_u32",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "&cpus_chosen"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu >= nr_cpu_ids"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "cpu",
            "cpu_online_mask"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "&cpus_chosen"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "smp_processor_id()",
            "&cpus_chosen"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "&cpus_chosen",
            "cpu_online_mask"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_verify_choose_cpus(void)\n{\n\tint cpu, i, n = verify_n_cpus;\n\n\tif (n < 0) {\n\t\t/* Check all of the CPUs. */\n\t\tcpumask_copy(&cpus_chosen, cpu_online_mask);\n\t\tcpumask_clear_cpu(smp_processor_id(), &cpus_chosen);\n\t\treturn;\n\t}\n\n\t/* If no checking desired, or no other CPU to check, leave. */\n\tcpumask_clear(&cpus_chosen);\n\tif (n == 0 || num_online_cpus() <= 1)\n\t\treturn;\n\n\t/* Make sure to select at least one CPU other than the current CPU. */\n\tcpu = cpumask_first(cpu_online_mask);\n\tif (cpu == smp_processor_id())\n\t\tcpu = cpumask_next(cpu, cpu_online_mask);\n\tif (WARN_ON_ONCE(cpu >= nr_cpu_ids))\n\t\treturn;\n\tcpumask_set_cpu(cpu, &cpus_chosen);\n\n\t/* Force a sane value for the boot parameter. */\n\tif (n > nr_cpu_ids)\n\t\tn = nr_cpu_ids;\n\n\t/*\n\t * Randomly select the specified number of CPUs.  If the same\n\t * CPU is selected multiple times, that CPU is checked only once,\n\t * and no replacement CPU is selected.  This gracefully handles\n\t * situations where verify_n_cpus is greater than the number of\n\t * CPUs that are currently online.\n\t */\n\tfor (i = 1; i < n; i++) {\n\t\tcpu = prandom_u32() % nr_cpu_ids;\n\t\tcpu = cpumask_next(cpu - 1, cpu_online_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = cpumask_first(cpu_online_mask);\n\t\tif (!WARN_ON_ONCE(cpu >= nr_cpu_ids))\n\t\t\tcpumask_set_cpu(cpu, &cpus_chosen);\n\t}\n\n\t/* Don't verify ourselves. */\n\tcpumask_clear_cpu(smp_processor_id(), &cpus_chosen);\n}"
  },
  {
    "function_name": "cs_watchdog_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "214-264",
    "snippet": "static enum wd_read_status cs_watchdog_read(struct clocksource *cs, u64 *csnow, u64 *wdnow)\n{\n\tunsigned int nretries;\n\tu64 wd_end, wd_end2, wd_delta;\n\tint64_t wd_delay, wd_seq_delay;\n\n\tfor (nretries = 0; nretries <= max_cswd_read_retries; nretries++) {\n\t\tlocal_irq_disable();\n\t\t*wdnow = watchdog->read(watchdog);\n\t\t*csnow = cs->read(cs);\n\t\twd_end = watchdog->read(watchdog);\n\t\twd_end2 = watchdog->read(watchdog);\n\t\tlocal_irq_enable();\n\n\t\twd_delta = clocksource_delta(wd_end, *wdnow, watchdog->mask);\n\t\twd_delay = clocksource_cyc2ns(wd_delta, watchdog->mult,\n\t\t\t\t\t      watchdog->shift);\n\t\tif (wd_delay <= WATCHDOG_MAX_SKEW) {\n\t\t\tif (nretries > 1 || nretries >= max_cswd_read_retries) {\n\t\t\t\tpr_warn(\"timekeeping watchdog on CPU%d: %s retried %d times before success\\n\",\n\t\t\t\t\tsmp_processor_id(), watchdog->name, nretries);\n\t\t\t}\n\t\t\treturn WD_READ_SUCCESS;\n\t\t}\n\n\t\t/*\n\t\t * Now compute delay in consecutive watchdog read to see if\n\t\t * there is too much external interferences that cause\n\t\t * significant delay in reading both clocksource and watchdog.\n\t\t *\n\t\t * If consecutive WD read-back delay > WATCHDOG_MAX_SKEW/2,\n\t\t * report system busy, reinit the watchdog and skip the current\n\t\t * watchdog test.\n\t\t */\n\t\twd_delta = clocksource_delta(wd_end2, wd_end, watchdog->mask);\n\t\twd_seq_delay = clocksource_cyc2ns(wd_delta, watchdog->mult, watchdog->shift);\n\t\tif (wd_seq_delay > WATCHDOG_MAX_SKEW/2)\n\t\t\tgoto skip_test;\n\t}\n\n\tpr_warn(\"timekeeping watchdog on CPU%d: %s read-back delay of %lldns, attempt %d, marking unstable\\n\",\n\t\tsmp_processor_id(), watchdog->name, wd_delay, nretries);\n\treturn WD_READ_UNSTABLE;\n\nskip_test:\n\tpr_info(\"timekeeping watchdog on CPU%d: %s wd-wd read-back delay of %lldns\\n\",\n\t\tsmp_processor_id(), watchdog->name, wd_seq_delay);\n\tpr_info(\"wd-%s-wd read-back delay of %lldns, clock-skew test skipped!\\n\",\n\t\tcs->name, wd_delay);\n\treturn WD_READ_SKIP;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [
      "#define WATCHDOG_MAX_SKEW (100 * NSEC_PER_USEC)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"wd-%s-wd read-back delay of %lldns, clock-skew test skipped!\\n\"",
            "cs->name",
            "wd_delay"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"timekeeping watchdog on CPU%d: %s wd-wd read-back delay of %lldns\\n\"",
            "smp_processor_id()",
            "watchdog->name",
            "wd_seq_delay"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"timekeeping watchdog on CPU%d: %s read-back delay of %lldns, attempt %d, marking unstable\\n\"",
            "smp_processor_id()",
            "watchdog->name",
            "wd_delay",
            "nretries"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_cyc2ns",
          "args": [
            "wd_delta",
            "watchdog->mult",
            "watchdog->shift"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "wd_end2",
            "wd_end",
            "watchdog->mask"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping_internal.h",
          "lines": "30-33",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/spinlock.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"timekeeping watchdog on CPU%d: %s retried %d times before success\\n\"",
            "smp_processor_id()",
            "watchdog->name",
            "nretries"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_cyc2ns",
          "args": [
            "wd_delta",
            "watchdog->mult",
            "watchdog->shift"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchdog->read",
          "args": [
            "watchdog"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchdog->read",
          "args": [
            "watchdog"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cs->read",
          "args": [
            "cs"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchdog->read",
          "args": [
            "watchdog"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\n#define WATCHDOG_MAX_SKEW (100 * NSEC_PER_USEC)\n\nstatic enum wd_read_status cs_watchdog_read(struct clocksource *cs, u64 *csnow, u64 *wdnow)\n{\n\tunsigned int nretries;\n\tu64 wd_end, wd_end2, wd_delta;\n\tint64_t wd_delay, wd_seq_delay;\n\n\tfor (nretries = 0; nretries <= max_cswd_read_retries; nretries++) {\n\t\tlocal_irq_disable();\n\t\t*wdnow = watchdog->read(watchdog);\n\t\t*csnow = cs->read(cs);\n\t\twd_end = watchdog->read(watchdog);\n\t\twd_end2 = watchdog->read(watchdog);\n\t\tlocal_irq_enable();\n\n\t\twd_delta = clocksource_delta(wd_end, *wdnow, watchdog->mask);\n\t\twd_delay = clocksource_cyc2ns(wd_delta, watchdog->mult,\n\t\t\t\t\t      watchdog->shift);\n\t\tif (wd_delay <= WATCHDOG_MAX_SKEW) {\n\t\t\tif (nretries > 1 || nretries >= max_cswd_read_retries) {\n\t\t\t\tpr_warn(\"timekeeping watchdog on CPU%d: %s retried %d times before success\\n\",\n\t\t\t\t\tsmp_processor_id(), watchdog->name, nretries);\n\t\t\t}\n\t\t\treturn WD_READ_SUCCESS;\n\t\t}\n\n\t\t/*\n\t\t * Now compute delay in consecutive watchdog read to see if\n\t\t * there is too much external interferences that cause\n\t\t * significant delay in reading both clocksource and watchdog.\n\t\t *\n\t\t * If consecutive WD read-back delay > WATCHDOG_MAX_SKEW/2,\n\t\t * report system busy, reinit the watchdog and skip the current\n\t\t * watchdog test.\n\t\t */\n\t\twd_delta = clocksource_delta(wd_end2, wd_end, watchdog->mask);\n\t\twd_seq_delay = clocksource_cyc2ns(wd_delta, watchdog->mult, watchdog->shift);\n\t\tif (wd_seq_delay > WATCHDOG_MAX_SKEW/2)\n\t\t\tgoto skip_test;\n\t}\n\n\tpr_warn(\"timekeeping watchdog on CPU%d: %s read-back delay of %lldns, attempt %d, marking unstable\\n\",\n\t\tsmp_processor_id(), watchdog->name, wd_delay, nretries);\n\treturn WD_READ_UNSTABLE;\n\nskip_test:\n\tpr_info(\"timekeeping watchdog on CPU%d: %s wd-wd read-back delay of %lldns\\n\",\n\t\tsmp_processor_id(), watchdog->name, wd_seq_delay);\n\tpr_info(\"wd-%s-wd read-back delay of %lldns, clock-skew test skipped!\\n\",\n\t\tcs->name, wd_delay);\n\treturn WD_READ_SKIP;\n}"
  },
  {
    "function_name": "clocksource_mark_unstable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "189-200",
    "snippet": "void clocksource_mark_unstable(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\tif (!(cs->flags & CLOCK_SOURCE_UNSTABLE)) {\n\t\tif (!list_empty(&cs->list) && list_empty(&cs->wd_list))\n\t\t\tlist_add(&cs->wd_list, &watchdog_list);\n\t\t__clocksource_unstable(cs);\n\t}\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&watchdog_lock",
            "flags"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clocksource_unstable",
          "args": [
            "cs"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_unstable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "160-180",
          "snippet": "static void __clocksource_unstable(struct clocksource *cs)\n{\n\tcs->flags &= ~(CLOCK_SOURCE_VALID_FOR_HRES | CLOCK_SOURCE_WATCHDOG);\n\tcs->flags |= CLOCK_SOURCE_UNSTABLE;\n\n\t/*\n\t * If the clocksource is registered clocksource_watchdog_kthread() will\n\t * re-rate and re-select.\n\t */\n\tif (list_empty(&cs->list)) {\n\t\tcs->rating = 0;\n\t\treturn;\n\t}\n\n\tif (cs->mark_unstable)\n\t\tcs->mark_unstable(cs);\n\n\t/* kick clocksource_watchdog_kthread() */\n\tif (finished_booting)\n\t\tschedule_work(&watchdog_work);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int finished_booting;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic int finished_booting;\n\nstatic void __clocksource_unstable(struct clocksource *cs)\n{\n\tcs->flags &= ~(CLOCK_SOURCE_VALID_FOR_HRES | CLOCK_SOURCE_WATCHDOG);\n\tcs->flags |= CLOCK_SOURCE_UNSTABLE;\n\n\t/*\n\t * If the clocksource is registered clocksource_watchdog_kthread() will\n\t * re-rate and re-select.\n\t */\n\tif (list_empty(&cs->list)) {\n\t\tcs->rating = 0;\n\t\treturn;\n\t}\n\n\tif (cs->mark_unstable)\n\t\tcs->mark_unstable(cs);\n\n\t/* kick clocksource_watchdog_kthread() */\n\tif (finished_booting)\n\t\tschedule_work(&watchdog_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cs->wd_list",
            "&watchdog_list"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cs->wd_list"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&watchdog_lock",
            "flags"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid clocksource_mark_unstable(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\tif (!(cs->flags & CLOCK_SOURCE_UNSTABLE)) {\n\t\tif (!list_empty(&cs->list) && list_empty(&cs->wd_list))\n\t\t\tlist_add(&cs->wd_list, &watchdog_list);\n\t\t__clocksource_unstable(cs);\n\t}\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n}"
  },
  {
    "function_name": "__clocksource_unstable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "160-180",
    "snippet": "static void __clocksource_unstable(struct clocksource *cs)\n{\n\tcs->flags &= ~(CLOCK_SOURCE_VALID_FOR_HRES | CLOCK_SOURCE_WATCHDOG);\n\tcs->flags |= CLOCK_SOURCE_UNSTABLE;\n\n\t/*\n\t * If the clocksource is registered clocksource_watchdog_kthread() will\n\t * re-rate and re-select.\n\t */\n\tif (list_empty(&cs->list)) {\n\t\tcs->rating = 0;\n\t\treturn;\n\t}\n\n\tif (cs->mark_unstable)\n\t\tcs->mark_unstable(cs);\n\n\t/* kick clocksource_watchdog_kthread() */\n\tif (finished_booting)\n\t\tschedule_work(&watchdog_work);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int finished_booting;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&watchdog_work"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cs->mark_unstable",
          "args": [
            "cs"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cs->list"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic int finished_booting;\n\nstatic void __clocksource_unstable(struct clocksource *cs)\n{\n\tcs->flags &= ~(CLOCK_SOURCE_VALID_FOR_HRES | CLOCK_SOURCE_WATCHDOG);\n\tcs->flags |= CLOCK_SOURCE_UNSTABLE;\n\n\t/*\n\t * If the clocksource is registered clocksource_watchdog_kthread() will\n\t * re-rate and re-select.\n\t */\n\tif (list_empty(&cs->list)) {\n\t\tcs->rating = 0;\n\t\treturn;\n\t}\n\n\tif (cs->mark_unstable)\n\t\tcs->mark_unstable(cs);\n\n\t/* kick clocksource_watchdog_kthread() */\n\tif (finished_booting)\n\t\tschedule_work(&watchdog_work);\n}"
  },
  {
    "function_name": "clocksource_watchdog_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "142-158",
    "snippet": "static void clocksource_watchdog_work(struct work_struct *work)\n{\n\t/*\n\t * We cannot directly run clocksource_watchdog_kthread() here, because\n\t * clocksource_select() calls timekeeping_notify() which uses\n\t * stop_machine(). One cannot use stop_machine() from a workqueue() due\n\t * lock inversions wrt CPU hotplug.\n\t *\n\t * Also, we only ever run this work once or twice during the lifetime\n\t * of the kernel, so there is no point in creating a more permanent\n\t * kthread for this.\n\t *\n\t * If kthread_run fails the next watchdog scan over the\n\t * watchdog_list will find the unstable clock again.\n\t */\n\tkthread_run(clocksource_watchdog_kthread, NULL, \"kwatchdog\");\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "clocksource_watchdog_kthread",
            "NULL",
            "\"kwatchdog\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_watchdog_work(struct work_struct *work)\n{\n\t/*\n\t * We cannot directly run clocksource_watchdog_kthread() here, because\n\t * clocksource_select() calls timekeeping_notify() which uses\n\t * stop_machine(). One cannot use stop_machine() from a workqueue() due\n\t * lock inversions wrt CPU hotplug.\n\t *\n\t * Also, we only ever run this work once or twice during the lifetime\n\t * of the kernel, so there is no point in creating a more permanent\n\t * kthread for this.\n\t *\n\t * If kthread_run fails the next watchdog scan over the\n\t * watchdog_list will find the unstable clock again.\n\t */\n\tkthread_run(clocksource_watchdog_kthread, NULL, \"kwatchdog\");\n}"
  },
  {
    "function_name": "clocksource_watchdog_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "129-132",
    "snippet": "static inline void clocksource_watchdog_unlock(unsigned long *flags)\n{\n\tspin_unlock_irqrestore(&watchdog_lock, *flags);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&watchdog_lock",
            "*flags"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_unlock(unsigned long *flags)\n{\n\tspin_unlock_irqrestore(&watchdog_lock, *flags);\n}"
  },
  {
    "function_name": "clocksource_watchdog_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "124-127",
    "snippet": "static inline void clocksource_watchdog_lock(unsigned long *flags)\n{\n\tspin_lock_irqsave(&watchdog_lock, *flags);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&watchdog_lock",
            "*flags"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_lock(unsigned long *flags)\n{\n\tspin_lock_irqsave(&watchdog_lock, *flags);\n}"
  },
  {
    "function_name": "clocks_calc_mult_shift",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
    "lines": "46-75",
    "snippet": "void\nclocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)\n{\n\tu64 tmp;\n\tu32 sft, sftacc= 32;\n\n\t/*\n\t * Calculate the shift factor which is limiting the conversion\n\t * range:\n\t */\n\ttmp = ((u64)maxsec * from) >> 32;\n\twhile (tmp) {\n\t\ttmp >>=1;\n\t\tsftacc--;\n\t}\n\n\t/*\n\t * Find the conversion shift/mult pair which has the best\n\t * accuracy and fits the maxsec conversion range:\n\t */\n\tfor (sft = 32; sft > 0; sft--) {\n\t\ttmp = (u64) to << sft;\n\t\ttmp += from / 2;\n\t\tdo_div(tmp, from);\n\t\tif ((tmp >> sftacc) == 0)\n\t\t\tbreak;\n\t}\n\t*mult = tmp;\n\t*shift = sft;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/cpu.h>",
      "#include <linux/prandom.h>",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "from"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid\nclocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)\n{\n\tu64 tmp;\n\tu32 sft, sftacc= 32;\n\n\t/*\n\t * Calculate the shift factor which is limiting the conversion\n\t * range:\n\t */\n\ttmp = ((u64)maxsec * from) >> 32;\n\twhile (tmp) {\n\t\ttmp >>=1;\n\t\tsftacc--;\n\t}\n\n\t/*\n\t * Find the conversion shift/mult pair which has the best\n\t * accuracy and fits the maxsec conversion range:\n\t */\n\tfor (sft = 32; sft > 0; sft--) {\n\t\ttmp = (u64) to << sft;\n\t\ttmp += from / 2;\n\t\tdo_div(tmp, from);\n\t\tif ((tmp >> sftacc) == 0)\n\t\t\tbreak;\n\t}\n\t*mult = tmp;\n\t*shift = sft;\n}"
  }
]