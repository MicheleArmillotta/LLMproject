[
  {
    "function_name": "nsproxy_cache_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
    "lines": "569-573",
    "snippet": "int __init nsproxy_cache_init(void)\n{\n\tnsproxy_cachep = KMEM_CACHE(nsproxy, SLAB_PANIC|SLAB_ACCOUNT);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/time_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nsproxy_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "nsproxy",
            "SLAB_PANIC|SLAB_ACCOUNT"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nint __init nsproxy_cache_init(void)\n{\n\tnsproxy_cachep = KMEM_CACHE(nsproxy, SLAB_PANIC|SLAB_ACCOUNT);\n\treturn 0;\n}"
  },
  {
    "function_name": "commit_nsset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
    "lines": "493-525",
    "snippet": "static void commit_nsset(struct nsset *nsset)\n{\n\tunsigned flags = nsset->flags;\n\tstruct task_struct *me = current;\n\n#ifdef CONFIG_USER_NS\n\tif (flags & CLONE_NEWUSER) {\n\t\t/* transfer ownership */\n\t\tcommit_creds(nsset_cred(nsset));\n\t\tnsset->cred = NULL;\n\t}\n#endif\n\n\t/* We only need to commit if we have used a temporary fs_struct. */\n\tif ((flags & CLONE_NEWNS) && (flags & ~CLONE_NEWNS)) {\n\t\tset_fs_root(me->fs, &nsset->fs->root);\n\t\tset_fs_pwd(me->fs, &nsset->fs->pwd);\n\t}\n\n#ifdef CONFIG_IPC_NS\n\tif (flags & CLONE_NEWIPC)\n\t\texit_sem(me);\n#endif\n\n#ifdef CONFIG_TIME_NS\n\tif (flags & CLONE_NEWTIME)\n\t\ttimens_commit(me, nsset->nsproxy->time_ns);\n#endif\n\n\t/* transfer ownership */\n\tswitch_task_namespaces(me, nsset->nsproxy);\n\tnsset->nsproxy = NULL;\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/time_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "switch_task_namespaces",
          "args": [
            "me",
            "nsset->nsproxy"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "switch_task_namespaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
          "lines": "237-250",
          "snippet": "void switch_task_namespaces(struct task_struct *p, struct nsproxy *new)\n{\n\tstruct nsproxy *ns;\n\n\tmight_sleep();\n\n\ttask_lock(p);\n\tns = p->nsproxy;\n\tp->nsproxy = new;\n\ttask_unlock(p);\n\n\tif (ns)\n\t\tput_nsproxy(ns);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/time_namespace.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid switch_task_namespaces(struct task_struct *p, struct nsproxy *new)\n{\n\tstruct nsproxy *ns;\n\n\tmight_sleep();\n\n\ttask_lock(p);\n\tns = p->nsproxy;\n\tp->nsproxy = new;\n\ttask_unlock(p);\n\n\tif (ns)\n\t\tput_nsproxy(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timens_commit",
          "args": [
            "me",
            "nsset->nsproxy->time_ns"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "timens_commit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/namespace.c",
          "lines": "280-284",
          "snippet": "void timens_commit(struct task_struct *tsk, struct time_namespace *ns)\n{\n\ttimens_set_vvar_page(tsk, ns);\n\tvdso_join_timens(tsk, ns);\n}",
          "includes": [
            "#include <vdso/datapage.h>",
            "#include <linux/mm.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/time_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vdso/datapage.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/proc_ns.h>\n#include <linux/seq_file.h>\n#include <linux/clocksource.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/user_namespace.h>\n#include <linux/time_namespace.h>\n\nvoid timens_commit(struct task_struct *tsk, struct time_namespace *ns)\n{\n\ttimens_set_vvar_page(tsk, ns);\n\tvdso_join_timens(tsk, ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit_sem",
          "args": [
            "me"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs_pwd",
          "args": [
            "me->fs",
            "&nsset->fs->pwd"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs_root",
          "args": [
            "me->fs",
            "&nsset->fs->root"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "nsset_cred(nsset)"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "commit_creds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "447-523",
          "snippet": "int commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tBUG_ON(task->cred != old);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(old) < 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\n\tget_cred(new); /* we will require a ref for the subj creds too */\n\n\t/* dumpability changes */\n\tif (!uid_eq(old->euid, new->euid) ||\n\t    !gid_eq(old->egid, new->egid) ||\n\t    !uid_eq(old->fsuid, new->fsuid) ||\n\t    !gid_eq(old->fsgid, new->fsgid) ||\n\t    !cred_cap_issubset(old, new)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\t/*\n\t\t * If a task drops privileges and becomes nondumpable,\n\t\t * the dumpability change must become visible before\n\t\t * the credential change; otherwise, a __ptrace_may_access()\n\t\t * racing with this change may be able to attach to a task it\n\t\t * shouldn't be able to attach to (as if the task had dropped\n\t\t * privileges without becoming nondumpable).\n\t\t * Pairs with a read barrier in __ptrace_may_access().\n\t\t */\n\t\tsmp_wmb();\n\t}\n\n\t/* alter the thread keyring */\n\tif (!uid_eq(new->fsuid, old->fsuid))\n\t\tkey_fsuid_changed(new);\n\tif (!gid_eq(new->fsgid, old->fsgid))\n\t\tkey_fsgid_changed(new);\n\n\t/* do it\n\t * RLIMIT_NPROC limits on user->processes have already been checked\n\t * in set_user().\n\t */\n\talter_cred_subscribers(new, 2);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tinc_rlimit_ucounts(new->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tdec_rlimit_ucounts(old->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\talter_cred_subscribers(old, -2);\n\n\t/* send notifications */\n\tif (!uid_eq(new->uid,   old->uid)  ||\n\t    !uid_eq(new->euid,  old->euid) ||\n\t    !uid_eq(new->suid,  old->suid) ||\n\t    !uid_eq(new->fsuid, old->fsuid))\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (!gid_eq(new->gid,   old->gid)  ||\n\t    !gid_eq(new->egid,  old->egid) ||\n\t    !gid_eq(new->sgid,  old->sgid) ||\n\t    !gid_eq(new->fsgid, old->fsgid))\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t/* release the old obj and subj refs both */\n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nint commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tBUG_ON(task->cred != old);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(old) < 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\n\tget_cred(new); /* we will require a ref for the subj creds too */\n\n\t/* dumpability changes */\n\tif (!uid_eq(old->euid, new->euid) ||\n\t    !gid_eq(old->egid, new->egid) ||\n\t    !uid_eq(old->fsuid, new->fsuid) ||\n\t    !gid_eq(old->fsgid, new->fsgid) ||\n\t    !cred_cap_issubset(old, new)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\t/*\n\t\t * If a task drops privileges and becomes nondumpable,\n\t\t * the dumpability change must become visible before\n\t\t * the credential change; otherwise, a __ptrace_may_access()\n\t\t * racing with this change may be able to attach to a task it\n\t\t * shouldn't be able to attach to (as if the task had dropped\n\t\t * privileges without becoming nondumpable).\n\t\t * Pairs with a read barrier in __ptrace_may_access().\n\t\t */\n\t\tsmp_wmb();\n\t}\n\n\t/* alter the thread keyring */\n\tif (!uid_eq(new->fsuid, old->fsuid))\n\t\tkey_fsuid_changed(new);\n\tif (!gid_eq(new->fsgid, old->fsgid))\n\t\tkey_fsgid_changed(new);\n\n\t/* do it\n\t * RLIMIT_NPROC limits on user->processes have already been checked\n\t * in set_user().\n\t */\n\talter_cred_subscribers(new, 2);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tinc_rlimit_ucounts(new->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user || new->user_ns != old->user_ns)\n\t\tdec_rlimit_ucounts(old->ucounts, UCOUNT_RLIMIT_NPROC, 1);\n\talter_cred_subscribers(old, -2);\n\n\t/* send notifications */\n\tif (!uid_eq(new->uid,   old->uid)  ||\n\t    !uid_eq(new->euid,  old->euid) ||\n\t    !uid_eq(new->suid,  old->suid) ||\n\t    !uid_eq(new->fsuid, old->fsuid))\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (!gid_eq(new->gid,   old->gid)  ||\n\t    !gid_eq(new->egid,  old->egid) ||\n\t    !gid_eq(new->sgid,  old->sgid) ||\n\t    !gid_eq(new->fsgid, old->fsgid))\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t/* release the old obj and subj refs both */\n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsset_cred",
          "args": [
            "nsset"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void commit_nsset(struct nsset *nsset)\n{\n\tunsigned flags = nsset->flags;\n\tstruct task_struct *me = current;\n\n#ifdef CONFIG_USER_NS\n\tif (flags & CLONE_NEWUSER) {\n\t\t/* transfer ownership */\n\t\tcommit_creds(nsset_cred(nsset));\n\t\tnsset->cred = NULL;\n\t}\n#endif\n\n\t/* We only need to commit if we have used a temporary fs_struct. */\n\tif ((flags & CLONE_NEWNS) && (flags & ~CLONE_NEWNS)) {\n\t\tset_fs_root(me->fs, &nsset->fs->root);\n\t\tset_fs_pwd(me->fs, &nsset->fs->pwd);\n\t}\n\n#ifdef CONFIG_IPC_NS\n\tif (flags & CLONE_NEWIPC)\n\t\texit_sem(me);\n#endif\n\n#ifdef CONFIG_TIME_NS\n\tif (flags & CLONE_NEWTIME)\n\t\ttimens_commit(me, nsset->nsproxy->time_ns);\n#endif\n\n\t/* transfer ownership */\n\tswitch_task_namespaces(me, nsset->nsproxy);\n\tnsset->nsproxy = NULL;\n}"
  },
  {
    "function_name": "validate_nsset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
    "lines": "356-482",
    "snippet": "static int validate_nsset(struct nsset *nsset, struct pid *pid)\n{\n\tint ret = 0;\n\tunsigned flags = nsset->flags;\n\tstruct user_namespace *user_ns = NULL;\n\tstruct pid_namespace *pid_ns = NULL;\n\tstruct nsproxy *nsp;\n\tstruct task_struct *tsk;\n\n\t/* Take a \"snapshot\" of the target task's namespaces. */\n\trcu_read_lock();\n\ttsk = pid_task(pid, PIDTYPE_PID);\n\tif (!tsk) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\tif (!ptrace_may_access(tsk, PTRACE_MODE_READ_REALCREDS)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\n\ttask_lock(tsk);\n\tnsp = tsk->nsproxy;\n\tif (nsp)\n\t\tget_nsproxy(nsp);\n\ttask_unlock(tsk);\n\tif (!nsp) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n#ifdef CONFIG_PID_NS\n\tif (flags & CLONE_NEWPID) {\n\t\tpid_ns = task_active_pid_ns(tsk);\n\t\tif (unlikely(!pid_ns)) {\n\t\t\trcu_read_unlock();\n\t\t\tret = -ESRCH;\n\t\t\tgoto out;\n\t\t}\n\t\tget_pid_ns(pid_ns);\n\t}\n#endif\n\n#ifdef CONFIG_USER_NS\n\tif (flags & CLONE_NEWUSER)\n\t\tuser_ns = get_user_ns(__task_cred(tsk)->user_ns);\n#endif\n\trcu_read_unlock();\n\n\t/*\n\t * Install requested namespaces. The caller will have\n\t * verified earlier that the requested namespaces are\n\t * supported on this kernel. We don't report errors here\n\t * if a namespace is requested that isn't supported.\n\t */\n#ifdef CONFIG_USER_NS\n\tif (flags & CLONE_NEWUSER) {\n\t\tret = validate_ns(nsset, &user_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n\tif (flags & CLONE_NEWNS) {\n\t\tret = validate_ns(nsset, from_mnt_ns(nsp->mnt_ns));\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n#ifdef CONFIG_UTS_NS\n\tif (flags & CLONE_NEWUTS) {\n\t\tret = validate_ns(nsset, &nsp->uts_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_IPC_NS\n\tif (flags & CLONE_NEWIPC) {\n\t\tret = validate_ns(nsset, &nsp->ipc_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_PID_NS\n\tif (flags & CLONE_NEWPID) {\n\t\tret = validate_ns(nsset, &pid_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_CGROUPS\n\tif (flags & CLONE_NEWCGROUP) {\n\t\tret = validate_ns(nsset, &nsp->cgroup_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_NET_NS\n\tif (flags & CLONE_NEWNET) {\n\t\tret = validate_ns(nsset, &nsp->net_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_TIME_NS\n\tif (flags & CLONE_NEWTIME) {\n\t\tret = validate_ns(nsset, &nsp->time_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\nout:\n\tif (pid_ns)\n\t\tput_pid_ns(pid_ns);\n\tif (nsp)\n\t\tput_nsproxy(nsp);\n\tput_user_ns(user_ns);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/time_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "user_ns"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "__put_user_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "208-211",
          "snippet": "void __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_user_ns(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void free_user_ns(struct work_struct *work);\n\nvoid __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_nsproxy",
          "args": [
            "nsp"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid_ns",
          "args": [
            "pid_ns"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "put_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid_namespace.c",
          "lines": "152-163",
          "snippet": "void put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!refcount_dec_and_test(&ns->ns.count))\n\t\t\tbreak;\n\t\tdestroy_pid_namespace(ns);\n\t\tns = parent;\n\t}\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nvoid put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!refcount_dec_and_test(&ns->ns.count))\n\t\t\tbreak;\n\t\tdestroy_pid_namespace(ns);\n\t\tns = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_ns",
          "args": [
            "nsset",
            "&nsp->time_ns->ns"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "validate_nsset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
          "lines": "356-482",
          "snippet": "static int validate_nsset(struct nsset *nsset, struct pid *pid)\n{\n\tint ret = 0;\n\tunsigned flags = nsset->flags;\n\tstruct user_namespace *user_ns = NULL;\n\tstruct pid_namespace *pid_ns = NULL;\n\tstruct nsproxy *nsp;\n\tstruct task_struct *tsk;\n\n\t/* Take a \"snapshot\" of the target task's namespaces. */\n\trcu_read_lock();\n\ttsk = pid_task(pid, PIDTYPE_PID);\n\tif (!tsk) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\tif (!ptrace_may_access(tsk, PTRACE_MODE_READ_REALCREDS)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\n\ttask_lock(tsk);\n\tnsp = tsk->nsproxy;\n\tif (nsp)\n\t\tget_nsproxy(nsp);\n\ttask_unlock(tsk);\n\tif (!nsp) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n#ifdef CONFIG_PID_NS\n\tif (flags & CLONE_NEWPID) {\n\t\tpid_ns = task_active_pid_ns(tsk);\n\t\tif (unlikely(!pid_ns)) {\n\t\t\trcu_read_unlock();\n\t\t\tret = -ESRCH;\n\t\t\tgoto out;\n\t\t}\n\t\tget_pid_ns(pid_ns);\n\t}\n#endif\n\n#ifdef CONFIG_USER_NS\n\tif (flags & CLONE_NEWUSER)\n\t\tuser_ns = get_user_ns(__task_cred(tsk)->user_ns);\n#endif\n\trcu_read_unlock();\n\n\t/*\n\t * Install requested namespaces. The caller will have\n\t * verified earlier that the requested namespaces are\n\t * supported on this kernel. We don't report errors here\n\t * if a namespace is requested that isn't supported.\n\t */\n#ifdef CONFIG_USER_NS\n\tif (flags & CLONE_NEWUSER) {\n\t\tret = validate_ns(nsset, &user_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n\tif (flags & CLONE_NEWNS) {\n\t\tret = validate_ns(nsset, from_mnt_ns(nsp->mnt_ns));\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n#ifdef CONFIG_UTS_NS\n\tif (flags & CLONE_NEWUTS) {\n\t\tret = validate_ns(nsset, &nsp->uts_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_IPC_NS\n\tif (flags & CLONE_NEWIPC) {\n\t\tret = validate_ns(nsset, &nsp->ipc_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_PID_NS\n\tif (flags & CLONE_NEWPID) {\n\t\tret = validate_ns(nsset, &pid_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_CGROUPS\n\tif (flags & CLONE_NEWCGROUP) {\n\t\tret = validate_ns(nsset, &nsp->cgroup_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_NET_NS\n\tif (flags & CLONE_NEWNET) {\n\t\tret = validate_ns(nsset, &nsp->net_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_TIME_NS\n\tif (flags & CLONE_NEWTIME) {\n\t\tret = validate_ns(nsset, &nsp->time_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\nout:\n\tif (pid_ns)\n\t\tput_pid_ns(pid_ns);\n\tif (nsp)\n\t\tput_nsproxy(nsp);\n\tput_user_ns(user_ns);\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "from_mnt_ns",
          "args": [
            "nsp->mnt_ns"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "__task_cred(tsk)->user_ns"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "tsk"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pid_ns",
          "args": [
            "pid_ns"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pid_ns"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "tsk"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "507-510",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "tsk"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nsproxy",
          "args": [
            "nsp"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "tsk"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_may_access",
          "args": [
            "tsk",
            "PTRACE_MODE_READ_REALCREDS"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_may_access",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ptrace.c",
          "lines": "365-372",
          "snippet": "bool ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tint err;\n\ttask_lock(task);\n\terr = __ptrace_may_access(task, mode);\n\ttask_unlock(task);\n\treturn !err;\n}",
          "includes": [
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <linux/minmax.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <linux/minmax.h>\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nbool ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tint err;\n\ttask_lock(task);\n\terr = __ptrace_may_access(task, mode);\n\ttask_unlock(task);\n\treturn !err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid",
            "PIDTYPE_PID"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "448-457",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int validate_nsset(struct nsset *nsset, struct pid *pid)\n{\n\tint ret = 0;\n\tunsigned flags = nsset->flags;\n\tstruct user_namespace *user_ns = NULL;\n\tstruct pid_namespace *pid_ns = NULL;\n\tstruct nsproxy *nsp;\n\tstruct task_struct *tsk;\n\n\t/* Take a \"snapshot\" of the target task's namespaces. */\n\trcu_read_lock();\n\ttsk = pid_task(pid, PIDTYPE_PID);\n\tif (!tsk) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\tif (!ptrace_may_access(tsk, PTRACE_MODE_READ_REALCREDS)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\n\ttask_lock(tsk);\n\tnsp = tsk->nsproxy;\n\tif (nsp)\n\t\tget_nsproxy(nsp);\n\ttask_unlock(tsk);\n\tif (!nsp) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n#ifdef CONFIG_PID_NS\n\tif (flags & CLONE_NEWPID) {\n\t\tpid_ns = task_active_pid_ns(tsk);\n\t\tif (unlikely(!pid_ns)) {\n\t\t\trcu_read_unlock();\n\t\t\tret = -ESRCH;\n\t\t\tgoto out;\n\t\t}\n\t\tget_pid_ns(pid_ns);\n\t}\n#endif\n\n#ifdef CONFIG_USER_NS\n\tif (flags & CLONE_NEWUSER)\n\t\tuser_ns = get_user_ns(__task_cred(tsk)->user_ns);\n#endif\n\trcu_read_unlock();\n\n\t/*\n\t * Install requested namespaces. The caller will have\n\t * verified earlier that the requested namespaces are\n\t * supported on this kernel. We don't report errors here\n\t * if a namespace is requested that isn't supported.\n\t */\n#ifdef CONFIG_USER_NS\n\tif (flags & CLONE_NEWUSER) {\n\t\tret = validate_ns(nsset, &user_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n\tif (flags & CLONE_NEWNS) {\n\t\tret = validate_ns(nsset, from_mnt_ns(nsp->mnt_ns));\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n#ifdef CONFIG_UTS_NS\n\tif (flags & CLONE_NEWUTS) {\n\t\tret = validate_ns(nsset, &nsp->uts_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_IPC_NS\n\tif (flags & CLONE_NEWIPC) {\n\t\tret = validate_ns(nsset, &nsp->ipc_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_PID_NS\n\tif (flags & CLONE_NEWPID) {\n\t\tret = validate_ns(nsset, &pid_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_CGROUPS\n\tif (flags & CLONE_NEWCGROUP) {\n\t\tret = validate_ns(nsset, &nsp->cgroup_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_NET_NS\n\tif (flags & CLONE_NEWNET) {\n\t\tret = validate_ns(nsset, &nsp->net_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\n#ifdef CONFIG_TIME_NS\n\tif (flags & CLONE_NEWTIME) {\n\t\tret = validate_ns(nsset, &nsp->time_ns->ns);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\nout:\n\tif (pid_ns)\n\t\tput_pid_ns(pid_ns);\n\tif (nsp)\n\t\tput_nsproxy(nsp);\n\tput_user_ns(user_ns);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "validate_ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
    "lines": "344-347",
    "snippet": "static inline int validate_ns(struct nsset *nsset, struct ns_common *ns)\n{\n\treturn ns->ops->install(nsset, ns);\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/time_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns->ops->install",
          "args": [
            "nsset",
            "ns"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline int validate_ns(struct nsset *nsset, struct ns_common *ns)\n{\n\treturn ns->ops->install(nsset, ns);\n}"
  },
  {
    "function_name": "prepare_nsset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
    "lines": "312-342",
    "snippet": "static int prepare_nsset(unsigned flags, struct nsset *nsset)\n{\n\tstruct task_struct *me = current;\n\n\tnsset->nsproxy = create_new_namespaces(0, me, current_user_ns(), me->fs);\n\tif (IS_ERR(nsset->nsproxy))\n\t\treturn PTR_ERR(nsset->nsproxy);\n\n\tif (flags & CLONE_NEWUSER)\n\t\tnsset->cred = prepare_creds();\n\telse\n\t\tnsset->cred = current_cred();\n\tif (!nsset->cred)\n\t\tgoto out;\n\n\t/* Only create a temporary copy of fs_struct if we really need to. */\n\tif (flags == CLONE_NEWNS) {\n\t\tnsset->fs = me->fs;\n\t} else if (flags & CLONE_NEWNS) {\n\t\tnsset->fs = copy_fs_struct(me->fs);\n\t\tif (!nsset->fs)\n\t\t\tgoto out;\n\t}\n\n\tnsset->flags = flags;\n\treturn 0;\n\nout:\n\tput_nsset(nsset);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/time_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_nsset",
          "args": [
            "nsset"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "put_nsset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
          "lines": "296-310",
          "snippet": "static void put_nsset(struct nsset *nsset)\n{\n\tunsigned flags = nsset->flags;\n\n\tif (flags & CLONE_NEWUSER)\n\t\tput_cred(nsset_cred(nsset));\n\t/*\n\t * We only created a temporary copy if we attached to more than just\n\t * the mount namespace.\n\t */\n\tif (nsset->fs && (flags & CLONE_NEWNS) && (flags & ~CLONE_NEWNS))\n\t\tfree_fs_struct(nsset->fs);\n\tif (nsset->nsproxy)\n\t\tfree_nsproxy(nsset->nsproxy);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/time_namespace.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void put_nsset(struct nsset *nsset)\n{\n\tunsigned flags = nsset->flags;\n\n\tif (flags & CLONE_NEWUSER)\n\t\tput_cred(nsset_cred(nsset));\n\t/*\n\t * We only created a temporary copy if we attached to more than just\n\t * the mount namespace.\n\t */\n\tif (nsset->fs && (flags & CLONE_NEWNS) && (flags & ~CLONE_NEWNS))\n\t\tfree_fs_struct(nsset->fs);\n\tif (nsset->nsproxy)\n\t\tfree_nsproxy(nsset->nsproxy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_fs_struct",
          "args": [
            "me->fs"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_creds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "252-300",
          "snippet": "struct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tnew->non_rcu = 0;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tnew->ucounts = get_ucounts(new->ucounts);\n\tif (!new->ucounts)\n\t\tgoto error;\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *cred_jar;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\n\nstruct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tnew->non_rcu = 0;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tnew->ucounts = get_ucounts(new->ucounts);\n\tif (!new->ucounts)\n\t\tgoto error;\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL_ACCOUNT) < 0)\n\t\tgoto error;\n\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "nsset->nsproxy"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nsset->nsproxy"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_new_namespaces",
          "args": [
            "0",
            "me",
            "current_user_ns()",
            "me->fs"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "create_new_namespaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
          "lines": "67-145",
          "snippet": "static struct nsproxy *create_new_namespaces(unsigned long flags,\n\tstruct task_struct *tsk, struct user_namespace *user_ns,\n\tstruct fs_struct *new_fs)\n{\n\tstruct nsproxy *new_nsp;\n\tint err;\n\n\tnew_nsp = create_nsproxy();\n\tif (!new_nsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);\n\tif (IS_ERR(new_nsp->mnt_ns)) {\n\t\terr = PTR_ERR(new_nsp->mnt_ns);\n\t\tgoto out_ns;\n\t}\n\n\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);\n\tif (IS_ERR(new_nsp->uts_ns)) {\n\t\terr = PTR_ERR(new_nsp->uts_ns);\n\t\tgoto out_uts;\n\t}\n\n\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);\n\tif (IS_ERR(new_nsp->ipc_ns)) {\n\t\terr = PTR_ERR(new_nsp->ipc_ns);\n\t\tgoto out_ipc;\n\t}\n\n\tnew_nsp->pid_ns_for_children =\n\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);\n\tif (IS_ERR(new_nsp->pid_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);\n\t\tgoto out_pid;\n\t}\n\n\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,\n\t\t\t\t\t    tsk->nsproxy->cgroup_ns);\n\tif (IS_ERR(new_nsp->cgroup_ns)) {\n\t\terr = PTR_ERR(new_nsp->cgroup_ns);\n\t\tgoto out_cgroup;\n\t}\n\n\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);\n\tif (IS_ERR(new_nsp->net_ns)) {\n\t\terr = PTR_ERR(new_nsp->net_ns);\n\t\tgoto out_net;\n\t}\n\n\tnew_nsp->time_ns_for_children = copy_time_ns(flags, user_ns,\n\t\t\t\t\ttsk->nsproxy->time_ns_for_children);\n\tif (IS_ERR(new_nsp->time_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->time_ns_for_children);\n\t\tgoto out_time;\n\t}\n\tnew_nsp->time_ns = get_time_ns(tsk->nsproxy->time_ns);\n\n\treturn new_nsp;\n\nout_time:\n\tput_net(new_nsp->net_ns);\nout_net:\n\tput_cgroup_ns(new_nsp->cgroup_ns);\nout_cgroup:\n\tif (new_nsp->pid_ns_for_children)\n\t\tput_pid_ns(new_nsp->pid_ns_for_children);\nout_pid:\n\tif (new_nsp->ipc_ns)\n\t\tput_ipc_ns(new_nsp->ipc_ns);\nout_ipc:\n\tif (new_nsp->uts_ns)\n\t\tput_uts_ns(new_nsp->uts_ns);\nout_uts:\n\tif (new_nsp->mnt_ns)\n\t\tput_mnt_ns(new_nsp->mnt_ns);\nout_ns:\n\tkmem_cache_free(nsproxy_cachep, new_nsp);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/time_namespace.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nsproxy_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nstatic struct nsproxy *create_new_namespaces(unsigned long flags,\n\tstruct task_struct *tsk, struct user_namespace *user_ns,\n\tstruct fs_struct *new_fs)\n{\n\tstruct nsproxy *new_nsp;\n\tint err;\n\n\tnew_nsp = create_nsproxy();\n\tif (!new_nsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);\n\tif (IS_ERR(new_nsp->mnt_ns)) {\n\t\terr = PTR_ERR(new_nsp->mnt_ns);\n\t\tgoto out_ns;\n\t}\n\n\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);\n\tif (IS_ERR(new_nsp->uts_ns)) {\n\t\terr = PTR_ERR(new_nsp->uts_ns);\n\t\tgoto out_uts;\n\t}\n\n\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);\n\tif (IS_ERR(new_nsp->ipc_ns)) {\n\t\terr = PTR_ERR(new_nsp->ipc_ns);\n\t\tgoto out_ipc;\n\t}\n\n\tnew_nsp->pid_ns_for_children =\n\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);\n\tif (IS_ERR(new_nsp->pid_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);\n\t\tgoto out_pid;\n\t}\n\n\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,\n\t\t\t\t\t    tsk->nsproxy->cgroup_ns);\n\tif (IS_ERR(new_nsp->cgroup_ns)) {\n\t\terr = PTR_ERR(new_nsp->cgroup_ns);\n\t\tgoto out_cgroup;\n\t}\n\n\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);\n\tif (IS_ERR(new_nsp->net_ns)) {\n\t\terr = PTR_ERR(new_nsp->net_ns);\n\t\tgoto out_net;\n\t}\n\n\tnew_nsp->time_ns_for_children = copy_time_ns(flags, user_ns,\n\t\t\t\t\ttsk->nsproxy->time_ns_for_children);\n\tif (IS_ERR(new_nsp->time_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->time_ns_for_children);\n\t\tgoto out_time;\n\t}\n\tnew_nsp->time_ns = get_time_ns(tsk->nsproxy->time_ns);\n\n\treturn new_nsp;\n\nout_time:\n\tput_net(new_nsp->net_ns);\nout_net:\n\tput_cgroup_ns(new_nsp->cgroup_ns);\nout_cgroup:\n\tif (new_nsp->pid_ns_for_children)\n\t\tput_pid_ns(new_nsp->pid_ns_for_children);\nout_pid:\n\tif (new_nsp->ipc_ns)\n\t\tput_ipc_ns(new_nsp->ipc_ns);\nout_ipc:\n\tif (new_nsp->uts_ns)\n\t\tput_uts_ns(new_nsp->uts_ns);\nout_uts:\n\tif (new_nsp->mnt_ns)\n\t\tput_mnt_ns(new_nsp->mnt_ns);\nout_ns:\n\tkmem_cache_free(nsproxy_cachep, new_nsp);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int prepare_nsset(unsigned flags, struct nsset *nsset)\n{\n\tstruct task_struct *me = current;\n\n\tnsset->nsproxy = create_new_namespaces(0, me, current_user_ns(), me->fs);\n\tif (IS_ERR(nsset->nsproxy))\n\t\treturn PTR_ERR(nsset->nsproxy);\n\n\tif (flags & CLONE_NEWUSER)\n\t\tnsset->cred = prepare_creds();\n\telse\n\t\tnsset->cred = current_cred();\n\tif (!nsset->cred)\n\t\tgoto out;\n\n\t/* Only create a temporary copy of fs_struct if we really need to. */\n\tif (flags == CLONE_NEWNS) {\n\t\tnsset->fs = me->fs;\n\t} else if (flags & CLONE_NEWNS) {\n\t\tnsset->fs = copy_fs_struct(me->fs);\n\t\tif (!nsset->fs)\n\t\t\tgoto out;\n\t}\n\n\tnsset->flags = flags;\n\treturn 0;\n\nout:\n\tput_nsset(nsset);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "put_nsset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
    "lines": "296-310",
    "snippet": "static void put_nsset(struct nsset *nsset)\n{\n\tunsigned flags = nsset->flags;\n\n\tif (flags & CLONE_NEWUSER)\n\t\tput_cred(nsset_cred(nsset));\n\t/*\n\t * We only created a temporary copy if we attached to more than just\n\t * the mount namespace.\n\t */\n\tif (nsset->fs && (flags & CLONE_NEWNS) && (flags & ~CLONE_NEWNS))\n\t\tfree_fs_struct(nsset->fs);\n\tif (nsset->nsproxy)\n\t\tfree_nsproxy(nsset->nsproxy);\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/time_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_nsproxy",
          "args": [
            "nsset->nsproxy"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "free_nsproxy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
          "lines": "188-205",
          "snippet": "void free_nsproxy(struct nsproxy *ns)\n{\n\tif (ns->mnt_ns)\n\t\tput_mnt_ns(ns->mnt_ns);\n\tif (ns->uts_ns)\n\t\tput_uts_ns(ns->uts_ns);\n\tif (ns->ipc_ns)\n\t\tput_ipc_ns(ns->ipc_ns);\n\tif (ns->pid_ns_for_children)\n\t\tput_pid_ns(ns->pid_ns_for_children);\n\tif (ns->time_ns)\n\t\tput_time_ns(ns->time_ns);\n\tif (ns->time_ns_for_children)\n\t\tput_time_ns(ns->time_ns_for_children);\n\tput_cgroup_ns(ns->cgroup_ns);\n\tput_net(ns->net_ns);\n\tkmem_cache_free(nsproxy_cachep, ns);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/time_namespace.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nsproxy_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nvoid free_nsproxy(struct nsproxy *ns)\n{\n\tif (ns->mnt_ns)\n\t\tput_mnt_ns(ns->mnt_ns);\n\tif (ns->uts_ns)\n\t\tput_uts_ns(ns->uts_ns);\n\tif (ns->ipc_ns)\n\t\tput_ipc_ns(ns->ipc_ns);\n\tif (ns->pid_ns_for_children)\n\t\tput_pid_ns(ns->pid_ns_for_children);\n\tif (ns->time_ns)\n\t\tput_time_ns(ns->time_ns);\n\tif (ns->time_ns_for_children)\n\t\tput_time_ns(ns->time_ns_for_children);\n\tput_cgroup_ns(ns->cgroup_ns);\n\tput_net(ns->net_ns);\n\tkmem_cache_free(nsproxy_cachep, ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_fs_struct",
          "args": [
            "nsset->fs"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "nsset_cred(nsset)"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "__put_cred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "135-154",
          "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tif (cred->non_rcu)\n\t\tput_cred_rcu(&cred->rcu);\n\telse\n\t\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsset_cred",
          "args": [
            "nsset"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void put_nsset(struct nsset *nsset)\n{\n\tunsigned flags = nsset->flags;\n\n\tif (flags & CLONE_NEWUSER)\n\t\tput_cred(nsset_cred(nsset));\n\t/*\n\t * We only created a temporary copy if we attached to more than just\n\t * the mount namespace.\n\t */\n\tif (nsset->fs && (flags & CLONE_NEWNS) && (flags & ~CLONE_NEWNS))\n\t\tfree_fs_struct(nsset->fs);\n\tif (nsset->nsproxy)\n\t\tfree_nsproxy(nsset->nsproxy);\n}"
  },
  {
    "function_name": "check_setns_flags",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
    "lines": "257-294",
    "snippet": "static int check_setns_flags(unsigned long flags)\n{\n\tif (!flags || (flags & ~(CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\n\t\t\t\t CLONE_NEWNET | CLONE_NEWTIME | CLONE_NEWUSER |\n\t\t\t\t CLONE_NEWPID | CLONE_NEWCGROUP)))\n\t\treturn -EINVAL;\n\n#ifndef CONFIG_USER_NS\n\tif (flags & CLONE_NEWUSER)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_PID_NS\n\tif (flags & CLONE_NEWPID)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_UTS_NS\n\tif (flags & CLONE_NEWUTS)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_IPC_NS\n\tif (flags & CLONE_NEWIPC)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_CGROUPS\n\tif (flags & CLONE_NEWCGROUP)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_NET_NS\n\tif (flags & CLONE_NEWNET)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_TIME_NS\n\tif (flags & CLONE_NEWTIME)\n\t\treturn -EINVAL;\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/time_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int check_setns_flags(unsigned long flags)\n{\n\tif (!flags || (flags & ~(CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\n\t\t\t\t CLONE_NEWNET | CLONE_NEWTIME | CLONE_NEWUSER |\n\t\t\t\t CLONE_NEWPID | CLONE_NEWCGROUP)))\n\t\treturn -EINVAL;\n\n#ifndef CONFIG_USER_NS\n\tif (flags & CLONE_NEWUSER)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_PID_NS\n\tif (flags & CLONE_NEWPID)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_UTS_NS\n\tif (flags & CLONE_NEWUTS)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_IPC_NS\n\tif (flags & CLONE_NEWIPC)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_CGROUPS\n\tif (flags & CLONE_NEWCGROUP)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_NET_NS\n\tif (flags & CLONE_NEWNET)\n\t\treturn -EINVAL;\n#endif\n#ifndef CONFIG_TIME_NS\n\tif (flags & CLONE_NEWTIME)\n\t\treturn -EINVAL;\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "exit_task_namespaces",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
    "lines": "252-255",
    "snippet": "void exit_task_namespaces(struct task_struct *p)\n{\n\tswitch_task_namespaces(p, NULL);\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/time_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "switch_task_namespaces",
          "args": [
            "p",
            "NULL"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "switch_task_namespaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
          "lines": "237-250",
          "snippet": "void switch_task_namespaces(struct task_struct *p, struct nsproxy *new)\n{\n\tstruct nsproxy *ns;\n\n\tmight_sleep();\n\n\ttask_lock(p);\n\tns = p->nsproxy;\n\tp->nsproxy = new;\n\ttask_unlock(p);\n\n\tif (ns)\n\t\tput_nsproxy(ns);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/time_namespace.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid switch_task_namespaces(struct task_struct *p, struct nsproxy *new)\n{\n\tstruct nsproxy *ns;\n\n\tmight_sleep();\n\n\ttask_lock(p);\n\tns = p->nsproxy;\n\tp->nsproxy = new;\n\ttask_unlock(p);\n\n\tif (ns)\n\t\tput_nsproxy(ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid exit_task_namespaces(struct task_struct *p)\n{\n\tswitch_task_namespaces(p, NULL);\n}"
  },
  {
    "function_name": "switch_task_namespaces",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
    "lines": "237-250",
    "snippet": "void switch_task_namespaces(struct task_struct *p, struct nsproxy *new)\n{\n\tstruct nsproxy *ns;\n\n\tmight_sleep();\n\n\ttask_lock(p);\n\tns = p->nsproxy;\n\tp->nsproxy = new;\n\ttask_unlock(p);\n\n\tif (ns)\n\t\tput_nsproxy(ns);\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/time_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_nsproxy",
          "args": [
            "ns"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "p"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "p"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid switch_task_namespaces(struct task_struct *p, struct nsproxy *new)\n{\n\tstruct nsproxy *ns;\n\n\tmight_sleep();\n\n\ttask_lock(p);\n\tns = p->nsproxy;\n\tp->nsproxy = new;\n\ttask_unlock(p);\n\n\tif (ns)\n\t\tput_nsproxy(ns);\n}"
  },
  {
    "function_name": "unshare_nsproxy_namespaces",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
    "lines": "211-235",
    "snippet": "int unshare_nsproxy_namespaces(unsigned long unshare_flags,\n\tstruct nsproxy **new_nsp, struct cred *new_cred, struct fs_struct *new_fs)\n{\n\tstruct user_namespace *user_ns;\n\tint err = 0;\n\n\tif (!(unshare_flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\n\t\t\t       CLONE_NEWNET | CLONE_NEWPID | CLONE_NEWCGROUP |\n\t\t\t       CLONE_NEWTIME)))\n\t\treturn 0;\n\n\tuser_ns = new_cred ? new_cred->user_ns : current_user_ns();\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t*new_nsp = create_new_namespaces(unshare_flags, current, user_ns,\n\t\t\t\t\t new_fs ? new_fs : current->fs);\n\tif (IS_ERR(*new_nsp)) {\n\t\terr = PTR_ERR(*new_nsp);\n\t\tgoto out;\n\t}\n\nout:\n\treturn err;\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/time_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "*new_nsp"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "*new_nsp"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_new_namespaces",
          "args": [
            "unshare_flags",
            "current",
            "user_ns",
            "new_fs ? new_fs : current->fs"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "create_new_namespaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
          "lines": "67-145",
          "snippet": "static struct nsproxy *create_new_namespaces(unsigned long flags,\n\tstruct task_struct *tsk, struct user_namespace *user_ns,\n\tstruct fs_struct *new_fs)\n{\n\tstruct nsproxy *new_nsp;\n\tint err;\n\n\tnew_nsp = create_nsproxy();\n\tif (!new_nsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);\n\tif (IS_ERR(new_nsp->mnt_ns)) {\n\t\terr = PTR_ERR(new_nsp->mnt_ns);\n\t\tgoto out_ns;\n\t}\n\n\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);\n\tif (IS_ERR(new_nsp->uts_ns)) {\n\t\terr = PTR_ERR(new_nsp->uts_ns);\n\t\tgoto out_uts;\n\t}\n\n\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);\n\tif (IS_ERR(new_nsp->ipc_ns)) {\n\t\terr = PTR_ERR(new_nsp->ipc_ns);\n\t\tgoto out_ipc;\n\t}\n\n\tnew_nsp->pid_ns_for_children =\n\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);\n\tif (IS_ERR(new_nsp->pid_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);\n\t\tgoto out_pid;\n\t}\n\n\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,\n\t\t\t\t\t    tsk->nsproxy->cgroup_ns);\n\tif (IS_ERR(new_nsp->cgroup_ns)) {\n\t\terr = PTR_ERR(new_nsp->cgroup_ns);\n\t\tgoto out_cgroup;\n\t}\n\n\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);\n\tif (IS_ERR(new_nsp->net_ns)) {\n\t\terr = PTR_ERR(new_nsp->net_ns);\n\t\tgoto out_net;\n\t}\n\n\tnew_nsp->time_ns_for_children = copy_time_ns(flags, user_ns,\n\t\t\t\t\ttsk->nsproxy->time_ns_for_children);\n\tif (IS_ERR(new_nsp->time_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->time_ns_for_children);\n\t\tgoto out_time;\n\t}\n\tnew_nsp->time_ns = get_time_ns(tsk->nsproxy->time_ns);\n\n\treturn new_nsp;\n\nout_time:\n\tput_net(new_nsp->net_ns);\nout_net:\n\tput_cgroup_ns(new_nsp->cgroup_ns);\nout_cgroup:\n\tif (new_nsp->pid_ns_for_children)\n\t\tput_pid_ns(new_nsp->pid_ns_for_children);\nout_pid:\n\tif (new_nsp->ipc_ns)\n\t\tput_ipc_ns(new_nsp->ipc_ns);\nout_ipc:\n\tif (new_nsp->uts_ns)\n\t\tput_uts_ns(new_nsp->uts_ns);\nout_uts:\n\tif (new_nsp->mnt_ns)\n\t\tput_mnt_ns(new_nsp->mnt_ns);\nout_ns:\n\tkmem_cache_free(nsproxy_cachep, new_nsp);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/time_namespace.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nsproxy_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nstatic struct nsproxy *create_new_namespaces(unsigned long flags,\n\tstruct task_struct *tsk, struct user_namespace *user_ns,\n\tstruct fs_struct *new_fs)\n{\n\tstruct nsproxy *new_nsp;\n\tint err;\n\n\tnew_nsp = create_nsproxy();\n\tif (!new_nsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);\n\tif (IS_ERR(new_nsp->mnt_ns)) {\n\t\terr = PTR_ERR(new_nsp->mnt_ns);\n\t\tgoto out_ns;\n\t}\n\n\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);\n\tif (IS_ERR(new_nsp->uts_ns)) {\n\t\terr = PTR_ERR(new_nsp->uts_ns);\n\t\tgoto out_uts;\n\t}\n\n\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);\n\tif (IS_ERR(new_nsp->ipc_ns)) {\n\t\terr = PTR_ERR(new_nsp->ipc_ns);\n\t\tgoto out_ipc;\n\t}\n\n\tnew_nsp->pid_ns_for_children =\n\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);\n\tif (IS_ERR(new_nsp->pid_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);\n\t\tgoto out_pid;\n\t}\n\n\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,\n\t\t\t\t\t    tsk->nsproxy->cgroup_ns);\n\tif (IS_ERR(new_nsp->cgroup_ns)) {\n\t\terr = PTR_ERR(new_nsp->cgroup_ns);\n\t\tgoto out_cgroup;\n\t}\n\n\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);\n\tif (IS_ERR(new_nsp->net_ns)) {\n\t\terr = PTR_ERR(new_nsp->net_ns);\n\t\tgoto out_net;\n\t}\n\n\tnew_nsp->time_ns_for_children = copy_time_ns(flags, user_ns,\n\t\t\t\t\ttsk->nsproxy->time_ns_for_children);\n\tif (IS_ERR(new_nsp->time_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->time_ns_for_children);\n\t\tgoto out_time;\n\t}\n\tnew_nsp->time_ns = get_time_ns(tsk->nsproxy->time_ns);\n\n\treturn new_nsp;\n\nout_time:\n\tput_net(new_nsp->net_ns);\nout_net:\n\tput_cgroup_ns(new_nsp->cgroup_ns);\nout_cgroup:\n\tif (new_nsp->pid_ns_for_children)\n\t\tput_pid_ns(new_nsp->pid_ns_for_children);\nout_pid:\n\tif (new_nsp->ipc_ns)\n\t\tput_ipc_ns(new_nsp->ipc_ns);\nout_ipc:\n\tif (new_nsp->uts_ns)\n\t\tput_uts_ns(new_nsp->uts_ns);\nout_uts:\n\tif (new_nsp->mnt_ns)\n\t\tput_mnt_ns(new_nsp->mnt_ns);\nout_ns:\n\tkmem_cache_free(nsproxy_cachep, new_nsp);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_setid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "431-434",
          "snippet": "bool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint unshare_nsproxy_namespaces(unsigned long unshare_flags,\n\tstruct nsproxy **new_nsp, struct cred *new_cred, struct fs_struct *new_fs)\n{\n\tstruct user_namespace *user_ns;\n\tint err = 0;\n\n\tif (!(unshare_flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\n\t\t\t       CLONE_NEWNET | CLONE_NEWPID | CLONE_NEWCGROUP |\n\t\t\t       CLONE_NEWTIME)))\n\t\treturn 0;\n\n\tuser_ns = new_cred ? new_cred->user_ns : current_user_ns();\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t*new_nsp = create_new_namespaces(unshare_flags, current, user_ns,\n\t\t\t\t\t new_fs ? new_fs : current->fs);\n\tif (IS_ERR(*new_nsp)) {\n\t\terr = PTR_ERR(*new_nsp);\n\t\tgoto out;\n\t}\n\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "free_nsproxy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
    "lines": "188-205",
    "snippet": "void free_nsproxy(struct nsproxy *ns)\n{\n\tif (ns->mnt_ns)\n\t\tput_mnt_ns(ns->mnt_ns);\n\tif (ns->uts_ns)\n\t\tput_uts_ns(ns->uts_ns);\n\tif (ns->ipc_ns)\n\t\tput_ipc_ns(ns->ipc_ns);\n\tif (ns->pid_ns_for_children)\n\t\tput_pid_ns(ns->pid_ns_for_children);\n\tif (ns->time_ns)\n\t\tput_time_ns(ns->time_ns);\n\tif (ns->time_ns_for_children)\n\t\tput_time_ns(ns->time_ns_for_children);\n\tput_cgroup_ns(ns->cgroup_ns);\n\tput_net(ns->net_ns);\n\tkmem_cache_free(nsproxy_cachep, ns);\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/time_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nsproxy_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nsproxy_cachep",
            "ns"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "ns->net_ns"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cgroup_ns",
          "args": [
            "ns->cgroup_ns"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_time_ns",
          "args": [
            "ns->time_ns_for_children"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_time_ns",
          "args": [
            "ns->time_ns"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid_ns",
          "args": [
            "ns->pid_ns_for_children"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "put_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid_namespace.c",
          "lines": "152-163",
          "snippet": "void put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!refcount_dec_and_test(&ns->ns.count))\n\t\t\tbreak;\n\t\tdestroy_pid_namespace(ns);\n\t\tns = parent;\n\t}\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nvoid put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!refcount_dec_and_test(&ns->ns.count))\n\t\t\tbreak;\n\t\tdestroy_pid_namespace(ns);\n\t\tns = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_ipc_ns",
          "args": [
            "ns->ipc_ns"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_uts_ns",
          "args": [
            "ns->uts_ns"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_mnt_ns",
          "args": [
            "ns->mnt_ns"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nvoid free_nsproxy(struct nsproxy *ns)\n{\n\tif (ns->mnt_ns)\n\t\tput_mnt_ns(ns->mnt_ns);\n\tif (ns->uts_ns)\n\t\tput_uts_ns(ns->uts_ns);\n\tif (ns->ipc_ns)\n\t\tput_ipc_ns(ns->ipc_ns);\n\tif (ns->pid_ns_for_children)\n\t\tput_pid_ns(ns->pid_ns_for_children);\n\tif (ns->time_ns)\n\t\tput_time_ns(ns->time_ns);\n\tif (ns->time_ns_for_children)\n\t\tput_time_ns(ns->time_ns_for_children);\n\tput_cgroup_ns(ns->cgroup_ns);\n\tput_net(ns->net_ns);\n\tkmem_cache_free(nsproxy_cachep, ns);\n}"
  },
  {
    "function_name": "copy_namespaces",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
    "lines": "151-186",
    "snippet": "int copy_namespaces(unsigned long flags, struct task_struct *tsk)\n{\n\tstruct nsproxy *old_ns = tsk->nsproxy;\n\tstruct user_namespace *user_ns = task_cred_xxx(tsk, user_ns);\n\tstruct nsproxy *new_ns;\n\n\tif (likely(!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\n\t\t\t      CLONE_NEWPID | CLONE_NEWNET |\n\t\t\t      CLONE_NEWCGROUP | CLONE_NEWTIME)))) {\n\t\tif (likely(old_ns->time_ns_for_children == old_ns->time_ns)) {\n\t\t\tget_nsproxy(old_ns);\n\t\t\treturn 0;\n\t\t}\n\t} else if (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/*\n\t * CLONE_NEWIPC must detach from the undolist: after switching\n\t * to a new ipc namespace, the semaphore arrays from the old\n\t * namespace are unreachable.  In clone parlance, CLONE_SYSVSEM\n\t * means share undolist with parent, so we must forbid using\n\t * it along with CLONE_NEWIPC.\n\t */\n\tif ((flags & (CLONE_NEWIPC | CLONE_SYSVSEM)) ==\n\t\t(CLONE_NEWIPC | CLONE_SYSVSEM))\n\t\treturn -EINVAL;\n\n\tnew_ns = create_new_namespaces(flags, tsk, user_ns, tsk->fs);\n\tif (IS_ERR(new_ns))\n\t\treturn  PTR_ERR(new_ns);\n\n\ttimens_on_fork(new_ns, tsk);\n\n\ttsk->nsproxy = new_ns;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/time_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timens_on_fork",
          "args": [
            "new_ns",
            "tsk"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "timens_on_fork",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/namespace.c",
          "lines": "308-322",
          "snippet": "void timens_on_fork(struct nsproxy *nsproxy, struct task_struct *tsk)\n{\n\tstruct ns_common *nsc = &nsproxy->time_ns_for_children->ns;\n\tstruct time_namespace *ns = to_time_ns(nsc);\n\n\t/* create_new_namespaces() already incremented the ref counter */\n\tif (nsproxy->time_ns == nsproxy->time_ns_for_children)\n\t\treturn;\n\n\tget_time_ns(ns);\n\tput_time_ns(nsproxy->time_ns);\n\tnsproxy->time_ns = ns;\n\n\ttimens_commit(tsk, ns);\n}",
          "includes": [
            "#include <vdso/datapage.h>",
            "#include <linux/mm.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/time_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vdso/datapage.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/proc_ns.h>\n#include <linux/seq_file.h>\n#include <linux/clocksource.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/user_namespace.h>\n#include <linux/time_namespace.h>\n\nvoid timens_on_fork(struct nsproxy *nsproxy, struct task_struct *tsk)\n{\n\tstruct ns_common *nsc = &nsproxy->time_ns_for_children->ns;\n\tstruct time_namespace *ns = to_time_ns(nsc);\n\n\t/* create_new_namespaces() already incremented the ref counter */\n\tif (nsproxy->time_ns == nsproxy->time_ns_for_children)\n\t\treturn;\n\n\tget_time_ns(ns);\n\tput_time_ns(nsproxy->time_ns);\n\tnsproxy->time_ns = ns;\n\n\ttimens_commit(tsk, ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_ns"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_ns"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_new_namespaces",
          "args": [
            "flags",
            "tsk",
            "user_ns",
            "tsk->fs"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "create_new_namespaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
          "lines": "67-145",
          "snippet": "static struct nsproxy *create_new_namespaces(unsigned long flags,\n\tstruct task_struct *tsk, struct user_namespace *user_ns,\n\tstruct fs_struct *new_fs)\n{\n\tstruct nsproxy *new_nsp;\n\tint err;\n\n\tnew_nsp = create_nsproxy();\n\tif (!new_nsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);\n\tif (IS_ERR(new_nsp->mnt_ns)) {\n\t\terr = PTR_ERR(new_nsp->mnt_ns);\n\t\tgoto out_ns;\n\t}\n\n\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);\n\tif (IS_ERR(new_nsp->uts_ns)) {\n\t\terr = PTR_ERR(new_nsp->uts_ns);\n\t\tgoto out_uts;\n\t}\n\n\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);\n\tif (IS_ERR(new_nsp->ipc_ns)) {\n\t\terr = PTR_ERR(new_nsp->ipc_ns);\n\t\tgoto out_ipc;\n\t}\n\n\tnew_nsp->pid_ns_for_children =\n\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);\n\tif (IS_ERR(new_nsp->pid_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);\n\t\tgoto out_pid;\n\t}\n\n\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,\n\t\t\t\t\t    tsk->nsproxy->cgroup_ns);\n\tif (IS_ERR(new_nsp->cgroup_ns)) {\n\t\terr = PTR_ERR(new_nsp->cgroup_ns);\n\t\tgoto out_cgroup;\n\t}\n\n\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);\n\tif (IS_ERR(new_nsp->net_ns)) {\n\t\terr = PTR_ERR(new_nsp->net_ns);\n\t\tgoto out_net;\n\t}\n\n\tnew_nsp->time_ns_for_children = copy_time_ns(flags, user_ns,\n\t\t\t\t\ttsk->nsproxy->time_ns_for_children);\n\tif (IS_ERR(new_nsp->time_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->time_ns_for_children);\n\t\tgoto out_time;\n\t}\n\tnew_nsp->time_ns = get_time_ns(tsk->nsproxy->time_ns);\n\n\treturn new_nsp;\n\nout_time:\n\tput_net(new_nsp->net_ns);\nout_net:\n\tput_cgroup_ns(new_nsp->cgroup_ns);\nout_cgroup:\n\tif (new_nsp->pid_ns_for_children)\n\t\tput_pid_ns(new_nsp->pid_ns_for_children);\nout_pid:\n\tif (new_nsp->ipc_ns)\n\t\tput_ipc_ns(new_nsp->ipc_ns);\nout_ipc:\n\tif (new_nsp->uts_ns)\n\t\tput_uts_ns(new_nsp->uts_ns);\nout_uts:\n\tif (new_nsp->mnt_ns)\n\t\tput_mnt_ns(new_nsp->mnt_ns);\nout_ns:\n\tkmem_cache_free(nsproxy_cachep, new_nsp);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/time_namespace.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nsproxy_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nstatic struct nsproxy *create_new_namespaces(unsigned long flags,\n\tstruct task_struct *tsk, struct user_namespace *user_ns,\n\tstruct fs_struct *new_fs)\n{\n\tstruct nsproxy *new_nsp;\n\tint err;\n\n\tnew_nsp = create_nsproxy();\n\tif (!new_nsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);\n\tif (IS_ERR(new_nsp->mnt_ns)) {\n\t\terr = PTR_ERR(new_nsp->mnt_ns);\n\t\tgoto out_ns;\n\t}\n\n\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);\n\tif (IS_ERR(new_nsp->uts_ns)) {\n\t\terr = PTR_ERR(new_nsp->uts_ns);\n\t\tgoto out_uts;\n\t}\n\n\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);\n\tif (IS_ERR(new_nsp->ipc_ns)) {\n\t\terr = PTR_ERR(new_nsp->ipc_ns);\n\t\tgoto out_ipc;\n\t}\n\n\tnew_nsp->pid_ns_for_children =\n\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);\n\tif (IS_ERR(new_nsp->pid_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);\n\t\tgoto out_pid;\n\t}\n\n\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,\n\t\t\t\t\t    tsk->nsproxy->cgroup_ns);\n\tif (IS_ERR(new_nsp->cgroup_ns)) {\n\t\terr = PTR_ERR(new_nsp->cgroup_ns);\n\t\tgoto out_cgroup;\n\t}\n\n\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);\n\tif (IS_ERR(new_nsp->net_ns)) {\n\t\terr = PTR_ERR(new_nsp->net_ns);\n\t\tgoto out_net;\n\t}\n\n\tnew_nsp->time_ns_for_children = copy_time_ns(flags, user_ns,\n\t\t\t\t\ttsk->nsproxy->time_ns_for_children);\n\tif (IS_ERR(new_nsp->time_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->time_ns_for_children);\n\t\tgoto out_time;\n\t}\n\tnew_nsp->time_ns = get_time_ns(tsk->nsproxy->time_ns);\n\n\treturn new_nsp;\n\nout_time:\n\tput_net(new_nsp->net_ns);\nout_net:\n\tput_cgroup_ns(new_nsp->cgroup_ns);\nout_cgroup:\n\tif (new_nsp->pid_ns_for_children)\n\t\tput_pid_ns(new_nsp->pid_ns_for_children);\nout_pid:\n\tif (new_nsp->ipc_ns)\n\t\tput_ipc_ns(new_nsp->ipc_ns);\nout_ipc:\n\tif (new_nsp->uts_ns)\n\t\tput_uts_ns(new_nsp->uts_ns);\nout_uts:\n\tif (new_nsp->mnt_ns)\n\t\tput_mnt_ns(new_nsp->mnt_ns);\nout_ns:\n\tkmem_cache_free(nsproxy_cachep, new_nsp);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_setid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "431-434",
          "snippet": "bool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nsproxy",
          "args": [
            "old_ns"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "old_ns->time_ns_for_children == old_ns->time_ns"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\n\t\t\t      CLONE_NEWPID | CLONE_NEWNET |\n\t\t\t      CLONE_NEWCGROUP | CLONE_NEWTIME))"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cred_xxx",
          "args": [
            "tsk",
            "user_ns"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_namespaces(unsigned long flags, struct task_struct *tsk)\n{\n\tstruct nsproxy *old_ns = tsk->nsproxy;\n\tstruct user_namespace *user_ns = task_cred_xxx(tsk, user_ns);\n\tstruct nsproxy *new_ns;\n\n\tif (likely(!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\n\t\t\t      CLONE_NEWPID | CLONE_NEWNET |\n\t\t\t      CLONE_NEWCGROUP | CLONE_NEWTIME)))) {\n\t\tif (likely(old_ns->time_ns_for_children == old_ns->time_ns)) {\n\t\t\tget_nsproxy(old_ns);\n\t\t\treturn 0;\n\t\t}\n\t} else if (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/*\n\t * CLONE_NEWIPC must detach from the undolist: after switching\n\t * to a new ipc namespace, the semaphore arrays from the old\n\t * namespace are unreachable.  In clone parlance, CLONE_SYSVSEM\n\t * means share undolist with parent, so we must forbid using\n\t * it along with CLONE_NEWIPC.\n\t */\n\tif ((flags & (CLONE_NEWIPC | CLONE_SYSVSEM)) ==\n\t\t(CLONE_NEWIPC | CLONE_SYSVSEM))\n\t\treturn -EINVAL;\n\n\tnew_ns = create_new_namespaces(flags, tsk, user_ns, tsk->fs);\n\tif (IS_ERR(new_ns))\n\t\treturn  PTR_ERR(new_ns);\n\n\ttimens_on_fork(new_ns, tsk);\n\n\ttsk->nsproxy = new_ns;\n\treturn 0;\n}"
  },
  {
    "function_name": "create_new_namespaces",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
    "lines": "67-145",
    "snippet": "static struct nsproxy *create_new_namespaces(unsigned long flags,\n\tstruct task_struct *tsk, struct user_namespace *user_ns,\n\tstruct fs_struct *new_fs)\n{\n\tstruct nsproxy *new_nsp;\n\tint err;\n\n\tnew_nsp = create_nsproxy();\n\tif (!new_nsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);\n\tif (IS_ERR(new_nsp->mnt_ns)) {\n\t\terr = PTR_ERR(new_nsp->mnt_ns);\n\t\tgoto out_ns;\n\t}\n\n\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);\n\tif (IS_ERR(new_nsp->uts_ns)) {\n\t\terr = PTR_ERR(new_nsp->uts_ns);\n\t\tgoto out_uts;\n\t}\n\n\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);\n\tif (IS_ERR(new_nsp->ipc_ns)) {\n\t\terr = PTR_ERR(new_nsp->ipc_ns);\n\t\tgoto out_ipc;\n\t}\n\n\tnew_nsp->pid_ns_for_children =\n\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);\n\tif (IS_ERR(new_nsp->pid_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);\n\t\tgoto out_pid;\n\t}\n\n\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,\n\t\t\t\t\t    tsk->nsproxy->cgroup_ns);\n\tif (IS_ERR(new_nsp->cgroup_ns)) {\n\t\terr = PTR_ERR(new_nsp->cgroup_ns);\n\t\tgoto out_cgroup;\n\t}\n\n\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);\n\tif (IS_ERR(new_nsp->net_ns)) {\n\t\terr = PTR_ERR(new_nsp->net_ns);\n\t\tgoto out_net;\n\t}\n\n\tnew_nsp->time_ns_for_children = copy_time_ns(flags, user_ns,\n\t\t\t\t\ttsk->nsproxy->time_ns_for_children);\n\tif (IS_ERR(new_nsp->time_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->time_ns_for_children);\n\t\tgoto out_time;\n\t}\n\tnew_nsp->time_ns = get_time_ns(tsk->nsproxy->time_ns);\n\n\treturn new_nsp;\n\nout_time:\n\tput_net(new_nsp->net_ns);\nout_net:\n\tput_cgroup_ns(new_nsp->cgroup_ns);\nout_cgroup:\n\tif (new_nsp->pid_ns_for_children)\n\t\tput_pid_ns(new_nsp->pid_ns_for_children);\nout_pid:\n\tif (new_nsp->ipc_ns)\n\t\tput_ipc_ns(new_nsp->ipc_ns);\nout_ipc:\n\tif (new_nsp->uts_ns)\n\t\tput_uts_ns(new_nsp->uts_ns);\nout_uts:\n\tif (new_nsp->mnt_ns)\n\t\tput_mnt_ns(new_nsp->mnt_ns);\nout_ns:\n\tkmem_cache_free(nsproxy_cachep, new_nsp);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/time_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nsproxy_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nsproxy_cachep",
            "new_nsp"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_mnt_ns",
          "args": [
            "new_nsp->mnt_ns"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_uts_ns",
          "args": [
            "new_nsp->uts_ns"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ipc_ns",
          "args": [
            "new_nsp->ipc_ns"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid_ns",
          "args": [
            "new_nsp->pid_ns_for_children"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "put_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid_namespace.c",
          "lines": "152-163",
          "snippet": "void put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!refcount_dec_and_test(&ns->ns.count))\n\t\t\tbreak;\n\t\tdestroy_pid_namespace(ns);\n\t\tns = parent;\n\t}\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nvoid put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!refcount_dec_and_test(&ns->ns.count))\n\t\t\tbreak;\n\t\tdestroy_pid_namespace(ns);\n\t\tns = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cgroup_ns",
          "args": [
            "new_nsp->cgroup_ns"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "new_nsp->net_ns"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_time_ns",
          "args": [
            "tsk->nsproxy->time_ns"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_nsp->time_ns_for_children"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_nsp->time_ns_for_children"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_time_ns",
          "args": [
            "flags",
            "user_ns",
            "tsk->nsproxy->time_ns_for_children"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "copy_time_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/namespace.c",
          "lines": "133-140",
          "snippet": "struct time_namespace *copy_time_ns(unsigned long flags,\n\tstruct user_namespace *user_ns, struct time_namespace *old_ns)\n{\n\tif (!(flags & CLONE_NEWTIME))\n\t\treturn get_time_ns(old_ns);\n\n\treturn clone_time_ns(user_ns, old_ns);\n}",
          "includes": [
            "#include <vdso/datapage.h>",
            "#include <linux/mm.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/time_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vdso/datapage.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/proc_ns.h>\n#include <linux/seq_file.h>\n#include <linux/clocksource.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/user_namespace.h>\n#include <linux/time_namespace.h>\n\nstruct time_namespace *copy_time_ns(unsigned long flags,\n\tstruct user_namespace *user_ns, struct time_namespace *old_ns)\n{\n\tif (!(flags & CLONE_NEWTIME))\n\t\treturn get_time_ns(old_ns);\n\n\treturn clone_time_ns(user_ns, old_ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_nsp->net_ns"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_nsp->net_ns"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_net_ns",
          "args": [
            "flags",
            "user_ns",
            "tsk->nsproxy->net_ns"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_nsp->cgroup_ns"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_nsp->cgroup_ns"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_cgroup_ns",
          "args": [
            "flags",
            "user_ns",
            "tsk->nsproxy->cgroup_ns"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "copy_cgroup_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/namespace.c",
          "lines": "50-91",
          "snippet": "struct cgroup_namespace *copy_cgroup_ns(unsigned long flags,\n\t\t\t\t\tstruct user_namespace *user_ns,\n\t\t\t\t\tstruct cgroup_namespace *old_ns)\n{\n\tstruct cgroup_namespace *new_ns;\n\tstruct ucounts *ucounts;\n\tstruct css_set *cset;\n\n\tBUG_ON(!old_ns);\n\n\tif (!(flags & CLONE_NEWCGROUP)) {\n\t\tget_cgroup_ns(old_ns);\n\t\treturn old_ns;\n\t}\n\n\t/* Allow only sysadmin to create cgroup namespace. */\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\tucounts = inc_cgroup_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* It is not safe to take cgroup_mutex here */\n\tspin_lock_irq(&css_set_lock);\n\tcset = task_css_set(current);\n\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tnew_ns = alloc_cgroup_ns();\n\tif (IS_ERR(new_ns)) {\n\t\tput_css_set(cset);\n\t\tdec_cgroup_namespaces(ucounts);\n\t\treturn new_ns;\n\t}\n\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\tnew_ns->ucounts = ucounts;\n\tnew_ns->root_cset = cset;\n\n\treturn new_ns;\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include \"cgroup-internal.h\"\n\nstruct cgroup_namespace *copy_cgroup_ns(unsigned long flags,\n\t\t\t\t\tstruct user_namespace *user_ns,\n\t\t\t\t\tstruct cgroup_namespace *old_ns)\n{\n\tstruct cgroup_namespace *new_ns;\n\tstruct ucounts *ucounts;\n\tstruct css_set *cset;\n\n\tBUG_ON(!old_ns);\n\n\tif (!(flags & CLONE_NEWCGROUP)) {\n\t\tget_cgroup_ns(old_ns);\n\t\treturn old_ns;\n\t}\n\n\t/* Allow only sysadmin to create cgroup namespace. */\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\tucounts = inc_cgroup_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\t/* It is not safe to take cgroup_mutex here */\n\tspin_lock_irq(&css_set_lock);\n\tcset = task_css_set(current);\n\tget_css_set(cset);\n\tspin_unlock_irq(&css_set_lock);\n\n\tnew_ns = alloc_cgroup_ns();\n\tif (IS_ERR(new_ns)) {\n\t\tput_css_set(cset);\n\t\tdec_cgroup_namespaces(ucounts);\n\t\treturn new_ns;\n\t}\n\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\tnew_ns->ucounts = ucounts;\n\tnew_ns->root_cset = cset;\n\n\treturn new_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_nsp->pid_ns_for_children"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_nsp->pid_ns_for_children"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_pid_ns",
          "args": [
            "flags",
            "user_ns",
            "tsk->nsproxy->pid_ns_for_children"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "copy_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid_namespace.c",
          "lines": "142-150",
          "snippet": "struct pid_namespace *copy_pid_ns(unsigned long flags,\n\tstruct user_namespace *user_ns, struct pid_namespace *old_ns)\n{\n\tif (!(flags & CLONE_NEWPID))\n\t\treturn get_pid_ns(old_ns);\n\tif (task_active_pid_ns(current) != old_ns)\n\t\treturn ERR_PTR(-EINVAL);\n\treturn create_pid_namespace(user_ns, old_ns);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstruct pid_namespace *copy_pid_ns(unsigned long flags,\n\tstruct user_namespace *user_ns, struct pid_namespace *old_ns)\n{\n\tif (!(flags & CLONE_NEWPID))\n\t\treturn get_pid_ns(old_ns);\n\tif (task_active_pid_ns(current) != old_ns)\n\t\treturn ERR_PTR(-EINVAL);\n\treturn create_pid_namespace(user_ns, old_ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_nsp->ipc_ns"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_nsp->ipc_ns"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_ipcs",
          "args": [
            "flags",
            "user_ns",
            "tsk->nsproxy->ipc_ns"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_nsp->uts_ns"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_nsp->uts_ns"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_utsname",
          "args": [
            "flags",
            "user_ns",
            "tsk->nsproxy->uts_ns"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "copy_utsname",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname.c",
          "lines": "89-104",
          "snippet": "struct uts_namespace *copy_utsname(unsigned long flags,\n\tstruct user_namespace *user_ns, struct uts_namespace *old_ns)\n{\n\tstruct uts_namespace *new_ns;\n\n\tBUG_ON(!old_ns);\n\tget_uts_ns(old_ns);\n\n\tif (!(flags & CLONE_NEWUTS))\n\t\treturn old_ns;\n\n\tnew_ns = clone_uts_ns(user_ns, old_ns);\n\n\tput_uts_ns(old_ns);\n\treturn new_ns;\n}",
          "includes": [
            "#include <linux/sched/task.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/utsname.h>",
            "#include <linux/uts.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstruct uts_namespace *copy_utsname(unsigned long flags,\n\tstruct user_namespace *user_ns, struct uts_namespace *old_ns)\n{\n\tstruct uts_namespace *new_ns;\n\n\tBUG_ON(!old_ns);\n\tget_uts_ns(old_ns);\n\n\tif (!(flags & CLONE_NEWUTS))\n\t\treturn old_ns;\n\n\tnew_ns = clone_uts_ns(user_ns, old_ns);\n\n\tput_uts_ns(old_ns);\n\treturn new_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_nsp->mnt_ns"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_nsp->mnt_ns"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_mnt_ns",
          "args": [
            "flags",
            "tsk->nsproxy->mnt_ns",
            "user_ns",
            "new_fs"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_nsproxy",
          "args": [],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "create_nsproxy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
          "lines": "52-60",
          "snippet": "static inline struct nsproxy *create_nsproxy(void)\n{\n\tstruct nsproxy *nsproxy;\n\n\tnsproxy = kmem_cache_alloc(nsproxy_cachep, GFP_KERNEL);\n\tif (nsproxy)\n\t\tatomic_set(&nsproxy->count, 1);\n\treturn nsproxy;\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/time_namespace.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nsproxy_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nstatic inline struct nsproxy *create_nsproxy(void)\n{\n\tstruct nsproxy *nsproxy;\n\n\tnsproxy = kmem_cache_alloc(nsproxy_cachep, GFP_KERNEL);\n\tif (nsproxy)\n\t\tatomic_set(&nsproxy->count, 1);\n\treturn nsproxy;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nstatic struct nsproxy *create_new_namespaces(unsigned long flags,\n\tstruct task_struct *tsk, struct user_namespace *user_ns,\n\tstruct fs_struct *new_fs)\n{\n\tstruct nsproxy *new_nsp;\n\tint err;\n\n\tnew_nsp = create_nsproxy();\n\tif (!new_nsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);\n\tif (IS_ERR(new_nsp->mnt_ns)) {\n\t\terr = PTR_ERR(new_nsp->mnt_ns);\n\t\tgoto out_ns;\n\t}\n\n\tnew_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);\n\tif (IS_ERR(new_nsp->uts_ns)) {\n\t\terr = PTR_ERR(new_nsp->uts_ns);\n\t\tgoto out_uts;\n\t}\n\n\tnew_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);\n\tif (IS_ERR(new_nsp->ipc_ns)) {\n\t\terr = PTR_ERR(new_nsp->ipc_ns);\n\t\tgoto out_ipc;\n\t}\n\n\tnew_nsp->pid_ns_for_children =\n\t\tcopy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);\n\tif (IS_ERR(new_nsp->pid_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->pid_ns_for_children);\n\t\tgoto out_pid;\n\t}\n\n\tnew_nsp->cgroup_ns = copy_cgroup_ns(flags, user_ns,\n\t\t\t\t\t    tsk->nsproxy->cgroup_ns);\n\tif (IS_ERR(new_nsp->cgroup_ns)) {\n\t\terr = PTR_ERR(new_nsp->cgroup_ns);\n\t\tgoto out_cgroup;\n\t}\n\n\tnew_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);\n\tif (IS_ERR(new_nsp->net_ns)) {\n\t\terr = PTR_ERR(new_nsp->net_ns);\n\t\tgoto out_net;\n\t}\n\n\tnew_nsp->time_ns_for_children = copy_time_ns(flags, user_ns,\n\t\t\t\t\ttsk->nsproxy->time_ns_for_children);\n\tif (IS_ERR(new_nsp->time_ns_for_children)) {\n\t\terr = PTR_ERR(new_nsp->time_ns_for_children);\n\t\tgoto out_time;\n\t}\n\tnew_nsp->time_ns = get_time_ns(tsk->nsproxy->time_ns);\n\n\treturn new_nsp;\n\nout_time:\n\tput_net(new_nsp->net_ns);\nout_net:\n\tput_cgroup_ns(new_nsp->cgroup_ns);\nout_cgroup:\n\tif (new_nsp->pid_ns_for_children)\n\t\tput_pid_ns(new_nsp->pid_ns_for_children);\nout_pid:\n\tif (new_nsp->ipc_ns)\n\t\tput_ipc_ns(new_nsp->ipc_ns);\nout_ipc:\n\tif (new_nsp->uts_ns)\n\t\tput_uts_ns(new_nsp->uts_ns);\nout_uts:\n\tif (new_nsp->mnt_ns)\n\t\tput_mnt_ns(new_nsp->mnt_ns);\nout_ns:\n\tkmem_cache_free(nsproxy_cachep, new_nsp);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "create_nsproxy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
    "lines": "52-60",
    "snippet": "static inline struct nsproxy *create_nsproxy(void)\n{\n\tstruct nsproxy *nsproxy;\n\n\tnsproxy = kmem_cache_alloc(nsproxy_cachep, GFP_KERNEL);\n\tif (nsproxy)\n\t\tatomic_set(&nsproxy->count, 1);\n\treturn nsproxy;\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/time_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nsproxy_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&nsproxy->count",
            "1"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "nsproxy_cachep",
            "GFP_KERNEL"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *nsproxy_cachep;\n\nstatic inline struct nsproxy *create_nsproxy(void)\n{\n\tstruct nsproxy *nsproxy;\n\n\tnsproxy = kmem_cache_alloc(nsproxy_cachep, GFP_KERNEL);\n\tif (nsproxy)\n\t\tatomic_set(&nsproxy->count, 1);\n\treturn nsproxy;\n}"
  },
  {
    "function_name": "setns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
    "lines": "527-567",
    "snippet": "SYSCALL_DEFINE2(setns, int, fd, int, flags)\n{\n\tstruct file *file;\n\tstruct ns_common *ns = NULL;\n\tstruct nsset nsset = {};\n\tint err = 0;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn -EBADF;\n\n\tif (proc_ns_file(file)) {\n\t\tns = get_proc_ns(file_inode(file));\n\t\tif (flags && (ns->ops->type != flags))\n\t\t\terr = -EINVAL;\n\t\tflags = ns->ops->type;\n\t} else if (!IS_ERR(pidfd_pid(file))) {\n\t\terr = check_setns_flags(flags);\n\t} else {\n\t\terr = -EINVAL;\n\t}\n\tif (err)\n\t\tgoto out;\n\n\terr = prepare_nsset(flags, &nsset);\n\tif (err)\n\t\tgoto out;\n\n\tif (proc_ns_file(file))\n\t\terr = validate_ns(&nsset, ns);\n\telse\n\t\terr = validate_nsset(&nsset, file->private_data);\n\tif (!err) {\n\t\tcommit_nsset(&nsset);\n\t\tperf_event_namespaces(current);\n\t}\n\tput_nsset(&nsset);\nout:\n\tfput(file);\n\treturn err;\n}",
    "includes": [
      "#include <linux/perf_event.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/time_namespace.h>",
      "#include <linux/ipc_namespace.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/init_task.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(setns, int, fd, int, flags)\n{\n\tstruct file *file;\n\tstruct ns_common *ns = NULL;\n\tstruct nsset nsset = {};\n\tint err = 0;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn -EBADF;\n\n\tif (proc_ns_file(file)) {\n\t\tns = get_proc_ns(file_inode(file));\n\t\tif (flags && (ns->ops->type != flags))\n\t\t\terr = -EINVAL;\n\t\tflags = ns->ops->type;\n\t} else if (!IS_ERR(pidfd_pid(file))) {\n\t\terr = check_setns_flags(flags);\n\t} else {\n\t\terr = -EINVAL;\n\t}\n\tif (err)\n\t\tgoto out;\n\n\terr = prepare_nsset(flags, &nsset);\n\tif (err)\n\t\tgoto out;\n\n\tif (proc_ns_file(file))\n\t\terr = validate_ns(&nsset, ns);\n\telse\n\t\terr = validate_nsset(&nsset, file->private_data);\n\tif (!err) {\n\t\tcommit_nsset(&nsset);\n\t\tperf_event_namespaces(current);\n\t}\n\tput_nsset(&nsset);\nout:\n\tfput(file);\n\treturn err;\n}"
  }
]