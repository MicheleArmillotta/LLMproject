[
  {
    "function_name": "proc_schedstat_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/stats.c",
    "lines": "227-231",
    "snippet": "static int __init proc_schedstat_init(void)\n{\n\tproc_create_seq(\"schedstat\", 0, NULL, &schedstat_sops);\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations schedstat_sops = {\n\t.start = schedstat_start,\n\t.next  = schedstat_next,\n\t.stop  = schedstat_stop,\n\t.show  = show_schedstat,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create_seq",
          "args": [
            "\"schedstat\"",
            "0",
            "NULL",
            "&schedstat_sops"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic const struct seq_operations schedstat_sops = {\n\t.start = schedstat_start,\n\t.next  = schedstat_next,\n\t.stop  = schedstat_stop,\n\t.show  = show_schedstat,\n};\n\nstatic int __init proc_schedstat_init(void)\n{\n\tproc_create_seq(\"schedstat\", 0, NULL, &schedstat_sops);\n\treturn 0;\n}"
  },
  {
    "function_name": "schedstat_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/stats.c",
    "lines": "216-218",
    "snippet": "static void schedstat_stop(struct seq_file *file, void *data)\n{\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void schedstat_stop(struct seq_file *file, void *data)\n{\n}"
  },
  {
    "function_name": "schedstat_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/stats.c",
    "lines": "209-214",
    "snippet": "static void *schedstat_next(struct seq_file *file, void *data, loff_t *offset)\n{\n\t(*offset)++;\n\n\treturn schedstat_start(file, offset);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedstat_start",
          "args": [
            "file",
            "offset"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "schedstat_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/stats.c",
          "lines": "187-207",
          "snippet": "static void *schedstat_start(struct seq_file *file, loff_t *offset)\n{\n\tunsigned long n = *offset;\n\n\tif (n == 0)\n\t\treturn (void *) 1;\n\n\tn--;\n\n\tif (n > 0)\n\t\tn = cpumask_next(n - 1, cpu_online_mask);\n\telse\n\t\tn = cpumask_first(cpu_online_mask);\n\n\t*offset = n + 1;\n\n\tif (n < nr_cpu_ids)\n\t\treturn (void *)(unsigned long)(n + 2);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void *schedstat_start(struct seq_file *file, loff_t *offset)\n{\n\tunsigned long n = *offset;\n\n\tif (n == 0)\n\t\treturn (void *) 1;\n\n\tn--;\n\n\tif (n > 0)\n\t\tn = cpumask_next(n - 1, cpu_online_mask);\n\telse\n\t\tn = cpumask_first(cpu_online_mask);\n\n\t*offset = n + 1;\n\n\tif (n < nr_cpu_ids)\n\t\treturn (void *)(unsigned long)(n + 2);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void *schedstat_next(struct seq_file *file, void *data, loff_t *offset)\n{\n\t(*offset)++;\n\n\treturn schedstat_start(file, offset);\n}"
  },
  {
    "function_name": "schedstat_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/stats.c",
    "lines": "187-207",
    "snippet": "static void *schedstat_start(struct seq_file *file, loff_t *offset)\n{\n\tunsigned long n = *offset;\n\n\tif (n == 0)\n\t\treturn (void *) 1;\n\n\tn--;\n\n\tif (n > 0)\n\t\tn = cpumask_next(n - 1, cpu_online_mask);\n\telse\n\t\tn = cpumask_first(cpu_online_mask);\n\n\t*offset = n + 1;\n\n\tif (n < nr_cpu_ids)\n\t\treturn (void *)(unsigned long)(n + 2);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "n - 1",
            "cpu_online_mask"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void *schedstat_start(struct seq_file *file, loff_t *offset)\n{\n\tunsigned long n = *offset;\n\n\tif (n == 0)\n\t\treturn (void *) 1;\n\n\tn--;\n\n\tif (n > 0)\n\t\tn = cpumask_next(n - 1, cpu_online_mask);\n\telse\n\t\tn = cpumask_first(cpu_online_mask);\n\n\t*offset = n + 1;\n\n\tif (n < nr_cpu_ids)\n\t\treturn (void *)(unsigned long)(n + 2);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "show_schedstat",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/stats.c",
    "lines": "119-178",
    "snippet": "static int show_schedstat(struct seq_file *seq, void *v)\n{\n\tint cpu;\n\n\tif (v == (void *)1) {\n\t\tseq_printf(seq, \"version %d\\n\", SCHEDSTAT_VERSION);\n\t\tseq_printf(seq, \"timestamp %lu\\n\", jiffies);\n\t} else {\n\t\tstruct rq *rq;\n#ifdef CONFIG_SMP\n\t\tstruct sched_domain *sd;\n\t\tint dcount = 0;\n#endif\n\t\tcpu = (unsigned long)(v - 2);\n\t\trq = cpu_rq(cpu);\n\n\t\t/* runqueue-specific stats */\n\t\tseq_printf(seq,\n\t\t    \"cpu%d %u 0 %u %u %u %u %llu %llu %lu\",\n\t\t    cpu, rq->yld_count,\n\t\t    rq->sched_count, rq->sched_goidle,\n\t\t    rq->ttwu_count, rq->ttwu_local,\n\t\t    rq->rq_cpu_time,\n\t\t    rq->rq_sched_info.run_delay, rq->rq_sched_info.pcount);\n\n\t\tseq_printf(seq, \"\\n\");\n\n#ifdef CONFIG_SMP\n\t\t/* domain-specific stats */\n\t\trcu_read_lock();\n\t\tfor_each_domain(cpu, sd) {\n\t\t\tenum cpu_idle_type itype;\n\n\t\t\tseq_printf(seq, \"domain%d %*pb\", dcount++,\n\t\t\t\t   cpumask_pr_args(sched_domain_span(sd)));\n\t\t\tfor (itype = CPU_IDLE; itype < CPU_MAX_IDLE_TYPES;\n\t\t\t\t\titype++) {\n\t\t\t\tseq_printf(seq, \" %u %u %u %u %u %u %u %u\",\n\t\t\t\t    sd->lb_count[itype],\n\t\t\t\t    sd->lb_balanced[itype],\n\t\t\t\t    sd->lb_failed[itype],\n\t\t\t\t    sd->lb_imbalance[itype],\n\t\t\t\t    sd->lb_gained[itype],\n\t\t\t\t    sd->lb_hot_gained[itype],\n\t\t\t\t    sd->lb_nobusyq[itype],\n\t\t\t\t    sd->lb_nobusyg[itype]);\n\t\t\t}\n\t\t\tseq_printf(seq,\n\t\t\t\t   \" %u %u %u %u %u %u %u %u %u %u %u %u\\n\",\n\t\t\t    sd->alb_count, sd->alb_failed, sd->alb_pushed,\n\t\t\t    sd->sbe_count, sd->sbe_balanced, sd->sbe_pushed,\n\t\t\t    sd->sbf_count, sd->sbf_balanced, sd->sbf_pushed,\n\t\t\t    sd->ttwu_wake_remote, sd->ttwu_move_affine,\n\t\t\t    sd->ttwu_move_balance);\n\t\t}\n\t\trcu_read_unlock();\n#endif\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define SCHEDSTAT_VERSION 15"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\" %u %u %u %u %u %u %u %u %u %u %u %u\\n\"",
            "sd->alb_count",
            "sd->alb_failed",
            "sd->alb_pushed",
            "sd->sbe_count",
            "sd->sbe_balanced",
            "sd->sbe_pushed",
            "sd->sbf_count",
            "sd->sbf_balanced",
            "sd->sbf_pushed",
            "sd->ttwu_wake_remote",
            "sd->ttwu_move_affine",
            "sd->ttwu_move_balance"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "sched_domain_span(sd)"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_domain",
          "args": [
            "cpu",
            "sd"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n#define SCHEDSTAT_VERSION 15\n\nstatic int show_schedstat(struct seq_file *seq, void *v)\n{\n\tint cpu;\n\n\tif (v == (void *)1) {\n\t\tseq_printf(seq, \"version %d\\n\", SCHEDSTAT_VERSION);\n\t\tseq_printf(seq, \"timestamp %lu\\n\", jiffies);\n\t} else {\n\t\tstruct rq *rq;\n#ifdef CONFIG_SMP\n\t\tstruct sched_domain *sd;\n\t\tint dcount = 0;\n#endif\n\t\tcpu = (unsigned long)(v - 2);\n\t\trq = cpu_rq(cpu);\n\n\t\t/* runqueue-specific stats */\n\t\tseq_printf(seq,\n\t\t    \"cpu%d %u 0 %u %u %u %u %llu %llu %lu\",\n\t\t    cpu, rq->yld_count,\n\t\t    rq->sched_count, rq->sched_goidle,\n\t\t    rq->ttwu_count, rq->ttwu_local,\n\t\t    rq->rq_cpu_time,\n\t\t    rq->rq_sched_info.run_delay, rq->rq_sched_info.pcount);\n\n\t\tseq_printf(seq, \"\\n\");\n\n#ifdef CONFIG_SMP\n\t\t/* domain-specific stats */\n\t\trcu_read_lock();\n\t\tfor_each_domain(cpu, sd) {\n\t\t\tenum cpu_idle_type itype;\n\n\t\t\tseq_printf(seq, \"domain%d %*pb\", dcount++,\n\t\t\t\t   cpumask_pr_args(sched_domain_span(sd)));\n\t\t\tfor (itype = CPU_IDLE; itype < CPU_MAX_IDLE_TYPES;\n\t\t\t\t\titype++) {\n\t\t\t\tseq_printf(seq, \" %u %u %u %u %u %u %u %u\",\n\t\t\t\t    sd->lb_count[itype],\n\t\t\t\t    sd->lb_balanced[itype],\n\t\t\t\t    sd->lb_failed[itype],\n\t\t\t\t    sd->lb_imbalance[itype],\n\t\t\t\t    sd->lb_gained[itype],\n\t\t\t\t    sd->lb_hot_gained[itype],\n\t\t\t\t    sd->lb_nobusyq[itype],\n\t\t\t\t    sd->lb_nobusyg[itype]);\n\t\t\t}\n\t\t\tseq_printf(seq,\n\t\t\t\t   \" %u %u %u %u %u %u %u %u %u %u %u %u\\n\",\n\t\t\t    sd->alb_count, sd->alb_failed, sd->alb_pushed,\n\t\t\t    sd->sbe_count, sd->sbe_balanced, sd->sbe_pushed,\n\t\t\t    sd->sbf_count, sd->sbf_balanced, sd->sbf_pushed,\n\t\t\t    sd->ttwu_wake_remote, sd->ttwu_move_affine,\n\t\t\t    sd->ttwu_move_balance);\n\t\t}\n\t\trcu_read_unlock();\n#endif\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__update_stats_enqueue_sleeper",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/stats.c",
    "lines": "48-109",
    "snippet": "void __update_stats_enqueue_sleeper(struct rq *rq, struct task_struct *p,\n\t\t\t\t    struct sched_statistics *stats)\n{\n\tu64 sleep_start, block_start;\n\n\tsleep_start = schedstat_val(stats->sleep_start);\n\tblock_start = schedstat_val(stats->block_start);\n\n\tif (sleep_start) {\n\t\tu64 delta = rq_clock(rq) - sleep_start;\n\n\t\tif ((s64)delta < 0)\n\t\t\tdelta = 0;\n\n\t\tif (unlikely(delta > schedstat_val(stats->sleep_max)))\n\t\t\t__schedstat_set(stats->sleep_max, delta);\n\n\t\t__schedstat_set(stats->sleep_start, 0);\n\t\t__schedstat_add(stats->sum_sleep_runtime, delta);\n\n\t\tif (p) {\n\t\t\taccount_scheduler_latency(p, delta >> 10, 1);\n\t\t\ttrace_sched_stat_sleep(p, delta);\n\t\t}\n\t}\n\n\tif (block_start) {\n\t\tu64 delta = rq_clock(rq) - block_start;\n\n\t\tif ((s64)delta < 0)\n\t\t\tdelta = 0;\n\n\t\tif (unlikely(delta > schedstat_val(stats->block_max)))\n\t\t\t__schedstat_set(stats->block_max, delta);\n\n\t\t__schedstat_set(stats->block_start, 0);\n\t\t__schedstat_add(stats->sum_sleep_runtime, delta);\n\t\t__schedstat_add(stats->sum_block_runtime, delta);\n\n\t\tif (p) {\n\t\t\tif (p->in_iowait) {\n\t\t\t\t__schedstat_add(stats->iowait_sum, delta);\n\t\t\t\t__schedstat_inc(stats->iowait_count);\n\t\t\t\ttrace_sched_stat_iowait(p, delta);\n\t\t\t}\n\n\t\t\ttrace_sched_stat_blocked(p, delta);\n\n\t\t\t/*\n\t\t\t * Blocking time is in units of nanosecs, so shift by\n\t\t\t * 20 to get a milliseconds-range estimation of the\n\t\t\t * amount of time that the task spent sleeping:\n\t\t\t */\n\t\t\tif (unlikely(prof_on == SLEEP_PROFILING)) {\n\t\t\t\tprofile_hits(SLEEP_PROFILING,\n\t\t\t\t\t     (void *)get_wchan(p),\n\t\t\t\t\t     delta >> 20);\n\t\t\t}\n\t\t\taccount_scheduler_latency(p, delta >> 10, 0);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "account_scheduler_latency",
          "args": [
            "p",
            "delta >> 10",
            "0"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "__account_scheduler_latency",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/latencytop.c",
          "lines": "150-215",
          "snippet": "void __sched\n__account_scheduler_latency(struct task_struct *tsk, int usecs, int inter)\n{\n\tunsigned long flags;\n\tint i, q;\n\tstruct latency_record lat;\n\n\t/* Long interruptible waits are generally user requested... */\n\tif (inter && usecs > 5000)\n\t\treturn;\n\n\t/* Negative sleeps are time going backwards */\n\t/* Zero-time sleeps are non-interesting */\n\tif (usecs <= 0)\n\t\treturn;\n\n\tmemset(&lat, 0, sizeof(lat));\n\tlat.count = 1;\n\tlat.time = usecs;\n\tlat.max = usecs;\n\n\tstack_trace_save_tsk(tsk, lat.backtrace, LT_BACKTRACEDEPTH, 0);\n\n\traw_spin_lock_irqsave(&latency_lock, flags);\n\n\taccount_global_scheduler_latency(tsk, &lat);\n\n\tfor (i = 0; i < tsk->latency_record_count; i++) {\n\t\tstruct latency_record *mylat;\n\t\tint same = 1;\n\n\t\tmylat = &tsk->latency_record[i];\n\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\tunsigned long record = lat.backtrace[q];\n\n\t\t\tif (mylat->backtrace[q] != record) {\n\t\t\t\tsame = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* 0 entry is end of backtrace */\n\t\t\tif (!record)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (same) {\n\t\t\tmylat->count++;\n\t\t\tmylat->time += lat.time;\n\t\t\tif (lat.time > mylat->max)\n\t\t\t\tmylat->max = lat.time;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * short term hack; if we're > 32 we stop; future we recycle:\n\t */\n\tif (tsk->latency_record_count >= LT_SAVECOUNT)\n\t\tgoto out_unlock;\n\n\t/* Allocated a new one: */\n\ti = tsk->latency_record_count++;\n\tmemcpy(&tsk->latency_record[i], &lat, sizeof(struct latency_record));\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&latency_lock, flags);\n}",
          "includes": [
            "#include <linux/stacktrace.h>",
            "#include <linux/list.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(latency_lock);",
            "static struct latency_record latency_record[MAXLR];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/stacktrace.h>\n#include <linux/list.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/latencytop.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n\nstatic DEFINE_RAW_SPINLOCK(latency_lock);\nstatic struct latency_record latency_record[MAXLR];\n\nvoid __sched\n__account_scheduler_latency(struct task_struct *tsk, int usecs, int inter)\n{\n\tunsigned long flags;\n\tint i, q;\n\tstruct latency_record lat;\n\n\t/* Long interruptible waits are generally user requested... */\n\tif (inter && usecs > 5000)\n\t\treturn;\n\n\t/* Negative sleeps are time going backwards */\n\t/* Zero-time sleeps are non-interesting */\n\tif (usecs <= 0)\n\t\treturn;\n\n\tmemset(&lat, 0, sizeof(lat));\n\tlat.count = 1;\n\tlat.time = usecs;\n\tlat.max = usecs;\n\n\tstack_trace_save_tsk(tsk, lat.backtrace, LT_BACKTRACEDEPTH, 0);\n\n\traw_spin_lock_irqsave(&latency_lock, flags);\n\n\taccount_global_scheduler_latency(tsk, &lat);\n\n\tfor (i = 0; i < tsk->latency_record_count; i++) {\n\t\tstruct latency_record *mylat;\n\t\tint same = 1;\n\n\t\tmylat = &tsk->latency_record[i];\n\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\tunsigned long record = lat.backtrace[q];\n\n\t\t\tif (mylat->backtrace[q] != record) {\n\t\t\t\tsame = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* 0 entry is end of backtrace */\n\t\t\tif (!record)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (same) {\n\t\t\tmylat->count++;\n\t\t\tmylat->time += lat.time;\n\t\t\tif (lat.time > mylat->max)\n\t\t\t\tmylat->max = lat.time;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * short term hack; if we're > 32 we stop; future we recycle:\n\t */\n\tif (tsk->latency_record_count >= LT_SAVECOUNT)\n\t\tgoto out_unlock;\n\n\t/* Allocated a new one: */\n\ti = tsk->latency_record_count++;\n\tmemcpy(&tsk->latency_record[i], &lat, sizeof(struct latency_record));\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&latency_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_hits",
          "args": [
            "SLEEP_PROFILING",
            "(void *)get_wchan(p)",
            "delta >> 20"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "profile_hits",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/profile.c",
          "lines": "322-327",
          "snippet": "void profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tif (prof_on != type || !prof_buffer)\n\t\treturn;\n\tdo_profile_hits(type, __pc, nr_hits);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/irq_regs.h>",
            "#include <asm/sections.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/highmem.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/mm.h>",
            "#include <linux/notifier.h>",
            "#include <linux/memblock.h>",
            "#include <linux/profile.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t *prof_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/ptrace.h>\n#include <asm/irq_regs.h>\n#include <asm/sections.h>\n#include <linux/sched/stat.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/highmem.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <linux/mm.h>\n#include <linux/notifier.h>\n#include <linux/memblock.h>\n#include <linux/profile.h>\n#include <linux/export.h>\n\nstatic atomic_t *prof_buffer;\n\nvoid profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tif (prof_on != type || !prof_buffer)\n\t\treturn;\n\tdo_profile_hits(type, __pc, nr_hits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_wchan",
          "args": [
            "p"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "get_wchan",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "1980-1997",
          "snippet": "unsigned long get_wchan(struct task_struct *p)\n{\n\tunsigned long ip = 0;\n\tunsigned int state;\n\n\tif (!p || p == current)\n\t\treturn 0;\n\n\t/* Only get wchan if task is blocked and we can keep it that way. */\n\traw_spin_lock_irq(&p->pi_lock);\n\tstate = READ_ONCE(p->__state);\n\tsmp_rmb(); /* see try_to_wake_up() */\n\tif (state != TASK_RUNNING && state != TASK_WAKING && !p->on_rq)\n\t\tip = __get_wchan(p);\n\traw_spin_unlock_irq(&p->pi_lock);\n\n\treturn ip;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nunsigned long get_wchan(struct task_struct *p)\n{\n\tunsigned long ip = 0;\n\tunsigned int state;\n\n\tif (!p || p == current)\n\t\treturn 0;\n\n\t/* Only get wchan if task is blocked and we can keep it that way. */\n\traw_spin_lock_irq(&p->pi_lock);\n\tstate = READ_ONCE(p->__state);\n\tsmp_rmb(); /* see try_to_wake_up() */\n\tif (state != TASK_RUNNING && state != TASK_WAKING && !p->on_rq)\n\t\tip = __get_wchan(p);\n\traw_spin_unlock_irq(&p->pi_lock);\n\n\treturn ip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "prof_on == SLEEP_PROFILING"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sched_stat_blocked",
          "args": [
            "p",
            "delta"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sched_stat_iowait",
          "args": [
            "p",
            "delta"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_inc",
          "args": [
            "stats->iowait_count"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_add",
          "args": [
            "stats->iowait_sum",
            "delta"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_add",
          "args": [
            "stats->sum_block_runtime",
            "delta"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_add",
          "args": [
            "stats->sum_sleep_runtime",
            "delta"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_set",
          "args": [
            "stats->block_start",
            "0"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_set",
          "args": [
            "stats->block_max",
            "delta"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "delta > schedstat_val(stats->block_max)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_val",
          "args": [
            "stats->block_max"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "trace_sched_stat_sleep",
          "args": [
            "p",
            "delta"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_add",
          "args": [
            "stats->sum_sleep_runtime",
            "delta"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_set",
          "args": [
            "stats->sleep_start",
            "0"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_set",
          "args": [
            "stats->sleep_max",
            "delta"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "delta > schedstat_val(stats->sleep_max)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_val",
          "args": [
            "stats->sleep_max"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_val",
          "args": [
            "stats->block_start"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_val",
          "args": [
            "stats->sleep_start"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __update_stats_enqueue_sleeper(struct rq *rq, struct task_struct *p,\n\t\t\t\t    struct sched_statistics *stats)\n{\n\tu64 sleep_start, block_start;\n\n\tsleep_start = schedstat_val(stats->sleep_start);\n\tblock_start = schedstat_val(stats->block_start);\n\n\tif (sleep_start) {\n\t\tu64 delta = rq_clock(rq) - sleep_start;\n\n\t\tif ((s64)delta < 0)\n\t\t\tdelta = 0;\n\n\t\tif (unlikely(delta > schedstat_val(stats->sleep_max)))\n\t\t\t__schedstat_set(stats->sleep_max, delta);\n\n\t\t__schedstat_set(stats->sleep_start, 0);\n\t\t__schedstat_add(stats->sum_sleep_runtime, delta);\n\n\t\tif (p) {\n\t\t\taccount_scheduler_latency(p, delta >> 10, 1);\n\t\t\ttrace_sched_stat_sleep(p, delta);\n\t\t}\n\t}\n\n\tif (block_start) {\n\t\tu64 delta = rq_clock(rq) - block_start;\n\n\t\tif ((s64)delta < 0)\n\t\t\tdelta = 0;\n\n\t\tif (unlikely(delta > schedstat_val(stats->block_max)))\n\t\t\t__schedstat_set(stats->block_max, delta);\n\n\t\t__schedstat_set(stats->block_start, 0);\n\t\t__schedstat_add(stats->sum_sleep_runtime, delta);\n\t\t__schedstat_add(stats->sum_block_runtime, delta);\n\n\t\tif (p) {\n\t\t\tif (p->in_iowait) {\n\t\t\t\t__schedstat_add(stats->iowait_sum, delta);\n\t\t\t\t__schedstat_inc(stats->iowait_count);\n\t\t\t\ttrace_sched_stat_iowait(p, delta);\n\t\t\t}\n\n\t\t\ttrace_sched_stat_blocked(p, delta);\n\n\t\t\t/*\n\t\t\t * Blocking time is in units of nanosecs, so shift by\n\t\t\t * 20 to get a milliseconds-range estimation of the\n\t\t\t * amount of time that the task spent sleeping:\n\t\t\t */\n\t\t\tif (unlikely(prof_on == SLEEP_PROFILING)) {\n\t\t\t\tprofile_hits(SLEEP_PROFILING,\n\t\t\t\t\t     (void *)get_wchan(p),\n\t\t\t\t\t     delta >> 20);\n\t\t\t}\n\t\t\taccount_scheduler_latency(p, delta >> 10, 0);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__update_stats_wait_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/stats.c",
    "lines": "21-46",
    "snippet": "void __update_stats_wait_end(struct rq *rq, struct task_struct *p,\n\t\t\t     struct sched_statistics *stats)\n{\n\tu64 delta = rq_clock(rq) - schedstat_val(stats->wait_start);\n\n\tif (p) {\n\t\tif (task_on_rq_migrating(p)) {\n\t\t\t/*\n\t\t\t * Preserve migrating task's wait time so wait_start\n\t\t\t * time stamp can be adjusted to accumulate wait time\n\t\t\t * prior to migration.\n\t\t\t */\n\t\t\t__schedstat_set(stats->wait_start, delta);\n\n\t\t\treturn;\n\t\t}\n\n\t\ttrace_sched_stat_wait(p, delta);\n\t}\n\n\t__schedstat_set(stats->wait_max,\n\t\t\tmax(schedstat_val(stats->wait_max), delta));\n\t__schedstat_inc(stats->wait_count);\n\t__schedstat_add(stats->wait_sum, delta);\n\t__schedstat_set(stats->wait_start, 0);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__schedstat_set",
          "args": [
            "stats->wait_start",
            "0"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_add",
          "args": [
            "stats->wait_sum",
            "delta"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_inc",
          "args": [
            "stats->wait_count"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_set",
          "args": [
            "stats->wait_max",
            "max(schedstat_val(stats->wait_max), delta)"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "schedstat_val(stats->wait_max)",
            "delta"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "254-257",
          "snippet": "static inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedstat_val",
          "args": [
            "stats->wait_max"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sched_stat_wait",
          "args": [
            "p",
            "delta"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__schedstat_set",
          "args": [
            "stats->wait_start",
            "delta"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_on_rq_migrating",
          "args": [
            "p"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_migrating",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2049-2052",
          "snippet": "static inline int task_on_rq_migrating(struct task_struct *p)\n{\n\treturn READ_ONCE(p->on_rq) == TASK_ON_RQ_MIGRATING;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_MIGRATING\t2"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_MIGRATING\t2\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_on_rq_migrating(struct task_struct *p)\n{\n\treturn READ_ONCE(p->on_rq) == TASK_ON_RQ_MIGRATING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedstat_val",
          "args": [
            "stats->wait_start"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __update_stats_wait_end(struct rq *rq, struct task_struct *p,\n\t\t\t     struct sched_statistics *stats)\n{\n\tu64 delta = rq_clock(rq) - schedstat_val(stats->wait_start);\n\n\tif (p) {\n\t\tif (task_on_rq_migrating(p)) {\n\t\t\t/*\n\t\t\t * Preserve migrating task's wait time so wait_start\n\t\t\t * time stamp can be adjusted to accumulate wait time\n\t\t\t * prior to migration.\n\t\t\t */\n\t\t\t__schedstat_set(stats->wait_start, delta);\n\n\t\t\treturn;\n\t\t}\n\n\t\ttrace_sched_stat_wait(p, delta);\n\t}\n\n\t__schedstat_set(stats->wait_max,\n\t\t\tmax(schedstat_val(stats->wait_max), delta));\n\t__schedstat_inc(stats->wait_count);\n\t__schedstat_add(stats->wait_sum, delta);\n\t__schedstat_set(stats->wait_start, 0);\n}"
  },
  {
    "function_name": "__update_stats_wait_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/stats.c",
    "lines": "7-19",
    "snippet": "void __update_stats_wait_start(struct rq *rq, struct task_struct *p,\n\t\t\t       struct sched_statistics *stats)\n{\n\tu64 wait_start, prev_wait_start;\n\n\twait_start = rq_clock(rq);\n\tprev_wait_start = schedstat_val(stats->wait_start);\n\n\tif (p && likely(wait_start > prev_wait_start))\n\t\twait_start -= prev_wait_start;\n\n\t__schedstat_set(stats->wait_start, wait_start);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__schedstat_set",
          "args": [
            "stats->wait_start",
            "wait_start"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "wait_start > prev_wait_start"
          ],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_val",
          "args": [
            "stats->wait_start"
          ],
          "line": 13
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 12
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __update_stats_wait_start(struct rq *rq, struct task_struct *p,\n\t\t\t       struct sched_statistics *stats)\n{\n\tu64 wait_start, prev_wait_start;\n\n\twait_start = rq_clock(rq);\n\tprev_wait_start = schedstat_val(stats->wait_start);\n\n\tif (p && likely(wait_start > prev_wait_start))\n\t\twait_start -= prev_wait_start;\n\n\t__schedstat_set(stats->wait_start, wait_start);\n}"
  }
]