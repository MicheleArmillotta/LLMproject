[
  {
    "function_name": "arch_kexec_unprotect_crashkres",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "1219-1220",
    "snippet": "void __weak arch_kexec_unprotect_crashkres(void)\n{}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid __weak arch_kexec_unprotect_crashkres(void)\n{}"
  },
  {
    "function_name": "arch_kexec_protect_crashkres",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "1216-1217",
    "snippet": "void __weak arch_kexec_protect_crashkres(void)\n{}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid __weak arch_kexec_protect_crashkres(void)\n{}"
  },
  {
    "function_name": "kernel_kexec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "1125-1207",
    "snippet": "int kernel_kexec(void)\n{\n\tint error = 0;\n\n\tif (!mutex_trylock(&kexec_mutex))\n\t\treturn -EBUSY;\n\tif (!kexec_image) {\n\t\terror = -EINVAL;\n\t\tgoto Unlock;\n\t}\n\n#ifdef CONFIG_KEXEC_JUMP\n\tif (kexec_image->preserve_context) {\n\t\tpm_prepare_console();\n\t\terror = freeze_processes();\n\t\tif (error) {\n\t\t\terror = -EBUSY;\n\t\t\tgoto Restore_console;\n\t\t}\n\t\tsuspend_console();\n\t\terror = dpm_suspend_start(PMSG_FREEZE);\n\t\tif (error)\n\t\t\tgoto Resume_console;\n\t\t/* At this point, dpm_suspend_start() has been called,\n\t\t * but *not* dpm_suspend_end(). We *must* call\n\t\t * dpm_suspend_end() now.  Otherwise, drivers for\n\t\t * some devices (e.g. interrupt controllers) become\n\t\t * desynchronized with the actual state of the\n\t\t * hardware at resume time, and evil weirdness ensues.\n\t\t */\n\t\terror = dpm_suspend_end(PMSG_FREEZE);\n\t\tif (error)\n\t\t\tgoto Resume_devices;\n\t\terror = suspend_disable_secondary_cpus();\n\t\tif (error)\n\t\t\tgoto Enable_cpus;\n\t\tlocal_irq_disable();\n\t\terror = syscore_suspend();\n\t\tif (error)\n\t\t\tgoto Enable_irqs;\n\t} else\n#endif\n\t{\n\t\tkexec_in_progress = true;\n\t\tkernel_restart_prepare(\"kexec reboot\");\n\t\tmigrate_to_reboot_cpu();\n\n\t\t/*\n\t\t * migrate_to_reboot_cpu() disables CPU hotplug assuming that\n\t\t * no further code needs to use CPU hotplug (which is true in\n\t\t * the reboot case). However, the kexec path depends on using\n\t\t * CPU hotplug again; so re-enable it here.\n\t\t */\n\t\tcpu_hotplug_enable();\n\t\tpr_notice(\"Starting new kernel\\n\");\n\t\tmachine_shutdown();\n\t}\n\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_kexec(kexec_image);\n\n#ifdef CONFIG_KEXEC_JUMP\n\tif (kexec_image->preserve_context) {\n\t\tsyscore_resume();\n Enable_irqs:\n\t\tlocal_irq_enable();\n Enable_cpus:\n\t\tsuspend_enable_secondary_cpus();\n\t\tdpm_resume_start(PMSG_RESTORE);\n Resume_devices:\n\t\tdpm_resume_end(PMSG_RESTORE);\n Resume_console:\n\t\tresume_console();\n\t\tthaw_processes();\n Restore_console:\n\t\tpm_restore_console();\n\t}\n#endif\n\n Unlock:\n\tmutex_unlock(&kexec_mutex);\n\treturn error;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool kexec_in_progress = false;",
      "struct kimage *kexec_image;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kexec_mutex"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_restore_console",
          "args": [],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "pm_restore_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
          "lines": "143-152",
          "snippet": "void pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int orig_fgconsole, orig_kmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "thaw_processes",
          "args": [],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_thaw_processes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "285-287",
          "snippet": "static inline void suspend_thaw_processes(void)\n{\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void suspend_thaw_processes(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "resume_console",
          "args": [],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "resume_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2484-2491",
          "snippet": "void resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;",
            "bool console_suspend_enabled = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nbool console_suspend_enabled = true;\n\nvoid resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpm_resume_end",
          "args": [
            "PMSG_RESTORE"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_resume_start",
          "args": [
            "PMSG_RESTORE"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suspend_enable_secondary_cpus",
          "args": [],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscore_resume",
          "args": [],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "irq_pm_syscore_resume",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/pm.c",
          "lines": "234-237",
          "snippet": "static void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/syscore_ops.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic void irq_pm_syscore_resume(void)\n{\n\tresume_irqs(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "machine_kexec",
          "args": [
            "kexec_image"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "machine_kexec_post_load",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "594-597",
          "snippet": "int __weak machine_kexec_post_load(struct kimage *image)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint __weak machine_kexec_post_load(struct kimage *image)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmsg_dump",
          "args": [
            "KMSG_DUMP_SHUTDOWN"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "kmsg_dump_rewind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3593-3597",
          "snippet": "void kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "machine_shutdown",
          "args": [],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"Starting new kernel\\n\""
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_hotplug_enable",
          "args": [],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_hotplug_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "388-393",
          "snippet": "void cpu_hotplug_enable(void)\n{\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tcpu_maps_update_done();\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpu_hotplug_enable(void)\n{\n\tcpu_maps_update_begin();\n\t__cpu_hotplug_enable();\n\tcpu_maps_update_done();\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_to_reboot_cpu",
          "args": [],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_to_reboot_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "220-236",
          "snippet": "void migrate_to_reboot_cpu(void)\n{\n\t/* The boot cpu is always logical cpu 0 */\n\tint cpu = reboot_cpu;\n\n\tcpu_hotplug_disable();\n\n\t/* Make certain the cpu I'm about to reboot on is online */\n\tif (!cpu_online(cpu))\n\t\tcpu = cpumask_first(cpu_online_mask);\n\n\t/* Prevent races with other tasks migrating this task */\n\tcurrent->flags |= PF_NO_SETAFFINITY;\n\n\t/* Make certain I only run on the appropriate processor */\n\tset_cpus_allowed_ptr(current, cpumask_of(cpu));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reboot_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nint reboot_cpu;\n\nvoid migrate_to_reboot_cpu(void)\n{\n\t/* The boot cpu is always logical cpu 0 */\n\tint cpu = reboot_cpu;\n\n\tcpu_hotplug_disable();\n\n\t/* Make certain the cpu I'm about to reboot on is online */\n\tif (!cpu_online(cpu))\n\t\tcpu = cpumask_first(cpu_online_mask);\n\n\t/* Prevent races with other tasks migrating this task */\n\tcurrent->flags |= PF_NO_SETAFFINITY;\n\n\t/* Make certain I only run on the appropriate processor */\n\tset_cpus_allowed_ptr(current, cpumask_of(cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_restart_prepare",
          "args": [
            "\"kexec reboot\""
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_restart_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "73-79",
          "snippet": "void kernel_restart_prepare(char *cmd)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list, SYS_RESTART, cmd);\n\tsystem_state = SYSTEM_RESTART;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid kernel_restart_prepare(char *cmd)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list, SYS_RESTART, cmd);\n\tsystem_state = SYSTEM_RESTART;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscore_suspend",
          "args": [],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suspend_disable_secondary_cpus",
          "args": [],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_suspend_end",
          "args": [
            "PMSG_FREEZE"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpm_suspend_start",
          "args": [
            "PMSG_FREEZE"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suspend_console",
          "args": [],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "2474-2482",
          "snippet": "void suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int console_locked, console_suspended;",
            "bool console_suspend_enabled = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int console_locked, console_suspended;\nbool console_suspend_enabled = true;\n\nvoid suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tpr_info(\"Suspending console(s) (use no_console_suspend to debug)\\n\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeze_processes",
          "args": [],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_freeze_processes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/power.h",
          "lines": "280-283",
          "snippet": "static inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int suspend_freeze_processes(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_prepare_console",
          "args": [],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "pm_prepare_console",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
          "lines": "130-141",
          "snippet": "void pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [
            "#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)"
          ],
          "globals_used": [
            "static int orig_fgconsole, orig_kmsg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\n#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&kexec_mutex"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1278-1284",
          "snippet": "static __always_inline int __rt_mutex_trylock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))\n\t\treturn 1;\n\n\treturn rt_mutex_slowtrylock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline int __rt_mutex_trylock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))\n\t\treturn 1;\n\n\treturn rt_mutex_slowtrylock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nbool kexec_in_progress = false;\nstruct kimage *kexec_image;\n\nint kernel_kexec(void)\n{\n\tint error = 0;\n\n\tif (!mutex_trylock(&kexec_mutex))\n\t\treturn -EBUSY;\n\tif (!kexec_image) {\n\t\terror = -EINVAL;\n\t\tgoto Unlock;\n\t}\n\n#ifdef CONFIG_KEXEC_JUMP\n\tif (kexec_image->preserve_context) {\n\t\tpm_prepare_console();\n\t\terror = freeze_processes();\n\t\tif (error) {\n\t\t\terror = -EBUSY;\n\t\t\tgoto Restore_console;\n\t\t}\n\t\tsuspend_console();\n\t\terror = dpm_suspend_start(PMSG_FREEZE);\n\t\tif (error)\n\t\t\tgoto Resume_console;\n\t\t/* At this point, dpm_suspend_start() has been called,\n\t\t * but *not* dpm_suspend_end(). We *must* call\n\t\t * dpm_suspend_end() now.  Otherwise, drivers for\n\t\t * some devices (e.g. interrupt controllers) become\n\t\t * desynchronized with the actual state of the\n\t\t * hardware at resume time, and evil weirdness ensues.\n\t\t */\n\t\terror = dpm_suspend_end(PMSG_FREEZE);\n\t\tif (error)\n\t\t\tgoto Resume_devices;\n\t\terror = suspend_disable_secondary_cpus();\n\t\tif (error)\n\t\t\tgoto Enable_cpus;\n\t\tlocal_irq_disable();\n\t\terror = syscore_suspend();\n\t\tif (error)\n\t\t\tgoto Enable_irqs;\n\t} else\n#endif\n\t{\n\t\tkexec_in_progress = true;\n\t\tkernel_restart_prepare(\"kexec reboot\");\n\t\tmigrate_to_reboot_cpu();\n\n\t\t/*\n\t\t * migrate_to_reboot_cpu() disables CPU hotplug assuming that\n\t\t * no further code needs to use CPU hotplug (which is true in\n\t\t * the reboot case). However, the kexec path depends on using\n\t\t * CPU hotplug again; so re-enable it here.\n\t\t */\n\t\tcpu_hotplug_enable();\n\t\tpr_notice(\"Starting new kernel\\n\");\n\t\tmachine_shutdown();\n\t}\n\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_kexec(kexec_image);\n\n#ifdef CONFIG_KEXEC_JUMP\n\tif (kexec_image->preserve_context) {\n\t\tsyscore_resume();\n Enable_irqs:\n\t\tlocal_irq_enable();\n Enable_cpus:\n\t\tsuspend_enable_secondary_cpus();\n\t\tdpm_resume_start(PMSG_RESTORE);\n Resume_devices:\n\t\tdpm_resume_end(PMSG_RESTORE);\n Resume_console:\n\t\tresume_console();\n\t\tthaw_processes();\n Restore_console:\n\t\tpm_restore_console();\n\t}\n#endif\n\n Unlock:\n\tmutex_unlock(&kexec_mutex);\n\treturn error;\n}"
  },
  {
    "function_name": "crash_notes_memory_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "1087-1117",
    "snippet": "static int __init crash_notes_memory_init(void)\n{\n\t/* Allocate memory for saving cpu registers. */\n\tsize_t size, align;\n\n\t/*\n\t * crash_notes could be allocated across 2 vmalloc pages when percpu\n\t * is vmalloc based . vmalloc doesn't guarantee 2 continuous vmalloc\n\t * pages are also on 2 continuous physical pages. In this case the\n\t * 2nd part of crash_notes in 2nd page could be lost since only the\n\t * starting address and size of crash_notes are exported through sysfs.\n\t * Here round up the size of crash_notes to the nearest power of two\n\t * and pass it to __alloc_percpu as align value. This can make sure\n\t * crash_notes is allocated inside one physical page.\n\t */\n\tsize = sizeof(note_buf_t);\n\talign = min(roundup_pow_of_two(sizeof(note_buf_t)), PAGE_SIZE);\n\n\t/*\n\t * Break compile if size is bigger than PAGE_SIZE since crash_notes\n\t * definitely will be in 2 pages with that.\n\t */\n\tBUILD_BUG_ON(size > PAGE_SIZE);\n\n\tcrash_notes = __alloc_percpu(size, align);\n\tif (!crash_notes) {\n\t\tpr_warn(\"Memory allocation for saving cpu register states failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "note_buf_t __percpu *crash_notes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Memory allocation for saving cpu register states failed\\n\""
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_percpu",
          "args": [
            "size",
            "align"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "size > PAGE_SIZE"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "roundup_pow_of_two(sizeof(note_buf_t))",
            "PAGE_SIZE"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "sizeof(note_buf_t)"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nnote_buf_t __percpu *crash_notes;\n\nstatic int __init crash_notes_memory_init(void)\n{\n\t/* Allocate memory for saving cpu registers. */\n\tsize_t size, align;\n\n\t/*\n\t * crash_notes could be allocated across 2 vmalloc pages when percpu\n\t * is vmalloc based . vmalloc doesn't guarantee 2 continuous vmalloc\n\t * pages are also on 2 continuous physical pages. In this case the\n\t * 2nd part of crash_notes in 2nd page could be lost since only the\n\t * starting address and size of crash_notes are exported through sysfs.\n\t * Here round up the size of crash_notes to the nearest power of two\n\t * and pass it to __alloc_percpu as align value. This can make sure\n\t * crash_notes is allocated inside one physical page.\n\t */\n\tsize = sizeof(note_buf_t);\n\talign = min(roundup_pow_of_two(sizeof(note_buf_t)), PAGE_SIZE);\n\n\t/*\n\t * Break compile if size is bigger than PAGE_SIZE since crash_notes\n\t * definitely will be in 2 pages with that.\n\t */\n\tBUILD_BUG_ON(size > PAGE_SIZE);\n\n\tcrash_notes = __alloc_percpu(size, align);\n\tif (!crash_notes) {\n\t\tpr_warn(\"Memory allocation for saving cpu register states failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "crash_save_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "1061-1085",
    "snippet": "void crash_save_cpu(struct pt_regs *regs, int cpu)\n{\n\tstruct elf_prstatus prstatus;\n\tu32 *buf;\n\n\tif ((cpu < 0) || (cpu >= nr_cpu_ids))\n\t\treturn;\n\n\t/* Using ELF notes here is opportunistic.\n\t * I need a well defined structure format\n\t * for the data I pass, and I need tags\n\t * on the data to indicate what information I have\n\t * squirrelled away.  ELF notes happen to provide\n\t * all of that, so there is no need to invent something new.\n\t */\n\tbuf = (u32 *)per_cpu_ptr(crash_notes, cpu);\n\tif (!buf)\n\t\treturn;\n\tmemset(&prstatus, 0, sizeof(prstatus));\n\tprstatus.common.pr_pid = current->pid;\n\telf_core_copy_kernel_regs(&prstatus.pr_reg, regs);\n\tbuf = append_elf_note(buf, KEXEC_CORE_NOTE_NAME, NT_PRSTATUS,\n\t\t\t      &prstatus, sizeof(prstatus));\n\tfinal_note(buf);\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "note_buf_t __percpu *crash_notes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "final_note",
          "args": [
            "buf"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "final_note",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "326-329",
          "snippet": "void final_note(Elf_Word *buf)\n{\n\tmemset(buf, 0, sizeof(struct elf_note));\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nvoid final_note(Elf_Word *buf)\n{\n\tmemset(buf, 0, sizeof(struct elf_note));\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_elf_note",
          "args": [
            "buf",
            "KEXEC_CORE_NOTE_NAME",
            "NT_PRSTATUS",
            "&prstatus",
            "sizeof(prstatus)"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "append_elf_note",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "309-324",
          "snippet": "Elf_Word *append_elf_note(Elf_Word *buf, char *name, unsigned int type,\n\t\t\t  void *data, size_t data_len)\n{\n\tstruct elf_note *note = (struct elf_note *)buf;\n\n\tnote->n_namesz = strlen(name) + 1;\n\tnote->n_descsz = data_len;\n\tnote->n_type   = type;\n\tbuf += DIV_ROUND_UP(sizeof(*note), sizeof(Elf_Word));\n\tmemcpy(buf, name, note->n_namesz);\n\tbuf += DIV_ROUND_UP(note->n_namesz, sizeof(Elf_Word));\n\tmemcpy(buf, data, data_len);\n\tbuf += DIV_ROUND_UP(data_len, sizeof(Elf_Word));\n\n\treturn buf;\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nElf_Word *append_elf_note(Elf_Word *buf, char *name, unsigned int type,\n\t\t\t  void *data, size_t data_len)\n{\n\tstruct elf_note *note = (struct elf_note *)buf;\n\n\tnote->n_namesz = strlen(name) + 1;\n\tnote->n_descsz = data_len;\n\tnote->n_type   = type;\n\tbuf += DIV_ROUND_UP(sizeof(*note), sizeof(Elf_Word));\n\tmemcpy(buf, name, note->n_namesz);\n\tbuf += DIV_ROUND_UP(note->n_namesz, sizeof(Elf_Word));\n\tmemcpy(buf, data, data_len);\n\tbuf += DIV_ROUND_UP(data_len, sizeof(Elf_Word));\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_copy_kernel_regs",
          "args": [
            "&prstatus.pr_reg",
            "regs"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&prstatus",
            "0",
            "sizeof(prstatus)"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "crash_notes",
            "cpu"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nnote_buf_t __percpu *crash_notes;\n\nvoid crash_save_cpu(struct pt_regs *regs, int cpu)\n{\n\tstruct elf_prstatus prstatus;\n\tu32 *buf;\n\n\tif ((cpu < 0) || (cpu >= nr_cpu_ids))\n\t\treturn;\n\n\t/* Using ELF notes here is opportunistic.\n\t * I need a well defined structure format\n\t * for the data I pass, and I need tags\n\t * on the data to indicate what information I have\n\t * squirrelled away.  ELF notes happen to provide\n\t * all of that, so there is no need to invent something new.\n\t */\n\tbuf = (u32 *)per_cpu_ptr(crash_notes, cpu);\n\tif (!buf)\n\t\treturn;\n\tmemset(&prstatus, 0, sizeof(prstatus));\n\tprstatus.common.pr_pid = current->pid;\n\telf_core_copy_kernel_regs(&prstatus.pr_reg, regs);\n\tbuf = append_elf_note(buf, KEXEC_CORE_NOTE_NAME, NT_PRSTATUS,\n\t\t\t      &prstatus, sizeof(prstatus));\n\tfinal_note(buf);\n}"
  },
  {
    "function_name": "crash_shrink_memory",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "1012-1059",
    "snippet": "int crash_shrink_memory(unsigned long new_size)\n{\n\tint ret = 0;\n\tunsigned long start, end;\n\tunsigned long old_size;\n\tstruct resource *ram_res;\n\n\tmutex_lock(&kexec_mutex);\n\n\tif (kexec_crash_image) {\n\t\tret = -ENOENT;\n\t\tgoto unlock;\n\t}\n\tstart = crashk_res.start;\n\tend = crashk_res.end;\n\told_size = (end == 0) ? 0 : end - start + 1;\n\tif (new_size >= old_size) {\n\t\tret = (new_size == old_size) ? 0 : -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tram_res = kzalloc(sizeof(*ram_res), GFP_KERNEL);\n\tif (!ram_res) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tstart = roundup(start, KEXEC_CRASH_MEM_ALIGN);\n\tend = roundup(start + new_size, KEXEC_CRASH_MEM_ALIGN);\n\n\tcrash_free_reserved_phys_range(end, crashk_res.end);\n\n\tif ((start == end) && (crashk_res.parent != NULL))\n\t\trelease_resource(&crashk_res);\n\n\tram_res->start = end;\n\tram_res->end = crashk_res.end;\n\tram_res->flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM;\n\tram_res->name = \"System RAM\";\n\n\tcrashk_res.end = end - 1;\n\n\tinsert_resource(&iomem_resource, ram_res);\n\nunlock:\n\tmutex_unlock(&kexec_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource crashk_res = {\n\t.name  = \"Crash kernel\",\n\t.start = 0,\n\t.end   = 0,\n\t.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,\n\t.desc  = IORES_DESC_CRASH_KERNEL\n};",
      "struct kimage *kexec_crash_image;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kexec_mutex"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_resource",
          "args": [
            "&iomem_resource",
            "ram_res"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "insert_resource_expand_to_fit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "894-918",
          "snippet": "void insert_resource_expand_to_fit(struct resource *root, struct resource *new)\n{\n\tif (new->parent)\n\t\treturn;\n\n\twrite_lock(&resource_lock);\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tconflict = __insert_resource(root, new);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\tif (conflict == root)\n\t\t\tbreak;\n\n\t\t/* Ok, expand resource to cover the conflict, then try again .. */\n\t\tif (conflict->start < new->start)\n\t\t\tnew->start = conflict->start;\n\t\tif (conflict->end > new->end)\n\t\t\tnew->end = conflict->end;\n\n\t\tprintk(\"Expanded resource %s due to conflict with %s\\n\", new->name, conflict->name);\n\t}\n\twrite_unlock(&resource_lock);\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nvoid insert_resource_expand_to_fit(struct resource *root, struct resource *new)\n{\n\tif (new->parent)\n\t\treturn;\n\n\twrite_lock(&resource_lock);\n\tfor (;;) {\n\t\tstruct resource *conflict;\n\n\t\tconflict = __insert_resource(root, new);\n\t\tif (!conflict)\n\t\t\tbreak;\n\t\tif (conflict == root)\n\t\t\tbreak;\n\n\t\t/* Ok, expand resource to cover the conflict, then try again .. */\n\t\tif (conflict->start < new->start)\n\t\t\tnew->start = conflict->start;\n\t\tif (conflict->end > new->end)\n\t\t\tnew->end = conflict->end;\n\n\t\tprintk(\"Expanded resource %s due to conflict with %s\\n\", new->name, conflict->name);\n\t}\n\twrite_unlock(&resource_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_resource",
          "args": [
            "&crashk_res"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "release_resource",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "321-329",
          "snippet": "int release_resource(struct resource *old)\n{\n\tint retval;\n\n\twrite_lock(&resource_lock);\n\tretval = __release_resource(old, true);\n\twrite_unlock(&resource_lock);\n\treturn retval;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nint release_resource(struct resource *old)\n{\n\tint retval;\n\n\twrite_lock(&resource_lock);\n\tretval = __release_resource(old, true);\n\twrite_unlock(&resource_lock);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crash_free_reserved_phys_range",
          "args": [
            "end",
            "crashk_res.end"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "crash_free_reserved_phys_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "1003-1010",
          "snippet": "void __weak crash_free_reserved_phys_range(unsigned long begin,\n\t\t\t\t\t   unsigned long end)\n{\n\tunsigned long addr;\n\n\tfor (addr = begin; addr < end; addr += PAGE_SIZE)\n\t\tfree_reserved_page(boot_pfn_to_page(addr >> PAGE_SHIFT));\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid __weak crash_free_reserved_phys_range(unsigned long begin,\n\t\t\t\t\t   unsigned long end)\n{\n\tunsigned long addr;\n\n\tfor (addr = begin; addr < end; addr += PAGE_SIZE)\n\t\tfree_reserved_page(boot_pfn_to_page(addr >> PAGE_SHIFT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "start + new_size",
            "KEXEC_CRASH_MEM_ALIGN"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "start",
            "KEXEC_CRASH_MEM_ALIGN"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ram_res)",
            "GFP_KERNEL"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kexec_mutex"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct resource crashk_res = {\n\t.name  = \"Crash kernel\",\n\t.start = 0,\n\t.end   = 0,\n\t.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,\n\t.desc  = IORES_DESC_CRASH_KERNEL\n};\nstruct kimage *kexec_crash_image;\n\nint crash_shrink_memory(unsigned long new_size)\n{\n\tint ret = 0;\n\tunsigned long start, end;\n\tunsigned long old_size;\n\tstruct resource *ram_res;\n\n\tmutex_lock(&kexec_mutex);\n\n\tif (kexec_crash_image) {\n\t\tret = -ENOENT;\n\t\tgoto unlock;\n\t}\n\tstart = crashk_res.start;\n\tend = crashk_res.end;\n\told_size = (end == 0) ? 0 : end - start + 1;\n\tif (new_size >= old_size) {\n\t\tret = (new_size == old_size) ? 0 : -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tram_res = kzalloc(sizeof(*ram_res), GFP_KERNEL);\n\tif (!ram_res) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tstart = roundup(start, KEXEC_CRASH_MEM_ALIGN);\n\tend = roundup(start + new_size, KEXEC_CRASH_MEM_ALIGN);\n\n\tcrash_free_reserved_phys_range(end, crashk_res.end);\n\n\tif ((start == end) && (crashk_res.parent != NULL))\n\t\trelease_resource(&crashk_res);\n\n\tram_res->start = end;\n\tram_res->end = crashk_res.end;\n\tram_res->flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM;\n\tram_res->name = \"System RAM\";\n\n\tcrashk_res.end = end - 1;\n\n\tinsert_resource(&iomem_resource, ram_res);\n\nunlock:\n\tmutex_unlock(&kexec_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "crash_free_reserved_phys_range",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "1003-1010",
    "snippet": "void __weak crash_free_reserved_phys_range(unsigned long begin,\n\t\t\t\t\t   unsigned long end)\n{\n\tunsigned long addr;\n\n\tfor (addr = begin; addr < end; addr += PAGE_SIZE)\n\t\tfree_reserved_page(boot_pfn_to_page(addr >> PAGE_SHIFT));\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_reserved_page",
          "args": [
            "boot_pfn_to_page(addr >> PAGE_SHIFT)"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_pfn_to_page",
          "args": [
            "addr >> PAGE_SHIFT"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid __weak crash_free_reserved_phys_range(unsigned long begin,\n\t\t\t\t\t   unsigned long end)\n{\n\tunsigned long addr;\n\n\tfor (addr = begin; addr < end; addr += PAGE_SIZE)\n\t\tfree_reserved_page(boot_pfn_to_page(addr >> PAGE_SHIFT));\n}"
  },
  {
    "function_name": "crash_get_memory_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "992-1001",
    "snippet": "size_t crash_get_memory_size(void)\n{\n\tsize_t size = 0;\n\n\tmutex_lock(&kexec_mutex);\n\tif (crashk_res.end != crashk_res.start)\n\t\tsize = resource_size(&crashk_res);\n\tmutex_unlock(&kexec_mutex);\n\treturn size;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource crashk_res = {\n\t.name  = \"Crash kernel\",\n\t.start = 0,\n\t.end   = 0,\n\t.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,\n\t.desc  = IORES_DESC_CRASH_KERNEL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kexec_mutex"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "resource_size",
          "args": [
            "&crashk_res"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kexec_mutex"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct resource crashk_res = {\n\t.name  = \"Crash kernel\",\n\t.start = 0,\n\t.end   = 0,\n\t.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,\n\t.desc  = IORES_DESC_CRASH_KERNEL\n};\n\nsize_t crash_get_memory_size(void)\n{\n\tsize_t size = 0;\n\n\tmutex_lock(&kexec_mutex);\n\tif (crashk_res.end != crashk_res.start)\n\t\tsize = resource_size(&crashk_res);\n\tmutex_unlock(&kexec_mutex);\n\treturn size;\n}"
  },
  {
    "function_name": "crash_kexec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "969-990",
    "snippet": "void crash_kexec(struct pt_regs *regs)\n{\n\tint old_cpu, this_cpu;\n\n\t/*\n\t * Only one CPU is allowed to execute the crash_kexec() code as with\n\t * panic().  Otherwise parallel calls of panic() and crash_kexec()\n\t * may stop each other.  To exclude them, we use panic_cpu here too.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\tif (old_cpu == PANIC_CPU_INVALID) {\n\t\t/* This is the 1st CPU which comes here, so go ahead. */\n\t\t__crash_kexec(regs);\n\n\t\t/*\n\t\t * Reset panic_cpu to allow another panic()/crash_kexec()\n\t\t * call.\n\t\t */\n\t\tatomic_set(&panic_cpu, PANIC_CPU_INVALID);\n\t}\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&panic_cpu",
            "PANIC_CPU_INVALID"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__crash_kexec",
          "args": [
            "regs"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "__crash_kexec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "945-966",
          "snippet": "void __noclone __crash_kexec(struct pt_regs *regs)\n{\n\t/* Take the kexec_mutex here to prevent sys_kexec_load\n\t * running on one cpu from replacing the crash kernel\n\t * we are using after a panic on a different cpu.\n\t *\n\t * If the crash kernel was not located in a fixed area\n\t * of memory the xchg(&kexec_crash_image) would be\n\t * sufficient.  But since I reuse the memory...\n\t */\n\tif (mutex_trylock(&kexec_mutex)) {\n\t\tif (kexec_crash_image) {\n\t\t\tstruct pt_regs fixed_regs;\n\n\t\t\tcrash_setup_regs(&fixed_regs, regs);\n\t\t\tcrash_save_vmcoreinfo();\n\t\t\tmachine_crash_shutdown(&fixed_regs);\n\t\t\tmachine_kexec(kexec_crash_image);\n\t\t}\n\t\tmutex_unlock(&kexec_mutex);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kimage *kexec_crash_image;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct kimage *kexec_crash_image;\n\nvoid __noclone __crash_kexec(struct pt_regs *regs)\n{\n\t/* Take the kexec_mutex here to prevent sys_kexec_load\n\t * running on one cpu from replacing the crash kernel\n\t * we are using after a panic on a different cpu.\n\t *\n\t * If the crash kernel was not located in a fixed area\n\t * of memory the xchg(&kexec_crash_image) would be\n\t * sufficient.  But since I reuse the memory...\n\t */\n\tif (mutex_trylock(&kexec_mutex)) {\n\t\tif (kexec_crash_image) {\n\t\t\tstruct pt_regs fixed_regs;\n\n\t\t\tcrash_setup_regs(&fixed_regs, regs);\n\t\t\tcrash_save_vmcoreinfo();\n\t\t\tmachine_crash_shutdown(&fixed_regs);\n\t\t\tmachine_kexec(kexec_crash_image);\n\t\t}\n\t\tmutex_unlock(&kexec_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&panic_cpu",
            "PANIC_CPU_INVALID",
            "this_cpu"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid crash_kexec(struct pt_regs *regs)\n{\n\tint old_cpu, this_cpu;\n\n\t/*\n\t * Only one CPU is allowed to execute the crash_kexec() code as with\n\t * panic().  Otherwise parallel calls of panic() and crash_kexec()\n\t * may stop each other.  To exclude them, we use panic_cpu here too.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\tif (old_cpu == PANIC_CPU_INVALID) {\n\t\t/* This is the 1st CPU which comes here, so go ahead. */\n\t\t__crash_kexec(regs);\n\n\t\t/*\n\t\t * Reset panic_cpu to allow another panic()/crash_kexec()\n\t\t * call.\n\t\t */\n\t\tatomic_set(&panic_cpu, PANIC_CPU_INVALID);\n\t}\n}"
  },
  {
    "function_name": "__crash_kexec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "945-966",
    "snippet": "void __noclone __crash_kexec(struct pt_regs *regs)\n{\n\t/* Take the kexec_mutex here to prevent sys_kexec_load\n\t * running on one cpu from replacing the crash kernel\n\t * we are using after a panic on a different cpu.\n\t *\n\t * If the crash kernel was not located in a fixed area\n\t * of memory the xchg(&kexec_crash_image) would be\n\t * sufficient.  But since I reuse the memory...\n\t */\n\tif (mutex_trylock(&kexec_mutex)) {\n\t\tif (kexec_crash_image) {\n\t\t\tstruct pt_regs fixed_regs;\n\n\t\t\tcrash_setup_regs(&fixed_regs, regs);\n\t\t\tcrash_save_vmcoreinfo();\n\t\t\tmachine_crash_shutdown(&fixed_regs);\n\t\t\tmachine_kexec(kexec_crash_image);\n\t\t}\n\t\tmutex_unlock(&kexec_mutex);\n\t}\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kimage *kexec_crash_image;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kexec_mutex"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "machine_kexec",
          "args": [
            "kexec_crash_image"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "machine_kexec_post_load",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "594-597",
          "snippet": "int __weak machine_kexec_post_load(struct kimage *image)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint __weak machine_kexec_post_load(struct kimage *image)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "machine_crash_shutdown",
          "args": [
            "&fixed_regs"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_save_vmcoreinfo",
          "args": [],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "crash_save_vmcoreinfo_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "393-491",
          "snippet": "static int __init crash_save_vmcoreinfo_init(void)\n{\n\tvmcoreinfo_data = (unsigned char *)get_zeroed_page(GFP_KERNEL);\n\tif (!vmcoreinfo_data) {\n\t\tpr_warn(\"Memory allocation for vmcoreinfo_data failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tvmcoreinfo_note = alloc_pages_exact(VMCOREINFO_NOTE_SIZE,\n\t\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\tif (!vmcoreinfo_note) {\n\t\tfree_page((unsigned long)vmcoreinfo_data);\n\t\tvmcoreinfo_data = NULL;\n\t\tpr_warn(\"Memory allocation for vmcoreinfo_note failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tVMCOREINFO_OSRELEASE(init_uts_ns.name.release);\n\tVMCOREINFO_BUILD_ID();\n\tVMCOREINFO_PAGESIZE(PAGE_SIZE);\n\n\tVMCOREINFO_SYMBOL(init_uts_ns);\n\tVMCOREINFO_OFFSET(uts_namespace, name);\n\tVMCOREINFO_SYMBOL(node_online_map);\n#ifdef CONFIG_MMU\n\tVMCOREINFO_SYMBOL_ARRAY(swapper_pg_dir);\n#endif\n\tVMCOREINFO_SYMBOL(_stext);\n\tVMCOREINFO_SYMBOL(vmap_area_list);\n\n#ifndef CONFIG_NUMA\n\tVMCOREINFO_SYMBOL(mem_map);\n\tVMCOREINFO_SYMBOL(contig_page_data);\n#endif\n#ifdef CONFIG_SPARSEMEM\n\tVMCOREINFO_SYMBOL_ARRAY(mem_section);\n\tVMCOREINFO_LENGTH(mem_section, NR_SECTION_ROOTS);\n\tVMCOREINFO_STRUCT_SIZE(mem_section);\n\tVMCOREINFO_OFFSET(mem_section, section_mem_map);\n\tVMCOREINFO_NUMBER(SECTION_SIZE_BITS);\n\tVMCOREINFO_NUMBER(MAX_PHYSMEM_BITS);\n#endif\n\tVMCOREINFO_STRUCT_SIZE(page);\n\tVMCOREINFO_STRUCT_SIZE(pglist_data);\n\tVMCOREINFO_STRUCT_SIZE(zone);\n\tVMCOREINFO_STRUCT_SIZE(free_area);\n\tVMCOREINFO_STRUCT_SIZE(list_head);\n\tVMCOREINFO_SIZE(nodemask_t);\n\tVMCOREINFO_OFFSET(page, flags);\n\tVMCOREINFO_OFFSET(page, _refcount);\n\tVMCOREINFO_OFFSET(page, mapping);\n\tVMCOREINFO_OFFSET(page, lru);\n\tVMCOREINFO_OFFSET(page, _mapcount);\n\tVMCOREINFO_OFFSET(page, private);\n\tVMCOREINFO_OFFSET(page, compound_dtor);\n\tVMCOREINFO_OFFSET(page, compound_order);\n\tVMCOREINFO_OFFSET(page, compound_head);\n\tVMCOREINFO_OFFSET(pglist_data, node_zones);\n\tVMCOREINFO_OFFSET(pglist_data, nr_zones);\n#ifdef CONFIG_FLATMEM\n\tVMCOREINFO_OFFSET(pglist_data, node_mem_map);\n#endif\n\tVMCOREINFO_OFFSET(pglist_data, node_start_pfn);\n\tVMCOREINFO_OFFSET(pglist_data, node_spanned_pages);\n\tVMCOREINFO_OFFSET(pglist_data, node_id);\n\tVMCOREINFO_OFFSET(zone, free_area);\n\tVMCOREINFO_OFFSET(zone, vm_stat);\n\tVMCOREINFO_OFFSET(zone, spanned_pages);\n\tVMCOREINFO_OFFSET(free_area, free_list);\n\tVMCOREINFO_OFFSET(list_head, next);\n\tVMCOREINFO_OFFSET(list_head, prev);\n\tVMCOREINFO_OFFSET(vmap_area, va_start);\n\tVMCOREINFO_OFFSET(vmap_area, list);\n\tVMCOREINFO_LENGTH(zone.free_area, MAX_ORDER);\n\tlog_buf_vmcoreinfo_setup();\n\tVMCOREINFO_LENGTH(free_area.free_list, MIGRATE_TYPES);\n\tVMCOREINFO_NUMBER(NR_FREE_PAGES);\n\tVMCOREINFO_NUMBER(PG_lru);\n\tVMCOREINFO_NUMBER(PG_private);\n\tVMCOREINFO_NUMBER(PG_swapcache);\n\tVMCOREINFO_NUMBER(PG_swapbacked);\n\tVMCOREINFO_NUMBER(PG_slab);\n#ifdef CONFIG_MEMORY_FAILURE\n\tVMCOREINFO_NUMBER(PG_hwpoison);\n#endif\n\tVMCOREINFO_NUMBER(PG_head_mask);\n#define PAGE_BUDDY_MAPCOUNT_VALUE\t(~PG_buddy)\n\tVMCOREINFO_NUMBER(PAGE_BUDDY_MAPCOUNT_VALUE);\n#ifdef CONFIG_HUGETLB_PAGE\n\tVMCOREINFO_NUMBER(HUGETLB_PAGE_DTOR);\n#define PAGE_OFFLINE_MAPCOUNT_VALUE\t(~PG_offline)\n\tVMCOREINFO_NUMBER(PAGE_OFFLINE_MAPCOUNT_VALUE);\n#endif\n\n\tarch_crash_save_vmcoreinfo();\n\tupdate_vmcoreinfo_note();\n\n\treturn 0;\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [
            "#define PAGE_OFFLINE_MAPCOUNT_VALUE\t(~PG_offline)",
            "#define PAGE_BUDDY_MAPCOUNT_VALUE\t(~PG_buddy)"
          ],
          "globals_used": [
            "unsigned char *vmcoreinfo_data;",
            "u32 *vmcoreinfo_note;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\n#define PAGE_OFFLINE_MAPCOUNT_VALUE\t(~PG_offline)\n#define PAGE_BUDDY_MAPCOUNT_VALUE\t(~PG_buddy)\n\nunsigned char *vmcoreinfo_data;\nu32 *vmcoreinfo_note;\n\nstatic int __init crash_save_vmcoreinfo_init(void)\n{\n\tvmcoreinfo_data = (unsigned char *)get_zeroed_page(GFP_KERNEL);\n\tif (!vmcoreinfo_data) {\n\t\tpr_warn(\"Memory allocation for vmcoreinfo_data failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tvmcoreinfo_note = alloc_pages_exact(VMCOREINFO_NOTE_SIZE,\n\t\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\tif (!vmcoreinfo_note) {\n\t\tfree_page((unsigned long)vmcoreinfo_data);\n\t\tvmcoreinfo_data = NULL;\n\t\tpr_warn(\"Memory allocation for vmcoreinfo_note failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tVMCOREINFO_OSRELEASE(init_uts_ns.name.release);\n\tVMCOREINFO_BUILD_ID();\n\tVMCOREINFO_PAGESIZE(PAGE_SIZE);\n\n\tVMCOREINFO_SYMBOL(init_uts_ns);\n\tVMCOREINFO_OFFSET(uts_namespace, name);\n\tVMCOREINFO_SYMBOL(node_online_map);\n#ifdef CONFIG_MMU\n\tVMCOREINFO_SYMBOL_ARRAY(swapper_pg_dir);\n#endif\n\tVMCOREINFO_SYMBOL(_stext);\n\tVMCOREINFO_SYMBOL(vmap_area_list);\n\n#ifndef CONFIG_NUMA\n\tVMCOREINFO_SYMBOL(mem_map);\n\tVMCOREINFO_SYMBOL(contig_page_data);\n#endif\n#ifdef CONFIG_SPARSEMEM\n\tVMCOREINFO_SYMBOL_ARRAY(mem_section);\n\tVMCOREINFO_LENGTH(mem_section, NR_SECTION_ROOTS);\n\tVMCOREINFO_STRUCT_SIZE(mem_section);\n\tVMCOREINFO_OFFSET(mem_section, section_mem_map);\n\tVMCOREINFO_NUMBER(SECTION_SIZE_BITS);\n\tVMCOREINFO_NUMBER(MAX_PHYSMEM_BITS);\n#endif\n\tVMCOREINFO_STRUCT_SIZE(page);\n\tVMCOREINFO_STRUCT_SIZE(pglist_data);\n\tVMCOREINFO_STRUCT_SIZE(zone);\n\tVMCOREINFO_STRUCT_SIZE(free_area);\n\tVMCOREINFO_STRUCT_SIZE(list_head);\n\tVMCOREINFO_SIZE(nodemask_t);\n\tVMCOREINFO_OFFSET(page, flags);\n\tVMCOREINFO_OFFSET(page, _refcount);\n\tVMCOREINFO_OFFSET(page, mapping);\n\tVMCOREINFO_OFFSET(page, lru);\n\tVMCOREINFO_OFFSET(page, _mapcount);\n\tVMCOREINFO_OFFSET(page, private);\n\tVMCOREINFO_OFFSET(page, compound_dtor);\n\tVMCOREINFO_OFFSET(page, compound_order);\n\tVMCOREINFO_OFFSET(page, compound_head);\n\tVMCOREINFO_OFFSET(pglist_data, node_zones);\n\tVMCOREINFO_OFFSET(pglist_data, nr_zones);\n#ifdef CONFIG_FLATMEM\n\tVMCOREINFO_OFFSET(pglist_data, node_mem_map);\n#endif\n\tVMCOREINFO_OFFSET(pglist_data, node_start_pfn);\n\tVMCOREINFO_OFFSET(pglist_data, node_spanned_pages);\n\tVMCOREINFO_OFFSET(pglist_data, node_id);\n\tVMCOREINFO_OFFSET(zone, free_area);\n\tVMCOREINFO_OFFSET(zone, vm_stat);\n\tVMCOREINFO_OFFSET(zone, spanned_pages);\n\tVMCOREINFO_OFFSET(free_area, free_list);\n\tVMCOREINFO_OFFSET(list_head, next);\n\tVMCOREINFO_OFFSET(list_head, prev);\n\tVMCOREINFO_OFFSET(vmap_area, va_start);\n\tVMCOREINFO_OFFSET(vmap_area, list);\n\tVMCOREINFO_LENGTH(zone.free_area, MAX_ORDER);\n\tlog_buf_vmcoreinfo_setup();\n\tVMCOREINFO_LENGTH(free_area.free_list, MIGRATE_TYPES);\n\tVMCOREINFO_NUMBER(NR_FREE_PAGES);\n\tVMCOREINFO_NUMBER(PG_lru);\n\tVMCOREINFO_NUMBER(PG_private);\n\tVMCOREINFO_NUMBER(PG_swapcache);\n\tVMCOREINFO_NUMBER(PG_swapbacked);\n\tVMCOREINFO_NUMBER(PG_slab);\n#ifdef CONFIG_MEMORY_FAILURE\n\tVMCOREINFO_NUMBER(PG_hwpoison);\n#endif\n\tVMCOREINFO_NUMBER(PG_head_mask);\n#define PAGE_BUDDY_MAPCOUNT_VALUE\t(~PG_buddy)\n\tVMCOREINFO_NUMBER(PAGE_BUDDY_MAPCOUNT_VALUE);\n#ifdef CONFIG_HUGETLB_PAGE\n\tVMCOREINFO_NUMBER(HUGETLB_PAGE_DTOR);\n#define PAGE_OFFLINE_MAPCOUNT_VALUE\t(~PG_offline)\n\tVMCOREINFO_NUMBER(PAGE_OFFLINE_MAPCOUNT_VALUE);\n#endif\n\n\tarch_crash_save_vmcoreinfo();\n\tupdate_vmcoreinfo_note();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crash_setup_regs",
          "args": [
            "&fixed_regs",
            "regs"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&kexec_mutex"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1278-1284",
          "snippet": "static __always_inline int __rt_mutex_trylock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))\n\t\treturn 1;\n\n\treturn rt_mutex_slowtrylock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline int __rt_mutex_trylock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_acquire(lock, NULL, current)))\n\t\treturn 1;\n\n\treturn rt_mutex_slowtrylock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct kimage *kexec_crash_image;\n\nvoid __noclone __crash_kexec(struct pt_regs *regs)\n{\n\t/* Take the kexec_mutex here to prevent sys_kexec_load\n\t * running on one cpu from replacing the crash kernel\n\t * we are using after a panic on a different cpu.\n\t *\n\t * If the crash kernel was not located in a fixed area\n\t * of memory the xchg(&kexec_crash_image) would be\n\t * sufficient.  But since I reuse the memory...\n\t */\n\tif (mutex_trylock(&kexec_mutex)) {\n\t\tif (kexec_crash_image) {\n\t\t\tstruct pt_regs fixed_regs;\n\n\t\t\tcrash_setup_regs(&fixed_regs, regs);\n\t\t\tcrash_save_vmcoreinfo();\n\t\t\tmachine_crash_shutdown(&fixed_regs);\n\t\t\tmachine_kexec(kexec_crash_image);\n\t\t}\n\t\tmutex_unlock(&kexec_mutex);\n\t}\n}"
  },
  {
    "function_name": "kimage_load_segment",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "919-934",
    "snippet": "int kimage_load_segment(struct kimage *image,\n\t\t\t\tstruct kexec_segment *segment)\n{\n\tint result = -ENOMEM;\n\n\tswitch (image->type) {\n\tcase KEXEC_TYPE_DEFAULT:\n\t\tresult = kimage_load_normal_segment(image, segment);\n\t\tbreak;\n\tcase KEXEC_TYPE_CRASH:\n\t\tresult = kimage_load_crash_segment(image, segment);\n\t\tbreak;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kimage_load_crash_segment",
          "args": [
            "image",
            "segment"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_load_crash_segment",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "851-917",
          "snippet": "static int kimage_load_crash_segment(struct kimage *image,\n\t\t\t\t\tstruct kexec_segment *segment)\n{\n\t/* For crash dumps kernels we simply copy the data from\n\t * user space to it's destination.\n\t * We do things a page at a time for the sake of kmap.\n\t */\n\tunsigned long maddr;\n\tsize_t ubytes, mbytes;\n\tint result;\n\tunsigned char __user *buf = NULL;\n\tunsigned char *kbuf = NULL;\n\n\tresult = 0;\n\tif (image->file_mode)\n\t\tkbuf = segment->kbuf;\n\telse\n\t\tbuf = segment->buf;\n\tubytes = segment->bufsz;\n\tmbytes = segment->memsz;\n\tmaddr = segment->mem;\n\twhile (mbytes) {\n\t\tstruct page *page;\n\t\tchar *ptr;\n\t\tsize_t uchunk, mchunk;\n\n\t\tpage = boot_pfn_to_page(maddr >> PAGE_SHIFT);\n\t\tif (!page) {\n\t\t\tresult  = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tarch_kexec_post_alloc_pages(page_address(page), 1, 0);\n\t\tptr = kmap(page);\n\t\tptr += maddr & ~PAGE_MASK;\n\t\tmchunk = min_t(size_t, mbytes,\n\t\t\t\tPAGE_SIZE - (maddr & ~PAGE_MASK));\n\t\tuchunk = min(ubytes, mchunk);\n\t\tif (mchunk > uchunk) {\n\t\t\t/* Zero the trailing part of the page */\n\t\t\tmemset(ptr + uchunk, 0, mchunk - uchunk);\n\t\t}\n\n\t\t/* For file based kexec, source pages are in kernel memory */\n\t\tif (image->file_mode)\n\t\t\tmemcpy(ptr, kbuf, uchunk);\n\t\telse\n\t\t\tresult = copy_from_user(ptr, buf, uchunk);\n\t\tkexec_flush_icache_page(page);\n\t\tkunmap(page);\n\t\tarch_kexec_pre_free_pages(page_address(page), 1);\n\t\tif (result) {\n\t\t\tresult = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tubytes -= uchunk;\n\t\tmaddr  += mchunk;\n\t\tif (image->file_mode)\n\t\t\tkbuf += mchunk;\n\t\telse\n\t\t\tbuf += mchunk;\n\t\tmbytes -= mchunk;\n\n\t\tcond_resched();\n\t}\nout:\n\treturn result;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kimage_load_crash_segment(struct kimage *image,\n\t\t\t\t\tstruct kexec_segment *segment)\n{\n\t/* For crash dumps kernels we simply copy the data from\n\t * user space to it's destination.\n\t * We do things a page at a time for the sake of kmap.\n\t */\n\tunsigned long maddr;\n\tsize_t ubytes, mbytes;\n\tint result;\n\tunsigned char __user *buf = NULL;\n\tunsigned char *kbuf = NULL;\n\n\tresult = 0;\n\tif (image->file_mode)\n\t\tkbuf = segment->kbuf;\n\telse\n\t\tbuf = segment->buf;\n\tubytes = segment->bufsz;\n\tmbytes = segment->memsz;\n\tmaddr = segment->mem;\n\twhile (mbytes) {\n\t\tstruct page *page;\n\t\tchar *ptr;\n\t\tsize_t uchunk, mchunk;\n\n\t\tpage = boot_pfn_to_page(maddr >> PAGE_SHIFT);\n\t\tif (!page) {\n\t\t\tresult  = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tarch_kexec_post_alloc_pages(page_address(page), 1, 0);\n\t\tptr = kmap(page);\n\t\tptr += maddr & ~PAGE_MASK;\n\t\tmchunk = min_t(size_t, mbytes,\n\t\t\t\tPAGE_SIZE - (maddr & ~PAGE_MASK));\n\t\tuchunk = min(ubytes, mchunk);\n\t\tif (mchunk > uchunk) {\n\t\t\t/* Zero the trailing part of the page */\n\t\t\tmemset(ptr + uchunk, 0, mchunk - uchunk);\n\t\t}\n\n\t\t/* For file based kexec, source pages are in kernel memory */\n\t\tif (image->file_mode)\n\t\t\tmemcpy(ptr, kbuf, uchunk);\n\t\telse\n\t\t\tresult = copy_from_user(ptr, buf, uchunk);\n\t\tkexec_flush_icache_page(page);\n\t\tkunmap(page);\n\t\tarch_kexec_pre_free_pages(page_address(page), 1);\n\t\tif (result) {\n\t\t\tresult = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tubytes -= uchunk;\n\t\tmaddr  += mchunk;\n\t\tif (image->file_mode)\n\t\t\tkbuf += mchunk;\n\t\telse\n\t\t\tbuf += mchunk;\n\t\tmbytes -= mchunk;\n\n\t\tcond_resched();\n\t}\nout:\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kimage_load_normal_segment",
          "args": [
            "image",
            "segment"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_load_normal_segment",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "782-849",
          "snippet": "static int kimage_load_normal_segment(struct kimage *image,\n\t\t\t\t\t struct kexec_segment *segment)\n{\n\tunsigned long maddr;\n\tsize_t ubytes, mbytes;\n\tint result;\n\tunsigned char __user *buf = NULL;\n\tunsigned char *kbuf = NULL;\n\n\tresult = 0;\n\tif (image->file_mode)\n\t\tkbuf = segment->kbuf;\n\telse\n\t\tbuf = segment->buf;\n\tubytes = segment->bufsz;\n\tmbytes = segment->memsz;\n\tmaddr = segment->mem;\n\n\tresult = kimage_set_destination(image, maddr);\n\tif (result < 0)\n\t\tgoto out;\n\n\twhile (mbytes) {\n\t\tstruct page *page;\n\t\tchar *ptr;\n\t\tsize_t uchunk, mchunk;\n\n\t\tpage = kimage_alloc_page(image, GFP_HIGHUSER, maddr);\n\t\tif (!page) {\n\t\t\tresult  = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tresult = kimage_add_page(image, page_to_boot_pfn(page)\n\t\t\t\t\t\t\t\t<< PAGE_SHIFT);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\n\t\tptr = kmap(page);\n\t\t/* Start with a clear page */\n\t\tclear_page(ptr);\n\t\tptr += maddr & ~PAGE_MASK;\n\t\tmchunk = min_t(size_t, mbytes,\n\t\t\t\tPAGE_SIZE - (maddr & ~PAGE_MASK));\n\t\tuchunk = min(ubytes, mchunk);\n\n\t\t/* For file based kexec, source pages are in kernel memory */\n\t\tif (image->file_mode)\n\t\t\tmemcpy(ptr, kbuf, uchunk);\n\t\telse\n\t\t\tresult = copy_from_user(ptr, buf, uchunk);\n\t\tkunmap(page);\n\t\tif (result) {\n\t\t\tresult = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tubytes -= uchunk;\n\t\tmaddr  += mchunk;\n\t\tif (image->file_mode)\n\t\t\tkbuf += mchunk;\n\t\telse\n\t\t\tbuf += mchunk;\n\t\tmbytes -= mchunk;\n\n\t\tcond_resched();\n\t}\nout:\n\treturn result;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kimage_load_normal_segment(struct kimage *image,\n\t\t\t\t\t struct kexec_segment *segment)\n{\n\tunsigned long maddr;\n\tsize_t ubytes, mbytes;\n\tint result;\n\tunsigned char __user *buf = NULL;\n\tunsigned char *kbuf = NULL;\n\n\tresult = 0;\n\tif (image->file_mode)\n\t\tkbuf = segment->kbuf;\n\telse\n\t\tbuf = segment->buf;\n\tubytes = segment->bufsz;\n\tmbytes = segment->memsz;\n\tmaddr = segment->mem;\n\n\tresult = kimage_set_destination(image, maddr);\n\tif (result < 0)\n\t\tgoto out;\n\n\twhile (mbytes) {\n\t\tstruct page *page;\n\t\tchar *ptr;\n\t\tsize_t uchunk, mchunk;\n\n\t\tpage = kimage_alloc_page(image, GFP_HIGHUSER, maddr);\n\t\tif (!page) {\n\t\t\tresult  = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tresult = kimage_add_page(image, page_to_boot_pfn(page)\n\t\t\t\t\t\t\t\t<< PAGE_SHIFT);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\n\t\tptr = kmap(page);\n\t\t/* Start with a clear page */\n\t\tclear_page(ptr);\n\t\tptr += maddr & ~PAGE_MASK;\n\t\tmchunk = min_t(size_t, mbytes,\n\t\t\t\tPAGE_SIZE - (maddr & ~PAGE_MASK));\n\t\tuchunk = min(ubytes, mchunk);\n\n\t\t/* For file based kexec, source pages are in kernel memory */\n\t\tif (image->file_mode)\n\t\t\tmemcpy(ptr, kbuf, uchunk);\n\t\telse\n\t\t\tresult = copy_from_user(ptr, buf, uchunk);\n\t\tkunmap(page);\n\t\tif (result) {\n\t\t\tresult = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tubytes -= uchunk;\n\t\tmaddr  += mchunk;\n\t\tif (image->file_mode)\n\t\t\tkbuf += mchunk;\n\t\telse\n\t\t\tbuf += mchunk;\n\t\tmbytes -= mchunk;\n\n\t\tcond_resched();\n\t}\nout:\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint kimage_load_segment(struct kimage *image,\n\t\t\t\tstruct kexec_segment *segment)\n{\n\tint result = -ENOMEM;\n\n\tswitch (image->type) {\n\tcase KEXEC_TYPE_DEFAULT:\n\t\tresult = kimage_load_normal_segment(image, segment);\n\t\tbreak;\n\tcase KEXEC_TYPE_CRASH:\n\t\tresult = kimage_load_crash_segment(image, segment);\n\t\tbreak;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "kimage_load_crash_segment",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "851-917",
    "snippet": "static int kimage_load_crash_segment(struct kimage *image,\n\t\t\t\t\tstruct kexec_segment *segment)\n{\n\t/* For crash dumps kernels we simply copy the data from\n\t * user space to it's destination.\n\t * We do things a page at a time for the sake of kmap.\n\t */\n\tunsigned long maddr;\n\tsize_t ubytes, mbytes;\n\tint result;\n\tunsigned char __user *buf = NULL;\n\tunsigned char *kbuf = NULL;\n\n\tresult = 0;\n\tif (image->file_mode)\n\t\tkbuf = segment->kbuf;\n\telse\n\t\tbuf = segment->buf;\n\tubytes = segment->bufsz;\n\tmbytes = segment->memsz;\n\tmaddr = segment->mem;\n\twhile (mbytes) {\n\t\tstruct page *page;\n\t\tchar *ptr;\n\t\tsize_t uchunk, mchunk;\n\n\t\tpage = boot_pfn_to_page(maddr >> PAGE_SHIFT);\n\t\tif (!page) {\n\t\t\tresult  = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tarch_kexec_post_alloc_pages(page_address(page), 1, 0);\n\t\tptr = kmap(page);\n\t\tptr += maddr & ~PAGE_MASK;\n\t\tmchunk = min_t(size_t, mbytes,\n\t\t\t\tPAGE_SIZE - (maddr & ~PAGE_MASK));\n\t\tuchunk = min(ubytes, mchunk);\n\t\tif (mchunk > uchunk) {\n\t\t\t/* Zero the trailing part of the page */\n\t\t\tmemset(ptr + uchunk, 0, mchunk - uchunk);\n\t\t}\n\n\t\t/* For file based kexec, source pages are in kernel memory */\n\t\tif (image->file_mode)\n\t\t\tmemcpy(ptr, kbuf, uchunk);\n\t\telse\n\t\t\tresult = copy_from_user(ptr, buf, uchunk);\n\t\tkexec_flush_icache_page(page);\n\t\tkunmap(page);\n\t\tarch_kexec_pre_free_pages(page_address(page), 1);\n\t\tif (result) {\n\t\t\tresult = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tubytes -= uchunk;\n\t\tmaddr  += mchunk;\n\t\tif (image->file_mode)\n\t\t\tkbuf += mchunk;\n\t\telse\n\t\t\tbuf += mchunk;\n\t\tmbytes -= mchunk;\n\n\t\tcond_resched();\n\t}\nout:\n\treturn result;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_kexec_pre_free_pages",
          "args": [
            "page_address(page)",
            "1"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kexec_flush_icache_page",
          "args": [
            "page"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "ptr",
            "buf",
            "uchunk"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "kbuf",
            "uchunk"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ptr + uchunk",
            "0",
            "mchunk - uchunk"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "ubytes",
            "mchunk"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "mbytes",
            "PAGE_SIZE - (maddr & ~PAGE_MASK)"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_kexec_post_alloc_pages",
          "args": [
            "page_address(page)",
            "1",
            "0"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_pfn_to_page",
          "args": [
            "maddr >> PAGE_SHIFT"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kimage_load_crash_segment(struct kimage *image,\n\t\t\t\t\tstruct kexec_segment *segment)\n{\n\t/* For crash dumps kernels we simply copy the data from\n\t * user space to it's destination.\n\t * We do things a page at a time for the sake of kmap.\n\t */\n\tunsigned long maddr;\n\tsize_t ubytes, mbytes;\n\tint result;\n\tunsigned char __user *buf = NULL;\n\tunsigned char *kbuf = NULL;\n\n\tresult = 0;\n\tif (image->file_mode)\n\t\tkbuf = segment->kbuf;\n\telse\n\t\tbuf = segment->buf;\n\tubytes = segment->bufsz;\n\tmbytes = segment->memsz;\n\tmaddr = segment->mem;\n\twhile (mbytes) {\n\t\tstruct page *page;\n\t\tchar *ptr;\n\t\tsize_t uchunk, mchunk;\n\n\t\tpage = boot_pfn_to_page(maddr >> PAGE_SHIFT);\n\t\tif (!page) {\n\t\t\tresult  = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tarch_kexec_post_alloc_pages(page_address(page), 1, 0);\n\t\tptr = kmap(page);\n\t\tptr += maddr & ~PAGE_MASK;\n\t\tmchunk = min_t(size_t, mbytes,\n\t\t\t\tPAGE_SIZE - (maddr & ~PAGE_MASK));\n\t\tuchunk = min(ubytes, mchunk);\n\t\tif (mchunk > uchunk) {\n\t\t\t/* Zero the trailing part of the page */\n\t\t\tmemset(ptr + uchunk, 0, mchunk - uchunk);\n\t\t}\n\n\t\t/* For file based kexec, source pages are in kernel memory */\n\t\tif (image->file_mode)\n\t\t\tmemcpy(ptr, kbuf, uchunk);\n\t\telse\n\t\t\tresult = copy_from_user(ptr, buf, uchunk);\n\t\tkexec_flush_icache_page(page);\n\t\tkunmap(page);\n\t\tarch_kexec_pre_free_pages(page_address(page), 1);\n\t\tif (result) {\n\t\t\tresult = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tubytes -= uchunk;\n\t\tmaddr  += mchunk;\n\t\tif (image->file_mode)\n\t\t\tkbuf += mchunk;\n\t\telse\n\t\t\tbuf += mchunk;\n\t\tmbytes -= mchunk;\n\n\t\tcond_resched();\n\t}\nout:\n\treturn result;\n}"
  },
  {
    "function_name": "kimage_load_normal_segment",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "782-849",
    "snippet": "static int kimage_load_normal_segment(struct kimage *image,\n\t\t\t\t\t struct kexec_segment *segment)\n{\n\tunsigned long maddr;\n\tsize_t ubytes, mbytes;\n\tint result;\n\tunsigned char __user *buf = NULL;\n\tunsigned char *kbuf = NULL;\n\n\tresult = 0;\n\tif (image->file_mode)\n\t\tkbuf = segment->kbuf;\n\telse\n\t\tbuf = segment->buf;\n\tubytes = segment->bufsz;\n\tmbytes = segment->memsz;\n\tmaddr = segment->mem;\n\n\tresult = kimage_set_destination(image, maddr);\n\tif (result < 0)\n\t\tgoto out;\n\n\twhile (mbytes) {\n\t\tstruct page *page;\n\t\tchar *ptr;\n\t\tsize_t uchunk, mchunk;\n\n\t\tpage = kimage_alloc_page(image, GFP_HIGHUSER, maddr);\n\t\tif (!page) {\n\t\t\tresult  = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tresult = kimage_add_page(image, page_to_boot_pfn(page)\n\t\t\t\t\t\t\t\t<< PAGE_SHIFT);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\n\t\tptr = kmap(page);\n\t\t/* Start with a clear page */\n\t\tclear_page(ptr);\n\t\tptr += maddr & ~PAGE_MASK;\n\t\tmchunk = min_t(size_t, mbytes,\n\t\t\t\tPAGE_SIZE - (maddr & ~PAGE_MASK));\n\t\tuchunk = min(ubytes, mchunk);\n\n\t\t/* For file based kexec, source pages are in kernel memory */\n\t\tif (image->file_mode)\n\t\t\tmemcpy(ptr, kbuf, uchunk);\n\t\telse\n\t\t\tresult = copy_from_user(ptr, buf, uchunk);\n\t\tkunmap(page);\n\t\tif (result) {\n\t\t\tresult = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tubytes -= uchunk;\n\t\tmaddr  += mchunk;\n\t\tif (image->file_mode)\n\t\t\tkbuf += mchunk;\n\t\telse\n\t\t\tbuf += mchunk;\n\t\tmbytes -= mchunk;\n\n\t\tcond_resched();\n\t}\nout:\n\treturn result;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "ptr",
            "buf",
            "uchunk"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "kbuf",
            "uchunk"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "ubytes",
            "mchunk"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "mbytes",
            "PAGE_SIZE - (maddr & ~PAGE_MASK)"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "ptr"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kimage_add_page",
          "args": [
            "image",
            "page_to_boot_pfn(page)\n\t\t\t\t\t\t\t\t<< PAGE_SHIFT"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_add_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "573-581",
          "snippet": "static int kimage_add_page(struct kimage *image, unsigned long page)\n{\n\tint result;\n\n\tpage &= PAGE_MASK;\n\tresult = kimage_add_entry(image, page | IND_SOURCE);\n\n\treturn result;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kimage_add_page(struct kimage *image, unsigned long page)\n{\n\tint result;\n\n\tpage &= PAGE_MASK;\n\tresult = kimage_add_entry(image, page | IND_SOURCE);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_boot_pfn",
          "args": [
            "page"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kimage_alloc_page",
          "args": [
            "image",
            "GFP_HIGHUSER",
            "maddr"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_alloc_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "685-780",
          "snippet": "static struct page *kimage_alloc_page(struct kimage *image,\n\t\t\t\t\tgfp_t gfp_mask,\n\t\t\t\t\tunsigned long destination)\n{\n\t/*\n\t * Here we implement safeguards to ensure that a source page\n\t * is not copied to its destination page before the data on\n\t * the destination page is no longer useful.\n\t *\n\t * To do this we maintain the invariant that a source page is\n\t * either its own destination page, or it is not a\n\t * destination page at all.\n\t *\n\t * That is slightly stronger than required, but the proof\n\t * that no problems will not occur is trivial, and the\n\t * implementation is simply to verify.\n\t *\n\t * When allocating all pages normally this algorithm will run\n\t * in O(N) time, but in the worst case it will run in O(N^2)\n\t * time.   If the runtime is a problem the data structures can\n\t * be fixed.\n\t */\n\tstruct page *page;\n\tunsigned long addr;\n\n\t/*\n\t * Walk through the list of destination pages, and see if I\n\t * have a match.\n\t */\n\tlist_for_each_entry(page, &image->dest_pages, lru) {\n\t\taddr = page_to_boot_pfn(page) << PAGE_SHIFT;\n\t\tif (addr == destination) {\n\t\t\tlist_del(&page->lru);\n\t\t\treturn page;\n\t\t}\n\t}\n\tpage = NULL;\n\twhile (1) {\n\t\tkimage_entry_t *old;\n\n\t\t/* Allocate a page, if we run out of memory give up */\n\t\tpage = kimage_alloc_pages(gfp_mask, 0);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\t/* If the page cannot be used file it away */\n\t\tif (page_to_boot_pfn(page) >\n\t\t\t\t(KEXEC_SOURCE_MEMORY_LIMIT >> PAGE_SHIFT)) {\n\t\t\tlist_add(&page->lru, &image->unusable_pages);\n\t\t\tcontinue;\n\t\t}\n\t\taddr = page_to_boot_pfn(page) << PAGE_SHIFT;\n\n\t\t/* If it is the destination page we want use it */\n\t\tif (addr == destination)\n\t\t\tbreak;\n\n\t\t/* If the page is not a destination page use it */\n\t\tif (!kimage_is_destination_range(image, addr,\n\t\t\t\t\t\t  addr + PAGE_SIZE))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * I know that the page is someones destination page.\n\t\t * See if there is already a source page for this\n\t\t * destination page.  And if so swap the source pages.\n\t\t */\n\t\told = kimage_dst_used(image, addr);\n\t\tif (old) {\n\t\t\t/* If so move it */\n\t\t\tunsigned long old_addr;\n\t\t\tstruct page *old_page;\n\n\t\t\told_addr = *old & PAGE_MASK;\n\t\t\told_page = boot_pfn_to_page(old_addr >> PAGE_SHIFT);\n\t\t\tcopy_highpage(page, old_page);\n\t\t\t*old = addr | (*old & ~PAGE_MASK);\n\n\t\t\t/* The old page I have found cannot be a\n\t\t\t * destination page, so return it if it's\n\t\t\t * gfp_flags honor the ones passed in.\n\t\t\t */\n\t\t\tif (!(gfp_mask & __GFP_HIGHMEM) &&\n\t\t\t    PageHighMem(old_page)) {\n\t\t\t\tkimage_free_pages(old_page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taddr = old_addr;\n\t\t\tpage = old_page;\n\t\t\tbreak;\n\t\t}\n\t\t/* Place the page on the destination list, to be used later */\n\t\tlist_add(&page->lru, &image->dest_pages);\n\t}\n\n\treturn page;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic struct page *kimage_alloc_page(struct kimage *image,\n\t\t\t\t\tgfp_t gfp_mask,\n\t\t\t\t\tunsigned long destination)\n{\n\t/*\n\t * Here we implement safeguards to ensure that a source page\n\t * is not copied to its destination page before the data on\n\t * the destination page is no longer useful.\n\t *\n\t * To do this we maintain the invariant that a source page is\n\t * either its own destination page, or it is not a\n\t * destination page at all.\n\t *\n\t * That is slightly stronger than required, but the proof\n\t * that no problems will not occur is trivial, and the\n\t * implementation is simply to verify.\n\t *\n\t * When allocating all pages normally this algorithm will run\n\t * in O(N) time, but in the worst case it will run in O(N^2)\n\t * time.   If the runtime is a problem the data structures can\n\t * be fixed.\n\t */\n\tstruct page *page;\n\tunsigned long addr;\n\n\t/*\n\t * Walk through the list of destination pages, and see if I\n\t * have a match.\n\t */\n\tlist_for_each_entry(page, &image->dest_pages, lru) {\n\t\taddr = page_to_boot_pfn(page) << PAGE_SHIFT;\n\t\tif (addr == destination) {\n\t\t\tlist_del(&page->lru);\n\t\t\treturn page;\n\t\t}\n\t}\n\tpage = NULL;\n\twhile (1) {\n\t\tkimage_entry_t *old;\n\n\t\t/* Allocate a page, if we run out of memory give up */\n\t\tpage = kimage_alloc_pages(gfp_mask, 0);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\t/* If the page cannot be used file it away */\n\t\tif (page_to_boot_pfn(page) >\n\t\t\t\t(KEXEC_SOURCE_MEMORY_LIMIT >> PAGE_SHIFT)) {\n\t\t\tlist_add(&page->lru, &image->unusable_pages);\n\t\t\tcontinue;\n\t\t}\n\t\taddr = page_to_boot_pfn(page) << PAGE_SHIFT;\n\n\t\t/* If it is the destination page we want use it */\n\t\tif (addr == destination)\n\t\t\tbreak;\n\n\t\t/* If the page is not a destination page use it */\n\t\tif (!kimage_is_destination_range(image, addr,\n\t\t\t\t\t\t  addr + PAGE_SIZE))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * I know that the page is someones destination page.\n\t\t * See if there is already a source page for this\n\t\t * destination page.  And if so swap the source pages.\n\t\t */\n\t\told = kimage_dst_used(image, addr);\n\t\tif (old) {\n\t\t\t/* If so move it */\n\t\t\tunsigned long old_addr;\n\t\t\tstruct page *old_page;\n\n\t\t\told_addr = *old & PAGE_MASK;\n\t\t\told_page = boot_pfn_to_page(old_addr >> PAGE_SHIFT);\n\t\t\tcopy_highpage(page, old_page);\n\t\t\t*old = addr | (*old & ~PAGE_MASK);\n\n\t\t\t/* The old page I have found cannot be a\n\t\t\t * destination page, so return it if it's\n\t\t\t * gfp_flags honor the ones passed in.\n\t\t\t */\n\t\t\tif (!(gfp_mask & __GFP_HIGHMEM) &&\n\t\t\t    PageHighMem(old_page)) {\n\t\t\t\tkimage_free_pages(old_page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taddr = old_addr;\n\t\t\tpage = old_page;\n\t\t\tbreak;\n\t\t}\n\t\t/* Place the page on the destination list, to be used later */\n\t\tlist_add(&page->lru, &image->dest_pages);\n\t}\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kimage_set_destination",
          "args": [
            "image",
            "maddr"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_set_destination",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "561-570",
          "snippet": "static int kimage_set_destination(struct kimage *image,\n\t\t\t\t   unsigned long destination)\n{\n\tint result;\n\n\tdestination &= PAGE_MASK;\n\tresult = kimage_add_entry(image, destination | IND_DESTINATION);\n\n\treturn result;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kimage_set_destination(struct kimage *image,\n\t\t\t\t   unsigned long destination)\n{\n\tint result;\n\n\tdestination &= PAGE_MASK;\n\tresult = kimage_add_entry(image, destination | IND_DESTINATION);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kimage_load_normal_segment(struct kimage *image,\n\t\t\t\t\t struct kexec_segment *segment)\n{\n\tunsigned long maddr;\n\tsize_t ubytes, mbytes;\n\tint result;\n\tunsigned char __user *buf = NULL;\n\tunsigned char *kbuf = NULL;\n\n\tresult = 0;\n\tif (image->file_mode)\n\t\tkbuf = segment->kbuf;\n\telse\n\t\tbuf = segment->buf;\n\tubytes = segment->bufsz;\n\tmbytes = segment->memsz;\n\tmaddr = segment->mem;\n\n\tresult = kimage_set_destination(image, maddr);\n\tif (result < 0)\n\t\tgoto out;\n\n\twhile (mbytes) {\n\t\tstruct page *page;\n\t\tchar *ptr;\n\t\tsize_t uchunk, mchunk;\n\n\t\tpage = kimage_alloc_page(image, GFP_HIGHUSER, maddr);\n\t\tif (!page) {\n\t\t\tresult  = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tresult = kimage_add_page(image, page_to_boot_pfn(page)\n\t\t\t\t\t\t\t\t<< PAGE_SHIFT);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\n\t\tptr = kmap(page);\n\t\t/* Start with a clear page */\n\t\tclear_page(ptr);\n\t\tptr += maddr & ~PAGE_MASK;\n\t\tmchunk = min_t(size_t, mbytes,\n\t\t\t\tPAGE_SIZE - (maddr & ~PAGE_MASK));\n\t\tuchunk = min(ubytes, mchunk);\n\n\t\t/* For file based kexec, source pages are in kernel memory */\n\t\tif (image->file_mode)\n\t\t\tmemcpy(ptr, kbuf, uchunk);\n\t\telse\n\t\t\tresult = copy_from_user(ptr, buf, uchunk);\n\t\tkunmap(page);\n\t\tif (result) {\n\t\t\tresult = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tubytes -= uchunk;\n\t\tmaddr  += mchunk;\n\t\tif (image->file_mode)\n\t\t\tkbuf += mchunk;\n\t\telse\n\t\t\tbuf += mchunk;\n\t\tmbytes -= mchunk;\n\n\t\tcond_resched();\n\t}\nout:\n\treturn result;\n}"
  },
  {
    "function_name": "kimage_alloc_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "685-780",
    "snippet": "static struct page *kimage_alloc_page(struct kimage *image,\n\t\t\t\t\tgfp_t gfp_mask,\n\t\t\t\t\tunsigned long destination)\n{\n\t/*\n\t * Here we implement safeguards to ensure that a source page\n\t * is not copied to its destination page before the data on\n\t * the destination page is no longer useful.\n\t *\n\t * To do this we maintain the invariant that a source page is\n\t * either its own destination page, or it is not a\n\t * destination page at all.\n\t *\n\t * That is slightly stronger than required, but the proof\n\t * that no problems will not occur is trivial, and the\n\t * implementation is simply to verify.\n\t *\n\t * When allocating all pages normally this algorithm will run\n\t * in O(N) time, but in the worst case it will run in O(N^2)\n\t * time.   If the runtime is a problem the data structures can\n\t * be fixed.\n\t */\n\tstruct page *page;\n\tunsigned long addr;\n\n\t/*\n\t * Walk through the list of destination pages, and see if I\n\t * have a match.\n\t */\n\tlist_for_each_entry(page, &image->dest_pages, lru) {\n\t\taddr = page_to_boot_pfn(page) << PAGE_SHIFT;\n\t\tif (addr == destination) {\n\t\t\tlist_del(&page->lru);\n\t\t\treturn page;\n\t\t}\n\t}\n\tpage = NULL;\n\twhile (1) {\n\t\tkimage_entry_t *old;\n\n\t\t/* Allocate a page, if we run out of memory give up */\n\t\tpage = kimage_alloc_pages(gfp_mask, 0);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\t/* If the page cannot be used file it away */\n\t\tif (page_to_boot_pfn(page) >\n\t\t\t\t(KEXEC_SOURCE_MEMORY_LIMIT >> PAGE_SHIFT)) {\n\t\t\tlist_add(&page->lru, &image->unusable_pages);\n\t\t\tcontinue;\n\t\t}\n\t\taddr = page_to_boot_pfn(page) << PAGE_SHIFT;\n\n\t\t/* If it is the destination page we want use it */\n\t\tif (addr == destination)\n\t\t\tbreak;\n\n\t\t/* If the page is not a destination page use it */\n\t\tif (!kimage_is_destination_range(image, addr,\n\t\t\t\t\t\t  addr + PAGE_SIZE))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * I know that the page is someones destination page.\n\t\t * See if there is already a source page for this\n\t\t * destination page.  And if so swap the source pages.\n\t\t */\n\t\told = kimage_dst_used(image, addr);\n\t\tif (old) {\n\t\t\t/* If so move it */\n\t\t\tunsigned long old_addr;\n\t\t\tstruct page *old_page;\n\n\t\t\told_addr = *old & PAGE_MASK;\n\t\t\told_page = boot_pfn_to_page(old_addr >> PAGE_SHIFT);\n\t\t\tcopy_highpage(page, old_page);\n\t\t\t*old = addr | (*old & ~PAGE_MASK);\n\n\t\t\t/* The old page I have found cannot be a\n\t\t\t * destination page, so return it if it's\n\t\t\t * gfp_flags honor the ones passed in.\n\t\t\t */\n\t\t\tif (!(gfp_mask & __GFP_HIGHMEM) &&\n\t\t\t    PageHighMem(old_page)) {\n\t\t\t\tkimage_free_pages(old_page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taddr = old_addr;\n\t\t\tpage = old_page;\n\t\t\tbreak;\n\t\t}\n\t\t/* Place the page on the destination list, to be used later */\n\t\tlist_add(&page->lru, &image->dest_pages);\n\t}\n\n\treturn page;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&image->dest_pages"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kimage_free_pages",
          "args": [
            "old_page"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "327-339",
          "snippet": "static void kimage_free_pages(struct page *page)\n{\n\tunsigned int order, count, i;\n\n\torder = page_private(page);\n\tcount = 1 << order;\n\n\tarch_kexec_pre_free_pages(page_address(page), count);\n\n\tfor (i = 0; i < count; i++)\n\t\tClearPageReserved(page + i);\n\t__free_pages(page, order);\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic void kimage_free_pages(struct page *page)\n{\n\tunsigned int order, count, i;\n\n\torder = page_private(page);\n\tcount = 1 << order;\n\n\tarch_kexec_pre_free_pages(page_address(page), count);\n\n\tfor (i = 0; i < count; i++)\n\t\tClearPageReserved(page + i);\n\t__free_pages(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "old_page"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_highpage",
          "args": [
            "page",
            "old_page"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_pfn_to_page",
          "args": [
            "old_addr >> PAGE_SHIFT"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kimage_dst_used",
          "args": [
            "image",
            "addr"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_dst_used",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "666-683",
          "snippet": "static kimage_entry_t *kimage_dst_used(struct kimage *image,\n\t\t\t\t\tunsigned long page)\n{\n\tkimage_entry_t *ptr, entry;\n\tunsigned long destination = 0;\n\n\tfor_each_kimage_entry(image, ptr, entry) {\n\t\tif (entry & IND_DESTINATION)\n\t\t\tdestination = entry & PAGE_MASK;\n\t\telse if (entry & IND_SOURCE) {\n\t\t\tif (page == destination)\n\t\t\t\treturn ptr;\n\t\t\tdestination += PAGE_SIZE;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic kimage_entry_t *kimage_dst_used(struct kimage *image,\n\t\t\t\t\tunsigned long page)\n{\n\tkimage_entry_t *ptr, entry;\n\tunsigned long destination = 0;\n\n\tfor_each_kimage_entry(image, ptr, entry) {\n\t\tif (entry & IND_DESTINATION)\n\t\t\tdestination = entry & PAGE_MASK;\n\t\telse if (entry & IND_SOURCE) {\n\t\t\tif (page == destination)\n\t\t\t\treturn ptr;\n\t\t\tdestination += PAGE_SIZE;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kimage_is_destination_range",
          "args": [
            "image",
            "addr",
            "addr + PAGE_SIZE"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_is_destination_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "282-298",
          "snippet": "int kimage_is_destination_range(struct kimage *image,\n\t\t\t\t\tunsigned long start,\n\t\t\t\t\tunsigned long end)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < image->nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend = mstart + image->segment[i].memsz;\n\t\tif ((end > mstart) && (start < mend))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint kimage_is_destination_range(struct kimage *image,\n\t\t\t\t\tunsigned long start,\n\t\t\t\t\tunsigned long end)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < image->nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend = mstart + image->segment[i].memsz;\n\t\tif ((end > mstart) && (start < mend))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_boot_pfn",
          "args": [
            "page"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_boot_pfn",
          "args": [
            "page"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kimage_alloc_pages",
          "args": [
            "gfp_mask",
            "0"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_alloc_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "300-325",
          "snippet": "static struct page *kimage_alloc_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *pages;\n\n\tif (fatal_signal_pending(current))\n\t\treturn NULL;\n\tpages = alloc_pages(gfp_mask & ~__GFP_ZERO, order);\n\tif (pages) {\n\t\tunsigned int count, i;\n\n\t\tpages->mapping = NULL;\n\t\tset_page_private(pages, order);\n\t\tcount = 1 << order;\n\t\tfor (i = 0; i < count; i++)\n\t\t\tSetPageReserved(pages + i);\n\n\t\tarch_kexec_post_alloc_pages(page_address(pages), count,\n\t\t\t\t\t    gfp_mask);\n\n\t\tif (gfp_mask & __GFP_ZERO)\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tclear_highpage(pages + i);\n\t}\n\n\treturn pages;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic struct page *kimage_alloc_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *pages;\n\n\tif (fatal_signal_pending(current))\n\t\treturn NULL;\n\tpages = alloc_pages(gfp_mask & ~__GFP_ZERO, order);\n\tif (pages) {\n\t\tunsigned int count, i;\n\n\t\tpages->mapping = NULL;\n\t\tset_page_private(pages, order);\n\t\tcount = 1 << order;\n\t\tfor (i = 0; i < count; i++)\n\t\t\tSetPageReserved(pages + i);\n\n\t\tarch_kexec_post_alloc_pages(page_address(pages), count,\n\t\t\t\t\t    gfp_mask);\n\n\t\tif (gfp_mask & __GFP_ZERO)\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tclear_highpage(pages + i);\n\t}\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_boot_pfn",
          "args": [
            "page"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&image->dest_pages",
            "lru"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic struct page *kimage_alloc_page(struct kimage *image,\n\t\t\t\t\tgfp_t gfp_mask,\n\t\t\t\t\tunsigned long destination)\n{\n\t/*\n\t * Here we implement safeguards to ensure that a source page\n\t * is not copied to its destination page before the data on\n\t * the destination page is no longer useful.\n\t *\n\t * To do this we maintain the invariant that a source page is\n\t * either its own destination page, or it is not a\n\t * destination page at all.\n\t *\n\t * That is slightly stronger than required, but the proof\n\t * that no problems will not occur is trivial, and the\n\t * implementation is simply to verify.\n\t *\n\t * When allocating all pages normally this algorithm will run\n\t * in O(N) time, but in the worst case it will run in O(N^2)\n\t * time.   If the runtime is a problem the data structures can\n\t * be fixed.\n\t */\n\tstruct page *page;\n\tunsigned long addr;\n\n\t/*\n\t * Walk through the list of destination pages, and see if I\n\t * have a match.\n\t */\n\tlist_for_each_entry(page, &image->dest_pages, lru) {\n\t\taddr = page_to_boot_pfn(page) << PAGE_SHIFT;\n\t\tif (addr == destination) {\n\t\t\tlist_del(&page->lru);\n\t\t\treturn page;\n\t\t}\n\t}\n\tpage = NULL;\n\twhile (1) {\n\t\tkimage_entry_t *old;\n\n\t\t/* Allocate a page, if we run out of memory give up */\n\t\tpage = kimage_alloc_pages(gfp_mask, 0);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\t/* If the page cannot be used file it away */\n\t\tif (page_to_boot_pfn(page) >\n\t\t\t\t(KEXEC_SOURCE_MEMORY_LIMIT >> PAGE_SHIFT)) {\n\t\t\tlist_add(&page->lru, &image->unusable_pages);\n\t\t\tcontinue;\n\t\t}\n\t\taddr = page_to_boot_pfn(page) << PAGE_SHIFT;\n\n\t\t/* If it is the destination page we want use it */\n\t\tif (addr == destination)\n\t\t\tbreak;\n\n\t\t/* If the page is not a destination page use it */\n\t\tif (!kimage_is_destination_range(image, addr,\n\t\t\t\t\t\t  addr + PAGE_SIZE))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * I know that the page is someones destination page.\n\t\t * See if there is already a source page for this\n\t\t * destination page.  And if so swap the source pages.\n\t\t */\n\t\told = kimage_dst_used(image, addr);\n\t\tif (old) {\n\t\t\t/* If so move it */\n\t\t\tunsigned long old_addr;\n\t\t\tstruct page *old_page;\n\n\t\t\told_addr = *old & PAGE_MASK;\n\t\t\told_page = boot_pfn_to_page(old_addr >> PAGE_SHIFT);\n\t\t\tcopy_highpage(page, old_page);\n\t\t\t*old = addr | (*old & ~PAGE_MASK);\n\n\t\t\t/* The old page I have found cannot be a\n\t\t\t * destination page, so return it if it's\n\t\t\t * gfp_flags honor the ones passed in.\n\t\t\t */\n\t\t\tif (!(gfp_mask & __GFP_HIGHMEM) &&\n\t\t\t    PageHighMem(old_page)) {\n\t\t\t\tkimage_free_pages(old_page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taddr = old_addr;\n\t\t\tpage = old_page;\n\t\t\tbreak;\n\t\t}\n\t\t/* Place the page on the destination list, to be used later */\n\t\tlist_add(&page->lru, &image->dest_pages);\n\t}\n\n\treturn page;\n}"
  },
  {
    "function_name": "kimage_dst_used",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "666-683",
    "snippet": "static kimage_entry_t *kimage_dst_used(struct kimage *image,\n\t\t\t\t\tunsigned long page)\n{\n\tkimage_entry_t *ptr, entry;\n\tunsigned long destination = 0;\n\n\tfor_each_kimage_entry(image, ptr, entry) {\n\t\tif (entry & IND_DESTINATION)\n\t\t\tdestination = entry & PAGE_MASK;\n\t\telse if (entry & IND_SOURCE) {\n\t\t\tif (page == destination)\n\t\t\t\treturn ptr;\n\t\t\tdestination += PAGE_SIZE;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_kimage_entry",
          "args": [
            "image",
            "ptr",
            "entry"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic kimage_entry_t *kimage_dst_used(struct kimage *image,\n\t\t\t\t\tunsigned long page)\n{\n\tkimage_entry_t *ptr, entry;\n\tunsigned long destination = 0;\n\n\tfor_each_kimage_entry(image, ptr, entry) {\n\t\tif (entry & IND_DESTINATION)\n\t\t\tdestination = entry & PAGE_MASK;\n\t\telse if (entry & IND_SOURCE) {\n\t\t\tif (page == destination)\n\t\t\t\treturn ptr;\n\t\t\tdestination += PAGE_SIZE;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "kimage_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "620-664",
    "snippet": "void kimage_free(struct kimage *image)\n{\n\tkimage_entry_t *ptr, entry;\n\tkimage_entry_t ind = 0;\n\n\tif (!image)\n\t\treturn;\n\n\tif (image->vmcoreinfo_data_copy) {\n\t\tcrash_update_vmcoreinfo_safecopy(NULL);\n\t\tvunmap(image->vmcoreinfo_data_copy);\n\t}\n\n\tkimage_free_extra_pages(image);\n\tfor_each_kimage_entry(image, ptr, entry) {\n\t\tif (entry & IND_INDIRECTION) {\n\t\t\t/* Free the previous indirection page */\n\t\t\tif (ind & IND_INDIRECTION)\n\t\t\t\tkimage_free_entry(ind);\n\t\t\t/* Save this indirection page until we are\n\t\t\t * done with it.\n\t\t\t */\n\t\t\tind = entry;\n\t\t} else if (entry & IND_SOURCE)\n\t\t\tkimage_free_entry(entry);\n\t}\n\t/* Free the final indirection page */\n\tif (ind & IND_INDIRECTION)\n\t\tkimage_free_entry(ind);\n\n\t/* Handle any machine specific cleanup */\n\tmachine_kexec_cleanup(image);\n\n\t/* Free the kexec control pages... */\n\tkimage_free_page_list(&image->control_pages);\n\n\t/*\n\t * Free up any temporary buffers allocated. This might hit if\n\t * error occurred much later after buffer allocation.\n\t */\n\tif (image->file_mode)\n\t\tkimage_file_post_load_cleanup(image);\n\n\tkfree(image);\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "image"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kimage_file_post_load_cleanup",
          "args": [
            "image"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_file_post_load_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_file.c",
          "lines": "150-184",
          "snippet": "void kimage_file_post_load_cleanup(struct kimage *image)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\n\tvfree(image->kernel_buf);\n\timage->kernel_buf = NULL;\n\n\tvfree(image->initrd_buf);\n\timage->initrd_buf = NULL;\n\n\tkfree(image->cmdline_buf);\n\timage->cmdline_buf = NULL;\n\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\n\tvfree(pi->sechdrs);\n\tpi->sechdrs = NULL;\n\n#ifdef CONFIG_IMA_KEXEC\n\tvfree(image->ima_buffer);\n\timage->ima_buffer = NULL;\n#endif /* CONFIG_IMA_KEXEC */\n\n\t/* See if architecture has anything to cleanup post load */\n\tarch_kimage_file_post_load_cleanup(image);\n\n\t/*\n\t * Above call should have called into bootloader to free up\n\t * any data stored in kimage->image_loader_data. It should\n\t * be ok now to free it up.\n\t */\n\tkfree(image->image_loader_data);\n\timage->image_loader_data = NULL;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <crypto/sha2.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/memblock.h>",
            "#include <linux/kexec.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kexec_calculate_store_digests(struct kimage *image);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/syscalls.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <crypto/sha2.h>\n#include <crypto/hash.h>\n#include <linux/ima.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/memblock.h>\n#include <linux/kexec.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kexec_calculate_store_digests(struct kimage *image);\n\nvoid kimage_file_post_load_cleanup(struct kimage *image)\n{\n\tstruct purgatory_info *pi = &image->purgatory_info;\n\n\tvfree(image->kernel_buf);\n\timage->kernel_buf = NULL;\n\n\tvfree(image->initrd_buf);\n\timage->initrd_buf = NULL;\n\n\tkfree(image->cmdline_buf);\n\timage->cmdline_buf = NULL;\n\n\tvfree(pi->purgatory_buf);\n\tpi->purgatory_buf = NULL;\n\n\tvfree(pi->sechdrs);\n\tpi->sechdrs = NULL;\n\n#ifdef CONFIG_IMA_KEXEC\n\tvfree(image->ima_buffer);\n\timage->ima_buffer = NULL;\n#endif /* CONFIG_IMA_KEXEC */\n\n\t/* See if architecture has anything to cleanup post load */\n\tarch_kimage_file_post_load_cleanup(image);\n\n\t/*\n\t * Above call should have called into bootloader to free up\n\t * any data stored in kimage->image_loader_data. It should\n\t * be ok now to free it up.\n\t */\n\tkfree(image->image_loader_data);\n\timage->image_loader_data = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kimage_free_page_list",
          "args": [
            "&image->control_pages"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "341-349",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "machine_kexec_cleanup",
          "args": [
            "image"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kimage_free_entry",
          "args": [
            "ind"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "612-618",
          "snippet": "static void kimage_free_entry(kimage_entry_t entry)\n{\n\tstruct page *page;\n\n\tpage = boot_pfn_to_page(entry >> PAGE_SHIFT);\n\tkimage_free_pages(page);\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic void kimage_free_entry(kimage_entry_t entry)\n{\n\tstruct page *page;\n\n\tpage = boot_pfn_to_page(entry >> PAGE_SHIFT);\n\tkimage_free_pages(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_kimage_entry",
          "args": [
            "image",
            "ptr",
            "entry"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kimage_free_extra_pages",
          "args": [
            "image"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_extra_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "584-592",
          "snippet": "static void kimage_free_extra_pages(struct kimage *image)\n{\n\t/* Walk through and free any extra destination pages I may have */\n\tkimage_free_page_list(&image->dest_pages);\n\n\t/* Walk through and free any unusable pages I have cached */\n\tkimage_free_page_list(&image->unusable_pages);\n\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic void kimage_free_extra_pages(struct kimage *image)\n{\n\t/* Walk through and free any extra destination pages I may have */\n\tkimage_free_page_list(&image->dest_pages);\n\n\t/* Walk through and free any unusable pages I have cached */\n\tkimage_free_page_list(&image->unusable_pages);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "vunmap",
          "args": [
            "image->vmcoreinfo_data_copy"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_update_vmcoreinfo_safecopy",
          "args": [
            "NULL"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "crash_update_vmcoreinfo_safecopy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "342-348",
          "snippet": "void crash_update_vmcoreinfo_safecopy(void *ptr)\n{\n\tif (ptr)\n\t\tmemcpy(ptr, vmcoreinfo_data, vmcoreinfo_size);\n\n\tvmcoreinfo_data_safecopy = ptr;\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned char *vmcoreinfo_data;",
            "size_t vmcoreinfo_size;",
            "static unsigned char *vmcoreinfo_data_safecopy;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nunsigned char *vmcoreinfo_data;\nsize_t vmcoreinfo_size;\nstatic unsigned char *vmcoreinfo_data_safecopy;\n\nvoid crash_update_vmcoreinfo_safecopy(void *ptr)\n{\n\tif (ptr)\n\t\tmemcpy(ptr, vmcoreinfo_data, vmcoreinfo_size);\n\n\tvmcoreinfo_data_safecopy = ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free(struct kimage *image)\n{\n\tkimage_entry_t *ptr, entry;\n\tkimage_entry_t ind = 0;\n\n\tif (!image)\n\t\treturn;\n\n\tif (image->vmcoreinfo_data_copy) {\n\t\tcrash_update_vmcoreinfo_safecopy(NULL);\n\t\tvunmap(image->vmcoreinfo_data_copy);\n\t}\n\n\tkimage_free_extra_pages(image);\n\tfor_each_kimage_entry(image, ptr, entry) {\n\t\tif (entry & IND_INDIRECTION) {\n\t\t\t/* Free the previous indirection page */\n\t\t\tif (ind & IND_INDIRECTION)\n\t\t\t\tkimage_free_entry(ind);\n\t\t\t/* Save this indirection page until we are\n\t\t\t * done with it.\n\t\t\t */\n\t\t\tind = entry;\n\t\t} else if (entry & IND_SOURCE)\n\t\t\tkimage_free_entry(entry);\n\t}\n\t/* Free the final indirection page */\n\tif (ind & IND_INDIRECTION)\n\t\tkimage_free_entry(ind);\n\n\t/* Handle any machine specific cleanup */\n\tmachine_kexec_cleanup(image);\n\n\t/* Free the kexec control pages... */\n\tkimage_free_page_list(&image->control_pages);\n\n\t/*\n\t * Free up any temporary buffers allocated. This might hit if\n\t * error occurred much later after buffer allocation.\n\t */\n\tif (image->file_mode)\n\t\tkimage_file_post_load_cleanup(image);\n\n\tkfree(image);\n}"
  },
  {
    "function_name": "kimage_free_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "612-618",
    "snippet": "static void kimage_free_entry(kimage_entry_t entry)\n{\n\tstruct page *page;\n\n\tpage = boot_pfn_to_page(entry >> PAGE_SHIFT);\n\tkimage_free_pages(page);\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kimage_free_pages",
          "args": [
            "page"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "327-339",
          "snippet": "static void kimage_free_pages(struct page *page)\n{\n\tunsigned int order, count, i;\n\n\torder = page_private(page);\n\tcount = 1 << order;\n\n\tarch_kexec_pre_free_pages(page_address(page), count);\n\n\tfor (i = 0; i < count; i++)\n\t\tClearPageReserved(page + i);\n\t__free_pages(page, order);\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic void kimage_free_pages(struct page *page)\n{\n\tunsigned int order, count, i;\n\n\torder = page_private(page);\n\tcount = 1 << order;\n\n\tarch_kexec_pre_free_pages(page_address(page), count);\n\n\tfor (i = 0; i < count; i++)\n\t\tClearPageReserved(page + i);\n\t__free_pages(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_pfn_to_page",
          "args": [
            "entry >> PAGE_SHIFT"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic void kimage_free_entry(kimage_entry_t entry)\n{\n\tstruct page *page;\n\n\tpage = boot_pfn_to_page(entry >> PAGE_SHIFT);\n\tkimage_free_pages(page);\n}"
  },
  {
    "function_name": "kimage_terminate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "599-605",
    "snippet": "void kimage_terminate(struct kimage *image)\n{\n\tif (*image->entry != 0)\n\t\timage->entry++;\n\n\t*image->entry = IND_DONE;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_terminate(struct kimage *image)\n{\n\tif (*image->entry != 0)\n\t\timage->entry++;\n\n\t*image->entry = IND_DONE;\n}"
  },
  {
    "function_name": "machine_kexec_post_load",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "594-597",
    "snippet": "int __weak machine_kexec_post_load(struct kimage *image)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint __weak machine_kexec_post_load(struct kimage *image)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "kimage_free_extra_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "584-592",
    "snippet": "static void kimage_free_extra_pages(struct kimage *image)\n{\n\t/* Walk through and free any extra destination pages I may have */\n\tkimage_free_page_list(&image->dest_pages);\n\n\t/* Walk through and free any unusable pages I have cached */\n\tkimage_free_page_list(&image->unusable_pages);\n\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kimage_free_page_list",
          "args": [
            "&image->unusable_pages"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "341-349",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic void kimage_free_extra_pages(struct kimage *image)\n{\n\t/* Walk through and free any extra destination pages I may have */\n\tkimage_free_page_list(&image->dest_pages);\n\n\t/* Walk through and free any unusable pages I have cached */\n\tkimage_free_page_list(&image->unusable_pages);\n\n}"
  },
  {
    "function_name": "kimage_add_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "573-581",
    "snippet": "static int kimage_add_page(struct kimage *image, unsigned long page)\n{\n\tint result;\n\n\tpage &= PAGE_MASK;\n\tresult = kimage_add_entry(image, page | IND_SOURCE);\n\n\treturn result;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kimage_add_entry",
          "args": [
            "image",
            "page | IND_SOURCE"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_add_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "535-559",
          "snippet": "static int kimage_add_entry(struct kimage *image, kimage_entry_t entry)\n{\n\tif (*image->entry != 0)\n\t\timage->entry++;\n\n\tif (image->entry == image->last_entry) {\n\t\tkimage_entry_t *ind_page;\n\t\tstruct page *page;\n\n\t\tpage = kimage_alloc_page(image, GFP_KERNEL, KIMAGE_NO_DEST);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tind_page = page_address(page);\n\t\t*image->entry = virt_to_boot_phys(ind_page) | IND_INDIRECTION;\n\t\timage->entry = ind_page;\n\t\timage->last_entry = ind_page +\n\t\t\t\t      ((PAGE_SIZE/sizeof(kimage_entry_t)) - 1);\n\t}\n\t*image->entry = entry;\n\timage->entry++;\n\t*image->entry = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define KIMAGE_NO_DEST (-1UL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\n#define KIMAGE_NO_DEST (-1UL)\n\nstatic int kimage_add_entry(struct kimage *image, kimage_entry_t entry)\n{\n\tif (*image->entry != 0)\n\t\timage->entry++;\n\n\tif (image->entry == image->last_entry) {\n\t\tkimage_entry_t *ind_page;\n\t\tstruct page *page;\n\n\t\tpage = kimage_alloc_page(image, GFP_KERNEL, KIMAGE_NO_DEST);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tind_page = page_address(page);\n\t\t*image->entry = virt_to_boot_phys(ind_page) | IND_INDIRECTION;\n\t\timage->entry = ind_page;\n\t\timage->last_entry = ind_page +\n\t\t\t\t      ((PAGE_SIZE/sizeof(kimage_entry_t)) - 1);\n\t}\n\t*image->entry = entry;\n\timage->entry++;\n\t*image->entry = 0;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kimage_add_page(struct kimage *image, unsigned long page)\n{\n\tint result;\n\n\tpage &= PAGE_MASK;\n\tresult = kimage_add_entry(image, page | IND_SOURCE);\n\n\treturn result;\n}"
  },
  {
    "function_name": "kimage_set_destination",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "561-570",
    "snippet": "static int kimage_set_destination(struct kimage *image,\n\t\t\t\t   unsigned long destination)\n{\n\tint result;\n\n\tdestination &= PAGE_MASK;\n\tresult = kimage_add_entry(image, destination | IND_DESTINATION);\n\n\treturn result;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kimage_add_entry",
          "args": [
            "image",
            "destination | IND_DESTINATION"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_add_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "535-559",
          "snippet": "static int kimage_add_entry(struct kimage *image, kimage_entry_t entry)\n{\n\tif (*image->entry != 0)\n\t\timage->entry++;\n\n\tif (image->entry == image->last_entry) {\n\t\tkimage_entry_t *ind_page;\n\t\tstruct page *page;\n\n\t\tpage = kimage_alloc_page(image, GFP_KERNEL, KIMAGE_NO_DEST);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tind_page = page_address(page);\n\t\t*image->entry = virt_to_boot_phys(ind_page) | IND_INDIRECTION;\n\t\timage->entry = ind_page;\n\t\timage->last_entry = ind_page +\n\t\t\t\t      ((PAGE_SIZE/sizeof(kimage_entry_t)) - 1);\n\t}\n\t*image->entry = entry;\n\timage->entry++;\n\t*image->entry = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define KIMAGE_NO_DEST (-1UL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\n#define KIMAGE_NO_DEST (-1UL)\n\nstatic int kimage_add_entry(struct kimage *image, kimage_entry_t entry)\n{\n\tif (*image->entry != 0)\n\t\timage->entry++;\n\n\tif (image->entry == image->last_entry) {\n\t\tkimage_entry_t *ind_page;\n\t\tstruct page *page;\n\n\t\tpage = kimage_alloc_page(image, GFP_KERNEL, KIMAGE_NO_DEST);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tind_page = page_address(page);\n\t\t*image->entry = virt_to_boot_phys(ind_page) | IND_INDIRECTION;\n\t\timage->entry = ind_page;\n\t\timage->last_entry = ind_page +\n\t\t\t\t      ((PAGE_SIZE/sizeof(kimage_entry_t)) - 1);\n\t}\n\t*image->entry = entry;\n\timage->entry++;\n\t*image->entry = 0;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic int kimage_set_destination(struct kimage *image,\n\t\t\t\t   unsigned long destination)\n{\n\tint result;\n\n\tdestination &= PAGE_MASK;\n\tresult = kimage_add_entry(image, destination | IND_DESTINATION);\n\n\treturn result;\n}"
  },
  {
    "function_name": "kimage_add_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "535-559",
    "snippet": "static int kimage_add_entry(struct kimage *image, kimage_entry_t entry)\n{\n\tif (*image->entry != 0)\n\t\timage->entry++;\n\n\tif (image->entry == image->last_entry) {\n\t\tkimage_entry_t *ind_page;\n\t\tstruct page *page;\n\n\t\tpage = kimage_alloc_page(image, GFP_KERNEL, KIMAGE_NO_DEST);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tind_page = page_address(page);\n\t\t*image->entry = virt_to_boot_phys(ind_page) | IND_INDIRECTION;\n\t\timage->entry = ind_page;\n\t\timage->last_entry = ind_page +\n\t\t\t\t      ((PAGE_SIZE/sizeof(kimage_entry_t)) - 1);\n\t}\n\t*image->entry = entry;\n\timage->entry++;\n\t*image->entry = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define KIMAGE_NO_DEST (-1UL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virt_to_boot_phys",
          "args": [
            "ind_page"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kimage_alloc_page",
          "args": [
            "image",
            "GFP_KERNEL",
            "KIMAGE_NO_DEST"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_alloc_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "685-780",
          "snippet": "static struct page *kimage_alloc_page(struct kimage *image,\n\t\t\t\t\tgfp_t gfp_mask,\n\t\t\t\t\tunsigned long destination)\n{\n\t/*\n\t * Here we implement safeguards to ensure that a source page\n\t * is not copied to its destination page before the data on\n\t * the destination page is no longer useful.\n\t *\n\t * To do this we maintain the invariant that a source page is\n\t * either its own destination page, or it is not a\n\t * destination page at all.\n\t *\n\t * That is slightly stronger than required, but the proof\n\t * that no problems will not occur is trivial, and the\n\t * implementation is simply to verify.\n\t *\n\t * When allocating all pages normally this algorithm will run\n\t * in O(N) time, but in the worst case it will run in O(N^2)\n\t * time.   If the runtime is a problem the data structures can\n\t * be fixed.\n\t */\n\tstruct page *page;\n\tunsigned long addr;\n\n\t/*\n\t * Walk through the list of destination pages, and see if I\n\t * have a match.\n\t */\n\tlist_for_each_entry(page, &image->dest_pages, lru) {\n\t\taddr = page_to_boot_pfn(page) << PAGE_SHIFT;\n\t\tif (addr == destination) {\n\t\t\tlist_del(&page->lru);\n\t\t\treturn page;\n\t\t}\n\t}\n\tpage = NULL;\n\twhile (1) {\n\t\tkimage_entry_t *old;\n\n\t\t/* Allocate a page, if we run out of memory give up */\n\t\tpage = kimage_alloc_pages(gfp_mask, 0);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\t/* If the page cannot be used file it away */\n\t\tif (page_to_boot_pfn(page) >\n\t\t\t\t(KEXEC_SOURCE_MEMORY_LIMIT >> PAGE_SHIFT)) {\n\t\t\tlist_add(&page->lru, &image->unusable_pages);\n\t\t\tcontinue;\n\t\t}\n\t\taddr = page_to_boot_pfn(page) << PAGE_SHIFT;\n\n\t\t/* If it is the destination page we want use it */\n\t\tif (addr == destination)\n\t\t\tbreak;\n\n\t\t/* If the page is not a destination page use it */\n\t\tif (!kimage_is_destination_range(image, addr,\n\t\t\t\t\t\t  addr + PAGE_SIZE))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * I know that the page is someones destination page.\n\t\t * See if there is already a source page for this\n\t\t * destination page.  And if so swap the source pages.\n\t\t */\n\t\told = kimage_dst_used(image, addr);\n\t\tif (old) {\n\t\t\t/* If so move it */\n\t\t\tunsigned long old_addr;\n\t\t\tstruct page *old_page;\n\n\t\t\told_addr = *old & PAGE_MASK;\n\t\t\told_page = boot_pfn_to_page(old_addr >> PAGE_SHIFT);\n\t\t\tcopy_highpage(page, old_page);\n\t\t\t*old = addr | (*old & ~PAGE_MASK);\n\n\t\t\t/* The old page I have found cannot be a\n\t\t\t * destination page, so return it if it's\n\t\t\t * gfp_flags honor the ones passed in.\n\t\t\t */\n\t\t\tif (!(gfp_mask & __GFP_HIGHMEM) &&\n\t\t\t    PageHighMem(old_page)) {\n\t\t\t\tkimage_free_pages(old_page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taddr = old_addr;\n\t\t\tpage = old_page;\n\t\t\tbreak;\n\t\t}\n\t\t/* Place the page on the destination list, to be used later */\n\t\tlist_add(&page->lru, &image->dest_pages);\n\t}\n\n\treturn page;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic struct page *kimage_alloc_page(struct kimage *image,\n\t\t\t\t\tgfp_t gfp_mask,\n\t\t\t\t\tunsigned long destination)\n{\n\t/*\n\t * Here we implement safeguards to ensure that a source page\n\t * is not copied to its destination page before the data on\n\t * the destination page is no longer useful.\n\t *\n\t * To do this we maintain the invariant that a source page is\n\t * either its own destination page, or it is not a\n\t * destination page at all.\n\t *\n\t * That is slightly stronger than required, but the proof\n\t * that no problems will not occur is trivial, and the\n\t * implementation is simply to verify.\n\t *\n\t * When allocating all pages normally this algorithm will run\n\t * in O(N) time, but in the worst case it will run in O(N^2)\n\t * time.   If the runtime is a problem the data structures can\n\t * be fixed.\n\t */\n\tstruct page *page;\n\tunsigned long addr;\n\n\t/*\n\t * Walk through the list of destination pages, and see if I\n\t * have a match.\n\t */\n\tlist_for_each_entry(page, &image->dest_pages, lru) {\n\t\taddr = page_to_boot_pfn(page) << PAGE_SHIFT;\n\t\tif (addr == destination) {\n\t\t\tlist_del(&page->lru);\n\t\t\treturn page;\n\t\t}\n\t}\n\tpage = NULL;\n\twhile (1) {\n\t\tkimage_entry_t *old;\n\n\t\t/* Allocate a page, if we run out of memory give up */\n\t\tpage = kimage_alloc_pages(gfp_mask, 0);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\t/* If the page cannot be used file it away */\n\t\tif (page_to_boot_pfn(page) >\n\t\t\t\t(KEXEC_SOURCE_MEMORY_LIMIT >> PAGE_SHIFT)) {\n\t\t\tlist_add(&page->lru, &image->unusable_pages);\n\t\t\tcontinue;\n\t\t}\n\t\taddr = page_to_boot_pfn(page) << PAGE_SHIFT;\n\n\t\t/* If it is the destination page we want use it */\n\t\tif (addr == destination)\n\t\t\tbreak;\n\n\t\t/* If the page is not a destination page use it */\n\t\tif (!kimage_is_destination_range(image, addr,\n\t\t\t\t\t\t  addr + PAGE_SIZE))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * I know that the page is someones destination page.\n\t\t * See if there is already a source page for this\n\t\t * destination page.  And if so swap the source pages.\n\t\t */\n\t\told = kimage_dst_used(image, addr);\n\t\tif (old) {\n\t\t\t/* If so move it */\n\t\t\tunsigned long old_addr;\n\t\t\tstruct page *old_page;\n\n\t\t\told_addr = *old & PAGE_MASK;\n\t\t\told_page = boot_pfn_to_page(old_addr >> PAGE_SHIFT);\n\t\t\tcopy_highpage(page, old_page);\n\t\t\t*old = addr | (*old & ~PAGE_MASK);\n\n\t\t\t/* The old page I have found cannot be a\n\t\t\t * destination page, so return it if it's\n\t\t\t * gfp_flags honor the ones passed in.\n\t\t\t */\n\t\t\tif (!(gfp_mask & __GFP_HIGHMEM) &&\n\t\t\t    PageHighMem(old_page)) {\n\t\t\t\tkimage_free_pages(old_page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taddr = old_addr;\n\t\t\tpage = old_page;\n\t\t\tbreak;\n\t\t}\n\t\t/* Place the page on the destination list, to be used later */\n\t\tlist_add(&page->lru, &image->dest_pages);\n\t}\n\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\n#define KIMAGE_NO_DEST (-1UL)\n\nstatic int kimage_add_entry(struct kimage *image, kimage_entry_t entry)\n{\n\tif (*image->entry != 0)\n\t\timage->entry++;\n\n\tif (image->entry == image->last_entry) {\n\t\tkimage_entry_t *ind_page;\n\t\tstruct page *page;\n\n\t\tpage = kimage_alloc_page(image, GFP_KERNEL, KIMAGE_NO_DEST);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tind_page = page_address(page);\n\t\t*image->entry = virt_to_boot_phys(ind_page) | IND_INDIRECTION;\n\t\timage->entry = ind_page;\n\t\timage->last_entry = ind_page +\n\t\t\t\t      ((PAGE_SIZE/sizeof(kimage_entry_t)) - 1);\n\t}\n\t*image->entry = entry;\n\timage->entry++;\n\t*image->entry = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kimage_crash_copy_vmcoreinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "501-533",
    "snippet": "int kimage_crash_copy_vmcoreinfo(struct kimage *image)\n{\n\tstruct page *vmcoreinfo_page;\n\tvoid *safecopy;\n\n\tif (image->type != KEXEC_TYPE_CRASH)\n\t\treturn 0;\n\n\t/*\n\t * For kdump, allocate one vmcoreinfo safe copy from the\n\t * crash memory. as we have arch_kexec_protect_crashkres()\n\t * after kexec syscall, we naturally protect it from write\n\t * (even read) access under kernel direct mapping. But on\n\t * the other hand, we still need to operate it when crash\n\t * happens to generate vmcoreinfo note, hereby we rely on\n\t * vmap for this purpose.\n\t */\n\tvmcoreinfo_page = kimage_alloc_control_pages(image, 0);\n\tif (!vmcoreinfo_page) {\n\t\tpr_warn(\"Could not allocate vmcoreinfo buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tsafecopy = vmap(&vmcoreinfo_page, 1, VM_MAP, PAGE_KERNEL);\n\tif (!safecopy) {\n\t\tpr_warn(\"Could not vmap vmcoreinfo buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\timage->vmcoreinfo_data_copy = safecopy;\n\tcrash_update_vmcoreinfo_safecopy(safecopy);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "crash_update_vmcoreinfo_safecopy",
          "args": [
            "safecopy"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "crash_update_vmcoreinfo_safecopy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "342-348",
          "snippet": "void crash_update_vmcoreinfo_safecopy(void *ptr)\n{\n\tif (ptr)\n\t\tmemcpy(ptr, vmcoreinfo_data, vmcoreinfo_size);\n\n\tvmcoreinfo_data_safecopy = ptr;\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned char *vmcoreinfo_data;",
            "size_t vmcoreinfo_size;",
            "static unsigned char *vmcoreinfo_data_safecopy;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nunsigned char *vmcoreinfo_data;\nsize_t vmcoreinfo_size;\nstatic unsigned char *vmcoreinfo_data_safecopy;\n\nvoid crash_update_vmcoreinfo_safecopy(void *ptr)\n{\n\tif (ptr)\n\t\tmemcpy(ptr, vmcoreinfo_data, vmcoreinfo_size);\n\n\tvmcoreinfo_data_safecopy = ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not vmap vmcoreinfo buffer\\n\""
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmap",
          "args": [
            "&vmcoreinfo_page",
            "1",
            "VM_MAP",
            "PAGE_KERNEL"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not allocate vmcoreinfo buffer\\n\""
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kimage_alloc_control_pages",
          "args": [
            "image",
            "0"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_alloc_control_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "484-499",
          "snippet": "struct page *kimage_alloc_control_pages(struct kimage *image,\n\t\t\t\t\t unsigned int order)\n{\n\tstruct page *pages = NULL;\n\n\tswitch (image->type) {\n\tcase KEXEC_TYPE_DEFAULT:\n\t\tpages = kimage_alloc_normal_control_pages(image, order);\n\t\tbreak;\n\tcase KEXEC_TYPE_CRASH:\n\t\tpages = kimage_alloc_crash_control_pages(image, order);\n\t\tbreak;\n\t}\n\n\treturn pages;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct page *kimage_alloc_control_pages(struct kimage *image,\n\t\t\t\t\t unsigned int order)\n{\n\tstruct page *pages = NULL;\n\n\tswitch (image->type) {\n\tcase KEXEC_TYPE_DEFAULT:\n\t\tpages = kimage_alloc_normal_control_pages(image, order);\n\t\tbreak;\n\tcase KEXEC_TYPE_CRASH:\n\t\tpages = kimage_alloc_crash_control_pages(image, order);\n\t\tbreak;\n\t}\n\n\treturn pages;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint kimage_crash_copy_vmcoreinfo(struct kimage *image)\n{\n\tstruct page *vmcoreinfo_page;\n\tvoid *safecopy;\n\n\tif (image->type != KEXEC_TYPE_CRASH)\n\t\treturn 0;\n\n\t/*\n\t * For kdump, allocate one vmcoreinfo safe copy from the\n\t * crash memory. as we have arch_kexec_protect_crashkres()\n\t * after kexec syscall, we naturally protect it from write\n\t * (even read) access under kernel direct mapping. But on\n\t * the other hand, we still need to operate it when crash\n\t * happens to generate vmcoreinfo note, hereby we rely on\n\t * vmap for this purpose.\n\t */\n\tvmcoreinfo_page = kimage_alloc_control_pages(image, 0);\n\tif (!vmcoreinfo_page) {\n\t\tpr_warn(\"Could not allocate vmcoreinfo buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tsafecopy = vmap(&vmcoreinfo_page, 1, VM_MAP, PAGE_KERNEL);\n\tif (!safecopy) {\n\t\tpr_warn(\"Could not vmap vmcoreinfo buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\timage->vmcoreinfo_data_copy = safecopy;\n\tcrash_update_vmcoreinfo_safecopy(safecopy);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kimage_alloc_control_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "484-499",
    "snippet": "struct page *kimage_alloc_control_pages(struct kimage *image,\n\t\t\t\t\t unsigned int order)\n{\n\tstruct page *pages = NULL;\n\n\tswitch (image->type) {\n\tcase KEXEC_TYPE_DEFAULT:\n\t\tpages = kimage_alloc_normal_control_pages(image, order);\n\t\tbreak;\n\tcase KEXEC_TYPE_CRASH:\n\t\tpages = kimage_alloc_crash_control_pages(image, order);\n\t\tbreak;\n\t}\n\n\treturn pages;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kimage_alloc_crash_control_pages",
          "args": [
            "image",
            "order"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_alloc_crash_control_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "417-481",
          "snippet": "static struct page *kimage_alloc_crash_control_pages(struct kimage *image,\n\t\t\t\t\t\t      unsigned int order)\n{\n\t/* Control pages are special, they are the intermediaries\n\t * that are needed while we copy the rest of the pages\n\t * to their final resting place.  As such they must\n\t * not conflict with either the destination addresses\n\t * or memory the kernel is already using.\n\t *\n\t * Control pages are also the only pags we must allocate\n\t * when loading a crash kernel.  All of the other pages\n\t * are specified by the segments and we just memcpy\n\t * into them directly.\n\t *\n\t * The only case where we really need more than one of\n\t * these are for architectures where we cannot disable\n\t * the MMU and must instead generate an identity mapped\n\t * page table for all of the memory.\n\t *\n\t * Given the low demand this implements a very simple\n\t * allocator that finds the first hole of the appropriate\n\t * size in the reserved memory region, and allocates all\n\t * of the memory up to and including the hole.\n\t */\n\tunsigned long hole_start, hole_end, size;\n\tstruct page *pages;\n\n\tpages = NULL;\n\tsize = (1 << order) << PAGE_SHIFT;\n\thole_start = (image->control_page + (size - 1)) & ~(size - 1);\n\thole_end   = hole_start + size - 1;\n\twhile (hole_end <= crashk_res.end) {\n\t\tunsigned long i;\n\n\t\tcond_resched();\n\n\t\tif (hole_end > KEXEC_CRASH_CONTROL_MEMORY_LIMIT)\n\t\t\tbreak;\n\t\t/* See if I overlap any of the segments */\n\t\tfor (i = 0; i < image->nr_segments; i++) {\n\t\t\tunsigned long mstart, mend;\n\n\t\t\tmstart = image->segment[i].mem;\n\t\t\tmend   = mstart + image->segment[i].memsz - 1;\n\t\t\tif ((hole_end >= mstart) && (hole_start <= mend)) {\n\t\t\t\t/* Advance the hole to the end of the segment */\n\t\t\t\thole_start = (mend + (size - 1)) & ~(size - 1);\n\t\t\t\thole_end   = hole_start + size - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* If I don't overlap any segments I have found my hole! */\n\t\tif (i == image->nr_segments) {\n\t\t\tpages = pfn_to_page(hole_start >> PAGE_SHIFT);\n\t\t\timage->control_page = hole_end;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Ensure that these pages are decrypted if SME is enabled. */\n\tif (pages)\n\t\tarch_kexec_post_alloc_pages(page_address(pages), 1 << order, 0);\n\n\treturn pages;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct resource crashk_res = {\n\t.name  = \"Crash kernel\",\n\t.start = 0,\n\t.end   = 0,\n\t.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,\n\t.desc  = IORES_DESC_CRASH_KERNEL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct resource crashk_res = {\n\t.name  = \"Crash kernel\",\n\t.start = 0,\n\t.end   = 0,\n\t.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,\n\t.desc  = IORES_DESC_CRASH_KERNEL\n};\n\nstatic struct page *kimage_alloc_crash_control_pages(struct kimage *image,\n\t\t\t\t\t\t      unsigned int order)\n{\n\t/* Control pages are special, they are the intermediaries\n\t * that are needed while we copy the rest of the pages\n\t * to their final resting place.  As such they must\n\t * not conflict with either the destination addresses\n\t * or memory the kernel is already using.\n\t *\n\t * Control pages are also the only pags we must allocate\n\t * when loading a crash kernel.  All of the other pages\n\t * are specified by the segments and we just memcpy\n\t * into them directly.\n\t *\n\t * The only case where we really need more than one of\n\t * these are for architectures where we cannot disable\n\t * the MMU and must instead generate an identity mapped\n\t * page table for all of the memory.\n\t *\n\t * Given the low demand this implements a very simple\n\t * allocator that finds the first hole of the appropriate\n\t * size in the reserved memory region, and allocates all\n\t * of the memory up to and including the hole.\n\t */\n\tunsigned long hole_start, hole_end, size;\n\tstruct page *pages;\n\n\tpages = NULL;\n\tsize = (1 << order) << PAGE_SHIFT;\n\thole_start = (image->control_page + (size - 1)) & ~(size - 1);\n\thole_end   = hole_start + size - 1;\n\twhile (hole_end <= crashk_res.end) {\n\t\tunsigned long i;\n\n\t\tcond_resched();\n\n\t\tif (hole_end > KEXEC_CRASH_CONTROL_MEMORY_LIMIT)\n\t\t\tbreak;\n\t\t/* See if I overlap any of the segments */\n\t\tfor (i = 0; i < image->nr_segments; i++) {\n\t\t\tunsigned long mstart, mend;\n\n\t\t\tmstart = image->segment[i].mem;\n\t\t\tmend   = mstart + image->segment[i].memsz - 1;\n\t\t\tif ((hole_end >= mstart) && (hole_start <= mend)) {\n\t\t\t\t/* Advance the hole to the end of the segment */\n\t\t\t\thole_start = (mend + (size - 1)) & ~(size - 1);\n\t\t\t\thole_end   = hole_start + size - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* If I don't overlap any segments I have found my hole! */\n\t\tif (i == image->nr_segments) {\n\t\t\tpages = pfn_to_page(hole_start >> PAGE_SHIFT);\n\t\t\timage->control_page = hole_end;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Ensure that these pages are decrypted if SME is enabled. */\n\tif (pages)\n\t\tarch_kexec_post_alloc_pages(page_address(pages), 1 << order, 0);\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kimage_alloc_normal_control_pages",
          "args": [
            "image",
            "order"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_alloc_normal_control_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "351-415",
          "snippet": "static struct page *kimage_alloc_normal_control_pages(struct kimage *image,\n\t\t\t\t\t\t\tunsigned int order)\n{\n\t/* Control pages are special, they are the intermediaries\n\t * that are needed while we copy the rest of the pages\n\t * to their final resting place.  As such they must\n\t * not conflict with either the destination addresses\n\t * or memory the kernel is already using.\n\t *\n\t * The only case where we really need more than one of\n\t * these are for architectures where we cannot disable\n\t * the MMU and must instead generate an identity mapped\n\t * page table for all of the memory.\n\t *\n\t * At worst this runs in O(N) of the image size.\n\t */\n\tstruct list_head extra_pages;\n\tstruct page *pages;\n\tunsigned int count;\n\n\tcount = 1 << order;\n\tINIT_LIST_HEAD(&extra_pages);\n\n\t/* Loop while I can allocate a page and the page allocated\n\t * is a destination page.\n\t */\n\tdo {\n\t\tunsigned long pfn, epfn, addr, eaddr;\n\n\t\tpages = kimage_alloc_pages(KEXEC_CONTROL_MEMORY_GFP, order);\n\t\tif (!pages)\n\t\t\tbreak;\n\t\tpfn   = page_to_boot_pfn(pages);\n\t\tepfn  = pfn + count;\n\t\taddr  = pfn << PAGE_SHIFT;\n\t\teaddr = epfn << PAGE_SHIFT;\n\t\tif ((epfn >= (KEXEC_CONTROL_MEMORY_LIMIT >> PAGE_SHIFT)) ||\n\t\t\t      kimage_is_destination_range(image, addr, eaddr)) {\n\t\t\tlist_add(&pages->lru, &extra_pages);\n\t\t\tpages = NULL;\n\t\t}\n\t} while (!pages);\n\n\tif (pages) {\n\t\t/* Remember the allocated page... */\n\t\tlist_add(&pages->lru, &image->control_pages);\n\n\t\t/* Because the page is already in it's destination\n\t\t * location we will never allocate another page at\n\t\t * that address.  Therefore kimage_alloc_pages\n\t\t * will not return it (again) and we don't need\n\t\t * to give it an entry in image->segment[].\n\t\t */\n\t}\n\t/* Deal with the destination pages I have inadvertently allocated.\n\t *\n\t * Ideally I would convert multi-page allocations into single\n\t * page allocations, and add everything to image->dest_pages.\n\t *\n\t * For now it is simpler to just free the pages.\n\t */\n\tkimage_free_page_list(&extra_pages);\n\n\treturn pages;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic struct page *kimage_alloc_normal_control_pages(struct kimage *image,\n\t\t\t\t\t\t\tunsigned int order)\n{\n\t/* Control pages are special, they are the intermediaries\n\t * that are needed while we copy the rest of the pages\n\t * to their final resting place.  As such they must\n\t * not conflict with either the destination addresses\n\t * or memory the kernel is already using.\n\t *\n\t * The only case where we really need more than one of\n\t * these are for architectures where we cannot disable\n\t * the MMU and must instead generate an identity mapped\n\t * page table for all of the memory.\n\t *\n\t * At worst this runs in O(N) of the image size.\n\t */\n\tstruct list_head extra_pages;\n\tstruct page *pages;\n\tunsigned int count;\n\n\tcount = 1 << order;\n\tINIT_LIST_HEAD(&extra_pages);\n\n\t/* Loop while I can allocate a page and the page allocated\n\t * is a destination page.\n\t */\n\tdo {\n\t\tunsigned long pfn, epfn, addr, eaddr;\n\n\t\tpages = kimage_alloc_pages(KEXEC_CONTROL_MEMORY_GFP, order);\n\t\tif (!pages)\n\t\t\tbreak;\n\t\tpfn   = page_to_boot_pfn(pages);\n\t\tepfn  = pfn + count;\n\t\taddr  = pfn << PAGE_SHIFT;\n\t\teaddr = epfn << PAGE_SHIFT;\n\t\tif ((epfn >= (KEXEC_CONTROL_MEMORY_LIMIT >> PAGE_SHIFT)) ||\n\t\t\t      kimage_is_destination_range(image, addr, eaddr)) {\n\t\t\tlist_add(&pages->lru, &extra_pages);\n\t\t\tpages = NULL;\n\t\t}\n\t} while (!pages);\n\n\tif (pages) {\n\t\t/* Remember the allocated page... */\n\t\tlist_add(&pages->lru, &image->control_pages);\n\n\t\t/* Because the page is already in it's destination\n\t\t * location we will never allocate another page at\n\t\t * that address.  Therefore kimage_alloc_pages\n\t\t * will not return it (again) and we don't need\n\t\t * to give it an entry in image->segment[].\n\t\t */\n\t}\n\t/* Deal with the destination pages I have inadvertently allocated.\n\t *\n\t * Ideally I would convert multi-page allocations into single\n\t * page allocations, and add everything to image->dest_pages.\n\t *\n\t * For now it is simpler to just free the pages.\n\t */\n\tkimage_free_page_list(&extra_pages);\n\n\treturn pages;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct page *kimage_alloc_control_pages(struct kimage *image,\n\t\t\t\t\t unsigned int order)\n{\n\tstruct page *pages = NULL;\n\n\tswitch (image->type) {\n\tcase KEXEC_TYPE_DEFAULT:\n\t\tpages = kimage_alloc_normal_control_pages(image, order);\n\t\tbreak;\n\tcase KEXEC_TYPE_CRASH:\n\t\tpages = kimage_alloc_crash_control_pages(image, order);\n\t\tbreak;\n\t}\n\n\treturn pages;\n}"
  },
  {
    "function_name": "kimage_alloc_crash_control_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "417-481",
    "snippet": "static struct page *kimage_alloc_crash_control_pages(struct kimage *image,\n\t\t\t\t\t\t      unsigned int order)\n{\n\t/* Control pages are special, they are the intermediaries\n\t * that are needed while we copy the rest of the pages\n\t * to their final resting place.  As such they must\n\t * not conflict with either the destination addresses\n\t * or memory the kernel is already using.\n\t *\n\t * Control pages are also the only pags we must allocate\n\t * when loading a crash kernel.  All of the other pages\n\t * are specified by the segments and we just memcpy\n\t * into them directly.\n\t *\n\t * The only case where we really need more than one of\n\t * these are for architectures where we cannot disable\n\t * the MMU and must instead generate an identity mapped\n\t * page table for all of the memory.\n\t *\n\t * Given the low demand this implements a very simple\n\t * allocator that finds the first hole of the appropriate\n\t * size in the reserved memory region, and allocates all\n\t * of the memory up to and including the hole.\n\t */\n\tunsigned long hole_start, hole_end, size;\n\tstruct page *pages;\n\n\tpages = NULL;\n\tsize = (1 << order) << PAGE_SHIFT;\n\thole_start = (image->control_page + (size - 1)) & ~(size - 1);\n\thole_end   = hole_start + size - 1;\n\twhile (hole_end <= crashk_res.end) {\n\t\tunsigned long i;\n\n\t\tcond_resched();\n\n\t\tif (hole_end > KEXEC_CRASH_CONTROL_MEMORY_LIMIT)\n\t\t\tbreak;\n\t\t/* See if I overlap any of the segments */\n\t\tfor (i = 0; i < image->nr_segments; i++) {\n\t\t\tunsigned long mstart, mend;\n\n\t\t\tmstart = image->segment[i].mem;\n\t\t\tmend   = mstart + image->segment[i].memsz - 1;\n\t\t\tif ((hole_end >= mstart) && (hole_start <= mend)) {\n\t\t\t\t/* Advance the hole to the end of the segment */\n\t\t\t\thole_start = (mend + (size - 1)) & ~(size - 1);\n\t\t\t\thole_end   = hole_start + size - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* If I don't overlap any segments I have found my hole! */\n\t\tif (i == image->nr_segments) {\n\t\t\tpages = pfn_to_page(hole_start >> PAGE_SHIFT);\n\t\t\timage->control_page = hole_end;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Ensure that these pages are decrypted if SME is enabled. */\n\tif (pages)\n\t\tarch_kexec_post_alloc_pages(page_address(pages), 1 << order, 0);\n\n\treturn pages;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource crashk_res = {\n\t.name  = \"Crash kernel\",\n\t.start = 0,\n\t.end   = 0,\n\t.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,\n\t.desc  = IORES_DESC_CRASH_KERNEL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_kexec_post_alloc_pages",
          "args": [
            "page_address(pages)",
            "1 << order",
            "0"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "pages"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "hole_start >> PAGE_SHIFT"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct resource crashk_res = {\n\t.name  = \"Crash kernel\",\n\t.start = 0,\n\t.end   = 0,\n\t.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,\n\t.desc  = IORES_DESC_CRASH_KERNEL\n};\n\nstatic struct page *kimage_alloc_crash_control_pages(struct kimage *image,\n\t\t\t\t\t\t      unsigned int order)\n{\n\t/* Control pages are special, they are the intermediaries\n\t * that are needed while we copy the rest of the pages\n\t * to their final resting place.  As such they must\n\t * not conflict with either the destination addresses\n\t * or memory the kernel is already using.\n\t *\n\t * Control pages are also the only pags we must allocate\n\t * when loading a crash kernel.  All of the other pages\n\t * are specified by the segments and we just memcpy\n\t * into them directly.\n\t *\n\t * The only case where we really need more than one of\n\t * these are for architectures where we cannot disable\n\t * the MMU and must instead generate an identity mapped\n\t * page table for all of the memory.\n\t *\n\t * Given the low demand this implements a very simple\n\t * allocator that finds the first hole of the appropriate\n\t * size in the reserved memory region, and allocates all\n\t * of the memory up to and including the hole.\n\t */\n\tunsigned long hole_start, hole_end, size;\n\tstruct page *pages;\n\n\tpages = NULL;\n\tsize = (1 << order) << PAGE_SHIFT;\n\thole_start = (image->control_page + (size - 1)) & ~(size - 1);\n\thole_end   = hole_start + size - 1;\n\twhile (hole_end <= crashk_res.end) {\n\t\tunsigned long i;\n\n\t\tcond_resched();\n\n\t\tif (hole_end > KEXEC_CRASH_CONTROL_MEMORY_LIMIT)\n\t\t\tbreak;\n\t\t/* See if I overlap any of the segments */\n\t\tfor (i = 0; i < image->nr_segments; i++) {\n\t\t\tunsigned long mstart, mend;\n\n\t\t\tmstart = image->segment[i].mem;\n\t\t\tmend   = mstart + image->segment[i].memsz - 1;\n\t\t\tif ((hole_end >= mstart) && (hole_start <= mend)) {\n\t\t\t\t/* Advance the hole to the end of the segment */\n\t\t\t\thole_start = (mend + (size - 1)) & ~(size - 1);\n\t\t\t\thole_end   = hole_start + size - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* If I don't overlap any segments I have found my hole! */\n\t\tif (i == image->nr_segments) {\n\t\t\tpages = pfn_to_page(hole_start >> PAGE_SHIFT);\n\t\t\timage->control_page = hole_end;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Ensure that these pages are decrypted if SME is enabled. */\n\tif (pages)\n\t\tarch_kexec_post_alloc_pages(page_address(pages), 1 << order, 0);\n\n\treturn pages;\n}"
  },
  {
    "function_name": "kimage_alloc_normal_control_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "351-415",
    "snippet": "static struct page *kimage_alloc_normal_control_pages(struct kimage *image,\n\t\t\t\t\t\t\tunsigned int order)\n{\n\t/* Control pages are special, they are the intermediaries\n\t * that are needed while we copy the rest of the pages\n\t * to their final resting place.  As such they must\n\t * not conflict with either the destination addresses\n\t * or memory the kernel is already using.\n\t *\n\t * The only case where we really need more than one of\n\t * these are for architectures where we cannot disable\n\t * the MMU and must instead generate an identity mapped\n\t * page table for all of the memory.\n\t *\n\t * At worst this runs in O(N) of the image size.\n\t */\n\tstruct list_head extra_pages;\n\tstruct page *pages;\n\tunsigned int count;\n\n\tcount = 1 << order;\n\tINIT_LIST_HEAD(&extra_pages);\n\n\t/* Loop while I can allocate a page and the page allocated\n\t * is a destination page.\n\t */\n\tdo {\n\t\tunsigned long pfn, epfn, addr, eaddr;\n\n\t\tpages = kimage_alloc_pages(KEXEC_CONTROL_MEMORY_GFP, order);\n\t\tif (!pages)\n\t\t\tbreak;\n\t\tpfn   = page_to_boot_pfn(pages);\n\t\tepfn  = pfn + count;\n\t\taddr  = pfn << PAGE_SHIFT;\n\t\teaddr = epfn << PAGE_SHIFT;\n\t\tif ((epfn >= (KEXEC_CONTROL_MEMORY_LIMIT >> PAGE_SHIFT)) ||\n\t\t\t      kimage_is_destination_range(image, addr, eaddr)) {\n\t\t\tlist_add(&pages->lru, &extra_pages);\n\t\t\tpages = NULL;\n\t\t}\n\t} while (!pages);\n\n\tif (pages) {\n\t\t/* Remember the allocated page... */\n\t\tlist_add(&pages->lru, &image->control_pages);\n\n\t\t/* Because the page is already in it's destination\n\t\t * location we will never allocate another page at\n\t\t * that address.  Therefore kimage_alloc_pages\n\t\t * will not return it (again) and we don't need\n\t\t * to give it an entry in image->segment[].\n\t\t */\n\t}\n\t/* Deal with the destination pages I have inadvertently allocated.\n\t *\n\t * Ideally I would convert multi-page allocations into single\n\t * page allocations, and add everything to image->dest_pages.\n\t *\n\t * For now it is simpler to just free the pages.\n\t */\n\tkimage_free_page_list(&extra_pages);\n\n\treturn pages;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kimage_free_page_list",
          "args": [
            "&extra_pages"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "341-349",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&pages->lru",
            "&image->control_pages"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kimage_is_destination_range",
          "args": [
            "image",
            "addr",
            "eaddr"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_is_destination_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "282-298",
          "snippet": "int kimage_is_destination_range(struct kimage *image,\n\t\t\t\t\tunsigned long start,\n\t\t\t\t\tunsigned long end)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < image->nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend = mstart + image->segment[i].memsz;\n\t\tif ((end > mstart) && (start < mend))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint kimage_is_destination_range(struct kimage *image,\n\t\t\t\t\tunsigned long start,\n\t\t\t\t\tunsigned long end)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < image->nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend = mstart + image->segment[i].memsz;\n\t\tif ((end > mstart) && (start < mend))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_boot_pfn",
          "args": [
            "pages"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kimage_alloc_pages",
          "args": [
            "KEXEC_CONTROL_MEMORY_GFP",
            "order"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_alloc_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "300-325",
          "snippet": "static struct page *kimage_alloc_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *pages;\n\n\tif (fatal_signal_pending(current))\n\t\treturn NULL;\n\tpages = alloc_pages(gfp_mask & ~__GFP_ZERO, order);\n\tif (pages) {\n\t\tunsigned int count, i;\n\n\t\tpages->mapping = NULL;\n\t\tset_page_private(pages, order);\n\t\tcount = 1 << order;\n\t\tfor (i = 0; i < count; i++)\n\t\t\tSetPageReserved(pages + i);\n\n\t\tarch_kexec_post_alloc_pages(page_address(pages), count,\n\t\t\t\t\t    gfp_mask);\n\n\t\tif (gfp_mask & __GFP_ZERO)\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tclear_highpage(pages + i);\n\t}\n\n\treturn pages;\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic struct page *kimage_alloc_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *pages;\n\n\tif (fatal_signal_pending(current))\n\t\treturn NULL;\n\tpages = alloc_pages(gfp_mask & ~__GFP_ZERO, order);\n\tif (pages) {\n\t\tunsigned int count, i;\n\n\t\tpages->mapping = NULL;\n\t\tset_page_private(pages, order);\n\t\tcount = 1 << order;\n\t\tfor (i = 0; i < count; i++)\n\t\t\tSetPageReserved(pages + i);\n\n\t\tarch_kexec_post_alloc_pages(page_address(pages), count,\n\t\t\t\t\t    gfp_mask);\n\n\t\tif (gfp_mask & __GFP_ZERO)\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tclear_highpage(pages + i);\n\t}\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&extra_pages"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic struct page *kimage_alloc_normal_control_pages(struct kimage *image,\n\t\t\t\t\t\t\tunsigned int order)\n{\n\t/* Control pages are special, they are the intermediaries\n\t * that are needed while we copy the rest of the pages\n\t * to their final resting place.  As such they must\n\t * not conflict with either the destination addresses\n\t * or memory the kernel is already using.\n\t *\n\t * The only case where we really need more than one of\n\t * these are for architectures where we cannot disable\n\t * the MMU and must instead generate an identity mapped\n\t * page table for all of the memory.\n\t *\n\t * At worst this runs in O(N) of the image size.\n\t */\n\tstruct list_head extra_pages;\n\tstruct page *pages;\n\tunsigned int count;\n\n\tcount = 1 << order;\n\tINIT_LIST_HEAD(&extra_pages);\n\n\t/* Loop while I can allocate a page and the page allocated\n\t * is a destination page.\n\t */\n\tdo {\n\t\tunsigned long pfn, epfn, addr, eaddr;\n\n\t\tpages = kimage_alloc_pages(KEXEC_CONTROL_MEMORY_GFP, order);\n\t\tif (!pages)\n\t\t\tbreak;\n\t\tpfn   = page_to_boot_pfn(pages);\n\t\tepfn  = pfn + count;\n\t\taddr  = pfn << PAGE_SHIFT;\n\t\teaddr = epfn << PAGE_SHIFT;\n\t\tif ((epfn >= (KEXEC_CONTROL_MEMORY_LIMIT >> PAGE_SHIFT)) ||\n\t\t\t      kimage_is_destination_range(image, addr, eaddr)) {\n\t\t\tlist_add(&pages->lru, &extra_pages);\n\t\t\tpages = NULL;\n\t\t}\n\t} while (!pages);\n\n\tif (pages) {\n\t\t/* Remember the allocated page... */\n\t\tlist_add(&pages->lru, &image->control_pages);\n\n\t\t/* Because the page is already in it's destination\n\t\t * location we will never allocate another page at\n\t\t * that address.  Therefore kimage_alloc_pages\n\t\t * will not return it (again) and we don't need\n\t\t * to give it an entry in image->segment[].\n\t\t */\n\t}\n\t/* Deal with the destination pages I have inadvertently allocated.\n\t *\n\t * Ideally I would convert multi-page allocations into single\n\t * page allocations, and add everything to image->dest_pages.\n\t *\n\t * For now it is simpler to just free the pages.\n\t */\n\tkimage_free_page_list(&extra_pages);\n\n\treturn pages;\n}"
  },
  {
    "function_name": "kimage_free_page_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "341-349",
    "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kimage_free_pages",
          "args": [
            "page"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "327-339",
          "snippet": "static void kimage_free_pages(struct page *page)\n{\n\tunsigned int order, count, i;\n\n\torder = page_private(page);\n\tcount = 1 << order;\n\n\tarch_kexec_pre_free_pages(page_address(page), count);\n\n\tfor (i = 0; i < count; i++)\n\t\tClearPageReserved(page + i);\n\t__free_pages(page, order);\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic void kimage_free_pages(struct page *page)\n{\n\tunsigned int order, count, i;\n\n\torder = page_private(page);\n\tcount = 1 << order;\n\n\tarch_kexec_pre_free_pages(page_address(page), count);\n\n\tfor (i = 0; i < count; i++)\n\t\tClearPageReserved(page + i);\n\t__free_pages(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "next",
            "list",
            "lru"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
  },
  {
    "function_name": "kimage_free_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "327-339",
    "snippet": "static void kimage_free_pages(struct page *page)\n{\n\tunsigned int order, count, i;\n\n\torder = page_private(page);\n\tcount = 1 << order;\n\n\tarch_kexec_pre_free_pages(page_address(page), count);\n\n\tfor (i = 0; i < count; i++)\n\t\tClearPageReserved(page + i);\n\t__free_pages(page, order);\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "order"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageReserved",
          "args": [
            "page + i"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_kexec_pre_free_pages",
          "args": [
            "page_address(page)",
            "count"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic void kimage_free_pages(struct page *page)\n{\n\tunsigned int order, count, i;\n\n\torder = page_private(page);\n\tcount = 1 << order;\n\n\tarch_kexec_pre_free_pages(page_address(page), count);\n\n\tfor (i = 0; i < count; i++)\n\t\tClearPageReserved(page + i);\n\t__free_pages(page, order);\n}"
  },
  {
    "function_name": "kimage_alloc_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "300-325",
    "snippet": "static struct page *kimage_alloc_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *pages;\n\n\tif (fatal_signal_pending(current))\n\t\treturn NULL;\n\tpages = alloc_pages(gfp_mask & ~__GFP_ZERO, order);\n\tif (pages) {\n\t\tunsigned int count, i;\n\n\t\tpages->mapping = NULL;\n\t\tset_page_private(pages, order);\n\t\tcount = 1 << order;\n\t\tfor (i = 0; i < count; i++)\n\t\t\tSetPageReserved(pages + i);\n\n\t\tarch_kexec_post_alloc_pages(page_address(pages), count,\n\t\t\t\t\t    gfp_mask);\n\n\t\tif (gfp_mask & __GFP_ZERO)\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tclear_highpage(pages + i);\n\t}\n\n\treturn pages;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_highpage",
          "args": [
            "pages + i"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_kexec_post_alloc_pages",
          "args": [
            "page_address(pages)",
            "count",
            "gfp_mask"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "pages"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageReserved",
          "args": [
            "pages + i"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "pages",
            "order"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "gfp_mask & ~__GFP_ZERO",
            "order"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_alloc_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "300-325",
          "snippet": "static struct page *kimage_alloc_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *pages;\n\n\tif (fatal_signal_pending(current))\n\t\treturn NULL;\n\tpages = alloc_pages(gfp_mask & ~__GFP_ZERO, order);\n\tif (pages) {\n\t\tunsigned int count, i;\n\n\t\tpages->mapping = NULL;\n\t\tset_page_private(pages, order);\n\t\tcount = 1 << order;\n\t\tfor (i = 0; i < count; i++)\n\t\t\tSetPageReserved(pages + i);\n\n\t\tarch_kexec_post_alloc_pages(page_address(pages), count,\n\t\t\t\t\t    gfp_mask);\n\n\t\tif (gfp_mask & __GFP_ZERO)\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tclear_highpage(pages + i);\n\t}\n\n\treturn pages;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstatic struct page *kimage_alloc_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *pages;\n\n\tif (fatal_signal_pending(current))\n\t\treturn NULL;\n\tpages = alloc_pages(gfp_mask & ~__GFP_ZERO, order);\n\tif (pages) {\n\t\tunsigned int count, i;\n\n\t\tpages->mapping = NULL;\n\t\tset_page_private(pages, order);\n\t\tcount = 1 << order;\n\t\tfor (i = 0; i < count; i++)\n\t\t\tSetPageReserved(pages + i);\n\n\t\tarch_kexec_post_alloc_pages(page_address(pages), count,\n\t\t\t\t\t    gfp_mask);\n\n\t\tif (gfp_mask & __GFP_ZERO)\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tclear_highpage(pages + i);\n\t}\n\n\treturn pages;\n}"
  },
  {
    "function_name": "kimage_is_destination_range",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "282-298",
    "snippet": "int kimage_is_destination_range(struct kimage *image,\n\t\t\t\t\tunsigned long start,\n\t\t\t\t\tunsigned long end)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < image->nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend = mstart + image->segment[i].memsz;\n\t\tif ((end > mstart) && (start < mend))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint kimage_is_destination_range(struct kimage *image,\n\t\t\t\t\tunsigned long start,\n\t\t\t\t\tunsigned long end)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < image->nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend = mstart + image->segment[i].memsz;\n\t\tif ((end > mstart) && (start < mend))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_kimage_alloc_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "255-280",
    "snippet": "struct kimage *do_kimage_alloc_init(void)\n{\n\tstruct kimage *image;\n\n\t/* Allocate a controlling structure */\n\timage = kzalloc(sizeof(*image), GFP_KERNEL);\n\tif (!image)\n\t\treturn NULL;\n\n\timage->head = 0;\n\timage->entry = &image->head;\n\timage->last_entry = &image->head;\n\timage->control_page = ~0; /* By default this does not apply */\n\timage->type = KEXEC_TYPE_DEFAULT;\n\n\t/* Initialize the list of control pages */\n\tINIT_LIST_HEAD(&image->control_pages);\n\n\t/* Initialize the list of destination pages */\n\tINIT_LIST_HEAD(&image->dest_pages);\n\n\t/* Initialize the list of unusable pages */\n\tINIT_LIST_HEAD(&image->unusable_pages);\n\n\treturn image;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&image->unusable_pages"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&image->dest_pages"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&image->control_pages"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*image)",
            "GFP_KERNEL"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct kimage *do_kimage_alloc_init(void)\n{\n\tstruct kimage *image;\n\n\t/* Allocate a controlling structure */\n\timage = kzalloc(sizeof(*image), GFP_KERNEL);\n\tif (!image)\n\t\treturn NULL;\n\n\timage->head = 0;\n\timage->entry = &image->head;\n\timage->last_entry = &image->head;\n\timage->control_page = ~0; /* By default this does not apply */\n\timage->type = KEXEC_TYPE_DEFAULT;\n\n\t/* Initialize the list of control pages */\n\tINIT_LIST_HEAD(&image->control_pages);\n\n\t/* Initialize the list of destination pages */\n\tINIT_LIST_HEAD(&image->dest_pages);\n\n\t/* Initialize the list of unusable pages */\n\tINIT_LIST_HEAD(&image->unusable_pages);\n\n\treturn image;\n}"
  },
  {
    "function_name": "sanity_check_segment_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "149-253",
    "snippet": "int sanity_check_segment_list(struct kimage *image)\n{\n\tint i;\n\tunsigned long nr_segments = image->nr_segments;\n\tunsigned long total_pages = 0;\n\tunsigned long nr_pages = totalram_pages();\n\n\t/*\n\t * Verify we have good destination addresses.  The caller is\n\t * responsible for making certain we don't attempt to load\n\t * the new image into invalid or reserved areas of RAM.  This\n\t * just verifies it is an address we can use.\n\t *\n\t * Since the kernel does everything in page size chunks ensure\n\t * the destination addresses are page aligned.  Too many\n\t * special cases crop of when we don't do this.  The most\n\t * insidious is getting overlapping destination addresses\n\t * simply because addresses are changed to page size\n\t * granularity.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend   = mstart + image->segment[i].memsz;\n\t\tif (mstart > mend)\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tif ((mstart & ~PAGE_MASK) || (mend & ~PAGE_MASK))\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tif (mend >= KEXEC_DESTINATION_MEMORY_LIMIT)\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\t/* Verify our destination addresses do not overlap.\n\t * If we alloed overlapping destination addresses\n\t * through very weird things can happen with no\n\t * easy explanation as one segment stops on another.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\t\tunsigned long j;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend   = mstart + image->segment[i].memsz;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tunsigned long pstart, pend;\n\n\t\t\tpstart = image->segment[j].mem;\n\t\t\tpend   = pstart + image->segment[j].memsz;\n\t\t\t/* Do the segments overlap ? */\n\t\t\tif ((mend > pstart) && (mstart < pend))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Ensure our buffer sizes are strictly less than\n\t * our memory sizes.  This should always be the case,\n\t * and it is easier to check up front than to be surprised\n\t * later on.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tif (image->segment[i].bufsz > image->segment[i].memsz)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Verify that no more than half of memory will be consumed. If the\n\t * request from userspace is too large, a large amount of time will be\n\t * wasted allocating pages, which can cause a soft lockup.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tif (PAGE_COUNT(image->segment[i].memsz) > nr_pages / 2)\n\t\t\treturn -EINVAL;\n\n\t\ttotal_pages += PAGE_COUNT(image->segment[i].memsz);\n\t}\n\n\tif (total_pages > nr_pages / 2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Verify we have good destination addresses.  Normally\n\t * the caller is responsible for making certain we don't\n\t * attempt to load the new image into invalid or reserved\n\t * areas of RAM.  But crash kernels are preloaded into a\n\t * reserved area of ram.  We must ensure the addresses\n\t * are in the reserved area otherwise preloading the\n\t * kernel could corrupt things.\n\t */\n\n\tif (image->type == KEXEC_TYPE_CRASH) {\n\t\tfor (i = 0; i < nr_segments; i++) {\n\t\t\tunsigned long mstart, mend;\n\n\t\t\tmstart = image->segment[i].mem;\n\t\t\tmend = mstart + image->segment[i].memsz - 1;\n\t\t\t/* Ensure we are within the crash kernel limits */\n\t\t\tif ((mstart < phys_to_boot_phys(crashk_res.start)) ||\n\t\t\t    (mend > phys_to_boot_phys(crashk_res.end)))\n\t\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct resource crashk_res = {\n\t.name  = \"Crash kernel\",\n\t.start = 0,\n\t.end   = 0,\n\t.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,\n\t.desc  = IORES_DESC_CRASH_KERNEL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "phys_to_boot_phys",
          "args": [
            "crashk_res.end"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_boot_phys",
          "args": [
            "crashk_res.start"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_COUNT",
          "args": [
            "image->segment[i].memsz"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_COUNT",
          "args": [
            "image->segment[i].memsz"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "totalram_pages",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct resource crashk_res = {\n\t.name  = \"Crash kernel\",\n\t.start = 0,\n\t.end   = 0,\n\t.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,\n\t.desc  = IORES_DESC_CRASH_KERNEL\n};\n\nint sanity_check_segment_list(struct kimage *image)\n{\n\tint i;\n\tunsigned long nr_segments = image->nr_segments;\n\tunsigned long total_pages = 0;\n\tunsigned long nr_pages = totalram_pages();\n\n\t/*\n\t * Verify we have good destination addresses.  The caller is\n\t * responsible for making certain we don't attempt to load\n\t * the new image into invalid or reserved areas of RAM.  This\n\t * just verifies it is an address we can use.\n\t *\n\t * Since the kernel does everything in page size chunks ensure\n\t * the destination addresses are page aligned.  Too many\n\t * special cases crop of when we don't do this.  The most\n\t * insidious is getting overlapping destination addresses\n\t * simply because addresses are changed to page size\n\t * granularity.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend   = mstart + image->segment[i].memsz;\n\t\tif (mstart > mend)\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tif ((mstart & ~PAGE_MASK) || (mend & ~PAGE_MASK))\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tif (mend >= KEXEC_DESTINATION_MEMORY_LIMIT)\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\t/* Verify our destination addresses do not overlap.\n\t * If we alloed overlapping destination addresses\n\t * through very weird things can happen with no\n\t * easy explanation as one segment stops on another.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\t\tunsigned long j;\n\n\t\tmstart = image->segment[i].mem;\n\t\tmend   = mstart + image->segment[i].memsz;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tunsigned long pstart, pend;\n\n\t\t\tpstart = image->segment[j].mem;\n\t\t\tpend   = pstart + image->segment[j].memsz;\n\t\t\t/* Do the segments overlap ? */\n\t\t\tif ((mend > pstart) && (mstart < pend))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Ensure our buffer sizes are strictly less than\n\t * our memory sizes.  This should always be the case,\n\t * and it is easier to check up front than to be surprised\n\t * later on.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tif (image->segment[i].bufsz > image->segment[i].memsz)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Verify that no more than half of memory will be consumed. If the\n\t * request from userspace is too large, a large amount of time will be\n\t * wasted allocating pages, which can cause a soft lockup.\n\t */\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tif (PAGE_COUNT(image->segment[i].memsz) > nr_pages / 2)\n\t\t\treturn -EINVAL;\n\n\t\ttotal_pages += PAGE_COUNT(image->segment[i].memsz);\n\t}\n\n\tif (total_pages > nr_pages / 2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Verify we have good destination addresses.  Normally\n\t * the caller is responsible for making certain we don't\n\t * attempt to load the new image into invalid or reserved\n\t * areas of RAM.  But crash kernels are preloaded into a\n\t * reserved area of ram.  We must ensure the addresses\n\t * are in the reserved area otherwise preloading the\n\t * kernel could corrupt things.\n\t */\n\n\tif (image->type == KEXEC_TYPE_CRASH) {\n\t\tfor (i = 0; i < nr_segments; i++) {\n\t\t\tunsigned long mstart, mend;\n\n\t\t\tmstart = image->segment[i].mem;\n\t\t\tmend = mstart + image->segment[i].memsz - 1;\n\t\t\t/* Ensure we are within the crash kernel limits */\n\t\t\tif ((mstart < phys_to_boot_phys(crashk_res.start)) ||\n\t\t\t    (mend > phys_to_boot_phys(crashk_res.end)))\n\t\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kexec_crash_loaded",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "92-95",
    "snippet": "int kexec_crash_loaded(void)\n{\n\treturn !!kexec_crash_image;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kimage *kexec_crash_image;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nstruct kimage *kexec_crash_image;\n\nint kexec_crash_loaded(void)\n{\n\treturn !!kexec_crash_image;\n}"
  },
  {
    "function_name": "kexec_should_crash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
    "lines": "74-90",
    "snippet": "int kexec_should_crash(struct task_struct *p)\n{\n\t/*\n\t * If crash_kexec_post_notifiers is enabled, don't run\n\t * crash_kexec() here yet, which must be run after panic\n\t * notifiers in panic().\n\t */\n\tif (crash_kexec_post_notifiers)\n\t\treturn 0;\n\t/*\n\t * There are 4 panic() calls in make_task_dead() path, each of which\n\t * corresponds to each of these 4 conditions.\n\t */\n\tif (in_interrupt() || !p->pid || is_global_init(p) || panic_on_oops)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"kexec_internal.h\"",
      "#include <crypto/hash.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/objtool.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/compiler.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/swap.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/console.h>",
      "#include <linux/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/cpu.h>",
      "#include <linux/pm.h>",
      "#include <linux/panic_notifier.h>",
      "#include <linux/freezer.h>",
      "#include <linux/device.h>",
      "#include <linux/suspend.h>",
      "#include <linux/numa.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/elf.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/ioport.h>",
      "#include <linux/reboot.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/list.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kexec.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_global_init",
          "args": [
            "p"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nint kexec_should_crash(struct task_struct *p)\n{\n\t/*\n\t * If crash_kexec_post_notifiers is enabled, don't run\n\t * crash_kexec() here yet, which must be run after panic\n\t * notifiers in panic().\n\t */\n\tif (crash_kexec_post_notifiers)\n\t\treturn 0;\n\t/*\n\t * There are 4 panic() calls in make_task_dead() path, each of which\n\t * corresponds to each of these 4 conditions.\n\t */\n\tif (in_interrupt() || !p->pid || is_global_init(p) || panic_on_oops)\n\t\treturn 1;\n\treturn 0;\n}"
  }
]