[
  {
    "function_name": "kallsyms_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "882-886",
    "snippet": "static int __init kallsyms_init(void)\n{\n\tproc_create(\"kallsyms\", 0444, NULL, &kallsyms_proc_ops);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct proc_ops kallsyms_proc_ops = {\n\t.proc_open\t= kallsyms_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= seq_release_private,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"kallsyms\"",
            "0444",
            "NULL",
            "&kallsyms_proc_ops"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic const struct proc_ops kallsyms_proc_ops = {\n\t.proc_open\t= kallsyms_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= seq_release_private,\n};\n\nstatic int __init kallsyms_init(void)\n{\n\tproc_create(\"kallsyms\", 0444, NULL, &kallsyms_proc_ops);\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_walk_kallsyms",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "856-872",
    "snippet": "const char *kdb_walk_kallsyms(loff_t *pos)\n{\n\tstatic struct kallsym_iter kdb_walk_kallsyms_iter;\n\tif (*pos == 0) {\n\t\tmemset(&kdb_walk_kallsyms_iter, 0,\n\t\t       sizeof(kdb_walk_kallsyms_iter));\n\t\treset_iter(&kdb_walk_kallsyms_iter, 0);\n\t}\n\twhile (1) {\n\t\tif (!update_iter(&kdb_walk_kallsyms_iter, *pos))\n\t\t\treturn NULL;\n\t\t++*pos;\n\t\t/* Some debugging symbols have no name.  Ignore them. */\n\t\tif (kdb_walk_kallsyms_iter.name[0])\n\t\t\treturn kdb_walk_kallsyms_iter.name;\n\t}\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_iter",
          "args": [
            "&kdb_walk_kallsyms_iter",
            "*pos"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "update_iter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "728-742",
          "snippet": "static int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t/* Module symbols can be accessed randomly. */\n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t/* If we're not on the desired position, reset to new position. */\n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned int kallsyms_num_syms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned int kallsyms_num_syms;\n\nstatic int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t/* Module symbols can be accessed randomly. */\n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t/* If we're not on the desired position, reset to new position. */\n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_iter",
          "args": [
            "&kdb_walk_kallsyms_iter",
            "0"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "reset_iter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "686-697",
          "snippet": "static void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_arch_end = 0;\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t\titer->pos_bpf_end = 0;\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_arch_end = 0;\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t\titer->pos_bpf_end = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&kdb_walk_kallsyms_iter",
            "0",
            "sizeof(kdb_walk_kallsyms_iter)"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kdb_walk_kallsyms(loff_t *pos)\n{\n\tstatic struct kallsym_iter kdb_walk_kallsyms_iter;\n\tif (*pos == 0) {\n\t\tmemset(&kdb_walk_kallsyms_iter, 0,\n\t\t       sizeof(kdb_walk_kallsyms_iter));\n\t\treset_iter(&kdb_walk_kallsyms_iter, 0);\n\t}\n\twhile (1) {\n\t\tif (!update_iter(&kdb_walk_kallsyms_iter, *pos))\n\t\t\treturn NULL;\n\t\t++*pos;\n\t\t/* Some debugging symbols have no name.  Ignore them. */\n\t\tif (kdb_walk_kallsyms_iter.name[0])\n\t\t\treturn kdb_walk_kallsyms_iter.name;\n\t}\n}"
  },
  {
    "function_name": "kallsyms_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "834-853",
    "snippet": "static int kallsyms_open(struct inode *inode, struct file *file)\n{\n\t/*\n\t * We keep iterator in m->private, since normal case is to\n\t * s_start from where we left off, so we avoid doing\n\t * using get_symbol_offset for every symbol.\n\t */\n\tstruct kallsym_iter *iter;\n\titer = __seq_open_private(file, &kallsyms_op, sizeof(*iter));\n\tif (!iter)\n\t\treturn -ENOMEM;\n\treset_iter(iter, 0);\n\n\t/*\n\t * Instead of checking this on every s_show() call, cache\n\t * the result here at open time.\n\t */\n\titer->show_value = kallsyms_show_value(file->f_cred);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations kallsyms_op = {\n\t.start = s_start,\n\t.next = s_next,\n\t.stop = s_stop,\n\t.show = s_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kallsyms_show_value",
          "args": [
            "file->f_cred"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_show_value",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "817-832",
          "snippet": "bool kallsyms_show_value(const struct cred *cred)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\tif (kallsyms_for_perf())\n\t\t\treturn true;\n\t\tfallthrough;\n\tcase 1:\n\t\tif (security_capable(cred, &init_user_ns, CAP_SYSLOG,\n\t\t\t\t     CAP_OPT_NOAUDIT) == 0)\n\t\t\treturn true;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nbool kallsyms_show_value(const struct cred *cred)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\tif (kallsyms_for_perf())\n\t\t\treturn true;\n\t\tfallthrough;\n\tcase 1:\n\t\tif (security_capable(cred, &init_user_ns, CAP_SYSLOG,\n\t\t\t\t     CAP_OPT_NOAUDIT) == 0)\n\t\t\treturn true;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_iter",
          "args": [
            "iter",
            "0"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "reset_iter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "686-697",
          "snippet": "static void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_arch_end = 0;\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t\titer->pos_bpf_end = 0;\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_arch_end = 0;\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t\titer->pos_bpf_end = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__seq_open_private",
          "args": [
            "file",
            "&kallsyms_op",
            "sizeof(*iter)"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic const struct seq_operations kallsyms_op = {\n\t.start = s_start,\n\t.next = s_next,\n\t.stop = s_stop,\n\t.show = s_show\n};\n\nstatic int kallsyms_open(struct inode *inode, struct file *file)\n{\n\t/*\n\t * We keep iterator in m->private, since normal case is to\n\t * s_start from where we left off, so we avoid doing\n\t * using get_symbol_offset for every symbol.\n\t */\n\tstruct kallsym_iter *iter;\n\titer = __seq_open_private(file, &kallsyms_op, sizeof(*iter));\n\tif (!iter)\n\t\treturn -ENOMEM;\n\treset_iter(iter, 0);\n\n\t/*\n\t * Instead of checking this on every s_show() call, cache\n\t * the result here at open time.\n\t */\n\titer->show_value = kallsyms_show_value(file->f_cred);\n\treturn 0;\n}"
  },
  {
    "function_name": "kallsyms_show_value",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "817-832",
    "snippet": "bool kallsyms_show_value(const struct cred *cred)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\tif (kallsyms_for_perf())\n\t\t\treturn true;\n\t\tfallthrough;\n\tcase 1:\n\t\tif (security_capable(cred, &init_user_ns, CAP_SYSLOG,\n\t\t\t\t     CAP_OPT_NOAUDIT) == 0)\n\t\t\treturn true;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_capable",
          "args": [
            "cred",
            "&init_user_ns",
            "CAP_SYSLOG",
            "CAP_OPT_NOAUDIT"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_for_perf",
          "args": [],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_for_perf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "799-807",
          "snippet": "static inline int kallsyms_for_perf(void)\n{\n#ifdef CONFIG_PERF_EVENTS\n\textern int sysctl_perf_event_paranoid;\n\tif (sysctl_perf_event_paranoid <= 1)\n\t\treturn 1;\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic inline int kallsyms_for_perf(void)\n{\n#ifdef CONFIG_PERF_EVENTS\n\textern int sysctl_perf_event_paranoid;\n\tif (sysctl_perf_event_paranoid <= 1)\n\t\treturn 1;\n#endif\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nbool kallsyms_show_value(const struct cred *cred)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\tif (kallsyms_for_perf())\n\t\t\treturn true;\n\t\tfallthrough;\n\tcase 1:\n\t\tif (security_capable(cred, &init_user_ns, CAP_SYSLOG,\n\t\t\t\t     CAP_OPT_NOAUDIT) == 0)\n\t\t\treturn true;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "kallsyms_for_perf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "799-807",
    "snippet": "static inline int kallsyms_for_perf(void)\n{\n#ifdef CONFIG_PERF_EVENTS\n\textern int sysctl_perf_event_paranoid;\n\tif (sysctl_perf_event_paranoid <= 1)\n\t\treturn 1;\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic inline int kallsyms_for_perf(void)\n{\n#ifdef CONFIG_PERF_EVENTS\n\textern int sysctl_perf_event_paranoid;\n\tif (sysctl_perf_event_paranoid <= 1)\n\t\treturn 1;\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "s_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "764-790",
    "snippet": "static int s_show(struct seq_file *m, void *p)\n{\n\tvoid *value;\n\tstruct kallsym_iter *iter = m->private;\n\n\t/* Some debugging symbols have no name.  Ignore them. */\n\tif (!iter->name[0])\n\t\treturn 0;\n\n\tvalue = iter->show_value ? (void *)iter->value : NULL;\n\n\tif (iter->module_name[0]) {\n\t\tchar type;\n\n\t\t/*\n\t\t * Label it \"global\" if it is exported,\n\t\t * \"local\" if not exported.\n\t\t */\n\t\ttype = iter->exported ? toupper(iter->type) :\n\t\t\t\t\ttolower(iter->type);\n\t\tseq_printf(m, \"%px %c %s\\t[%s]\\n\", value,\n\t\t\t   type, iter->name, iter->module_name);\n\t} else\n\t\tseq_printf(m, \"%px %c %s\\n\", value,\n\t\t\t   iter->type, iter->name);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%px %c %s\\n\"",
            "value",
            "iter->type",
            "iter->name"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "iter->type"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "iter->type"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int s_show(struct seq_file *m, void *p)\n{\n\tvoid *value;\n\tstruct kallsym_iter *iter = m->private;\n\n\t/* Some debugging symbols have no name.  Ignore them. */\n\tif (!iter->name[0])\n\t\treturn 0;\n\n\tvalue = iter->show_value ? (void *)iter->value : NULL;\n\n\tif (iter->module_name[0]) {\n\t\tchar type;\n\n\t\t/*\n\t\t * Label it \"global\" if it is exported,\n\t\t * \"local\" if not exported.\n\t\t */\n\t\ttype = iter->exported ? toupper(iter->type) :\n\t\t\t\t\ttolower(iter->type);\n\t\tseq_printf(m, \"%px %c %s\\t[%s]\\n\", value,\n\t\t\t   type, iter->name, iter->module_name);\n\t} else\n\t\tseq_printf(m, \"%px %c %s\\n\", value,\n\t\t\t   iter->type, iter->name);\n\treturn 0;\n}"
  },
  {
    "function_name": "s_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "760-762",
    "snippet": "static void s_stop(struct seq_file *m, void *p)\n{\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic void s_stop(struct seq_file *m, void *p)\n{\n}"
  },
  {
    "function_name": "s_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "753-758",
    "snippet": "static void *s_start(struct seq_file *m, loff_t *pos)\n{\n\tif (!update_iter(m->private, *pos))\n\t\treturn NULL;\n\treturn m->private;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_iter",
          "args": [
            "m->private",
            "*pos"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "update_iter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "728-742",
          "snippet": "static int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t/* Module symbols can be accessed randomly. */\n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t/* If we're not on the desired position, reset to new position. */\n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned int kallsyms_num_syms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned int kallsyms_num_syms;\n\nstatic int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t/* Module symbols can be accessed randomly. */\n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t/* If we're not on the desired position, reset to new position. */\n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic void *s_start(struct seq_file *m, loff_t *pos)\n{\n\tif (!update_iter(m->private, *pos))\n\t\treturn NULL;\n\treturn m->private;\n}"
  },
  {
    "function_name": "s_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "744-751",
    "snippet": "static void *s_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\t(*pos)++;\n\n\tif (!update_iter(m->private, *pos))\n\t\treturn NULL;\n\treturn p;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_iter",
          "args": [
            "m->private",
            "*pos"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "update_iter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "728-742",
          "snippet": "static int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t/* Module symbols can be accessed randomly. */\n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t/* If we're not on the desired position, reset to new position. */\n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned int kallsyms_num_syms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned int kallsyms_num_syms;\n\nstatic int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t/* Module symbols can be accessed randomly. */\n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t/* If we're not on the desired position, reset to new position. */\n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic void *s_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\t(*pos)++;\n\n\tif (!update_iter(m->private, *pos))\n\t\treturn NULL;\n\treturn p;\n}"
  },
  {
    "function_name": "update_iter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "728-742",
    "snippet": "static int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t/* Module symbols can be accessed randomly. */\n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t/* If we're not on the desired position, reset to new position. */\n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const unsigned int kallsyms_num_syms"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_ksymbol_core",
          "args": [
            "iter"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksymbol_core",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "672-684",
          "snippet": "static unsigned long get_ksymbol_core(struct kallsym_iter *iter)\n{\n\tunsigned off = iter->nameoff;\n\n\titer->module_name[0] = '\\0';\n\titer->value = kallsyms_sym_address(iter->pos);\n\n\titer->type = kallsyms_get_symbol_type(off);\n\n\toff = kallsyms_expand_symbol(off, iter->name, ARRAY_SIZE(iter->name));\n\n\treturn off - iter->nameoff;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic unsigned long get_ksymbol_core(struct kallsym_iter *iter)\n{\n\tunsigned off = iter->nameoff;\n\n\titer->module_name[0] = '\\0';\n\titer->value = kallsyms_sym_address(iter->pos);\n\n\titer->type = kallsyms_get_symbol_type(off);\n\n\toff = kallsyms_expand_symbol(off, iter->name, ARRAY_SIZE(iter->name));\n\n\treturn off - iter->nameoff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_iter",
          "args": [
            "iter",
            "pos"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "reset_iter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "686-697",
          "snippet": "static void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_arch_end = 0;\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t\titer->pos_bpf_end = 0;\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_arch_end = 0;\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t\titer->pos_bpf_end = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_iter_mod",
          "args": [
            "iter",
            "pos"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "update_iter_mod",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "704-725",
          "snippet": "static int update_iter_mod(struct kallsym_iter *iter, loff_t pos)\n{\n\titer->pos = pos;\n\n\tif ((!iter->pos_arch_end || iter->pos_arch_end > pos) &&\n\t    get_ksymbol_arch(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_mod_end || iter->pos_mod_end > pos) &&\n\t    get_ksymbol_mod(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_ftrace_mod_end || iter->pos_ftrace_mod_end > pos) &&\n\t    get_ksymbol_ftrace_mod(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_bpf_end || iter->pos_bpf_end > pos) &&\n\t    get_ksymbol_bpf(iter))\n\t\treturn 1;\n\n\treturn get_ksymbol_kprobe(iter);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int update_iter_mod(struct kallsym_iter *iter, loff_t pos)\n{\n\titer->pos = pos;\n\n\tif ((!iter->pos_arch_end || iter->pos_arch_end > pos) &&\n\t    get_ksymbol_arch(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_mod_end || iter->pos_mod_end > pos) &&\n\t    get_ksymbol_mod(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_ftrace_mod_end || iter->pos_ftrace_mod_end > pos) &&\n\t    get_ksymbol_ftrace_mod(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_bpf_end || iter->pos_bpf_end > pos) &&\n\t    get_ksymbol_bpf(iter))\n\t\treturn 1;\n\n\treturn get_ksymbol_kprobe(iter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned int kallsyms_num_syms;\n\nstatic int update_iter(struct kallsym_iter *iter, loff_t pos)\n{\n\t/* Module symbols can be accessed randomly. */\n\tif (pos >= kallsyms_num_syms)\n\t\treturn update_iter_mod(iter, pos);\n\n\t/* If we're not on the desired position, reset to new position. */\n\tif (pos != iter->pos)\n\t\treset_iter(iter, pos);\n\n\titer->nameoff += get_ksymbol_core(iter);\n\titer->pos++;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "update_iter_mod",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "704-725",
    "snippet": "static int update_iter_mod(struct kallsym_iter *iter, loff_t pos)\n{\n\titer->pos = pos;\n\n\tif ((!iter->pos_arch_end || iter->pos_arch_end > pos) &&\n\t    get_ksymbol_arch(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_mod_end || iter->pos_mod_end > pos) &&\n\t    get_ksymbol_mod(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_ftrace_mod_end || iter->pos_ftrace_mod_end > pos) &&\n\t    get_ksymbol_ftrace_mod(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_bpf_end || iter->pos_bpf_end > pos) &&\n\t    get_ksymbol_bpf(iter))\n\t\treturn 1;\n\n\treturn get_ksymbol_kprobe(iter);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_ksymbol_kprobe",
          "args": [
            "iter"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksymbol_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "662-669",
          "snippet": "static int get_ksymbol_kprobe(struct kallsym_iter *iter)\n{\n\tstrlcpy(iter->module_name, \"__builtin__kprobes\", MODULE_NAME_LEN);\n\titer->exported = 0;\n\treturn kprobe_get_kallsym(iter->pos - iter->pos_bpf_end,\n\t\t\t\t  &iter->value, &iter->type,\n\t\t\t\t  iter->name) < 0 ? 0 : 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int get_ksymbol_kprobe(struct kallsym_iter *iter)\n{\n\tstrlcpy(iter->module_name, \"__builtin__kprobes\", MODULE_NAME_LEN);\n\titer->exported = 0;\n\treturn kprobe_get_kallsym(iter->pos - iter->pos_bpf_end,\n\t\t\t\t  &iter->value, &iter->type,\n\t\t\t\t  iter->name) < 0 ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ksymbol_bpf",
          "args": [
            "iter"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksymbol_bpf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "640-655",
          "snippet": "static int get_ksymbol_bpf(struct kallsym_iter *iter)\n{\n\tint ret;\n\n\tstrlcpy(iter->module_name, \"bpf\", MODULE_NAME_LEN);\n\titer->exported = 0;\n\tret = bpf_get_kallsym(iter->pos - iter->pos_ftrace_mod_end,\n\t\t\t      &iter->value, &iter->type,\n\t\t\t      iter->name);\n\tif (ret < 0) {\n\t\titer->pos_bpf_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int get_ksymbol_bpf(struct kallsym_iter *iter)\n{\n\tint ret;\n\n\tstrlcpy(iter->module_name, \"bpf\", MODULE_NAME_LEN);\n\titer->exported = 0;\n\tret = bpf_get_kallsym(iter->pos - iter->pos_ftrace_mod_end,\n\t\t\t      &iter->value, &iter->type,\n\t\t\t      iter->name);\n\tif (ret < 0) {\n\t\titer->pos_bpf_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ksymbol_ftrace_mod",
          "args": [
            "iter"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksymbol_ftrace_mod",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "626-638",
          "snippet": "static int get_ksymbol_ftrace_mod(struct kallsym_iter *iter)\n{\n\tint ret = ftrace_mod_get_kallsym(iter->pos - iter->pos_mod_end,\n\t\t\t\t\t &iter->value, &iter->type,\n\t\t\t\t\t iter->name, iter->module_name,\n\t\t\t\t\t &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_ftrace_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int get_ksymbol_ftrace_mod(struct kallsym_iter *iter)\n{\n\tint ret = ftrace_mod_get_kallsym(iter->pos - iter->pos_mod_end,\n\t\t\t\t\t &iter->value, &iter->type,\n\t\t\t\t\t iter->name, iter->module_name,\n\t\t\t\t\t &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_ftrace_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ksymbol_mod",
          "args": [
            "iter"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksymbol_mod",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "607-619",
          "snippet": "static int get_ksymbol_mod(struct kallsym_iter *iter)\n{\n\tint ret = module_get_kallsym(iter->pos - iter->pos_arch_end,\n\t\t\t\t     &iter->value, &iter->type,\n\t\t\t\t     iter->name, iter->module_name,\n\t\t\t\t     &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int get_ksymbol_mod(struct kallsym_iter *iter)\n{\n\tint ret = module_get_kallsym(iter->pos - iter->pos_arch_end,\n\t\t\t\t     &iter->value, &iter->type,\n\t\t\t\t     iter->name, iter->module_name,\n\t\t\t\t     &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ksymbol_arch",
          "args": [
            "iter"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "get_ksymbol_arch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "593-605",
          "snippet": "static int get_ksymbol_arch(struct kallsym_iter *iter)\n{\n\tint ret = arch_get_kallsym(iter->pos - kallsyms_num_syms,\n\t\t\t\t   &iter->value, &iter->type,\n\t\t\t\t   iter->name);\n\n\tif (ret < 0) {\n\t\titer->pos_arch_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned int kallsyms_num_syms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned int kallsyms_num_syms;\n\nstatic int get_ksymbol_arch(struct kallsym_iter *iter)\n{\n\tint ret = arch_get_kallsym(iter->pos - kallsyms_num_syms,\n\t\t\t\t   &iter->value, &iter->type,\n\t\t\t\t   iter->name);\n\n\tif (ret < 0) {\n\t\titer->pos_arch_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int update_iter_mod(struct kallsym_iter *iter, loff_t pos)\n{\n\titer->pos = pos;\n\n\tif ((!iter->pos_arch_end || iter->pos_arch_end > pos) &&\n\t    get_ksymbol_arch(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_mod_end || iter->pos_mod_end > pos) &&\n\t    get_ksymbol_mod(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_ftrace_mod_end || iter->pos_ftrace_mod_end > pos) &&\n\t    get_ksymbol_ftrace_mod(iter))\n\t\treturn 1;\n\n\tif ((!iter->pos_bpf_end || iter->pos_bpf_end > pos) &&\n\t    get_ksymbol_bpf(iter))\n\t\treturn 1;\n\n\treturn get_ksymbol_kprobe(iter);\n}"
  },
  {
    "function_name": "reset_iter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "686-697",
    "snippet": "static void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_arch_end = 0;\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t\titer->pos_bpf_end = 0;\n\t}\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_symbol_offset",
          "args": [
            "new_pos"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "get_symbol_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "127-148",
          "snippet": "static unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const unsigned int kallsyms_markers[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const unsigned int kallsyms_markers[] __weak;\n\nstatic unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic void reset_iter(struct kallsym_iter *iter, loff_t new_pos)\n{\n\titer->name[0] = '\\0';\n\titer->nameoff = get_symbol_offset(new_pos);\n\titer->pos = new_pos;\n\tif (new_pos == 0) {\n\t\titer->pos_arch_end = 0;\n\t\titer->pos_mod_end = 0;\n\t\titer->pos_ftrace_mod_end = 0;\n\t\titer->pos_bpf_end = 0;\n\t}\n}"
  },
  {
    "function_name": "get_ksymbol_core",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "672-684",
    "snippet": "static unsigned long get_ksymbol_core(struct kallsym_iter *iter)\n{\n\tunsigned off = iter->nameoff;\n\n\titer->module_name[0] = '\\0';\n\titer->value = kallsyms_sym_address(iter->pos);\n\n\titer->type = kallsyms_get_symbol_type(off);\n\n\toff = kallsyms_expand_symbol(off, iter->name, ARRAY_SIZE(iter->name));\n\n\treturn off - iter->nameoff;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kallsyms_expand_symbol",
          "args": [
            "off",
            "iter->name",
            "ARRAY_SIZE(iter->name)"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_expand_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "61-107",
          "snippet": "static unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst char *tptr;\n\tconst u8 *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const char kallsyms_token_table[] __weak;",
            "extern const u16 kallsyms_token_index[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const char kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst char *tptr;\n\tconst u8 *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "iter->name"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_get_symbol_type",
          "args": [
            "off"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_get_symbol_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "113-120",
          "snippet": "static char kallsyms_get_symbol_type(unsigned int off)\n{\n\t/*\n\t * Get just the first code, look it up in the token table,\n\t * and return the first char from this token.\n\t */\n\treturn kallsyms_token_table[kallsyms_token_index[kallsyms_names[off + 1]]];\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const char kallsyms_token_table[] __weak;",
            "extern const u16 kallsyms_token_index[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const char kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic char kallsyms_get_symbol_type(unsigned int off)\n{\n\t/*\n\t * Get just the first code, look it up in the token table,\n\t * and return the first char from this token.\n\t */\n\treturn kallsyms_token_table[kallsyms_token_index[kallsyms_names[off + 1]]];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_sym_address",
          "args": [
            "iter->pos"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_sym_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "150-165",
          "snippet": "static unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned long kallsyms_addresses[] __weak;",
            "extern const int kallsyms_offsets[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\n\nstatic unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic unsigned long get_ksymbol_core(struct kallsym_iter *iter)\n{\n\tunsigned off = iter->nameoff;\n\n\titer->module_name[0] = '\\0';\n\titer->value = kallsyms_sym_address(iter->pos);\n\n\titer->type = kallsyms_get_symbol_type(off);\n\n\toff = kallsyms_expand_symbol(off, iter->name, ARRAY_SIZE(iter->name));\n\n\treturn off - iter->nameoff;\n}"
  },
  {
    "function_name": "get_ksymbol_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "662-669",
    "snippet": "static int get_ksymbol_kprobe(struct kallsym_iter *iter)\n{\n\tstrlcpy(iter->module_name, \"__builtin__kprobes\", MODULE_NAME_LEN);\n\titer->exported = 0;\n\treturn kprobe_get_kallsym(iter->pos - iter->pos_bpf_end,\n\t\t\t\t  &iter->value, &iter->type,\n\t\t\t\t  iter->name) < 0 ? 0 : 1;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_get_kallsym",
          "args": [
            "iter->pos - iter->pos_bpf_end",
            "&iter->value",
            "&iter->type",
            "iter->name"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_get_kallsym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2386-2400",
          "snippet": "int kprobe_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t       char *sym)\n{\n#ifdef __ARCH_WANT_KPROBES_INSN_SLOT\n\tif (!kprobe_cache_get_kallsym(&kprobe_insn_slots, &symnum, value, type, sym))\n\t\treturn 0;\n#ifdef CONFIG_OPTPROBES\n\tif (!kprobe_cache_get_kallsym(&kprobe_optinsn_slots, &symnum, value, type, sym))\n\t\treturn 0;\n#endif\n#endif\n\tif (!arch_kprobe_get_kallsym(&symnum, value, type, sym))\n\t\treturn 0;\n\treturn -ERANGE;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint kprobe_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t       char *sym)\n{\n#ifdef __ARCH_WANT_KPROBES_INSN_SLOT\n\tif (!kprobe_cache_get_kallsym(&kprobe_insn_slots, &symnum, value, type, sym))\n\t\treturn 0;\n#ifdef CONFIG_OPTPROBES\n\tif (!kprobe_cache_get_kallsym(&kprobe_optinsn_slots, &symnum, value, type, sym))\n\t\treturn 0;\n#endif\n#endif\n\tif (!arch_kprobe_get_kallsym(&symnum, value, type, sym))\n\t\treturn 0;\n\treturn -ERANGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "iter->module_name",
            "\"__builtin__kprobes\"",
            "MODULE_NAME_LEN"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int get_ksymbol_kprobe(struct kallsym_iter *iter)\n{\n\tstrlcpy(iter->module_name, \"__builtin__kprobes\", MODULE_NAME_LEN);\n\titer->exported = 0;\n\treturn kprobe_get_kallsym(iter->pos - iter->pos_bpf_end,\n\t\t\t\t  &iter->value, &iter->type,\n\t\t\t\t  iter->name) < 0 ? 0 : 1;\n}"
  },
  {
    "function_name": "get_ksymbol_bpf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "640-655",
    "snippet": "static int get_ksymbol_bpf(struct kallsym_iter *iter)\n{\n\tint ret;\n\n\tstrlcpy(iter->module_name, \"bpf\", MODULE_NAME_LEN);\n\titer->exported = 0;\n\tret = bpf_get_kallsym(iter->pos - iter->pos_ftrace_mod_end,\n\t\t\t      &iter->value, &iter->type,\n\t\t\t      iter->name);\n\tif (ret < 0) {\n\t\titer->pos_bpf_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_get_kallsym",
          "args": [
            "iter->pos - iter->pos_ftrace_mod_end",
            "&iter->value",
            "&iter->type",
            "iter->name"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_kallsym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "749-775",
          "snippet": "int bpf_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t    char *sym)\n{\n\tstruct bpf_ksym *ksym;\n\tunsigned int it = 0;\n\tint ret = -ERANGE;\n\n\tif (!bpf_jit_kallsyms_enabled())\n\t\treturn ret;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ksym, &bpf_kallsyms, lnode) {\n\t\tif (it++ != symnum)\n\t\t\tcontinue;\n\n\t\tstrncpy(sym, ksym->name, KSYM_NAME_LEN);\n\n\t\t*value = ksym->start;\n\t\t*type  = BPF_SYM_ELF_TYPE;\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nint bpf_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t    char *sym)\n{\n\tstruct bpf_ksym *ksym;\n\tunsigned int it = 0;\n\tint ret = -ERANGE;\n\n\tif (!bpf_jit_kallsyms_enabled())\n\t\treturn ret;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ksym, &bpf_kallsyms, lnode) {\n\t\tif (it++ != symnum)\n\t\t\tcontinue;\n\n\t\tstrncpy(sym, ksym->name, KSYM_NAME_LEN);\n\n\t\t*value = ksym->start;\n\t\t*type  = BPF_SYM_ELF_TYPE;\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "iter->module_name",
            "\"bpf\"",
            "MODULE_NAME_LEN"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int get_ksymbol_bpf(struct kallsym_iter *iter)\n{\n\tint ret;\n\n\tstrlcpy(iter->module_name, \"bpf\", MODULE_NAME_LEN);\n\titer->exported = 0;\n\tret = bpf_get_kallsym(iter->pos - iter->pos_ftrace_mod_end,\n\t\t\t      &iter->value, &iter->type,\n\t\t\t      iter->name);\n\tif (ret < 0) {\n\t\titer->pos_bpf_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "get_ksymbol_ftrace_mod",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "626-638",
    "snippet": "static int get_ksymbol_ftrace_mod(struct kallsym_iter *iter)\n{\n\tint ret = ftrace_mod_get_kallsym(iter->pos - iter->pos_mod_end,\n\t\t\t\t\t &iter->value, &iter->type,\n\t\t\t\t\t iter->name, iter->module_name,\n\t\t\t\t\t &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_ftrace_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_mod_get_kallsym",
          "args": [
            "iter->pos - iter->pos_mod_end",
            "&iter->value",
            "&iter->type",
            "iter->name",
            "iter->module_name",
            "&iter->exported"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_mod_get_kallsym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6955-6966",
          "snippet": "int ftrace_mod_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t   char *type, char *name, char *module_name,\n\t\t\t   int *exported)\n{\n\tint ret;\n\n\tpreempt_disable();\n\tret = ftrace_get_trampoline_kallsym(symnum, value, type, name,\n\t\t\t\t\t    module_name, exported);\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_mod_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t   char *type, char *name, char *module_name,\n\t\t\t   int *exported)\n{\n\tint ret;\n\n\tpreempt_disable();\n\tret = ftrace_get_trampoline_kallsym(symnum, value, type, name,\n\t\t\t\t\t    module_name, exported);\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int get_ksymbol_ftrace_mod(struct kallsym_iter *iter)\n{\n\tint ret = ftrace_mod_get_kallsym(iter->pos - iter->pos_mod_end,\n\t\t\t\t\t &iter->value, &iter->type,\n\t\t\t\t\t iter->name, iter->module_name,\n\t\t\t\t\t &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_ftrace_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "get_ksymbol_mod",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "607-619",
    "snippet": "static int get_ksymbol_mod(struct kallsym_iter *iter)\n{\n\tint ret = module_get_kallsym(iter->pos - iter->pos_arch_end,\n\t\t\t\t     &iter->value, &iter->type,\n\t\t\t\t     iter->name, iter->module_name,\n\t\t\t\t     &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_get_kallsym",
          "args": [
            "iter->pos - iter->pos_arch_end",
            "&iter->value",
            "&iter->type",
            "iter->name",
            "iter->module_name",
            "&iter->exported"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "module_get_kallsym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4420-4447",
          "snippet": "int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t\tchar *name, char *module_name, int *exported)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tstruct mod_kallsyms *kallsyms;\n\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tkallsyms = rcu_dereference_sched(mod->kallsyms);\n\t\tif (symnum < kallsyms->num_symtab) {\n\t\t\tconst Elf_Sym *sym = &kallsyms->symtab[symnum];\n\n\t\t\t*value = kallsyms_symbol_value(sym);\n\t\t\t*type = kallsyms->typetab[symnum];\n\t\t\tstrlcpy(name, kallsyms_symbol_name(kallsyms, symnum), KSYM_NAME_LEN);\n\t\t\tstrlcpy(module_name, mod->name, MODULE_NAME_LEN);\n\t\t\t*exported = is_exported(name, *value, mod);\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t\tsymnum -= kallsyms->num_symtab;\n\t}\n\tpreempt_enable();\n\treturn -ERANGE;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);",
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nint module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t\tchar *name, char *module_name, int *exported)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tstruct mod_kallsyms *kallsyms;\n\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tkallsyms = rcu_dereference_sched(mod->kallsyms);\n\t\tif (symnum < kallsyms->num_symtab) {\n\t\t\tconst Elf_Sym *sym = &kallsyms->symtab[symnum];\n\n\t\t\t*value = kallsyms_symbol_value(sym);\n\t\t\t*type = kallsyms->typetab[symnum];\n\t\t\tstrlcpy(name, kallsyms_symbol_name(kallsyms, symnum), KSYM_NAME_LEN);\n\t\t\tstrlcpy(module_name, mod->name, MODULE_NAME_LEN);\n\t\t\t*exported = is_exported(name, *value, mod);\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t\tsymnum -= kallsyms->num_symtab;\n\t}\n\tpreempt_enable();\n\treturn -ERANGE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int get_ksymbol_mod(struct kallsym_iter *iter)\n{\n\tint ret = module_get_kallsym(iter->pos - iter->pos_arch_end,\n\t\t\t\t     &iter->value, &iter->type,\n\t\t\t\t     iter->name, iter->module_name,\n\t\t\t\t     &iter->exported);\n\tif (ret < 0) {\n\t\titer->pos_mod_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "get_ksymbol_arch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "593-605",
    "snippet": "static int get_ksymbol_arch(struct kallsym_iter *iter)\n{\n\tint ret = arch_get_kallsym(iter->pos - kallsyms_num_syms,\n\t\t\t\t   &iter->value, &iter->type,\n\t\t\t\t   iter->name);\n\n\tif (ret < 0) {\n\t\titer->pos_arch_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const unsigned int kallsyms_num_syms"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_get_kallsym",
          "args": [
            "iter->pos - kallsyms_num_syms",
            "&iter->value",
            "&iter->type",
            "iter->name"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "arch_get_kallsym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "587-591",
          "snippet": "int __weak arch_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t    char *type, char *name)\n{\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint __weak arch_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t    char *type, char *name)\n{\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned int kallsyms_num_syms;\n\nstatic int get_ksymbol_arch(struct kallsym_iter *iter)\n{\n\tint ret = arch_get_kallsym(iter->pos - kallsyms_num_syms,\n\t\t\t\t   &iter->value, &iter->type,\n\t\t\t\t   iter->name);\n\n\tif (ret < 0) {\n\t\titer->pos_arch_end = iter->pos;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "arch_get_kallsym",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "587-591",
    "snippet": "int __weak arch_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t    char *type, char *name)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint __weak arch_get_kallsym(unsigned int symnum, unsigned long *value,\n\t\t\t    char *type, char *name)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "sprint_backtrace_build_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "566-569",
    "snippet": "int sprint_backtrace_build_id(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, -1, 1, 1);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sprint_symbol",
          "args": [
            "buffer",
            "address",
            "-1",
            "1",
            "1"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "__sprint_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "441-479",
          "snippet": "static int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset, int add_buildid)\n{\n\tchar *modname;\n\tconst unsigned char *buildid;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup_buildid(address, &size, &offset, &modname, &buildid,\n\t\t\t\t       buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname) {\n\t\tlen += sprintf(buffer + len, \" [%s\", modname);\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\tif (add_buildid && buildid) {\n\t\t\t/* build ID should match length of sprintf */\n#if IS_ENABLED(CONFIG_MODULES)\n\t\t\tstatic_assert(sizeof(typeof_member(struct module, build_id)) == 20);\n#endif\n\t\t\tlen += sprintf(buffer + len, \" %20phN\", buildid);\n\t\t}\n#endif\n\t\tlen += sprintf(buffer + len, \"]\");\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset, int add_buildid)\n{\n\tchar *modname;\n\tconst unsigned char *buildid;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup_buildid(address, &size, &offset, &modname, &buildid,\n\t\t\t\t       buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname) {\n\t\tlen += sprintf(buffer + len, \" [%s\", modname);\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\tif (add_buildid && buildid) {\n\t\t\t/* build ID should match length of sprintf */\n#if IS_ENABLED(CONFIG_MODULES)\n\t\t\tstatic_assert(sizeof(typeof_member(struct module, build_id)) == 20);\n#endif\n\t\t\tlen += sprintf(buffer + len, \" %20phN\", buildid);\n\t\t}\n#endif\n\t\tlen += sprintf(buffer + len, \"]\");\n\t}\n\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint sprint_backtrace_build_id(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, -1, 1, 1);\n}"
  },
  {
    "function_name": "sprint_backtrace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "546-549",
    "snippet": "int sprint_backtrace(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, -1, 1, 0);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sprint_symbol",
          "args": [
            "buffer",
            "address",
            "-1",
            "1",
            "0"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "__sprint_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "441-479",
          "snippet": "static int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset, int add_buildid)\n{\n\tchar *modname;\n\tconst unsigned char *buildid;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup_buildid(address, &size, &offset, &modname, &buildid,\n\t\t\t\t       buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname) {\n\t\tlen += sprintf(buffer + len, \" [%s\", modname);\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\tif (add_buildid && buildid) {\n\t\t\t/* build ID should match length of sprintf */\n#if IS_ENABLED(CONFIG_MODULES)\n\t\t\tstatic_assert(sizeof(typeof_member(struct module, build_id)) == 20);\n#endif\n\t\t\tlen += sprintf(buffer + len, \" %20phN\", buildid);\n\t\t}\n#endif\n\t\tlen += sprintf(buffer + len, \"]\");\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset, int add_buildid)\n{\n\tchar *modname;\n\tconst unsigned char *buildid;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup_buildid(address, &size, &offset, &modname, &buildid,\n\t\t\t\t       buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname) {\n\t\tlen += sprintf(buffer + len, \" [%s\", modname);\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\tif (add_buildid && buildid) {\n\t\t\t/* build ID should match length of sprintf */\n#if IS_ENABLED(CONFIG_MODULES)\n\t\t\tstatic_assert(sizeof(typeof_member(struct module, build_id)) == 20);\n#endif\n\t\t\tlen += sprintf(buffer + len, \" %20phN\", buildid);\n\t\t}\n#endif\n\t\tlen += sprintf(buffer + len, \"]\");\n\t}\n\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint sprint_backtrace(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, -1, 1, 0);\n}"
  },
  {
    "function_name": "sprint_symbol_no_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "526-529",
    "snippet": "int sprint_symbol_no_offset(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 0, 0);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sprint_symbol",
          "args": [
            "buffer",
            "address",
            "0",
            "0",
            "0"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "__sprint_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "441-479",
          "snippet": "static int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset, int add_buildid)\n{\n\tchar *modname;\n\tconst unsigned char *buildid;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup_buildid(address, &size, &offset, &modname, &buildid,\n\t\t\t\t       buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname) {\n\t\tlen += sprintf(buffer + len, \" [%s\", modname);\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\tif (add_buildid && buildid) {\n\t\t\t/* build ID should match length of sprintf */\n#if IS_ENABLED(CONFIG_MODULES)\n\t\t\tstatic_assert(sizeof(typeof_member(struct module, build_id)) == 20);\n#endif\n\t\t\tlen += sprintf(buffer + len, \" %20phN\", buildid);\n\t\t}\n#endif\n\t\tlen += sprintf(buffer + len, \"]\");\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset, int add_buildid)\n{\n\tchar *modname;\n\tconst unsigned char *buildid;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup_buildid(address, &size, &offset, &modname, &buildid,\n\t\t\t\t       buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname) {\n\t\tlen += sprintf(buffer + len, \" [%s\", modname);\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\tif (add_buildid && buildid) {\n\t\t\t/* build ID should match length of sprintf */\n#if IS_ENABLED(CONFIG_MODULES)\n\t\t\tstatic_assert(sizeof(typeof_member(struct module, build_id)) == 20);\n#endif\n\t\t\tlen += sprintf(buffer + len, \" %20phN\", buildid);\n\t\t}\n#endif\n\t\tlen += sprintf(buffer + len, \"]\");\n\t}\n\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint sprint_symbol_no_offset(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 0, 0);\n}"
  },
  {
    "function_name": "sprint_symbol_build_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "509-512",
    "snippet": "int sprint_symbol_build_id(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 1, 1);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sprint_symbol",
          "args": [
            "buffer",
            "address",
            "0",
            "1",
            "1"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "__sprint_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "441-479",
          "snippet": "static int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset, int add_buildid)\n{\n\tchar *modname;\n\tconst unsigned char *buildid;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup_buildid(address, &size, &offset, &modname, &buildid,\n\t\t\t\t       buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname) {\n\t\tlen += sprintf(buffer + len, \" [%s\", modname);\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\tif (add_buildid && buildid) {\n\t\t\t/* build ID should match length of sprintf */\n#if IS_ENABLED(CONFIG_MODULES)\n\t\t\tstatic_assert(sizeof(typeof_member(struct module, build_id)) == 20);\n#endif\n\t\t\tlen += sprintf(buffer + len, \" %20phN\", buildid);\n\t\t}\n#endif\n\t\tlen += sprintf(buffer + len, \"]\");\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset, int add_buildid)\n{\n\tchar *modname;\n\tconst unsigned char *buildid;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup_buildid(address, &size, &offset, &modname, &buildid,\n\t\t\t\t       buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname) {\n\t\tlen += sprintf(buffer + len, \" [%s\", modname);\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\tif (add_buildid && buildid) {\n\t\t\t/* build ID should match length of sprintf */\n#if IS_ENABLED(CONFIG_MODULES)\n\t\t\tstatic_assert(sizeof(typeof_member(struct module, build_id)) == 20);\n#endif\n\t\t\tlen += sprintf(buffer + len, \" %20phN\", buildid);\n\t\t}\n#endif\n\t\tlen += sprintf(buffer + len, \"]\");\n\t}\n\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint sprint_symbol_build_id(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 1, 1);\n}"
  },
  {
    "function_name": "sprint_symbol",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "492-495",
    "snippet": "int sprint_symbol(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 1, 0);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sprint_symbol",
          "args": [
            "buffer",
            "address",
            "0",
            "1",
            "0"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "__sprint_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "441-479",
          "snippet": "static int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset, int add_buildid)\n{\n\tchar *modname;\n\tconst unsigned char *buildid;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup_buildid(address, &size, &offset, &modname, &buildid,\n\t\t\t\t       buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname) {\n\t\tlen += sprintf(buffer + len, \" [%s\", modname);\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\tif (add_buildid && buildid) {\n\t\t\t/* build ID should match length of sprintf */\n#if IS_ENABLED(CONFIG_MODULES)\n\t\t\tstatic_assert(sizeof(typeof_member(struct module, build_id)) == 20);\n#endif\n\t\t\tlen += sprintf(buffer + len, \" %20phN\", buildid);\n\t\t}\n#endif\n\t\tlen += sprintf(buffer + len, \"]\");\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset, int add_buildid)\n{\n\tchar *modname;\n\tconst unsigned char *buildid;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup_buildid(address, &size, &offset, &modname, &buildid,\n\t\t\t\t       buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname) {\n\t\tlen += sprintf(buffer + len, \" [%s\", modname);\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\tif (add_buildid && buildid) {\n\t\t\t/* build ID should match length of sprintf */\n#if IS_ENABLED(CONFIG_MODULES)\n\t\t\tstatic_assert(sizeof(typeof_member(struct module, build_id)) == 20);\n#endif\n\t\t\tlen += sprintf(buffer + len, \" %20phN\", buildid);\n\t\t}\n#endif\n\t\tlen += sprintf(buffer + len, \"]\");\n\t}\n\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint sprint_symbol(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 1, 0);\n}"
  },
  {
    "function_name": "__sprint_symbol",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "441-479",
    "snippet": "static int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset, int add_buildid)\n{\n\tchar *modname;\n\tconst unsigned char *buildid;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup_buildid(address, &size, &offset, &modname, &buildid,\n\t\t\t\t       buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname) {\n\t\tlen += sprintf(buffer + len, \" [%s\", modname);\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\tif (add_buildid && buildid) {\n\t\t\t/* build ID should match length of sprintf */\n#if IS_ENABLED(CONFIG_MODULES)\n\t\t\tstatic_assert(sizeof(typeof_member(struct module, build_id)) == 20);\n#endif\n\t\t\tlen += sprintf(buffer + len, \" %20phN\", buildid);\n\t\t}\n#endif\n\t\tlen += sprintf(buffer + len, \"]\");\n\t}\n\n\treturn len;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer + len",
            "\"]\""
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer + len",
            "\" %20phN\"",
            "buildid"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_assert",
          "args": [
            "sizeof(typeof_member(struct module, build_id)) == 20"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_MODULES"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_STACKTRACE_BUILD_ID"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer + len",
            "\" [%s\"",
            "modname"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer + len",
            "\"+%#lx/%#lx\"",
            "offset",
            "size"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "name"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer",
            "\"0x%lx\"",
            "address - symbol_offset"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_buildid",
          "args": [
            "address",
            "&size",
            "&offset",
            "&modname",
            "&buildid",
            "buffer"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup_buildid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "328-368",
          "snippet": "static const char *kallsyms_lookup_buildid(unsigned long addr,\n\t\t\tunsigned long *symbolsize,\n\t\t\tunsigned long *offset, char **modname,\n\t\t\tconst unsigned char **modbuildid, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\tif (modbuildid)\n\t\t\t*modbuildid = NULL;\n\n\t\tret = namebuf;\n\t\tgoto found;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, modbuildid, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\nfound:\n\tcleanup_symbol_name(namebuf);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic const char *kallsyms_lookup_buildid(unsigned long addr,\n\t\t\tunsigned long *symbolsize,\n\t\t\tunsigned long *offset, char **modname,\n\t\t\tconst unsigned char **modbuildid, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\tif (modbuildid)\n\t\t\t*modbuildid = NULL;\n\n\t\tret = namebuf;\n\t\tgoto found;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, modbuildid, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\nfound:\n\tcleanup_symbol_name(namebuf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic int __sprint_symbol(char *buffer, unsigned long address,\n\t\t\t   int symbol_offset, int add_offset, int add_buildid)\n{\n\tchar *modname;\n\tconst unsigned char *buildid;\n\tconst char *name;\n\tunsigned long offset, size;\n\tint len;\n\n\taddress += symbol_offset;\n\tname = kallsyms_lookup_buildid(address, &size, &offset, &modname, &buildid,\n\t\t\t\t       buffer);\n\tif (!name)\n\t\treturn sprintf(buffer, \"0x%lx\", address - symbol_offset);\n\n\tif (name != buffer)\n\t\tstrcpy(buffer, name);\n\tlen = strlen(buffer);\n\toffset -= symbol_offset;\n\n\tif (add_offset)\n\t\tlen += sprintf(buffer + len, \"+%#lx/%#lx\", offset, size);\n\n\tif (modname) {\n\t\tlen += sprintf(buffer + len, \" [%s\", modname);\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\tif (add_buildid && buildid) {\n\t\t\t/* build ID should match length of sprintf */\n#if IS_ENABLED(CONFIG_MODULES)\n\t\t\tstatic_assert(sizeof(typeof_member(struct module, build_id)) == 20);\n#endif\n\t\t\tlen += sprintf(buffer + len, \" %20phN\", buildid);\n\t\t}\n#endif\n\t\tlen += sprintf(buffer + len, \"]\");\n\t}\n\n\treturn len;\n}"
  },
  {
    "function_name": "lookup_symbol_attrs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "412-438",
    "snippet": "int lookup_symbol_attrs(unsigned long addr, unsigned long *size,\n\t\t\tunsigned long *offset, char *modname, char *name)\n{\n\tint res;\n\n\tname[0] = '\\0';\n\tname[KSYM_NAME_LEN - 1] = '\\0';\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, size, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       name, KSYM_NAME_LEN);\n\t\tmodname[0] = '\\0';\n\t\tgoto found;\n\t}\n\t/* See if it's in a module. */\n\tres = lookup_module_symbol_attrs(addr, size, offset, modname, name);\n\tif (res)\n\t\treturn res;\n\nfound:\n\tcleanup_symbol_name(name);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_symbol_name",
          "args": [
            "name"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_symbol_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "167-206",
          "snippet": "static bool cleanup_symbol_name(char *s)\n{\n\tchar *res;\n\n\tif (!IS_ENABLED(CONFIG_LTO_CLANG))\n\t\treturn false;\n\n\t/*\n\t * LLVM appends various suffixes for local functions and variables that\n\t * must be promoted to global scope as part of LTO.  This can break\n\t * hooking of static functions with kprobes. '.' is not a valid\n\t * character in an identifier in C. Suffixes observed:\n\t * - foo.llvm.[0-9a-f]+\n\t * - foo.[0-9a-f]+\n\t * - foo.[0-9a-f]+.cfi_jt\n\t */\n\tres = strchr(s, '.');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_CFI_CLANG) ||\n\t    !IS_ENABLED(CONFIG_LTO_CLANG_THIN) ||\n\t    CONFIG_CLANG_VERSION >= 130000)\n\t\treturn false;\n\n\t/*\n\t * Prior to LLVM 13, the following suffixes were observed when thinLTO\n\t * and CFI are both enabled:\n\t * - foo$[0-9]+\n\t */\n\tres = strrchr(s, '$');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic bool cleanup_symbol_name(char *s)\n{\n\tchar *res;\n\n\tif (!IS_ENABLED(CONFIG_LTO_CLANG))\n\t\treturn false;\n\n\t/*\n\t * LLVM appends various suffixes for local functions and variables that\n\t * must be promoted to global scope as part of LTO.  This can break\n\t * hooking of static functions with kprobes. '.' is not a valid\n\t * character in an identifier in C. Suffixes observed:\n\t * - foo.llvm.[0-9a-f]+\n\t * - foo.[0-9a-f]+\n\t * - foo.[0-9a-f]+.cfi_jt\n\t */\n\tres = strchr(s, '.');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_CFI_CLANG) ||\n\t    !IS_ENABLED(CONFIG_LTO_CLANG_THIN) ||\n\t    CONFIG_CLANG_VERSION >= 130000)\n\t\treturn false;\n\n\t/*\n\t * Prior to LLVM 13, the following suffixes were observed when thinLTO\n\t * and CFI are both enabled:\n\t * - foo$[0-9]+\n\t */\n\tres = strrchr(s, '$');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_module_symbol_attrs",
          "args": [
            "addr",
            "size",
            "offset",
            "modname",
            "name"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_module_symbol_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4392-4418",
          "snippet": "int lookup_module_symbol_attrs(unsigned long addr, unsigned long *size,\n\t\t\tunsigned long *offset, char *modname, char *name)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tif (within_module(addr, mod)) {\n\t\t\tconst char *sym;\n\n\t\t\tsym = find_kallsyms_symbol(mod, addr, size, offset);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\t\t\tif (modname)\n\t\t\t\tstrlcpy(modname, mod->name, MODULE_NAME_LEN);\n\t\t\tif (name)\n\t\t\t\tstrlcpy(name, sym, KSYM_NAME_LEN);\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\treturn -ERANGE;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);",
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nint lookup_module_symbol_attrs(unsigned long addr, unsigned long *size,\n\t\t\tunsigned long *offset, char *modname, char *name)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tif (within_module(addr, mod)) {\n\t\t\tconst char *sym;\n\n\t\t\tsym = find_kallsyms_symbol(mod, addr, size, offset);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\t\t\tif (modname)\n\t\t\t\tstrlcpy(modname, mod->name, MODULE_NAME_LEN);\n\t\t\tif (name)\n\t\t\t\tstrlcpy(name, sym, KSYM_NAME_LEN);\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\treturn -ERANGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_expand_symbol",
          "args": [
            "get_symbol_offset(pos)",
            "name",
            "KSYM_NAME_LEN"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_expand_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "61-107",
          "snippet": "static unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst char *tptr;\n\tconst u8 *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const char kallsyms_token_table[] __weak;",
            "extern const u16 kallsyms_token_index[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const char kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst char *tptr;\n\tconst u8 *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_symbol_offset",
          "args": [
            "pos"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "get_symbol_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "127-148",
          "snippet": "static unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const unsigned int kallsyms_markers[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const unsigned int kallsyms_markers[] __weak;\n\nstatic unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_symbol_pos",
          "args": [
            "addr",
            "size",
            "offset"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "get_symbol_pos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "252-310",
          "snippet": "static unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned long kallsyms_addresses[] __weak;",
            "extern const int kallsyms_offsets[] __weak;",
            "extern const unsigned int kallsyms_num_syms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\nextern const unsigned int kallsyms_num_syms;\n\nstatic unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ksym_addr",
          "args": [
            "addr"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint lookup_symbol_attrs(unsigned long addr, unsigned long *size,\n\t\t\tunsigned long *offset, char *modname, char *name)\n{\n\tint res;\n\n\tname[0] = '\\0';\n\tname[KSYM_NAME_LEN - 1] = '\\0';\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, size, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       name, KSYM_NAME_LEN);\n\t\tmodname[0] = '\\0';\n\t\tgoto found;\n\t}\n\t/* See if it's in a module. */\n\tres = lookup_module_symbol_attrs(addr, size, offset, modname, name);\n\tif (res)\n\t\treturn res;\n\nfound:\n\tcleanup_symbol_name(name);\n\treturn 0;\n}"
  },
  {
    "function_name": "lookup_symbol_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "386-410",
    "snippet": "int lookup_symbol_name(unsigned long addr, char *symname)\n{\n\tint res;\n\n\tsymname[0] = '\\0';\n\tsymname[KSYM_NAME_LEN - 1] = '\\0';\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, NULL, NULL);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       symname, KSYM_NAME_LEN);\n\t\tgoto found;\n\t}\n\t/* See if it's in a module. */\n\tres = lookup_module_symbol_name(addr, symname);\n\tif (res)\n\t\treturn res;\n\nfound:\n\tcleanup_symbol_name(symname);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_symbol_name",
          "args": [
            "symname"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_symbol_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "167-206",
          "snippet": "static bool cleanup_symbol_name(char *s)\n{\n\tchar *res;\n\n\tif (!IS_ENABLED(CONFIG_LTO_CLANG))\n\t\treturn false;\n\n\t/*\n\t * LLVM appends various suffixes for local functions and variables that\n\t * must be promoted to global scope as part of LTO.  This can break\n\t * hooking of static functions with kprobes. '.' is not a valid\n\t * character in an identifier in C. Suffixes observed:\n\t * - foo.llvm.[0-9a-f]+\n\t * - foo.[0-9a-f]+\n\t * - foo.[0-9a-f]+.cfi_jt\n\t */\n\tres = strchr(s, '.');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_CFI_CLANG) ||\n\t    !IS_ENABLED(CONFIG_LTO_CLANG_THIN) ||\n\t    CONFIG_CLANG_VERSION >= 130000)\n\t\treturn false;\n\n\t/*\n\t * Prior to LLVM 13, the following suffixes were observed when thinLTO\n\t * and CFI are both enabled:\n\t * - foo$[0-9]+\n\t */\n\tres = strrchr(s, '$');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic bool cleanup_symbol_name(char *s)\n{\n\tchar *res;\n\n\tif (!IS_ENABLED(CONFIG_LTO_CLANG))\n\t\treturn false;\n\n\t/*\n\t * LLVM appends various suffixes for local functions and variables that\n\t * must be promoted to global scope as part of LTO.  This can break\n\t * hooking of static functions with kprobes. '.' is not a valid\n\t * character in an identifier in C. Suffixes observed:\n\t * - foo.llvm.[0-9a-f]+\n\t * - foo.[0-9a-f]+\n\t * - foo.[0-9a-f]+.cfi_jt\n\t */\n\tres = strchr(s, '.');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_CFI_CLANG) ||\n\t    !IS_ENABLED(CONFIG_LTO_CLANG_THIN) ||\n\t    CONFIG_CLANG_VERSION >= 130000)\n\t\treturn false;\n\n\t/*\n\t * Prior to LLVM 13, the following suffixes were observed when thinLTO\n\t * and CFI are both enabled:\n\t * - foo$[0-9]+\n\t */\n\tres = strrchr(s, '$');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_module_symbol_name",
          "args": [
            "addr",
            "symname"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_module_symbol_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4367-4390",
          "snippet": "int lookup_module_symbol_name(unsigned long addr, char *symname)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tif (within_module(addr, mod)) {\n\t\t\tconst char *sym;\n\n\t\t\tsym = find_kallsyms_symbol(mod, addr, NULL, NULL);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\n\t\t\tstrlcpy(symname, sym, KSYM_NAME_LEN);\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\treturn -ERANGE;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);",
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nint lookup_module_symbol_name(unsigned long addr, char *symname)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tif (within_module(addr, mod)) {\n\t\t\tconst char *sym;\n\n\t\t\tsym = find_kallsyms_symbol(mod, addr, NULL, NULL);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\n\t\t\tstrlcpy(symname, sym, KSYM_NAME_LEN);\n\t\t\tpreempt_enable();\n\t\t\treturn 0;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\treturn -ERANGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_expand_symbol",
          "args": [
            "get_symbol_offset(pos)",
            "symname",
            "KSYM_NAME_LEN"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_expand_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "61-107",
          "snippet": "static unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst char *tptr;\n\tconst u8 *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const char kallsyms_token_table[] __weak;",
            "extern const u16 kallsyms_token_index[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const char kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst char *tptr;\n\tconst u8 *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_symbol_offset",
          "args": [
            "pos"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "get_symbol_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "127-148",
          "snippet": "static unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const unsigned int kallsyms_markers[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const unsigned int kallsyms_markers[] __weak;\n\nstatic unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_symbol_pos",
          "args": [
            "addr",
            "NULL",
            "NULL"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "get_symbol_pos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "252-310",
          "snippet": "static unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned long kallsyms_addresses[] __weak;",
            "extern const int kallsyms_offsets[] __weak;",
            "extern const unsigned int kallsyms_num_syms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\nextern const unsigned int kallsyms_num_syms;\n\nstatic unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ksym_addr",
          "args": [
            "addr"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint lookup_symbol_name(unsigned long addr, char *symname)\n{\n\tint res;\n\n\tsymname[0] = '\\0';\n\tsymname[KSYM_NAME_LEN - 1] = '\\0';\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, NULL, NULL);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       symname, KSYM_NAME_LEN);\n\t\tgoto found;\n\t}\n\t/* See if it's in a module. */\n\tres = lookup_module_symbol_name(addr, symname);\n\tif (res)\n\t\treturn res;\n\nfound:\n\tcleanup_symbol_name(symname);\n\treturn 0;\n}"
  },
  {
    "function_name": "kallsyms_lookup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "377-384",
    "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kallsyms_lookup_buildid",
          "args": [
            "addr",
            "symbolsize",
            "offset",
            "modname",
            "NULL",
            "namebuf"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup_buildid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "328-368",
          "snippet": "static const char *kallsyms_lookup_buildid(unsigned long addr,\n\t\t\tunsigned long *symbolsize,\n\t\t\tunsigned long *offset, char **modname,\n\t\t\tconst unsigned char **modbuildid, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\tif (modbuildid)\n\t\t\t*modbuildid = NULL;\n\n\t\tret = namebuf;\n\t\tgoto found;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, modbuildid, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\nfound:\n\tcleanup_symbol_name(namebuf);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic const char *kallsyms_lookup_buildid(unsigned long addr,\n\t\t\tunsigned long *symbolsize,\n\t\t\tunsigned long *offset, char **modname,\n\t\t\tconst unsigned char **modbuildid, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\tif (modbuildid)\n\t\t\t*modbuildid = NULL;\n\n\t\tret = namebuf;\n\t\tgoto found;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, modbuildid, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\nfound:\n\tcleanup_symbol_name(namebuf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}"
  },
  {
    "function_name": "kallsyms_lookup_buildid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "328-368",
    "snippet": "static const char *kallsyms_lookup_buildid(unsigned long addr,\n\t\t\tunsigned long *symbolsize,\n\t\t\tunsigned long *offset, char **modname,\n\t\t\tconst unsigned char **modbuildid, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\tif (modbuildid)\n\t\t\t*modbuildid = NULL;\n\n\t\tret = namebuf;\n\t\tgoto found;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, modbuildid, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\nfound:\n\tcleanup_symbol_name(namebuf);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_symbol_name",
          "args": [
            "namebuf"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_symbol_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "167-206",
          "snippet": "static bool cleanup_symbol_name(char *s)\n{\n\tchar *res;\n\n\tif (!IS_ENABLED(CONFIG_LTO_CLANG))\n\t\treturn false;\n\n\t/*\n\t * LLVM appends various suffixes for local functions and variables that\n\t * must be promoted to global scope as part of LTO.  This can break\n\t * hooking of static functions with kprobes. '.' is not a valid\n\t * character in an identifier in C. Suffixes observed:\n\t * - foo.llvm.[0-9a-f]+\n\t * - foo.[0-9a-f]+\n\t * - foo.[0-9a-f]+.cfi_jt\n\t */\n\tres = strchr(s, '.');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_CFI_CLANG) ||\n\t    !IS_ENABLED(CONFIG_LTO_CLANG_THIN) ||\n\t    CONFIG_CLANG_VERSION >= 130000)\n\t\treturn false;\n\n\t/*\n\t * Prior to LLVM 13, the following suffixes were observed when thinLTO\n\t * and CFI are both enabled:\n\t * - foo$[0-9]+\n\t */\n\tres = strrchr(s, '$');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic bool cleanup_symbol_name(char *s)\n{\n\tchar *res;\n\n\tif (!IS_ENABLED(CONFIG_LTO_CLANG))\n\t\treturn false;\n\n\t/*\n\t * LLVM appends various suffixes for local functions and variables that\n\t * must be promoted to global scope as part of LTO.  This can break\n\t * hooking of static functions with kprobes. '.' is not a valid\n\t * character in an identifier in C. Suffixes observed:\n\t * - foo.llvm.[0-9a-f]+\n\t * - foo.[0-9a-f]+\n\t * - foo.[0-9a-f]+.cfi_jt\n\t */\n\tres = strchr(s, '.');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_CFI_CLANG) ||\n\t    !IS_ENABLED(CONFIG_LTO_CLANG_THIN) ||\n\t    CONFIG_CLANG_VERSION >= 130000)\n\t\treturn false;\n\n\t/*\n\t * Prior to LLVM 13, the following suffixes were observed when thinLTO\n\t * and CFI are both enabled:\n\t * - foo$[0-9]+\n\t */\n\tres = strrchr(s, '$');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_mod_address_lookup",
          "args": [
            "addr",
            "symbolsize",
            "offset",
            "modname",
            "namebuf"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_mod_address_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "6885-6905",
          "snippet": "const char *\nftrace_mod_address_lookup(unsigned long addr, unsigned long *size,\n\t\t   unsigned long *off, char **modname, char *sym)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tconst char *ret = NULL;\n\n\t/* mod_map is freed via call_rcu() */\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod_map, &ftrace_mod_maps, list) {\n\t\tret = ftrace_func_address_lookup(mod_map, addr, size, off, sym);\n\t\tif (ret) {\n\t\t\tif (modname)\n\t\t\t\t*modname = mod_map->mod->name;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nconst char *\nftrace_mod_address_lookup(unsigned long addr, unsigned long *size,\n\t\t   unsigned long *off, char **modname, char *sym)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tconst char *ret = NULL;\n\n\t/* mod_map is freed via call_rcu() */\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod_map, &ftrace_mod_maps, list) {\n\t\tret = ftrace_func_address_lookup(mod_map, addr, size, off, sym);\n\t\tif (ret) {\n\t\t\tif (modname)\n\t\t\t\t*modname = mod_map->mod->name;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_address_lookup",
          "args": [
            "addr",
            "symbolsize",
            "offset",
            "modname",
            "namebuf"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_address_lookup",
          "args": [
            "addr",
            "symbolsize",
            "offset",
            "modname",
            "modbuildid",
            "namebuf"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "module_address_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4332-4365",
          "snippet": "const char *module_address_lookup(unsigned long addr,\n\t\t\t    unsigned long *size,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname,\n\t\t\t    const unsigned char **modbuildid,\n\t\t\t    char *namebuf)\n{\n\tconst char *ret = NULL;\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_address(addr);\n\tif (mod) {\n\t\tif (modname)\n\t\t\t*modname = mod->name;\n\t\tif (modbuildid) {\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\t\t*modbuildid = mod->build_id;\n#else\n\t\t\t*modbuildid = NULL;\n#endif\n\t\t}\n\n\t\tret = find_kallsyms_symbol(mod, addr, size, offset);\n\t}\n\t/* Make a copy in here where it's safe */\n\tif (ret) {\n\t\tstrncpy(namebuf, ret, KSYM_NAME_LEN - 1);\n\t\tret = namebuf;\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nconst char *module_address_lookup(unsigned long addr,\n\t\t\t    unsigned long *size,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname,\n\t\t\t    const unsigned char **modbuildid,\n\t\t\t    char *namebuf)\n{\n\tconst char *ret = NULL;\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_address(addr);\n\tif (mod) {\n\t\tif (modname)\n\t\t\t*modname = mod->name;\n\t\tif (modbuildid) {\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\t\t*modbuildid = mod->build_id;\n#else\n\t\t\t*modbuildid = NULL;\n#endif\n\t\t}\n\n\t\tret = find_kallsyms_symbol(mod, addr, size, offset);\n\t}\n\t/* Make a copy in here where it's safe */\n\tif (ret) {\n\t\tstrncpy(namebuf, ret, KSYM_NAME_LEN - 1);\n\t\tret = namebuf;\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_expand_symbol",
          "args": [
            "get_symbol_offset(pos)",
            "namebuf",
            "KSYM_NAME_LEN"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_expand_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "61-107",
          "snippet": "static unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst char *tptr;\n\tconst u8 *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const char kallsyms_token_table[] __weak;",
            "extern const u16 kallsyms_token_index[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const char kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst char *tptr;\n\tconst u8 *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_symbol_offset",
          "args": [
            "pos"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "get_symbol_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "127-148",
          "snippet": "static unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const unsigned int kallsyms_markers[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const unsigned int kallsyms_markers[] __weak;\n\nstatic unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_symbol_pos",
          "args": [
            "addr",
            "symbolsize",
            "offset"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "get_symbol_pos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "252-310",
          "snippet": "static unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned long kallsyms_addresses[] __weak;",
            "extern const int kallsyms_offsets[] __weak;",
            "extern const unsigned int kallsyms_num_syms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\nextern const unsigned int kallsyms_num_syms;\n\nstatic unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ksym_addr",
          "args": [
            "addr"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic const char *kallsyms_lookup_buildid(unsigned long addr,\n\t\t\tunsigned long *symbolsize,\n\t\t\tunsigned long *offset, char **modname,\n\t\t\tconst unsigned char **modbuildid, char *namebuf)\n{\n\tconst char *ret;\n\n\tnamebuf[KSYM_NAME_LEN - 1] = 0;\n\tnamebuf[0] = 0;\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, symbolsize, offset);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       namebuf, KSYM_NAME_LEN);\n\t\tif (modname)\n\t\t\t*modname = NULL;\n\t\tif (modbuildid)\n\t\t\t*modbuildid = NULL;\n\n\t\tret = namebuf;\n\t\tgoto found;\n\t}\n\n\t/* See if it's in a module or a BPF JITed image. */\n\tret = module_address_lookup(addr, symbolsize, offset,\n\t\t\t\t    modname, modbuildid, namebuf);\n\tif (!ret)\n\t\tret = bpf_address_lookup(addr, symbolsize,\n\t\t\t\t\t offset, modname, namebuf);\n\n\tif (!ret)\n\t\tret = ftrace_mod_address_lookup(addr, symbolsize,\n\t\t\t\t\t\toffset, modname, namebuf);\n\nfound:\n\tcleanup_symbol_name(namebuf);\n\treturn ret;\n}"
  },
  {
    "function_name": "kallsyms_lookup_size_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "315-326",
    "snippet": "int kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr)) {\n\t\tget_symbol_pos(addr, symbolsize, offset);\n\t\treturn 1;\n\t}\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_address_lookup",
          "args": [
            "addr",
            "symbolsize",
            "offset",
            "namebuf"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_address_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "686-709",
          "snippet": "const char *__bpf_address_lookup(unsigned long addr, unsigned long *size,\n\t\t\t\t unsigned long *off, char *sym)\n{\n\tstruct bpf_ksym *ksym;\n\tchar *ret = NULL;\n\n\trcu_read_lock();\n\tksym = bpf_ksym_find(addr);\n\tif (ksym) {\n\t\tunsigned long symbol_start = ksym->start;\n\t\tunsigned long symbol_end = ksym->end;\n\n\t\tstrncpy(sym, ksym->name, KSYM_NAME_LEN);\n\n\t\tret = sym;\n\t\tif (size)\n\t\t\t*size = symbol_end - symbol_start;\n\t\tif (off)\n\t\t\t*off  = addr - symbol_start;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nconst char *__bpf_address_lookup(unsigned long addr, unsigned long *size,\n\t\t\t\t unsigned long *off, char *sym)\n{\n\tstruct bpf_ksym *ksym;\n\tchar *ret = NULL;\n\n\trcu_read_lock();\n\tksym = bpf_ksym_find(addr);\n\tif (ksym) {\n\t\tunsigned long symbol_start = ksym->start;\n\t\tunsigned long symbol_end = ksym->end;\n\n\t\tstrncpy(sym, ksym->name, KSYM_NAME_LEN);\n\n\t\tret = sym;\n\t\tif (size)\n\t\t\t*size = symbol_end - symbol_start;\n\t\tif (off)\n\t\t\t*off  = addr - symbol_start;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_address_lookup",
          "args": [
            "addr",
            "symbolsize",
            "offset",
            "NULL",
            "NULL",
            "namebuf"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "module_address_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4332-4365",
          "snippet": "const char *module_address_lookup(unsigned long addr,\n\t\t\t    unsigned long *size,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname,\n\t\t\t    const unsigned char **modbuildid,\n\t\t\t    char *namebuf)\n{\n\tconst char *ret = NULL;\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_address(addr);\n\tif (mod) {\n\t\tif (modname)\n\t\t\t*modname = mod->name;\n\t\tif (modbuildid) {\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\t\t*modbuildid = mod->build_id;\n#else\n\t\t\t*modbuildid = NULL;\n#endif\n\t\t}\n\n\t\tret = find_kallsyms_symbol(mod, addr, size, offset);\n\t}\n\t/* Make a copy in here where it's safe */\n\tif (ret) {\n\t\tstrncpy(namebuf, ret, KSYM_NAME_LEN - 1);\n\t\tret = namebuf;\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nconst char *module_address_lookup(unsigned long addr,\n\t\t\t    unsigned long *size,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname,\n\t\t\t    const unsigned char **modbuildid,\n\t\t\t    char *namebuf)\n{\n\tconst char *ret = NULL;\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_address(addr);\n\tif (mod) {\n\t\tif (modname)\n\t\t\t*modname = mod->name;\n\t\tif (modbuildid) {\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID)\n\t\t\t*modbuildid = mod->build_id;\n#else\n\t\t\t*modbuildid = NULL;\n#endif\n\t\t}\n\n\t\tret = find_kallsyms_symbol(mod, addr, size, offset);\n\t}\n\t/* Make a copy in here where it's safe */\n\tif (ret) {\n\t\tstrncpy(namebuf, ret, KSYM_NAME_LEN - 1);\n\t\tret = namebuf;\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_symbol_pos",
          "args": [
            "addr",
            "symbolsize",
            "offset"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "get_symbol_pos",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "252-310",
          "snippet": "static unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned long kallsyms_addresses[] __weak;",
            "extern const int kallsyms_offsets[] __weak;",
            "extern const unsigned int kallsyms_num_syms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\nextern const unsigned int kallsyms_num_syms;\n\nstatic unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ksym_addr",
          "args": [
            "addr"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr)) {\n\t\tget_symbol_pos(addr, symbolsize, offset);\n\t\treturn 1;\n\t}\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}"
  },
  {
    "function_name": "get_symbol_pos",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "252-310",
    "snippet": "static unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const unsigned long kallsyms_addresses[] __weak;",
      "extern const int kallsyms_offsets[] __weak;",
      "extern const unsigned int kallsyms_num_syms"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KALLSYMS_ALL"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_kernel_inittext",
          "args": [
            "addr"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_sym_address",
          "args": [
            "i"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_sym_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "150-165",
          "snippet": "static unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned long kallsyms_addresses[] __weak;",
            "extern const int kallsyms_offsets[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\n\nstatic unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!kallsyms_offsets"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!kallsyms_addresses"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KALLSYMS_BASE_RELATIVE"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\nextern const unsigned int kallsyms_num_syms;\n\nstatic unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t/* This kernel should never had been booted. */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\tBUG_ON(!kallsyms_addresses);\n\telse\n\t\tBUG_ON(!kallsyms_offsets);\n\n\t/* Do a binary search on the sorted kallsyms_addresses array. */\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low > 1) {\n\t\tmid = low + (high - low) / 2;\n\t\tif (kallsyms_sym_address(mid) <= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t/*\n\t * Search for the first aliased symbol. Aliased\n\t * symbols are symbols with the same address.\n\t */\n\twhile (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))\n\t\t--low;\n\n\tsymbol_start = kallsyms_sym_address(low);\n\n\t/* Search for next non-aliased symbol. */\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_sym_address(i) > symbol_start) {\n\t\t\tsymbol_end = kallsyms_sym_address(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we found no next symbol, we use the end of the section. */\n\tif (!symbol_end) {\n\t\tif (is_kernel_inittext(addr))\n\t\t\tsymbol_end = (unsigned long)_einittext;\n\t\telse if (IS_ENABLED(CONFIG_KALLSYMS_ALL))\n\t\t\tsymbol_end = (unsigned long)_end;\n\t\telse\n\t\t\tsymbol_end = (unsigned long)_etext;\n\t}\n\n\tif (symbolsize)\n\t\t*symbolsize = symbol_end - symbol_start;\n\tif (offset)\n\t\t*offset = addr - symbol_start;\n\n\treturn low;\n}"
  },
  {
    "function_name": "kallsyms_on_each_symbol",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "232-249",
    "snippet": "int kallsyms_on_each_symbol(int (*fn)(void *, const char *, struct module *,\n\t\t\t\t      unsigned long),\n\t\t\t    void *data)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\tunsigned long i;\n\tunsigned int off;\n\tint ret;\n\n\tfor (i = 0, off = 0; i < kallsyms_num_syms; i++) {\n\t\toff = kallsyms_expand_symbol(off, namebuf, ARRAY_SIZE(namebuf));\n\t\tret = fn(data, namebuf, NULL, kallsyms_sym_address(i));\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tcond_resched();\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const unsigned int kallsyms_num_syms"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "data",
            "namebuf",
            "NULL",
            "kallsyms_sym_address(i)"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "cwt_wakefn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3123-3130",
          "snippet": "static int cwt_wakefn(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct cwt_wait *cwait = container_of(wait, struct cwt_wait, wait);\n\n\tif (cwait->work != key)\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, key);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int cwt_wakefn(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct cwt_wait *cwait = container_of(wait, struct cwt_wait, wait);\n\n\tif (cwait->work != key)\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_sym_address",
          "args": [
            "i"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_sym_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "150-165",
          "snippet": "static unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned long kallsyms_addresses[] __weak;",
            "extern const int kallsyms_offsets[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\n\nstatic unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_expand_symbol",
          "args": [
            "off",
            "namebuf",
            "ARRAY_SIZE(namebuf)"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_expand_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "61-107",
          "snippet": "static unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst char *tptr;\n\tconst u8 *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const char kallsyms_token_table[] __weak;",
            "extern const u16 kallsyms_token_index[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const char kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst char *tptr;\n\tconst u8 *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "namebuf"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned int kallsyms_num_syms;\n\nint kallsyms_on_each_symbol(int (*fn)(void *, const char *, struct module *,\n\t\t\t\t      unsigned long),\n\t\t\t    void *data)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\tunsigned long i;\n\tunsigned int off;\n\tint ret;\n\n\tfor (i = 0, off = 0; i < kallsyms_num_syms; i++) {\n\t\toff = kallsyms_expand_symbol(off, namebuf, ARRAY_SIZE(namebuf));\n\t\tret = fn(data, namebuf, NULL, kallsyms_sym_address(i));\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tcond_resched();\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kallsyms_lookup_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "209-225",
    "snippet": "unsigned long kallsyms_lookup_name(const char *name)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\tunsigned long i;\n\tunsigned int off;\n\n\tfor (i = 0, off = 0; i < kallsyms_num_syms; i++) {\n\t\toff = kallsyms_expand_symbol(off, namebuf, ARRAY_SIZE(namebuf));\n\n\t\tif (strcmp(namebuf, name) == 0)\n\t\t\treturn kallsyms_sym_address(i);\n\n\t\tif (cleanup_symbol_name(namebuf) && strcmp(namebuf, name) == 0)\n\t\t\treturn kallsyms_sym_address(i);\n\t}\n\treturn module_kallsyms_lookup_name(name);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const unsigned int kallsyms_num_syms"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_kallsyms_lookup_name",
          "args": [
            "name"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "module_kallsyms_lookup_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4466-4487",
          "snippet": "unsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = find_kallsyms_symbol_value(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = find_kallsyms_symbol_value(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);",
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nunsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = find_kallsyms_symbol_value(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = find_kallsyms_symbol_value(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_sym_address",
          "args": [
            "i"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_sym_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "150-165",
          "snippet": "static unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const unsigned long kallsyms_addresses[] __weak;",
            "extern const int kallsyms_offsets[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\n\nstatic unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "namebuf",
            "name"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_symbol_name",
          "args": [
            "namebuf"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_symbol_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "167-206",
          "snippet": "static bool cleanup_symbol_name(char *s)\n{\n\tchar *res;\n\n\tif (!IS_ENABLED(CONFIG_LTO_CLANG))\n\t\treturn false;\n\n\t/*\n\t * LLVM appends various suffixes for local functions and variables that\n\t * must be promoted to global scope as part of LTO.  This can break\n\t * hooking of static functions with kprobes. '.' is not a valid\n\t * character in an identifier in C. Suffixes observed:\n\t * - foo.llvm.[0-9a-f]+\n\t * - foo.[0-9a-f]+\n\t * - foo.[0-9a-f]+.cfi_jt\n\t */\n\tres = strchr(s, '.');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_CFI_CLANG) ||\n\t    !IS_ENABLED(CONFIG_LTO_CLANG_THIN) ||\n\t    CONFIG_CLANG_VERSION >= 130000)\n\t\treturn false;\n\n\t/*\n\t * Prior to LLVM 13, the following suffixes were observed when thinLTO\n\t * and CFI are both enabled:\n\t * - foo$[0-9]+\n\t */\n\tres = strrchr(s, '$');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic bool cleanup_symbol_name(char *s)\n{\n\tchar *res;\n\n\tif (!IS_ENABLED(CONFIG_LTO_CLANG))\n\t\treturn false;\n\n\t/*\n\t * LLVM appends various suffixes for local functions and variables that\n\t * must be promoted to global scope as part of LTO.  This can break\n\t * hooking of static functions with kprobes. '.' is not a valid\n\t * character in an identifier in C. Suffixes observed:\n\t * - foo.llvm.[0-9a-f]+\n\t * - foo.[0-9a-f]+\n\t * - foo.[0-9a-f]+.cfi_jt\n\t */\n\tres = strchr(s, '.');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_CFI_CLANG) ||\n\t    !IS_ENABLED(CONFIG_LTO_CLANG_THIN) ||\n\t    CONFIG_CLANG_VERSION >= 130000)\n\t\treturn false;\n\n\t/*\n\t * Prior to LLVM 13, the following suffixes were observed when thinLTO\n\t * and CFI are both enabled:\n\t * - foo$[0-9]+\n\t */\n\tres = strrchr(s, '$');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_expand_symbol",
          "args": [
            "off",
            "namebuf",
            "ARRAY_SIZE(namebuf)"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_expand_symbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "61-107",
          "snippet": "static unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst char *tptr;\n\tconst u8 *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const u8 kallsyms_names[] __weak;",
            "extern const char kallsyms_token_table[] __weak;",
            "extern const u16 kallsyms_token_index[] __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const char kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst char *tptr;\n\tconst u8 *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "namebuf"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned int kallsyms_num_syms;\n\nunsigned long kallsyms_lookup_name(const char *name)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\tunsigned long i;\n\tunsigned int off;\n\n\tfor (i = 0, off = 0; i < kallsyms_num_syms; i++) {\n\t\toff = kallsyms_expand_symbol(off, namebuf, ARRAY_SIZE(namebuf));\n\n\t\tif (strcmp(namebuf, name) == 0)\n\t\t\treturn kallsyms_sym_address(i);\n\n\t\tif (cleanup_symbol_name(namebuf) && strcmp(namebuf, name) == 0)\n\t\t\treturn kallsyms_sym_address(i);\n\t}\n\treturn module_kallsyms_lookup_name(name);\n}"
  },
  {
    "function_name": "cleanup_symbol_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "167-206",
    "snippet": "static bool cleanup_symbol_name(char *s)\n{\n\tchar *res;\n\n\tif (!IS_ENABLED(CONFIG_LTO_CLANG))\n\t\treturn false;\n\n\t/*\n\t * LLVM appends various suffixes for local functions and variables that\n\t * must be promoted to global scope as part of LTO.  This can break\n\t * hooking of static functions with kprobes. '.' is not a valid\n\t * character in an identifier in C. Suffixes observed:\n\t * - foo.llvm.[0-9a-f]+\n\t * - foo.[0-9a-f]+\n\t * - foo.[0-9a-f]+.cfi_jt\n\t */\n\tres = strchr(s, '.');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_CFI_CLANG) ||\n\t    !IS_ENABLED(CONFIG_LTO_CLANG_THIN) ||\n\t    CONFIG_CLANG_VERSION >= 130000)\n\t\treturn false;\n\n\t/*\n\t * Prior to LLVM 13, the following suffixes were observed when thinLTO\n\t * and CFI are both enabled:\n\t * - foo$[0-9]+\n\t */\n\tres = strrchr(s, '$');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "s",
            "'$'"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_LTO_CLANG_THIN"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_CFI_CLANG"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "s",
            "'.'"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_LTO_CLANG"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nstatic bool cleanup_symbol_name(char *s)\n{\n\tchar *res;\n\n\tif (!IS_ENABLED(CONFIG_LTO_CLANG))\n\t\treturn false;\n\n\t/*\n\t * LLVM appends various suffixes for local functions and variables that\n\t * must be promoted to global scope as part of LTO.  This can break\n\t * hooking of static functions with kprobes. '.' is not a valid\n\t * character in an identifier in C. Suffixes observed:\n\t * - foo.llvm.[0-9a-f]+\n\t * - foo.[0-9a-f]+\n\t * - foo.[0-9a-f]+.cfi_jt\n\t */\n\tres = strchr(s, '.');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_CFI_CLANG) ||\n\t    !IS_ENABLED(CONFIG_LTO_CLANG_THIN) ||\n\t    CONFIG_CLANG_VERSION >= 130000)\n\t\treturn false;\n\n\t/*\n\t * Prior to LLVM 13, the following suffixes were observed when thinLTO\n\t * and CFI are both enabled:\n\t * - foo$[0-9]+\n\t */\n\tres = strrchr(s, '$');\n\tif (res) {\n\t\t*res = '\\0';\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "kallsyms_sym_address",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "150-165",
    "snippet": "static unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const unsigned long kallsyms_addresses[] __weak;",
      "extern const int kallsyms_offsets[] __weak;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KALLSYMS_ABSOLUTE_PERCPU"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KALLSYMS_BASE_RELATIVE"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const unsigned long kallsyms_addresses[] __weak;\nextern const int kallsyms_offsets[] __weak;\n\nstatic unsigned long kallsyms_sym_address(int idx)\n{\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))\n\t\treturn kallsyms_addresses[idx];\n\n\t/* values are unsigned offsets if --absolute-percpu is not in effect */\n\tif (!IS_ENABLED(CONFIG_KALLSYMS_ABSOLUTE_PERCPU))\n\t\treturn kallsyms_relative_base + (u32)kallsyms_offsets[idx];\n\n\t/* ...otherwise, positive offsets are absolute values */\n\tif (kallsyms_offsets[idx] >= 0)\n\t\treturn kallsyms_offsets[idx];\n\n\t/* ...and negative offsets are relative to kallsyms_relative_base - 1 */\n\treturn kallsyms_relative_base - 1 - kallsyms_offsets[idx];\n}"
  },
  {
    "function_name": "get_symbol_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "127-148",
    "snippet": "static unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const u8 kallsyms_names[] __weak;",
      "extern const unsigned int kallsyms_markers[] __weak;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const unsigned int kallsyms_markers[] __weak;\n\nstatic unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t/*\n\t * Use the closest marker we have. We have markers every 256 positions,\n\t * so that should be close enough.\n\t */\n\tname = &kallsyms_names[kallsyms_markers[pos >> 8]];\n\n\t/*\n\t * Sequentially scan all the symbols up to the point we're searching\n\t * for. Every symbol is stored in a [<len>][<len> bytes of data] format,\n\t * so we just need to add the len to the current pointer for every\n\t * symbol we wish to skip.\n\t */\n\tfor (i = 0; i < (pos & 0xFF); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}"
  },
  {
    "function_name": "kallsyms_get_symbol_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "113-120",
    "snippet": "static char kallsyms_get_symbol_type(unsigned int off)\n{\n\t/*\n\t * Get just the first code, look it up in the token table,\n\t * and return the first char from this token.\n\t */\n\treturn kallsyms_token_table[kallsyms_token_index[kallsyms_names[off + 1]]];\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const u8 kallsyms_names[] __weak;",
      "extern const char kallsyms_token_table[] __weak;",
      "extern const u16 kallsyms_token_index[] __weak;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const char kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic char kallsyms_get_symbol_type(unsigned int off)\n{\n\t/*\n\t * Get just the first code, look it up in the token table,\n\t * and return the first char from this token.\n\t */\n\treturn kallsyms_token_table[kallsyms_token_index[kallsyms_names[off + 1]]];\n}"
  },
  {
    "function_name": "kallsyms_expand_symbol",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
    "lines": "61-107",
    "snippet": "static unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst char *tptr;\n\tconst u8 *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/module.h>",
      "#include <linux/compiler.h>",
      "#include <linux/build_bug.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/filter.h>",
      "#include <linux/slab.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>\t/* for cond_resched */",
      "#include <linux/proc_fs.h>",
      "#include <linux/err.h>",
      "#include <linux/kdb.h>",
      "#include <linux/fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern const u8 kallsyms_names[] __weak;",
      "extern const char kallsyms_token_table[] __weak;",
      "extern const u16 kallsyms_token_index[] __weak;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nextern const u8 kallsyms_names[] __weak;\nextern const char kallsyms_token_table[] __weak;\nextern const u16 kallsyms_token_index[] __weak;\n\nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst char *tptr;\n\tconst u8 *data;\n\n\t/* Get the compressed symbol length from the first symbol byte. */\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t/*\n\t * Update the offset to return the offset for the next symbol on\n\t * the compressed stream.\n\t */\n\toff += len + 1;\n\n\t/*\n\t * For every byte on the compressed symbol data, copy the table\n\t * entry for that byte.\n\t */\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t/* Return to offset to the next symbol. */\n\treturn off;\n}"
  }
]