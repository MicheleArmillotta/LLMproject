[
  {
    "function_name": "fini_umd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/preload/bpf_preload_kern.c",
    "lines": "84-99",
    "snippet": "static void __exit fini_umd(void)\n{\n\tstruct pid *tgid;\n\n\tbpf_preload_ops = NULL;\n\n\t/* kill UMD in case it's still there due to earlier error */\n\ttgid = umd_ops.info.tgid;\n\tif (tgid) {\n\t\tkill_pid(tgid, SIGKILL, 1);\n\n\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n\t\tumd_cleanup_helper(&umd_ops.info);\n\t}\n\tumd_unload_blob(&umd_ops.info);\n}",
    "includes": [
      "#include \"bpf_preload.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bpf_preload_ops umd_ops = {\n\t.info.driver_name = \"bpf_preload\",\n\t.preload = preload,\n\t.finish = finish,\n\t.owner = THIS_MODULE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "umd_unload_blob",
          "args": [
            "&umd_ops.info"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "umd_unload_blob",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/usermode_driver.c",
          "lines": "82-93",
          "snippet": "int umd_unload_blob(struct umd_info *info)\n{\n\tif (WARN_ON_ONCE(!info->wd.mnt ||\n\t\t\t !info->wd.dentry ||\n\t\t\t info->wd.mnt->mnt_root != info->wd.dentry))\n\t\treturn -EINVAL;\n\n\tkern_unmount(info->wd.mnt);\n\tinfo->wd.mnt = NULL;\n\tinfo->wd.dentry = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/usermode_driver.h>",
            "#include <linux/task_work.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mount.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/usermode_driver.h>\n#include <linux/task_work.h>\n#include <linux/fs_struct.h>\n#include <linux/mount.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n\nint umd_unload_blob(struct umd_info *info)\n{\n\tif (WARN_ON_ONCE(!info->wd.mnt ||\n\t\t\t !info->wd.dentry ||\n\t\t\t info->wd.mnt->mnt_root != info->wd.dentry))\n\t\treturn -EINVAL;\n\n\tkern_unmount(info->wd.mnt);\n\tinfo->wd.mnt = NULL;\n\tinfo->wd.dentry = NULL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umd_cleanup_helper",
          "args": [
            "&umd_ops.info"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "umd_cleanup_helper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/usermode_driver.c",
          "lines": "150-156",
          "snippet": "void umd_cleanup_helper(struct umd_info *info)\n{\n\tfput(info->pipe_to_umh);\n\tfput(info->pipe_from_umh);\n\tput_pid(info->tgid);\n\tinfo->tgid = NULL;\n}",
          "includes": [
            "#include <linux/usermode_driver.h>",
            "#include <linux/task_work.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mount.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/usermode_driver.h>\n#include <linux/task_work.h>\n#include <linux/fs_struct.h>\n#include <linux/mount.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n\nvoid umd_cleanup_helper(struct umd_info *info)\n{\n\tfput(info->pipe_to_umh);\n\tfput(info->pipe_from_umh);\n\tput_pid(info->tgid);\n\tinfo->tgid = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "tgid->wait_pidfd",
            "thread_group_exited(tgid)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_exited",
          "args": [
            "tgid"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_pid",
          "args": [
            "tgid",
            "SIGKILL",
            "1"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "kill_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1905-1908",
          "snippet": "int kill_pid(struct pid *pid, int sig, int priv)\n{\n\treturn kill_pid_info(sig, __si_special(priv), pid);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint kill_pid(struct pid *pid, int sig, int priv)\n{\n\treturn kill_pid_info(sig, __si_special(priv), pid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_preload.h\"\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/pid.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct bpf_preload_ops umd_ops = {\n\t.info.driver_name = \"bpf_preload\",\n\t.preload = preload,\n\t.finish = finish,\n\t.owner = THIS_MODULE,\n};\n\nstatic void __exit fini_umd(void)\n{\n\tstruct pid *tgid;\n\n\tbpf_preload_ops = NULL;\n\n\t/* kill UMD in case it's still there due to earlier error */\n\ttgid = umd_ops.info.tgid;\n\tif (tgid) {\n\t\tkill_pid(tgid, SIGKILL, 1);\n\n\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n\t\tumd_cleanup_helper(&umd_ops.info);\n\t}\n\tumd_unload_blob(&umd_ops.info);\n}"
  },
  {
    "function_name": "load_umd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/preload/bpf_preload_kern.c",
    "lines": "72-82",
    "snippet": "static int __init load_umd(void)\n{\n\tint err;\n\n\terr = umd_load_blob(&umd_ops.info, &bpf_preload_umd_start,\n\t\t\t    &bpf_preload_umd_end - &bpf_preload_umd_start);\n\tif (err)\n\t\treturn err;\n\tbpf_preload_ops = &umd_ops;\n\treturn err;\n}",
    "includes": [
      "#include \"bpf_preload.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern char bpf_preload_umd_start;",
      "extern char bpf_preload_umd_end;",
      "static struct bpf_preload_ops umd_ops = {\n\t.info.driver_name = \"bpf_preload\",\n\t.preload = preload,\n\t.finish = finish,\n\t.owner = THIS_MODULE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "umd_load_blob",
          "args": [
            "&umd_ops.info",
            "&bpf_preload_umd_start",
            "&bpf_preload_umd_end - &bpf_preload_umd_start"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "umd_load_blob",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/usermode_driver.c",
          "lines": "60-74",
          "snippet": "int umd_load_blob(struct umd_info *info, const void *data, size_t len)\n{\n\tstruct vfsmount *mnt;\n\n\tif (WARN_ON_ONCE(info->wd.dentry || info->wd.mnt))\n\t\treturn -EBUSY;\n\n\tmnt = blob_to_mnt(data, len, info->driver_name);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\tinfo->wd.mnt = mnt;\n\tinfo->wd.dentry = mnt->mnt_root;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/usermode_driver.h>",
            "#include <linux/task_work.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mount.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/usermode_driver.h>\n#include <linux/task_work.h>\n#include <linux/fs_struct.h>\n#include <linux/mount.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n\nint umd_load_blob(struct umd_info *info, const void *data, size_t len)\n{\n\tstruct vfsmount *mnt;\n\n\tif (WARN_ON_ONCE(info->wd.dentry || info->wd.mnt))\n\t\treturn -EBUSY;\n\n\tmnt = blob_to_mnt(data, len, info->driver_name);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\tinfo->wd.mnt = mnt;\n\tinfo->wd.dentry = mnt->mnt_root;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_preload.h\"\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/pid.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nextern char bpf_preload_umd_start;\nextern char bpf_preload_umd_end;\nstatic struct bpf_preload_ops umd_ops = {\n\t.info.driver_name = \"bpf_preload\",\n\t.preload = preload,\n\t.finish = finish,\n\t.owner = THIS_MODULE,\n};\n\nstatic int __init load_umd(void)\n{\n\tint err;\n\n\terr = umd_load_blob(&umd_ops.info, &bpf_preload_umd_start,\n\t\t\t    &bpf_preload_umd_end - &bpf_preload_umd_start);\n\tif (err)\n\t\treturn err;\n\tbpf_preload_ops = &umd_ops;\n\treturn err;\n}"
  },
  {
    "function_name": "finish",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/preload/bpf_preload_kern.c",
    "lines": "51-70",
    "snippet": "static int finish(void)\n{\n\tint magic = BPF_PRELOAD_END;\n\tstruct pid *tgid;\n\tloff_t pos = 0;\n\tssize_t n;\n\n\t/* send the last magic to UMD. It will do a normal exit. */\n\tn = kernel_write(umd_ops.info.pipe_to_umh,\n\t\t\t &magic, sizeof(magic), &pos);\n\tif (n != sizeof(magic))\n\t\treturn -EPIPE;\n\n\ttgid = umd_ops.info.tgid;\n\tif (tgid) {\n\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n\t\tumd_cleanup_helper(&umd_ops.info);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"bpf_preload.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int finish(void);",
      "static struct bpf_preload_ops umd_ops = {\n\t.info.driver_name = \"bpf_preload\",\n\t.preload = preload,\n\t.finish = finish,\n\t.owner = THIS_MODULE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "umd_cleanup_helper",
          "args": [
            "&umd_ops.info"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "umd_cleanup_helper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/usermode_driver.c",
          "lines": "150-156",
          "snippet": "void umd_cleanup_helper(struct umd_info *info)\n{\n\tfput(info->pipe_to_umh);\n\tfput(info->pipe_from_umh);\n\tput_pid(info->tgid);\n\tinfo->tgid = NULL;\n}",
          "includes": [
            "#include <linux/usermode_driver.h>",
            "#include <linux/task_work.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mount.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/usermode_driver.h>\n#include <linux/task_work.h>\n#include <linux/fs_struct.h>\n#include <linux/mount.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n\nvoid umd_cleanup_helper(struct umd_info *info)\n{\n\tfput(info->pipe_to_umh);\n\tfput(info->pipe_from_umh);\n\tput_pid(info->tgid);\n\tinfo->tgid = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "tgid->wait_pidfd",
            "thread_group_exited(tgid)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_exited",
          "args": [
            "tgid"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_write",
          "args": [
            "umd_ops.info.pipe_to_umh",
            "&magic",
            "sizeof(magic)",
            "&pos"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_preload.h\"\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/pid.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int finish(void);\nstatic struct bpf_preload_ops umd_ops = {\n\t.info.driver_name = \"bpf_preload\",\n\t.preload = preload,\n\t.finish = finish,\n\t.owner = THIS_MODULE,\n};\n\nstatic int finish(void)\n{\n\tint magic = BPF_PRELOAD_END;\n\tstruct pid *tgid;\n\tloff_t pos = 0;\n\tssize_t n;\n\n\t/* send the last magic to UMD. It will do a normal exit. */\n\tn = kernel_write(umd_ops.info.pipe_to_umh,\n\t\t\t &magic, sizeof(magic), &pos);\n\tif (n != sizeof(magic))\n\t\treturn -EPIPE;\n\n\ttgid = umd_ops.info.tgid;\n\tif (tgid) {\n\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n\t\tumd_cleanup_helper(&umd_ops.info);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "preload",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/preload/bpf_preload_kern.c",
    "lines": "23-49",
    "snippet": "static int preload(struct bpf_preload_info *obj)\n{\n\tint magic = BPF_PRELOAD_START;\n\tloff_t pos = 0;\n\tint i, err;\n\tssize_t n;\n\n\terr = fork_usermode_driver(&umd_ops.info);\n\tif (err)\n\t\treturn err;\n\n\t/* send the start magic to let UMD proceed with loading BPF progs */\n\tn = kernel_write(umd_ops.info.pipe_to_umh,\n\t\t\t &magic, sizeof(magic), &pos);\n\tif (n != sizeof(magic))\n\t\treturn -EPIPE;\n\n\t/* receive bpf_link IDs and names from UMD */\n\tpos = 0;\n\tfor (i = 0; i < BPF_PRELOAD_LINKS; i++) {\n\t\tn = kernel_read(umd_ops.info.pipe_from_umh,\n\t\t\t\t&obj[i], sizeof(*obj), &pos);\n\t\tif (n != sizeof(*obj))\n\t\t\treturn -EPIPE;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"bpf_preload.h\"",
      "#include <linux/sched/signal.h>",
      "#include <linux/fs.h>",
      "#include <linux/pid.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int preload(struct bpf_preload_info *obj);",
      "static struct bpf_preload_ops umd_ops = {\n\t.info.driver_name = \"bpf_preload\",\n\t.preload = preload,\n\t.finish = finish,\n\t.owner = THIS_MODULE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "umd_ops.info.pipe_from_umh",
            "&obj[i]",
            "sizeof(*obj)",
            "&pos"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_write",
          "args": [
            "umd_ops.info.pipe_to_umh",
            "&magic",
            "sizeof(magic)",
            "&pos"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork_usermode_driver",
          "args": [
            "&umd_ops.info"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "fork_usermode_driver",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/usermode_driver.c",
          "lines": "169-188",
          "snippet": "int fork_usermode_driver(struct umd_info *info)\n{\n\tstruct subprocess_info *sub_info;\n\tconst char *argv[] = { info->driver_name, NULL };\n\tint err;\n\n\tif (WARN_ON_ONCE(info->tgid))\n\t\treturn -EBUSY;\n\n\terr = -ENOMEM;\n\tsub_info = call_usermodehelper_setup(info->driver_name,\n\t\t\t\t\t     (char **)argv, NULL, GFP_KERNEL,\n\t\t\t\t\t     umd_setup, umd_cleanup, info);\n\tif (!sub_info)\n\t\tgoto out;\n\n\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);\nout:\n\treturn err;\n}",
          "includes": [
            "#include <linux/usermode_driver.h>",
            "#include <linux/task_work.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mount.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/usermode_driver.h>\n#include <linux/task_work.h>\n#include <linux/fs_struct.h>\n#include <linux/mount.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n\nint fork_usermode_driver(struct umd_info *info)\n{\n\tstruct subprocess_info *sub_info;\n\tconst char *argv[] = { info->driver_name, NULL };\n\tint err;\n\n\tif (WARN_ON_ONCE(info->tgid))\n\t\treturn -EBUSY;\n\n\terr = -ENOMEM;\n\tsub_info = call_usermodehelper_setup(info->driver_name,\n\t\t\t\t\t     (char **)argv, NULL, GFP_KERNEL,\n\t\t\t\t\t     umd_setup, umd_cleanup, info);\n\tif (!sub_info)\n\t\tgoto out;\n\n\terr = call_usermodehelper_exec(sub_info, UMH_WAIT_EXEC);\nout:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_preload.h\"\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/pid.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int preload(struct bpf_preload_info *obj);\nstatic struct bpf_preload_ops umd_ops = {\n\t.info.driver_name = \"bpf_preload\",\n\t.preload = preload,\n\t.finish = finish,\n\t.owner = THIS_MODULE,\n};\n\nstatic int preload(struct bpf_preload_info *obj)\n{\n\tint magic = BPF_PRELOAD_START;\n\tloff_t pos = 0;\n\tint i, err;\n\tssize_t n;\n\n\terr = fork_usermode_driver(&umd_ops.info);\n\tif (err)\n\t\treturn err;\n\n\t/* send the start magic to let UMD proceed with loading BPF progs */\n\tn = kernel_write(umd_ops.info.pipe_to_umh,\n\t\t\t &magic, sizeof(magic), &pos);\n\tif (n != sizeof(magic))\n\t\treturn -EPIPE;\n\n\t/* receive bpf_link IDs and names from UMD */\n\tpos = 0;\n\tfor (i = 0; i < BPF_PRELOAD_LINKS; i++) {\n\t\tn = kernel_read(umd_ops.info.pipe_from_umh,\n\t\t\t\t&obj[i], sizeof(*obj), &pos);\n\t\tif (n != sizeof(*obj))\n\t\t\treturn -EPIPE;\n\t}\n\treturn 0;\n}"
  }
]