[
  {
    "function_name": "stack_trace_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "554-580",
    "snippet": "static __init int stack_trace_init(void)\n{\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn 0;\n\n\ttrace_create_file(\"stack_max_size\", TRACE_MODE_WRITE, NULL,\n\t\t\t&stack_trace_max_size, &stack_max_size_fops);\n\n\ttrace_create_file(\"stack_trace\", TRACE_MODE_READ, NULL,\n\t\t\tNULL, &stack_trace_fops);\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\ttrace_create_file(\"stack_trace_filter\", TRACE_MODE_WRITE, NULL,\n\t\t\t  &trace_ops, &stack_trace_filter_fops);\n#endif\n\n\tif (stack_trace_filter_buf[0])\n\t\tftrace_set_early_filter(&trace_ops, stack_trace_filter_buf, 1);\n\n\tif (stack_tracer_enabled)\n\t\tregister_ftrace_function(&trace_ops);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long stack_trace_max_size;",
      "int stack_tracer_enabled;",
      "static const struct file_operations stack_max_size_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= stack_max_size_read,\n\t.write\t\t= stack_max_size_write,\n\t.llseek\t\t= default_llseek,\n};",
      "static const struct file_operations stack_trace_fops = {\n\t.open\t\t= stack_trace_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};",
      "static char stack_trace_filter_buf[COMMAND_LINE_SIZE+1]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "&trace_ops"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_early_filter",
          "args": [
            "&trace_ops",
            "stack_trace_filter_buf",
            "1"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_early_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5812-5823",
          "snippet": "void __init\nftrace_set_early_filter(struct ftrace_ops *ops, char *buf, int enable)\n{\n\tchar *func;\n\n\tftrace_ops_init(ops);\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\tftrace_set_regex(ops, func, strlen(func), 0, enable);\n\t}\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid __init\nftrace_set_early_filter(struct ftrace_ops *ops, char *buf, int enable)\n{\n\tchar *func;\n\n\tftrace_ops_init(ops);\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \",\");\n\t\tftrace_set_regex(ops, func, strlen(func), 0, enable);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"stack_trace_filter\"",
            "TRACE_MODE_WRITE",
            "NULL",
            "&trace_ops",
            "&stack_trace_filter_fops"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "8771-8784",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9527-9553",
          "snippet": "int tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nint tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_trace_max_size;\nint stack_tracer_enabled;\nstatic const struct file_operations stack_max_size_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= stack_max_size_read,\n\t.write\t\t= stack_max_size_write,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct file_operations stack_trace_fops = {\n\t.open\t\t= stack_trace_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\nstatic char stack_trace_filter_buf[COMMAND_LINE_SIZE+1];\n\nstatic __init int stack_trace_init(void)\n{\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn 0;\n\n\ttrace_create_file(\"stack_max_size\", TRACE_MODE_WRITE, NULL,\n\t\t\t&stack_trace_max_size, &stack_max_size_fops);\n\n\ttrace_create_file(\"stack_trace\", TRACE_MODE_READ, NULL,\n\t\t\tNULL, &stack_trace_fops);\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\ttrace_create_file(\"stack_trace_filter\", TRACE_MODE_WRITE, NULL,\n\t\t\t  &trace_ops, &stack_trace_filter_fops);\n#endif\n\n\tif (stack_trace_filter_buf[0])\n\t\tftrace_set_early_filter(&trace_ops, stack_trace_filter_buf, 1);\n\n\tif (stack_tracer_enabled)\n\t\tregister_ftrace_function(&trace_ops);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "enable_stacktrace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "542-551",
    "snippet": "static __init int enable_stacktrace(char *str)\n{\n\tint len;\n\n\tif ((len = str_has_prefix(str, \"_filter=\")))\n\t\tstrncpy(stack_trace_filter_buf, str + len, COMMAND_LINE_SIZE);\n\n\tstack_tracer_enabled = 1;\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int stack_tracer_enabled;",
      "static char stack_trace_filter_buf[COMMAND_LINE_SIZE+1]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "stack_trace_filter_buf",
            "str + len",
            "COMMAND_LINE_SIZE"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "str",
            "\"_filter=\""
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nint stack_tracer_enabled;\nstatic char stack_trace_filter_buf[COMMAND_LINE_SIZE+1];\n\nstatic __init int enable_stacktrace(char *str)\n{\n\tint len;\n\n\tif ((len = str_has_prefix(str, \"_filter=\")))\n\t\tstrncpy(stack_trace_filter_buf, str + len, COMMAND_LINE_SIZE);\n\n\tstack_tracer_enabled = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "stack_trace_sysctl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "516-538",
    "snippet": "int\nstack_trace_sysctl(struct ctl_table *table, int write, void *buffer,\n\t\t   size_t *lenp, loff_t *ppos)\n{\n\tint was_enabled;\n\tint ret;\n\n\tmutex_lock(&stack_sysctl_mutex);\n\twas_enabled = !!stack_tracer_enabled;\n\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write || (was_enabled == !!stack_tracer_enabled))\n\t\tgoto out;\n\n\tif (stack_tracer_enabled)\n\t\tregister_ftrace_function(&trace_ops);\n\telse\n\t\tunregister_ftrace_function(&trace_ops);\n out:\n\tmutex_unlock(&stack_sysctl_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(stack_sysctl_mutex);",
      "int stack_tracer_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stack_sysctl_mutex"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&trace_ops"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dointvec",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_ms_jiffies",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "1597-1601",
          "snippet": "int proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nint proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&stack_sysctl_mutex"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic DEFINE_MUTEX(stack_sysctl_mutex);\nint stack_tracer_enabled;\n\nint\nstack_trace_sysctl(struct ctl_table *table, int write, void *buffer,\n\t\t   size_t *lenp, loff_t *ppos)\n{\n\tint was_enabled;\n\tint ret;\n\n\tmutex_lock(&stack_sysctl_mutex);\n\twas_enabled = !!stack_tracer_enabled;\n\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write || (was_enabled == !!stack_tracer_enabled))\n\t\tgoto out;\n\n\tif (stack_tracer_enabled)\n\t\tregister_ftrace_function(&trace_ops);\n\telse\n\t\tunregister_ftrace_function(&trace_ops);\n out:\n\tmutex_unlock(&stack_sysctl_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "stack_trace_filter_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "496-504",
    "snippet": "static int\nstack_trace_filter_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_ops *ops = inode->i_private;\n\n\t/* Checks for tracefs lockdown */\n\treturn ftrace_regex_open(ops, FTRACE_ITER_FILTER,\n\t\t\t\t inode, file);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_regex_open",
          "args": [
            "ops",
            "FTRACE_ITER_FILTER",
            "inode",
            "file"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_regex_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "3784-3870",
          "snippet": "int\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *mod_head;\n\tstruct trace_array *tr = ops->private;\n\tint ret = -ENOMEM;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tif (tracing_check_open_get_tr(tr))\n\t\treturn -ENODEV;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\tgoto out;\n\n\tif (trace_parser_get_init(&iter->parser, FTRACE_BUFF_MAX))\n\t\tgoto out;\n\n\titer->ops = ops;\n\titer->flags = flag;\n\titer->tr = tr;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & FTRACE_ITER_NOTRACE) {\n\t\thash = ops->func_hash->notrace_hash;\n\t\tmod_head = tr ? &tr->mod_notrace : NULL;\n\t} else {\n\t\thash = ops->func_hash->filter_hash;\n\t\tmod_head = tr ? &tr->mod_trace : NULL;\n\t}\n\n\titer->mod_list = mod_head;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (file->f_flags & O_TRUNC) {\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\t\tclear_ftrace_mod_list(mod_head);\n\t        } else {\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\t\t}\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else\n\t\titer->hash = hash;\n\n\tret = 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n out:\n\tif (ret) {\n\t\tkfree(iter);\n\t\tif (tr)\n\t\t\ttrace_array_put(tr);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */",
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static int ftrace_disabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_BUFF_MAX (KSYM_SYMBOL_LEN+4) /* room for wildcards */\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic int ftrace_disabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tstruct list_head *mod_head;\n\tstruct trace_array *tr = ops->private;\n\tint ret = -ENOMEM;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tif (tracing_check_open_get_tr(tr))\n\t\treturn -ENODEV;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\tgoto out;\n\n\tif (trace_parser_get_init(&iter->parser, FTRACE_BUFF_MAX))\n\t\tgoto out;\n\n\titer->ops = ops;\n\titer->flags = flag;\n\titer->tr = tr;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & FTRACE_ITER_NOTRACE) {\n\t\thash = ops->func_hash->notrace_hash;\n\t\tmod_head = tr ? &tr->mod_notrace : NULL;\n\t} else {\n\t\thash = ops->func_hash->filter_hash;\n\t\tmod_head = tr ? &tr->mod_trace : NULL;\n\t}\n\n\titer->mod_list = mod_head;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tconst int size_bits = FTRACE_HASH_DEFAULT_BITS;\n\n\t\tif (file->f_flags & O_TRUNC) {\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\t\tclear_ftrace_mod_list(mod_head);\n\t        } else {\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\t\t}\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else\n\t\titer->hash = hash;\n\n\tret = 0;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t/* Failed */\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n out:\n\tif (ret) {\n\t\tkfree(iter);\n\t\tif (tr)\n\t\t\ttrace_array_put(tr);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic int\nstack_trace_filter_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_ops *ops = inode->i_private;\n\n\t/* Checks for tracefs lockdown */\n\treturn ftrace_regex_open(ops, FTRACE_ITER_FILTER,\n\t\t\t\t inode, file);\n}"
  },
  {
    "function_name": "stack_trace_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "476-485",
    "snippet": "static int stack_trace_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn seq_open(file, &stack_trace_seq_ops);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations stack_trace_seq_ops = {\n\t.start\t\t= t_start,\n\t.next\t\t= t_next,\n\t.stop\t\t= t_stop,\n\t.show\t\t= t_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&stack_trace_seq_ops"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_TRACEFS"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic const struct seq_operations stack_trace_seq_ops = {\n\t.start\t\t= t_start,\n\t.next\t\t= t_next,\n\t.stop\t\t= t_stop,\n\t.show\t\t= t_show,\n};\n\nstatic int stack_trace_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn seq_open(file, &stack_trace_seq_ops);\n}"
  },
  {
    "function_name": "t_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "435-467",
    "snippet": "static int t_show(struct seq_file *m, void *v)\n{\n\tlong i;\n\tint size;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(m, \"        Depth    Size   Location\"\n\t\t\t   \"    (%d entries)\\n\"\n\t\t\t   \"        -----    ----   --------\\n\",\n\t\t\t   stack_trace_nr_entries);\n\n\t\tif (!stack_tracer_enabled && !stack_trace_max_size)\n\t\t\tprint_disabled(m);\n\n\t\treturn 0;\n\t}\n\n\ti = *(long *)v;\n\n\tif (i >= stack_trace_nr_entries)\n\t\treturn 0;\n\n\tif (i + 1 == stack_trace_nr_entries)\n\t\tsize = stack_trace_index[i];\n\telse\n\t\tsize = stack_trace_index[i] - stack_trace_index[i+1];\n\n\tseq_printf(m, \"%3ld) %8d   %5d   \", i, stack_trace_index[i], size);\n\n\ttrace_lookup_stack(m, i);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned stack_trace_index[STACK_TRACE_ENTRIES];",
      "static unsigned int stack_trace_nr_entries;",
      "static unsigned long stack_trace_max_size;",
      "int stack_tracer_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_lookup_stack",
          "args": [
            "m",
            "i"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "trace_lookup_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
          "lines": "417-422",
          "snippet": "static void trace_lookup_stack(struct seq_file *m, long i)\n{\n\tunsigned long addr = stack_dump_trace[i];\n\n\tseq_printf(m, \"%pS\\n\", (void *)addr);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/setup.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/security.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_dump_trace[STACK_TRACE_ENTRIES];\n\nstatic void trace_lookup_stack(struct seq_file *m, long i)\n{\n\tunsigned long addr = stack_dump_trace[i];\n\n\tseq_printf(m, \"%pS\\n\", (void *)addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%3ld) %8d   %5d   \"",
            "i",
            "stack_trace_index[i]",
            "size"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_disabled",
          "args": [
            "m"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "print_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
          "lines": "424-433",
          "snippet": "static void print_disabled(struct seq_file *m)\n{\n\tseq_puts(m, \"#\\n\"\n\t\t \"#  Stack tracer disabled\\n\"\n\t\t \"#\\n\"\n\t\t \"# To enable the stack tracer, either add 'stacktrace' to the\\n\"\n\t\t \"# kernel command line\\n\"\n\t\t \"# or 'echo 1 > /proc/sys/kernel/stack_tracer_enabled'\\n\"\n\t\t \"#\\n\");\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/setup.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/security.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int stack_tracer_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nint stack_tracer_enabled;\n\nstatic void print_disabled(struct seq_file *m)\n{\n\tseq_puts(m, \"#\\n\"\n\t\t \"#  Stack tracer disabled\\n\"\n\t\t \"#\\n\"\n\t\t \"# To enable the stack tracer, either add 'stacktrace' to the\\n\"\n\t\t \"# kernel command line\\n\"\n\t\t \"# or 'echo 1 > /proc/sys/kernel/stack_tracer_enabled'\\n\"\n\t\t \"#\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned stack_trace_index[STACK_TRACE_ENTRIES];\nstatic unsigned int stack_trace_nr_entries;\nstatic unsigned long stack_trace_max_size;\nint stack_tracer_enabled;\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tlong i;\n\tint size;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(m, \"        Depth    Size   Location\"\n\t\t\t   \"    (%d entries)\\n\"\n\t\t\t   \"        -----    ----   --------\\n\",\n\t\t\t   stack_trace_nr_entries);\n\n\t\tif (!stack_tracer_enabled && !stack_trace_max_size)\n\t\t\tprint_disabled(m);\n\n\t\treturn 0;\n\t}\n\n\ti = *(long *)v;\n\n\tif (i >= stack_trace_nr_entries)\n\t\treturn 0;\n\n\tif (i + 1 == stack_trace_nr_entries)\n\t\tsize = stack_trace_index[i];\n\telse\n\t\tsize = stack_trace_index[i] - stack_trace_index[i+1];\n\n\tseq_printf(m, \"%3ld) %8d   %5d   \", i, stack_trace_index[i], size);\n\n\ttrace_lookup_stack(m, i);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "print_disabled",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "424-433",
    "snippet": "static void print_disabled(struct seq_file *m)\n{\n\tseq_puts(m, \"#\\n\"\n\t\t \"#  Stack tracer disabled\\n\"\n\t\t \"#\\n\"\n\t\t \"# To enable the stack tracer, either add 'stacktrace' to the\\n\"\n\t\t \"# kernel command line\\n\"\n\t\t \"# or 'echo 1 > /proc/sys/kernel/stack_tracer_enabled'\\n\"\n\t\t \"#\\n\");\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int stack_tracer_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"#\\n\"\n\t\t \"#  Stack tracer disabled\\n\"\n\t\t \"#\\n\"\n\t\t \"# To enable the stack tracer, either add 'stacktrace' to the\\n\"\n\t\t \"# kernel command line\\n\"\n\t\t \"# or 'echo 1 > /proc/sys/kernel/stack_tracer_enabled'\\n\"\n\t\t \"#\\n\""
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nint stack_tracer_enabled;\n\nstatic void print_disabled(struct seq_file *m)\n{\n\tseq_puts(m, \"#\\n\"\n\t\t \"#  Stack tracer disabled\\n\"\n\t\t \"#\\n\"\n\t\t \"# To enable the stack tracer, either add 'stacktrace' to the\\n\"\n\t\t \"# kernel command line\\n\"\n\t\t \"# or 'echo 1 > /proc/sys/kernel/stack_tracer_enabled'\\n\"\n\t\t \"#\\n\");\n}"
  },
  {
    "function_name": "trace_lookup_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "417-422",
    "snippet": "static void trace_lookup_stack(struct seq_file *m, long i)\n{\n\tunsigned long addr = stack_dump_trace[i];\n\n\tseq_printf(m, \"%pS\\n\", (void *)addr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%pS\\n\"",
            "(void *)addr"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_dump_trace[STACK_TRACE_ENTRIES];\n\nstatic void trace_lookup_stack(struct seq_file *m, long i)\n{\n\tunsigned long addr = stack_dump_trace[i];\n\n\tseq_printf(m, \"%pS\\n\", (void *)addr);\n}"
  },
  {
    "function_name": "t_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "408-415",
    "snippet": "static void t_stop(struct seq_file *m, void *p)\n{\n\tarch_spin_unlock(&stack_trace_max_lock);\n\n\t__this_cpu_dec(disable_stack_tracer);\n\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "disable_stack_tracer"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&stack_trace_max_lock"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic arch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic void t_stop(struct seq_file *m, void *p)\n{\n\tarch_spin_unlock(&stack_trace_max_lock);\n\n\t__this_cpu_dec(disable_stack_tracer);\n\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "t_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "394-406",
    "snippet": "static void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tlocal_irq_disable();\n\n\t__this_cpu_inc(disable_stack_tracer);\n\n\tarch_spin_lock(&stack_trace_max_lock);\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn __next(m, pos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__next",
          "args": [
            "m",
            "pos"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "__next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
          "lines": "375-385",
          "snippet": "static void *\n__next(struct seq_file *m, loff_t *pos)\n{\n\tlong n = *pos - 1;\n\n\tif (n >= stack_trace_nr_entries)\n\t\treturn NULL;\n\n\tm->private = (void *)n;\n\treturn &m->private;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/setup.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/security.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int stack_trace_nr_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned int stack_trace_nr_entries;\n\nstatic void *\n__next(struct seq_file *m, loff_t *pos)\n{\n\tlong n = *pos - 1;\n\n\tif (n >= stack_trace_nr_entries)\n\t\treturn NULL;\n\n\tm->private = (void *)n;\n\treturn &m->private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&stack_trace_max_lock"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "disable_stack_tracer"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic arch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tlocal_irq_disable();\n\n\t__this_cpu_inc(disable_stack_tracer);\n\n\tarch_spin_lock(&stack_trace_max_lock);\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn __next(m, pos);\n}"
  },
  {
    "function_name": "t_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "387-392",
    "snippet": "static void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn __next(m, pos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__next",
          "args": [
            "m",
            "pos"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "__next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
          "lines": "375-385",
          "snippet": "static void *\n__next(struct seq_file *m, loff_t *pos)\n{\n\tlong n = *pos - 1;\n\n\tif (n >= stack_trace_nr_entries)\n\t\treturn NULL;\n\n\tm->private = (void *)n;\n\treturn &m->private;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/setup.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/security.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int stack_trace_nr_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned int stack_trace_nr_entries;\n\nstatic void *\n__next(struct seq_file *m, loff_t *pos)\n{\n\tlong n = *pos - 1;\n\n\tif (n >= stack_trace_nr_entries)\n\t\treturn NULL;\n\n\tm->private = (void *)n;\n\treturn &m->private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn __next(m, pos);\n}"
  },
  {
    "function_name": "__next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "375-385",
    "snippet": "static void *\n__next(struct seq_file *m, loff_t *pos)\n{\n\tlong n = *pos - 1;\n\n\tif (n >= stack_trace_nr_entries)\n\t\treturn NULL;\n\n\tm->private = (void *)n;\n\treturn &m->private;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int stack_trace_nr_entries;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned int stack_trace_nr_entries;\n\nstatic void *\n__next(struct seq_file *m, loff_t *pos)\n{\n\tlong n = *pos - 1;\n\n\tif (n >= stack_trace_nr_entries)\n\t\treturn NULL;\n\n\tm->private = (void *)n;\n\treturn &m->private;\n}"
  },
  {
    "function_name": "stack_max_size_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "337-366",
    "snippet": "static ssize_t\nstack_max_size_write(struct file *filp, const char __user *ubuf,\n\t\t     size_t count, loff_t *ppos)\n{\n\tlong *ptr = filp->private_data;\n\tunsigned long val, flags;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, count, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tlocal_irq_save(flags);\n\n\t/*\n\t * In case we trace inside arch_spin_lock() or after (NMI),\n\t * we will cause circular lock, so we also need to increase\n\t * the percpu disable_stack_tracer here.\n\t */\n\t__this_cpu_inc(disable_stack_tracer);\n\n\tarch_spin_lock(&stack_trace_max_lock);\n\t*ptr = val;\n\tarch_spin_unlock(&stack_trace_max_lock);\n\n\t__this_cpu_dec(disable_stack_tracer);\n\tlocal_irq_restore(flags);\n\n\treturn count;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "disable_stack_tracer"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&stack_trace_max_lock"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&stack_trace_max_lock"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "disable_stack_tracer"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul_from_user",
          "args": [
            "ubuf",
            "count",
            "10",
            "&val"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic arch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic ssize_t\nstack_max_size_write(struct file *filp, const char __user *ubuf,\n\t\t     size_t count, loff_t *ppos)\n{\n\tlong *ptr = filp->private_data;\n\tunsigned long val, flags;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, count, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tlocal_irq_save(flags);\n\n\t/*\n\t * In case we trace inside arch_spin_lock() or after (NMI),\n\t * we will cause circular lock, so we also need to increase\n\t * the percpu disable_stack_tracer here.\n\t */\n\t__this_cpu_inc(disable_stack_tracer);\n\n\tarch_spin_lock(&stack_trace_max_lock);\n\t*ptr = val;\n\tarch_spin_unlock(&stack_trace_max_lock);\n\n\t__this_cpu_dec(disable_stack_tracer);\n\tlocal_irq_restore(flags);\n\n\treturn count;\n}"
  },
  {
    "function_name": "stack_max_size_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "323-335",
    "snippet": "static ssize_t\nstack_max_size_read(struct file *filp, char __user *ubuf,\n\t\t    size_t count, loff_t *ppos)\n{\n\tunsigned long *ptr = filp->private_data;\n\tchar buf[64];\n\tint r;\n\n\tr = snprintf(buf, sizeof(buf), \"%ld\\n\", *ptr);\n\tif (r > sizeof(buf))\n\t\tr = sizeof(buf);\n\treturn simple_read_from_buffer(ubuf, count, ppos, buf, r);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "count",
            "ppos",
            "buf",
            "r"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%ld\\n\"",
            "*ptr"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic ssize_t\nstack_max_size_read(struct file *filp, char __user *ubuf,\n\t\t    size_t count, loff_t *ppos)\n{\n\tunsigned long *ptr = filp->private_data;\n\tchar buf[64];\n\tint r;\n\n\tr = snprintf(buf, sizeof(buf), \"%ld\\n\", *ptr);\n\tif (r > sizeof(buf))\n\t\tr = sizeof(buf);\n\treturn simple_read_from_buffer(ubuf, count, ppos, buf, r);\n}"
  },
  {
    "function_name": "stack_trace_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "291-316",
    "snippet": "static void\nstack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tunsigned long stack;\n\n\tpreempt_disable_notrace();\n\n\t/* no atomic needed, we only modify this variable by this cpu */\n\t__this_cpu_inc(disable_stack_tracer);\n\tif (__this_cpu_read(disable_stack_tracer) != 1)\n\t\tgoto out;\n\n\t/* If rcu is not watching, then save stack trace can fail */\n\tif (!rcu_is_watching())\n\t\tgoto out;\n\n\tip += MCOUNT_INSN_SIZE;\n\n\tcheck_stack(ip, &stack);\n\n out:\n\t__this_cpu_dec(disable_stack_tracer);\n\t/* prevent recursion in schedule */\n\tpreempt_enable_notrace();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "disable_stack_tracer"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack",
          "args": [
            "ip",
            "&stack"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "check_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
          "lines": "155-284",
          "snippet": "static void check_stack(unsigned long ip, unsigned long *stack)\n{\n\tunsigned long this_size, flags; unsigned long *p, *top, *start;\n\tstatic int tracer_frame;\n\tint frame_size = READ_ONCE(tracer_frame);\n\tint i, x;\n\n\tthis_size = ((unsigned long)stack) & (THREAD_SIZE-1);\n\tthis_size = THREAD_SIZE - this_size;\n\t/* Remove the frame of the tracer */\n\tthis_size -= frame_size;\n\n\tif (this_size <= stack_trace_max_size)\n\t\treturn;\n\n\t/* we do not handle interrupt stacks yet */\n\tif (!object_is_on_stack(stack))\n\t\treturn;\n\n\t/* Can't do this from NMI context (can cause deadlocks) */\n\tif (in_nmi())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&stack_trace_max_lock);\n\n\t/* In case another CPU set the tracer_frame on us */\n\tif (unlikely(!frame_size))\n\t\tthis_size -= tracer_frame;\n\n\t/* a race could have already updated it */\n\tif (this_size <= stack_trace_max_size)\n\t\tgoto out;\n\n\tstack_trace_max_size = this_size;\n\n\tstack_trace_nr_entries = stack_trace_save(stack_dump_trace,\n\t\t\t\t\t       ARRAY_SIZE(stack_dump_trace) - 1,\n\t\t\t\t\t       0);\n\n\t/* Skip over the overhead of the stack tracer itself */\n\tfor (i = 0; i < stack_trace_nr_entries; i++) {\n\t\tif (stack_dump_trace[i] == ip)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Some archs may not have the passed in ip in the dump.\n\t * If that happens, we need to show everything.\n\t */\n\tif (i == stack_trace_nr_entries)\n\t\ti = 0;\n\n\t/*\n\t * Now find where in the stack these are.\n\t */\n\tx = 0;\n\tstart = stack;\n\ttop = (unsigned long *)\n\t\t(((unsigned long)start & ~(THREAD_SIZE-1)) + THREAD_SIZE);\n\n\t/*\n\t * Loop through all the entries. One of the entries may\n\t * for some reason be missed on the stack, so we may\n\t * have to account for them. If they are all there, this\n\t * loop will only happen once. This code only takes place\n\t * on a new max, so it is far from a fast path.\n\t */\n\twhile (i < stack_trace_nr_entries) {\n\t\tint found = 0;\n\n\t\tstack_trace_index[x] = this_size;\n\t\tp = start;\n\n\t\tfor (; p < top && i < stack_trace_nr_entries; p++) {\n\t\t\t/*\n\t\t\t * The READ_ONCE_NOCHECK is used to let KASAN know that\n\t\t\t * this is not a stack-out-of-bounds error.\n\t\t\t */\n\t\t\tif ((READ_ONCE_NOCHECK(*p)) == stack_dump_trace[i]) {\n\t\t\t\tstack_dump_trace[x] = stack_dump_trace[i++];\n\t\t\t\tthis_size = stack_trace_index[x++] =\n\t\t\t\t\t(top - p) * sizeof(unsigned long);\n\t\t\t\tfound = 1;\n\t\t\t\t/* Start the search from here */\n\t\t\t\tstart = p + 1;\n\t\t\t\t/*\n\t\t\t\t * We do not want to show the overhead\n\t\t\t\t * of the stack tracer stack in the\n\t\t\t\t * max stack. If we haven't figured\n\t\t\t\t * out what that is, then figure it out\n\t\t\t\t * now.\n\t\t\t\t */\n\t\t\t\tif (unlikely(!tracer_frame)) {\n\t\t\t\t\ttracer_frame = (p - stack) *\n\t\t\t\t\t\tsizeof(unsigned long);\n\t\t\t\t\tstack_trace_max_size -= tracer_frame;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\ti++;\n\t}\n\n#ifdef ARCH_FTRACE_SHIFT_STACK_TRACER\n\t/*\n\t * Some archs will store the link register before calling\n\t * nested functions. This means the saved return address\n\t * comes after the local storage, and we need to shift\n\t * for that.\n\t */\n\tif (x > 1) {\n\t\tmemmove(&stack_trace_index[0], &stack_trace_index[1],\n\t\t\tsizeof(stack_trace_index[0]) * (x - 1));\n\t\tx--;\n\t}\n#endif\n\n\tstack_trace_nr_entries = x;\n\n\tif (task_stack_end_corrupted(current)) {\n\t\tprint_max_stack();\n\t\tBUG();\n\t}\n\n out:\n\tarch_spin_unlock(&stack_trace_max_lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/setup.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/security.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES];",
            "static unsigned stack_trace_index[STACK_TRACE_ENTRIES];",
            "static unsigned int stack_trace_nr_entries;",
            "static unsigned long stack_trace_max_size;",
            "static arch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_dump_trace[STACK_TRACE_ENTRIES];\nstatic unsigned stack_trace_index[STACK_TRACE_ENTRIES];\nstatic unsigned int stack_trace_nr_entries;\nstatic unsigned long stack_trace_max_size;\nstatic arch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic void check_stack(unsigned long ip, unsigned long *stack)\n{\n\tunsigned long this_size, flags; unsigned long *p, *top, *start;\n\tstatic int tracer_frame;\n\tint frame_size = READ_ONCE(tracer_frame);\n\tint i, x;\n\n\tthis_size = ((unsigned long)stack) & (THREAD_SIZE-1);\n\tthis_size = THREAD_SIZE - this_size;\n\t/* Remove the frame of the tracer */\n\tthis_size -= frame_size;\n\n\tif (this_size <= stack_trace_max_size)\n\t\treturn;\n\n\t/* we do not handle interrupt stacks yet */\n\tif (!object_is_on_stack(stack))\n\t\treturn;\n\n\t/* Can't do this from NMI context (can cause deadlocks) */\n\tif (in_nmi())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&stack_trace_max_lock);\n\n\t/* In case another CPU set the tracer_frame on us */\n\tif (unlikely(!frame_size))\n\t\tthis_size -= tracer_frame;\n\n\t/* a race could have already updated it */\n\tif (this_size <= stack_trace_max_size)\n\t\tgoto out;\n\n\tstack_trace_max_size = this_size;\n\n\tstack_trace_nr_entries = stack_trace_save(stack_dump_trace,\n\t\t\t\t\t       ARRAY_SIZE(stack_dump_trace) - 1,\n\t\t\t\t\t       0);\n\n\t/* Skip over the overhead of the stack tracer itself */\n\tfor (i = 0; i < stack_trace_nr_entries; i++) {\n\t\tif (stack_dump_trace[i] == ip)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Some archs may not have the passed in ip in the dump.\n\t * If that happens, we need to show everything.\n\t */\n\tif (i == stack_trace_nr_entries)\n\t\ti = 0;\n\n\t/*\n\t * Now find where in the stack these are.\n\t */\n\tx = 0;\n\tstart = stack;\n\ttop = (unsigned long *)\n\t\t(((unsigned long)start & ~(THREAD_SIZE-1)) + THREAD_SIZE);\n\n\t/*\n\t * Loop through all the entries. One of the entries may\n\t * for some reason be missed on the stack, so we may\n\t * have to account for them. If they are all there, this\n\t * loop will only happen once. This code only takes place\n\t * on a new max, so it is far from a fast path.\n\t */\n\twhile (i < stack_trace_nr_entries) {\n\t\tint found = 0;\n\n\t\tstack_trace_index[x] = this_size;\n\t\tp = start;\n\n\t\tfor (; p < top && i < stack_trace_nr_entries; p++) {\n\t\t\t/*\n\t\t\t * The READ_ONCE_NOCHECK is used to let KASAN know that\n\t\t\t * this is not a stack-out-of-bounds error.\n\t\t\t */\n\t\t\tif ((READ_ONCE_NOCHECK(*p)) == stack_dump_trace[i]) {\n\t\t\t\tstack_dump_trace[x] = stack_dump_trace[i++];\n\t\t\t\tthis_size = stack_trace_index[x++] =\n\t\t\t\t\t(top - p) * sizeof(unsigned long);\n\t\t\t\tfound = 1;\n\t\t\t\t/* Start the search from here */\n\t\t\t\tstart = p + 1;\n\t\t\t\t/*\n\t\t\t\t * We do not want to show the overhead\n\t\t\t\t * of the stack tracer stack in the\n\t\t\t\t * max stack. If we haven't figured\n\t\t\t\t * out what that is, then figure it out\n\t\t\t\t * now.\n\t\t\t\t */\n\t\t\t\tif (unlikely(!tracer_frame)) {\n\t\t\t\t\ttracer_frame = (p - stack) *\n\t\t\t\t\t\tsizeof(unsigned long);\n\t\t\t\t\tstack_trace_max_size -= tracer_frame;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\ti++;\n\t}\n\n#ifdef ARCH_FTRACE_SHIFT_STACK_TRACER\n\t/*\n\t * Some archs will store the link register before calling\n\t * nested functions. This means the saved return address\n\t * comes after the local storage, and we need to shift\n\t * for that.\n\t */\n\tif (x > 1) {\n\t\tmemmove(&stack_trace_index[0], &stack_trace_index[1],\n\t\t\tsizeof(stack_trace_index[0]) * (x - 1));\n\t\tx--;\n\t}\n#endif\n\n\tstack_trace_nr_entries = x;\n\n\tif (task_stack_end_corrupted(current)) {\n\t\tprint_max_stack();\n\t\tBUG();\n\t}\n\n out:\n\tarch_spin_unlock(&stack_trace_max_lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_is_watching",
          "args": [],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_watching",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1123-1131",
          "snippet": "notrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nnotrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "disable_stack_tracer"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "disable_stack_tracer"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic void\nstack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t struct ftrace_ops *op, struct ftrace_regs *fregs)\n{\n\tunsigned long stack;\n\n\tpreempt_disable_notrace();\n\n\t/* no atomic needed, we only modify this variable by this cpu */\n\t__this_cpu_inc(disable_stack_tracer);\n\tif (__this_cpu_read(disable_stack_tracer) != 1)\n\t\tgoto out;\n\n\t/* If rcu is not watching, then save stack trace can fail */\n\tif (!rcu_is_watching())\n\t\tgoto out;\n\n\tip += MCOUNT_INSN_SIZE;\n\n\tcheck_stack(ip, &stack);\n\n out:\n\t__this_cpu_dec(disable_stack_tracer);\n\t/* prevent recursion in schedule */\n\tpreempt_enable_notrace();\n}"
  },
  {
    "function_name": "check_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "155-284",
    "snippet": "static void check_stack(unsigned long ip, unsigned long *stack)\n{\n\tunsigned long this_size, flags; unsigned long *p, *top, *start;\n\tstatic int tracer_frame;\n\tint frame_size = READ_ONCE(tracer_frame);\n\tint i, x;\n\n\tthis_size = ((unsigned long)stack) & (THREAD_SIZE-1);\n\tthis_size = THREAD_SIZE - this_size;\n\t/* Remove the frame of the tracer */\n\tthis_size -= frame_size;\n\n\tif (this_size <= stack_trace_max_size)\n\t\treturn;\n\n\t/* we do not handle interrupt stacks yet */\n\tif (!object_is_on_stack(stack))\n\t\treturn;\n\n\t/* Can't do this from NMI context (can cause deadlocks) */\n\tif (in_nmi())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&stack_trace_max_lock);\n\n\t/* In case another CPU set the tracer_frame on us */\n\tif (unlikely(!frame_size))\n\t\tthis_size -= tracer_frame;\n\n\t/* a race could have already updated it */\n\tif (this_size <= stack_trace_max_size)\n\t\tgoto out;\n\n\tstack_trace_max_size = this_size;\n\n\tstack_trace_nr_entries = stack_trace_save(stack_dump_trace,\n\t\t\t\t\t       ARRAY_SIZE(stack_dump_trace) - 1,\n\t\t\t\t\t       0);\n\n\t/* Skip over the overhead of the stack tracer itself */\n\tfor (i = 0; i < stack_trace_nr_entries; i++) {\n\t\tif (stack_dump_trace[i] == ip)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Some archs may not have the passed in ip in the dump.\n\t * If that happens, we need to show everything.\n\t */\n\tif (i == stack_trace_nr_entries)\n\t\ti = 0;\n\n\t/*\n\t * Now find where in the stack these are.\n\t */\n\tx = 0;\n\tstart = stack;\n\ttop = (unsigned long *)\n\t\t(((unsigned long)start & ~(THREAD_SIZE-1)) + THREAD_SIZE);\n\n\t/*\n\t * Loop through all the entries. One of the entries may\n\t * for some reason be missed on the stack, so we may\n\t * have to account for them. If they are all there, this\n\t * loop will only happen once. This code only takes place\n\t * on a new max, so it is far from a fast path.\n\t */\n\twhile (i < stack_trace_nr_entries) {\n\t\tint found = 0;\n\n\t\tstack_trace_index[x] = this_size;\n\t\tp = start;\n\n\t\tfor (; p < top && i < stack_trace_nr_entries; p++) {\n\t\t\t/*\n\t\t\t * The READ_ONCE_NOCHECK is used to let KASAN know that\n\t\t\t * this is not a stack-out-of-bounds error.\n\t\t\t */\n\t\t\tif ((READ_ONCE_NOCHECK(*p)) == stack_dump_trace[i]) {\n\t\t\t\tstack_dump_trace[x] = stack_dump_trace[i++];\n\t\t\t\tthis_size = stack_trace_index[x++] =\n\t\t\t\t\t(top - p) * sizeof(unsigned long);\n\t\t\t\tfound = 1;\n\t\t\t\t/* Start the search from here */\n\t\t\t\tstart = p + 1;\n\t\t\t\t/*\n\t\t\t\t * We do not want to show the overhead\n\t\t\t\t * of the stack tracer stack in the\n\t\t\t\t * max stack. If we haven't figured\n\t\t\t\t * out what that is, then figure it out\n\t\t\t\t * now.\n\t\t\t\t */\n\t\t\t\tif (unlikely(!tracer_frame)) {\n\t\t\t\t\ttracer_frame = (p - stack) *\n\t\t\t\t\t\tsizeof(unsigned long);\n\t\t\t\t\tstack_trace_max_size -= tracer_frame;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\ti++;\n\t}\n\n#ifdef ARCH_FTRACE_SHIFT_STACK_TRACER\n\t/*\n\t * Some archs will store the link register before calling\n\t * nested functions. This means the saved return address\n\t * comes after the local storage, and we need to shift\n\t * for that.\n\t */\n\tif (x > 1) {\n\t\tmemmove(&stack_trace_index[0], &stack_trace_index[1],\n\t\t\tsizeof(stack_trace_index[0]) * (x - 1));\n\t\tx--;\n\t}\n#endif\n\n\tstack_trace_nr_entries = x;\n\n\tif (task_stack_end_corrupted(current)) {\n\t\tprint_max_stack();\n\t\tBUG();\n\t}\n\n out:\n\tarch_spin_unlock(&stack_trace_max_lock);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES];",
      "static unsigned stack_trace_index[STACK_TRACE_ENTRIES];",
      "static unsigned int stack_trace_nr_entries;",
      "static unsigned long stack_trace_max_size;",
      "static arch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&stack_trace_max_lock"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_max_stack",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "print_max_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
          "lines": "37-55",
          "snippet": "static void print_max_stack(void)\n{\n\tlong i;\n\tint size;\n\n\tpr_emerg(\"        Depth    Size   Location    (%d entries)\\n\"\n\t\t\t   \"        -----    ----   --------\\n\",\n\t\t\t   stack_trace_nr_entries);\n\n\tfor (i = 0; i < stack_trace_nr_entries; i++) {\n\t\tif (i + 1 == stack_trace_nr_entries)\n\t\t\tsize = stack_trace_index[i];\n\t\telse\n\t\t\tsize = stack_trace_index[i] - stack_trace_index[i+1];\n\n\t\tpr_emerg(\"%3ld) %8d   %5d   %pS\\n\", i, stack_trace_index[i],\n\t\t\t\tsize, (void *)stack_dump_trace[i]);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <asm/setup.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/security.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES];",
            "static unsigned stack_trace_index[STACK_TRACE_ENTRIES];",
            "static unsigned int stack_trace_nr_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_dump_trace[STACK_TRACE_ENTRIES];\nstatic unsigned stack_trace_index[STACK_TRACE_ENTRIES];\nstatic unsigned int stack_trace_nr_entries;\n\nstatic void print_max_stack(void)\n{\n\tlong i;\n\tint size;\n\n\tpr_emerg(\"        Depth    Size   Location    (%d entries)\\n\"\n\t\t\t   \"        -----    ----   --------\\n\",\n\t\t\t   stack_trace_nr_entries);\n\n\tfor (i = 0; i < stack_trace_nr_entries; i++) {\n\t\tif (i + 1 == stack_trace_nr_entries)\n\t\t\tsize = stack_trace_index[i];\n\t\telse\n\t\t\tsize = stack_trace_index[i] - stack_trace_index[i+1];\n\n\t\tpr_emerg(\"%3ld) %8d   %5d   %pS\\n\", i, stack_trace_index[i],\n\t\t\t\tsize, (void *)stack_dump_trace[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_stack_end_corrupted",
          "args": [
            "current"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&stack_trace_index[0]",
            "&stack_trace_index[1]",
            "sizeof(stack_trace_index[0]) * (x - 1)"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tracer_frame"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE_NOCHECK",
          "args": [
            "*p"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack_trace_save",
          "args": [
            "stack_dump_trace",
            "ARRAY_SIZE(stack_dump_trace) - 1",
            "0"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "stack_trace_save_tsk_reliable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stacktrace.c",
          "lines": "343-353",
          "snippet": "int stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,\n\t\t\t\t  unsigned int size)\n{\n\tstruct stack_trace trace = {\n\t\t.entries\t= store,\n\t\t.max_entries\t= size,\n\t};\n\tint ret = save_stack_trace_tsk_reliable(tsk, &trace);\n\n\treturn ret ? ret : trace.nr_entries;\n}",
          "includes": [
            "#include <linux/interrupt.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interrupt.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task_stack.h>\n\nint stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,\n\t\t\t\t  unsigned int size)\n{\n\tstruct stack_trace trace = {\n\t\t.entries\t= store,\n\t\t.max_entries\t= size,\n\t};\n\tint ret = save_stack_trace_tsk_reliable(tsk, &trace);\n\n\treturn ret ? ret : trace.nr_entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "stack_dump_trace"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!frame_size"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&stack_trace_max_lock"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_is_on_stack",
          "args": [
            "stack"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "tracer_frame"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_dump_trace[STACK_TRACE_ENTRIES];\nstatic unsigned stack_trace_index[STACK_TRACE_ENTRIES];\nstatic unsigned int stack_trace_nr_entries;\nstatic unsigned long stack_trace_max_size;\nstatic arch_spinlock_t stack_trace_max_lock =\n\t(arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic void check_stack(unsigned long ip, unsigned long *stack)\n{\n\tunsigned long this_size, flags; unsigned long *p, *top, *start;\n\tstatic int tracer_frame;\n\tint frame_size = READ_ONCE(tracer_frame);\n\tint i, x;\n\n\tthis_size = ((unsigned long)stack) & (THREAD_SIZE-1);\n\tthis_size = THREAD_SIZE - this_size;\n\t/* Remove the frame of the tracer */\n\tthis_size -= frame_size;\n\n\tif (this_size <= stack_trace_max_size)\n\t\treturn;\n\n\t/* we do not handle interrupt stacks yet */\n\tif (!object_is_on_stack(stack))\n\t\treturn;\n\n\t/* Can't do this from NMI context (can cause deadlocks) */\n\tif (in_nmi())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&stack_trace_max_lock);\n\n\t/* In case another CPU set the tracer_frame on us */\n\tif (unlikely(!frame_size))\n\t\tthis_size -= tracer_frame;\n\n\t/* a race could have already updated it */\n\tif (this_size <= stack_trace_max_size)\n\t\tgoto out;\n\n\tstack_trace_max_size = this_size;\n\n\tstack_trace_nr_entries = stack_trace_save(stack_dump_trace,\n\t\t\t\t\t       ARRAY_SIZE(stack_dump_trace) - 1,\n\t\t\t\t\t       0);\n\n\t/* Skip over the overhead of the stack tracer itself */\n\tfor (i = 0; i < stack_trace_nr_entries; i++) {\n\t\tif (stack_dump_trace[i] == ip)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Some archs may not have the passed in ip in the dump.\n\t * If that happens, we need to show everything.\n\t */\n\tif (i == stack_trace_nr_entries)\n\t\ti = 0;\n\n\t/*\n\t * Now find where in the stack these are.\n\t */\n\tx = 0;\n\tstart = stack;\n\ttop = (unsigned long *)\n\t\t(((unsigned long)start & ~(THREAD_SIZE-1)) + THREAD_SIZE);\n\n\t/*\n\t * Loop through all the entries. One of the entries may\n\t * for some reason be missed on the stack, so we may\n\t * have to account for them. If they are all there, this\n\t * loop will only happen once. This code only takes place\n\t * on a new max, so it is far from a fast path.\n\t */\n\twhile (i < stack_trace_nr_entries) {\n\t\tint found = 0;\n\n\t\tstack_trace_index[x] = this_size;\n\t\tp = start;\n\n\t\tfor (; p < top && i < stack_trace_nr_entries; p++) {\n\t\t\t/*\n\t\t\t * The READ_ONCE_NOCHECK is used to let KASAN know that\n\t\t\t * this is not a stack-out-of-bounds error.\n\t\t\t */\n\t\t\tif ((READ_ONCE_NOCHECK(*p)) == stack_dump_trace[i]) {\n\t\t\t\tstack_dump_trace[x] = stack_dump_trace[i++];\n\t\t\t\tthis_size = stack_trace_index[x++] =\n\t\t\t\t\t(top - p) * sizeof(unsigned long);\n\t\t\t\tfound = 1;\n\t\t\t\t/* Start the search from here */\n\t\t\t\tstart = p + 1;\n\t\t\t\t/*\n\t\t\t\t * We do not want to show the overhead\n\t\t\t\t * of the stack tracer stack in the\n\t\t\t\t * max stack. If we haven't figured\n\t\t\t\t * out what that is, then figure it out\n\t\t\t\t * now.\n\t\t\t\t */\n\t\t\t\tif (unlikely(!tracer_frame)) {\n\t\t\t\t\ttracer_frame = (p - stack) *\n\t\t\t\t\t\tsizeof(unsigned long);\n\t\t\t\t\tstack_trace_max_size -= tracer_frame;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\ti++;\n\t}\n\n#ifdef ARCH_FTRACE_SHIFT_STACK_TRACER\n\t/*\n\t * Some archs will store the link register before calling\n\t * nested functions. This means the saved return address\n\t * comes after the local storage, and we need to shift\n\t * for that.\n\t */\n\tif (x > 1) {\n\t\tmemmove(&stack_trace_index[0], &stack_trace_index[1],\n\t\t\tsizeof(stack_trace_index[0]) * (x - 1));\n\t\tx--;\n\t}\n#endif\n\n\tstack_trace_nr_entries = x;\n\n\tif (task_stack_end_corrupted(current)) {\n\t\tprint_max_stack();\n\t\tBUG();\n\t}\n\n out:\n\tarch_spin_unlock(&stack_trace_max_lock);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "print_max_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_stack.c",
    "lines": "37-55",
    "snippet": "static void print_max_stack(void)\n{\n\tlong i;\n\tint size;\n\n\tpr_emerg(\"        Depth    Size   Location    (%d entries)\\n\"\n\t\t\t   \"        -----    ----   --------\\n\",\n\t\t\t   stack_trace_nr_entries);\n\n\tfor (i = 0; i < stack_trace_nr_entries; i++) {\n\t\tif (i + 1 == stack_trace_nr_entries)\n\t\t\tsize = stack_trace_index[i];\n\t\telse\n\t\t\tsize = stack_trace_index[i] - stack_trace_index[i+1];\n\n\t\tpr_emerg(\"%3ld) %8d   %5d   %pS\\n\", i, stack_trace_index[i],\n\t\t\t\tsize, (void *)stack_dump_trace[i]);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <asm/setup.h>",
      "#include <linux/init.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/security.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/sched/task_stack.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long stack_dump_trace[STACK_TRACE_ENTRIES];",
      "static unsigned stack_trace_index[STACK_TRACE_ENTRIES];",
      "static unsigned int stack_trace_nr_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"%3ld) %8d   %5d   %pS\\n\"",
            "i",
            "stack_trace_index[i]",
            "size",
            "(void *)stack_dump_trace[i]"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"        Depth    Size   Location    (%d entries)\\n\"\n\t\t\t   \"        -----    ----   --------\\n\"",
            "stack_trace_nr_entries"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <asm/setup.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task_stack.h>\n\nstatic unsigned long stack_dump_trace[STACK_TRACE_ENTRIES];\nstatic unsigned stack_trace_index[STACK_TRACE_ENTRIES];\nstatic unsigned int stack_trace_nr_entries;\n\nstatic void print_max_stack(void)\n{\n\tlong i;\n\tint size;\n\n\tpr_emerg(\"        Depth    Size   Location    (%d entries)\\n\"\n\t\t\t   \"        -----    ----   --------\\n\",\n\t\t\t   stack_trace_nr_entries);\n\n\tfor (i = 0; i < stack_trace_nr_entries; i++) {\n\t\tif (i + 1 == stack_trace_nr_entries)\n\t\t\tsize = stack_trace_index[i];\n\t\telse\n\t\t\tsize = stack_trace_index[i] - stack_trace_index[i+1];\n\n\t\tpr_emerg(\"%3ld) %8d   %5d   %pS\\n\", i, stack_trace_index[i],\n\t\t\t\tsize, (void *)stack_dump_trace[i]);\n\t}\n}"
  }
]