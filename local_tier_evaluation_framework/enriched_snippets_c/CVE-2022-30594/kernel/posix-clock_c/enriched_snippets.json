[
  {
    "function_name": "pc_clock_settime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
    "lines": "288-310",
    "snippet": "static int pc_clock_settime(clockid_t id, const struct timespec64 *ts)\n{\n\tstruct posix_clock_desc cd;\n\tint err;\n\n\terr = get_clock_desc(id, &cd);\n\tif (err)\n\t\treturn err;\n\n\tif ((cd.fp->f_mode & FMODE_WRITE) == 0) {\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (cd.clk->ops.clock_settime)\n\t\terr = cd.clk->ops.clock_settime(cd.clk, ts);\n\telse\n\t\terr = -EOPNOTSUPP;\nout:\n\tput_clock_desc(&cd);\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/file.h>",
      "#include <linux/export.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_clock_desc",
          "args": [
            "&cd"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "put_clock_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "220-224",
          "snippet": "static void put_clock_desc(struct posix_clock_desc *cd)\n{\n\tput_posix_clock(cd->clk);\n\tfput(cd->fp);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic void put_clock_desc(struct posix_clock_desc *cd)\n{\n\tput_posix_clock(cd->clk);\n\tfput(cd->fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd.clk->ops.clock_settime",
          "args": [
            "cd.clk",
            "ts"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_clock_desc",
          "args": [
            "id",
            "&cd"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "get_clock_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "199-218",
          "snippet": "static int get_clock_desc(const clockid_t id, struct posix_clock_desc *cd)\n{\n\tstruct file *fp = fget(clockid_to_fd(id));\n\tint err = -EINVAL;\n\n\tif (!fp)\n\t\treturn err;\n\n\tif (fp->f_op->open != posix_clock_open || !fp->private_data)\n\t\tgoto out;\n\n\tcd->fp = fp;\n\tcd->clk = get_posix_clock(fp);\n\n\terr = cd->clk ? 0 : -ENODEV;\nout:\n\tif (err)\n\t\tfput(fp);\n\treturn err;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic int get_clock_desc(const clockid_t id, struct posix_clock_desc *cd)\n{\n\tstruct file *fp = fget(clockid_to_fd(id));\n\tint err = -EINVAL;\n\n\tif (!fp)\n\t\treturn err;\n\n\tif (fp->f_op->open != posix_clock_open || !fp->private_data)\n\t\tgoto out;\n\n\tcd->fp = fp;\n\tcd->clk = get_posix_clock(fp);\n\n\terr = cd->clk ? 0 : -ENODEV;\nout:\n\tif (err)\n\t\tfput(fp);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic int pc_clock_settime(clockid_t id, const struct timespec64 *ts)\n{\n\tstruct posix_clock_desc cd;\n\tint err;\n\n\terr = get_clock_desc(id, &cd);\n\tif (err)\n\t\treturn err;\n\n\tif ((cd.fp->f_mode & FMODE_WRITE) == 0) {\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (cd.clk->ops.clock_settime)\n\t\terr = cd.clk->ops.clock_settime(cd.clk, ts);\n\telse\n\t\terr = -EOPNOTSUPP;\nout:\n\tput_clock_desc(&cd);\n\n\treturn err;\n}"
  },
  {
    "function_name": "pc_clock_getres",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
    "lines": "269-286",
    "snippet": "static int pc_clock_getres(clockid_t id, struct timespec64 *ts)\n{\n\tstruct posix_clock_desc cd;\n\tint err;\n\n\terr = get_clock_desc(id, &cd);\n\tif (err)\n\t\treturn err;\n\n\tif (cd.clk->ops.clock_getres)\n\t\terr = cd.clk->ops.clock_getres(cd.clk, ts);\n\telse\n\t\terr = -EOPNOTSUPP;\n\n\tput_clock_desc(&cd);\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/file.h>",
      "#include <linux/export.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_clock_desc",
          "args": [
            "&cd"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "put_clock_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "220-224",
          "snippet": "static void put_clock_desc(struct posix_clock_desc *cd)\n{\n\tput_posix_clock(cd->clk);\n\tfput(cd->fp);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic void put_clock_desc(struct posix_clock_desc *cd)\n{\n\tput_posix_clock(cd->clk);\n\tfput(cd->fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd.clk->ops.clock_getres",
          "args": [
            "cd.clk",
            "ts"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_clock_desc",
          "args": [
            "id",
            "&cd"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "get_clock_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "199-218",
          "snippet": "static int get_clock_desc(const clockid_t id, struct posix_clock_desc *cd)\n{\n\tstruct file *fp = fget(clockid_to_fd(id));\n\tint err = -EINVAL;\n\n\tif (!fp)\n\t\treturn err;\n\n\tif (fp->f_op->open != posix_clock_open || !fp->private_data)\n\t\tgoto out;\n\n\tcd->fp = fp;\n\tcd->clk = get_posix_clock(fp);\n\n\terr = cd->clk ? 0 : -ENODEV;\nout:\n\tif (err)\n\t\tfput(fp);\n\treturn err;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic int get_clock_desc(const clockid_t id, struct posix_clock_desc *cd)\n{\n\tstruct file *fp = fget(clockid_to_fd(id));\n\tint err = -EINVAL;\n\n\tif (!fp)\n\t\treturn err;\n\n\tif (fp->f_op->open != posix_clock_open || !fp->private_data)\n\t\tgoto out;\n\n\tcd->fp = fp;\n\tcd->clk = get_posix_clock(fp);\n\n\terr = cd->clk ? 0 : -ENODEV;\nout:\n\tif (err)\n\t\tfput(fp);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic int pc_clock_getres(clockid_t id, struct timespec64 *ts)\n{\n\tstruct posix_clock_desc cd;\n\tint err;\n\n\terr = get_clock_desc(id, &cd);\n\tif (err)\n\t\treturn err;\n\n\tif (cd.clk->ops.clock_getres)\n\t\terr = cd.clk->ops.clock_getres(cd.clk, ts);\n\telse\n\t\terr = -EOPNOTSUPP;\n\n\tput_clock_desc(&cd);\n\n\treturn err;\n}"
  },
  {
    "function_name": "pc_clock_gettime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
    "lines": "250-267",
    "snippet": "static int pc_clock_gettime(clockid_t id, struct timespec64 *ts)\n{\n\tstruct posix_clock_desc cd;\n\tint err;\n\n\terr = get_clock_desc(id, &cd);\n\tif (err)\n\t\treturn err;\n\n\tif (cd.clk->ops.clock_gettime)\n\t\terr = cd.clk->ops.clock_gettime(cd.clk, ts);\n\telse\n\t\terr = -EOPNOTSUPP;\n\n\tput_clock_desc(&cd);\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/file.h>",
      "#include <linux/export.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_clock_desc",
          "args": [
            "&cd"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "put_clock_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "220-224",
          "snippet": "static void put_clock_desc(struct posix_clock_desc *cd)\n{\n\tput_posix_clock(cd->clk);\n\tfput(cd->fp);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic void put_clock_desc(struct posix_clock_desc *cd)\n{\n\tput_posix_clock(cd->clk);\n\tfput(cd->fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd.clk->ops.clock_gettime",
          "args": [
            "cd.clk",
            "ts"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_clock_desc",
          "args": [
            "id",
            "&cd"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "get_clock_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "199-218",
          "snippet": "static int get_clock_desc(const clockid_t id, struct posix_clock_desc *cd)\n{\n\tstruct file *fp = fget(clockid_to_fd(id));\n\tint err = -EINVAL;\n\n\tif (!fp)\n\t\treturn err;\n\n\tif (fp->f_op->open != posix_clock_open || !fp->private_data)\n\t\tgoto out;\n\n\tcd->fp = fp;\n\tcd->clk = get_posix_clock(fp);\n\n\terr = cd->clk ? 0 : -ENODEV;\nout:\n\tif (err)\n\t\tfput(fp);\n\treturn err;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic int get_clock_desc(const clockid_t id, struct posix_clock_desc *cd)\n{\n\tstruct file *fp = fget(clockid_to_fd(id));\n\tint err = -EINVAL;\n\n\tif (!fp)\n\t\treturn err;\n\n\tif (fp->f_op->open != posix_clock_open || !fp->private_data)\n\t\tgoto out;\n\n\tcd->fp = fp;\n\tcd->clk = get_posix_clock(fp);\n\n\terr = cd->clk ? 0 : -ENODEV;\nout:\n\tif (err)\n\t\tfput(fp);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic int pc_clock_gettime(clockid_t id, struct timespec64 *ts)\n{\n\tstruct posix_clock_desc cd;\n\tint err;\n\n\terr = get_clock_desc(id, &cd);\n\tif (err)\n\t\treturn err;\n\n\tif (cd.clk->ops.clock_gettime)\n\t\terr = cd.clk->ops.clock_gettime(cd.clk, ts);\n\telse\n\t\terr = -EOPNOTSUPP;\n\n\tput_clock_desc(&cd);\n\n\treturn err;\n}"
  },
  {
    "function_name": "pc_clock_adjtime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
    "lines": "226-248",
    "snippet": "static int pc_clock_adjtime(clockid_t id, struct __kernel_timex *tx)\n{\n\tstruct posix_clock_desc cd;\n\tint err;\n\n\terr = get_clock_desc(id, &cd);\n\tif (err)\n\t\treturn err;\n\n\tif ((cd.fp->f_mode & FMODE_WRITE) == 0) {\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (cd.clk->ops.clock_adjtime)\n\t\terr = cd.clk->ops.clock_adjtime(cd.clk, tx);\n\telse\n\t\terr = -EOPNOTSUPP;\nout:\n\tput_clock_desc(&cd);\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/file.h>",
      "#include <linux/export.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_clock_desc",
          "args": [
            "&cd"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "put_clock_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "220-224",
          "snippet": "static void put_clock_desc(struct posix_clock_desc *cd)\n{\n\tput_posix_clock(cd->clk);\n\tfput(cd->fp);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic void put_clock_desc(struct posix_clock_desc *cd)\n{\n\tput_posix_clock(cd->clk);\n\tfput(cd->fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd.clk->ops.clock_adjtime",
          "args": [
            "cd.clk",
            "tx"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_clock_desc",
          "args": [
            "id",
            "&cd"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "get_clock_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "199-218",
          "snippet": "static int get_clock_desc(const clockid_t id, struct posix_clock_desc *cd)\n{\n\tstruct file *fp = fget(clockid_to_fd(id));\n\tint err = -EINVAL;\n\n\tif (!fp)\n\t\treturn err;\n\n\tif (fp->f_op->open != posix_clock_open || !fp->private_data)\n\t\tgoto out;\n\n\tcd->fp = fp;\n\tcd->clk = get_posix_clock(fp);\n\n\terr = cd->clk ? 0 : -ENODEV;\nout:\n\tif (err)\n\t\tfput(fp);\n\treturn err;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic int get_clock_desc(const clockid_t id, struct posix_clock_desc *cd)\n{\n\tstruct file *fp = fget(clockid_to_fd(id));\n\tint err = -EINVAL;\n\n\tif (!fp)\n\t\treturn err;\n\n\tif (fp->f_op->open != posix_clock_open || !fp->private_data)\n\t\tgoto out;\n\n\tcd->fp = fp;\n\tcd->clk = get_posix_clock(fp);\n\n\terr = cd->clk ? 0 : -ENODEV;\nout:\n\tif (err)\n\t\tfput(fp);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic int pc_clock_adjtime(clockid_t id, struct __kernel_timex *tx)\n{\n\tstruct posix_clock_desc cd;\n\tint err;\n\n\terr = get_clock_desc(id, &cd);\n\tif (err)\n\t\treturn err;\n\n\tif ((cd.fp->f_mode & FMODE_WRITE) == 0) {\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (cd.clk->ops.clock_adjtime)\n\t\terr = cd.clk->ops.clock_adjtime(cd.clk, tx);\n\telse\n\t\terr = -EOPNOTSUPP;\nout:\n\tput_clock_desc(&cd);\n\n\treturn err;\n}"
  },
  {
    "function_name": "put_clock_desc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
    "lines": "220-224",
    "snippet": "static void put_clock_desc(struct posix_clock_desc *cd)\n{\n\tput_posix_clock(cd->clk);\n\tfput(cd->fp);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/file.h>",
      "#include <linux/export.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "cd->fp"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_posix_clock",
          "args": [
            "cd->clk"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "put_posix_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "34-37",
          "snippet": "static void put_posix_clock(struct posix_clock *clk)\n{\n\tup_read(&clk->rwsem);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic void put_posix_clock(struct posix_clock *clk)\n{\n\tup_read(&clk->rwsem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic void put_clock_desc(struct posix_clock_desc *cd)\n{\n\tput_posix_clock(cd->clk);\n\tfput(cd->fp);\n}"
  },
  {
    "function_name": "get_clock_desc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
    "lines": "199-218",
    "snippet": "static int get_clock_desc(const clockid_t id, struct posix_clock_desc *cd)\n{\n\tstruct file *fp = fget(clockid_to_fd(id));\n\tint err = -EINVAL;\n\n\tif (!fp)\n\t\treturn err;\n\n\tif (fp->f_op->open != posix_clock_open || !fp->private_data)\n\t\tgoto out;\n\n\tcd->fp = fp;\n\tcd->clk = get_posix_clock(fp);\n\n\terr = cd->clk ? 0 : -ENODEV;\nout:\n\tif (err)\n\t\tfput(fp);\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/file.h>",
      "#include <linux/export.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "fp"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_posix_clock",
          "args": [
            "fp"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "get_posix_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "20-32",
          "snippet": "static struct posix_clock *get_posix_clock(struct file *fp)\n{\n\tstruct posix_clock *clk = fp->private_data;\n\n\tdown_read(&clk->rwsem);\n\n\tif (!clk->zombie)\n\t\treturn clk;\n\n\tup_read(&clk->rwsem);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic struct posix_clock *get_posix_clock(struct file *fp)\n{\n\tstruct posix_clock *clk = fp->private_data;\n\n\tdown_read(&clk->rwsem);\n\n\tif (!clk->zombie)\n\t\treturn clk;\n\n\tup_read(&clk->rwsem);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fget",
          "args": [
            "clockid_to_fd(id)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockid_to_fd",
          "args": [
            "id"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic int get_clock_desc(const clockid_t id, struct posix_clock_desc *cd)\n{\n\tstruct file *fp = fget(clockid_to_fd(id));\n\tint err = -EINVAL;\n\n\tif (!fp)\n\t\treturn err;\n\n\tif (fp->f_op->open != posix_clock_open || !fp->private_data)\n\t\tgoto out;\n\n\tcd->fp = fp;\n\tcd->clk = get_posix_clock(fp);\n\n\terr = cd->clk ? 0 : -ENODEV;\nout:\n\tif (err)\n\t\tfput(fp);\n\treturn err;\n}"
  },
  {
    "function_name": "posix_clock_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
    "lines": "182-191",
    "snippet": "void posix_clock_unregister(struct posix_clock *clk)\n{\n\tcdev_device_del(&clk->cdev, clk->dev);\n\n\tdown_write(&clk->rwsem);\n\tclk->zombie = true;\n\tup_write(&clk->rwsem);\n\n\tput_device(clk->dev);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/file.h>",
      "#include <linux/export.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_device",
          "args": [
            "clk->dev"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&clk->rwsem"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&clk->rwsem"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cdev_device_del",
          "args": [
            "&clk->cdev",
            "clk->dev"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nvoid posix_clock_unregister(struct posix_clock *clk)\n{\n\tcdev_device_del(&clk->cdev, clk->dev);\n\n\tdown_write(&clk->rwsem);\n\tclk->zombie = true;\n\tup_write(&clk->rwsem);\n\n\tput_device(clk->dev);\n}"
  },
  {
    "function_name": "posix_clock_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
    "lines": "162-179",
    "snippet": "int posix_clock_register(struct posix_clock *clk, struct device *dev)\n{\n\tint err;\n\n\tinit_rwsem(&clk->rwsem);\n\n\tcdev_init(&clk->cdev, &posix_clock_file_operations);\n\terr = cdev_device_add(&clk->cdev, dev);\n\tif (err) {\n\t\tpr_err(\"%s unable to add device %d:%d\\n\",\n\t\t\tdev_name(dev), MAJOR(dev->devt), MINOR(dev->devt));\n\t\treturn err;\n\t}\n\tclk->cdev.owner = clk->ops.owner;\n\tclk->dev = dev;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/file.h>",
      "#include <linux/export.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations posix_clock_file_operations = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= posix_clock_read,\n\t.poll\t\t= posix_clock_poll,\n\t.unlocked_ioctl\t= posix_clock_ioctl,\n\t.open\t\t= posix_clock_open,\n\t.release\t= posix_clock_release,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= posix_clock_compat_ioctl,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s unable to add device %d:%d\\n\"",
            "dev_name(dev)",
            "MAJOR(dev->devt)",
            "MINOR(dev->devt)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "dev->devt"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "dev->devt"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cdev_device_add",
          "args": [
            "&clk->cdev",
            "dev"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cdev_init",
          "args": [
            "&clk->cdev",
            "&posix_clock_file_operations"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&clk->rwsem"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic const struct file_operations posix_clock_file_operations = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= posix_clock_read,\n\t.poll\t\t= posix_clock_poll,\n\t.unlocked_ioctl\t= posix_clock_ioctl,\n\t.open\t\t= posix_clock_open,\n\t.release\t= posix_clock_release,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= posix_clock_compat_ioctl,\n#endif\n};\n\nint posix_clock_register(struct posix_clock *clk, struct device *dev)\n{\n\tint err;\n\n\tinit_rwsem(&clk->rwsem);\n\n\tcdev_init(&clk->cdev, &posix_clock_file_operations);\n\terr = cdev_device_add(&clk->cdev, dev);\n\tif (err) {\n\t\tpr_err(\"%s unable to add device %d:%d\\n\",\n\t\t\tdev_name(dev), MAJOR(dev->devt), MINOR(dev->devt));\n\t\treturn err;\n\t}\n\tclk->cdev.owner = clk->ops.owner;\n\tclk->dev = dev;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "posix_clock_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
    "lines": "134-147",
    "snippet": "static int posix_clock_release(struct inode *inode, struct file *fp)\n{\n\tstruct posix_clock *clk = fp->private_data;\n\tint err = 0;\n\n\tif (clk->ops.release)\n\t\terr = clk->ops.release(clk);\n\n\tput_device(clk->dev);\n\n\tfp->private_data = NULL;\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/file.h>",
      "#include <linux/export.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_device",
          "args": [
            "clk->dev"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clk->ops.release",
          "args": [
            "clk"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic int posix_clock_release(struct inode *inode, struct file *fp)\n{\n\tstruct posix_clock *clk = fp->private_data;\n\tint err = 0;\n\n\tif (clk->ops.release)\n\t\terr = clk->ops.release(clk);\n\n\tput_device(clk->dev);\n\n\tfp->private_data = NULL;\n\n\treturn err;\n}"
  },
  {
    "function_name": "posix_clock_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
    "lines": "108-132",
    "snippet": "static int posix_clock_open(struct inode *inode, struct file *fp)\n{\n\tint err;\n\tstruct posix_clock *clk =\n\t\tcontainer_of(inode->i_cdev, struct posix_clock, cdev);\n\n\tdown_read(&clk->rwsem);\n\n\tif (clk->zombie) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tif (clk->ops.open)\n\t\terr = clk->ops.open(clk, fp->f_mode);\n\telse\n\t\terr = 0;\n\n\tif (!err) {\n\t\tget_device(clk->dev);\n\t\tfp->private_data = clk;\n\t}\nout:\n\tup_read(&clk->rwsem);\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/file.h>",
      "#include <linux/export.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&clk->rwsem"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_device",
          "args": [
            "clk->dev"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "63-66",
          "snippet": "struct tick_device *tick_get_device(int cpu)\n{\n\treturn &per_cpu(tick_cpu_device, cpu);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstruct tick_device *tick_get_device(int cpu)\n{\n\treturn &per_cpu(tick_cpu_device, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clk->ops.open",
          "args": [
            "clk",
            "fp->f_mode"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&clk->rwsem"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "inode->i_cdev",
            "structposix_clock",
            "cdev"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic int posix_clock_open(struct inode *inode, struct file *fp)\n{\n\tint err;\n\tstruct posix_clock *clk =\n\t\tcontainer_of(inode->i_cdev, struct posix_clock, cdev);\n\n\tdown_read(&clk->rwsem);\n\n\tif (clk->zombie) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tif (clk->ops.open)\n\t\terr = clk->ops.open(clk, fp->f_mode);\n\telse\n\t\terr = 0;\n\n\tif (!err) {\n\t\tget_device(clk->dev);\n\t\tfp->private_data = clk;\n\t}\nout:\n\tup_read(&clk->rwsem);\n\treturn err;\n}"
  },
  {
    "function_name": "posix_clock_compat_ioctl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
    "lines": "90-105",
    "snippet": "static long posix_clock_compat_ioctl(struct file *fp,\n\t\t\t\t     unsigned int cmd, unsigned long arg)\n{\n\tstruct posix_clock *clk = get_posix_clock(fp);\n\tint err = -ENOTTY;\n\n\tif (!clk)\n\t\treturn -ENODEV;\n\n\tif (clk->ops.ioctl)\n\t\terr = clk->ops.ioctl(clk, cmd, arg);\n\n\tput_posix_clock(clk);\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/file.h>",
      "#include <linux/export.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_posix_clock",
          "args": [
            "clk"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "put_posix_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "34-37",
          "snippet": "static void put_posix_clock(struct posix_clock *clk)\n{\n\tup_read(&clk->rwsem);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic void put_posix_clock(struct posix_clock *clk)\n{\n\tup_read(&clk->rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clk->ops.ioctl",
          "args": [
            "clk",
            "cmd",
            "arg"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_posix_clock",
          "args": [
            "fp"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "get_posix_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "20-32",
          "snippet": "static struct posix_clock *get_posix_clock(struct file *fp)\n{\n\tstruct posix_clock *clk = fp->private_data;\n\n\tdown_read(&clk->rwsem);\n\n\tif (!clk->zombie)\n\t\treturn clk;\n\n\tup_read(&clk->rwsem);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic struct posix_clock *get_posix_clock(struct file *fp)\n{\n\tstruct posix_clock *clk = fp->private_data;\n\n\tdown_read(&clk->rwsem);\n\n\tif (!clk->zombie)\n\t\treturn clk;\n\n\tup_read(&clk->rwsem);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic long posix_clock_compat_ioctl(struct file *fp,\n\t\t\t\t     unsigned int cmd, unsigned long arg)\n{\n\tstruct posix_clock *clk = get_posix_clock(fp);\n\tint err = -ENOTTY;\n\n\tif (!clk)\n\t\treturn -ENODEV;\n\n\tif (clk->ops.ioctl)\n\t\terr = clk->ops.ioctl(clk, cmd, arg);\n\n\tput_posix_clock(clk);\n\n\treturn err;\n}"
  },
  {
    "function_name": "posix_clock_ioctl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
    "lines": "72-87",
    "snippet": "static long posix_clock_ioctl(struct file *fp,\n\t\t\t      unsigned int cmd, unsigned long arg)\n{\n\tstruct posix_clock *clk = get_posix_clock(fp);\n\tint err = -ENOTTY;\n\n\tif (!clk)\n\t\treturn -ENODEV;\n\n\tif (clk->ops.ioctl)\n\t\terr = clk->ops.ioctl(clk, cmd, arg);\n\n\tput_posix_clock(clk);\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/file.h>",
      "#include <linux/export.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_posix_clock",
          "args": [
            "clk"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "put_posix_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "34-37",
          "snippet": "static void put_posix_clock(struct posix_clock *clk)\n{\n\tup_read(&clk->rwsem);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic void put_posix_clock(struct posix_clock *clk)\n{\n\tup_read(&clk->rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clk->ops.ioctl",
          "args": [
            "clk",
            "cmd",
            "arg"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_posix_clock",
          "args": [
            "fp"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "get_posix_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "20-32",
          "snippet": "static struct posix_clock *get_posix_clock(struct file *fp)\n{\n\tstruct posix_clock *clk = fp->private_data;\n\n\tdown_read(&clk->rwsem);\n\n\tif (!clk->zombie)\n\t\treturn clk;\n\n\tup_read(&clk->rwsem);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic struct posix_clock *get_posix_clock(struct file *fp)\n{\n\tstruct posix_clock *clk = fp->private_data;\n\n\tdown_read(&clk->rwsem);\n\n\tif (!clk->zombie)\n\t\treturn clk;\n\n\tup_read(&clk->rwsem);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic long posix_clock_ioctl(struct file *fp,\n\t\t\t      unsigned int cmd, unsigned long arg)\n{\n\tstruct posix_clock *clk = get_posix_clock(fp);\n\tint err = -ENOTTY;\n\n\tif (!clk)\n\t\treturn -ENODEV;\n\n\tif (clk->ops.ioctl)\n\t\terr = clk->ops.ioctl(clk, cmd, arg);\n\n\tput_posix_clock(clk);\n\n\treturn err;\n}"
  },
  {
    "function_name": "posix_clock_poll",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
    "lines": "56-70",
    "snippet": "static __poll_t posix_clock_poll(struct file *fp, poll_table *wait)\n{\n\tstruct posix_clock *clk = get_posix_clock(fp);\n\t__poll_t result = 0;\n\n\tif (!clk)\n\t\treturn EPOLLERR;\n\n\tif (clk->ops.poll)\n\t\tresult = clk->ops.poll(clk, fp, wait);\n\n\tput_posix_clock(clk);\n\n\treturn result;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/file.h>",
      "#include <linux/export.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_posix_clock",
          "args": [
            "clk"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "put_posix_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "34-37",
          "snippet": "static void put_posix_clock(struct posix_clock *clk)\n{\n\tup_read(&clk->rwsem);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic void put_posix_clock(struct posix_clock *clk)\n{\n\tup_read(&clk->rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clk->ops.poll",
          "args": [
            "clk",
            "fp",
            "wait"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_posix_clock",
          "args": [
            "fp"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "get_posix_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "20-32",
          "snippet": "static struct posix_clock *get_posix_clock(struct file *fp)\n{\n\tstruct posix_clock *clk = fp->private_data;\n\n\tdown_read(&clk->rwsem);\n\n\tif (!clk->zombie)\n\t\treturn clk;\n\n\tup_read(&clk->rwsem);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic struct posix_clock *get_posix_clock(struct file *fp)\n{\n\tstruct posix_clock *clk = fp->private_data;\n\n\tdown_read(&clk->rwsem);\n\n\tif (!clk->zombie)\n\t\treturn clk;\n\n\tup_read(&clk->rwsem);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic __poll_t posix_clock_poll(struct file *fp, poll_table *wait)\n{\n\tstruct posix_clock *clk = get_posix_clock(fp);\n\t__poll_t result = 0;\n\n\tif (!clk)\n\t\treturn EPOLLERR;\n\n\tif (clk->ops.poll)\n\t\tresult = clk->ops.poll(clk, fp, wait);\n\n\tput_posix_clock(clk);\n\n\treturn result;\n}"
  },
  {
    "function_name": "posix_clock_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
    "lines": "39-54",
    "snippet": "static ssize_t posix_clock_read(struct file *fp, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct posix_clock *clk = get_posix_clock(fp);\n\tint err = -EINVAL;\n\n\tif (!clk)\n\t\treturn -ENODEV;\n\n\tif (clk->ops.read)\n\t\terr = clk->ops.read(clk, fp->f_flags, buf, count);\n\n\tput_posix_clock(clk);\n\n\treturn err;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/file.h>",
      "#include <linux/export.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_posix_clock",
          "args": [
            "clk"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "put_posix_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "34-37",
          "snippet": "static void put_posix_clock(struct posix_clock *clk)\n{\n\tup_read(&clk->rwsem);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic void put_posix_clock(struct posix_clock *clk)\n{\n\tup_read(&clk->rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clk->ops.read",
          "args": [
            "clk",
            "fp->f_flags",
            "buf",
            "count"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_posix_clock",
          "args": [
            "fp"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "get_posix_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
          "lines": "20-32",
          "snippet": "static struct posix_clock *get_posix_clock(struct file *fp)\n{\n\tstruct posix_clock *clk = fp->private_data;\n\n\tdown_read(&clk->rwsem);\n\n\tif (!clk->zombie)\n\t\treturn clk;\n\n\tup_read(&clk->rwsem);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/file.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic struct posix_clock *get_posix_clock(struct file *fp)\n{\n\tstruct posix_clock *clk = fp->private_data;\n\n\tdown_read(&clk->rwsem);\n\n\tif (!clk->zombie)\n\t\treturn clk;\n\n\tup_read(&clk->rwsem);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic ssize_t posix_clock_read(struct file *fp, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct posix_clock *clk = get_posix_clock(fp);\n\tint err = -EINVAL;\n\n\tif (!clk)\n\t\treturn -ENODEV;\n\n\tif (clk->ops.read)\n\t\terr = clk->ops.read(clk, fp->f_flags, buf, count);\n\n\tput_posix_clock(clk);\n\n\treturn err;\n}"
  },
  {
    "function_name": "put_posix_clock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
    "lines": "34-37",
    "snippet": "static void put_posix_clock(struct posix_clock *clk)\n{\n\tup_read(&clk->rwsem);\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/file.h>",
      "#include <linux/export.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&clk->rwsem"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic void put_posix_clock(struct posix_clock *clk)\n{\n\tup_read(&clk->rwsem);\n}"
  },
  {
    "function_name": "get_posix_clock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-clock.c",
    "lines": "20-32",
    "snippet": "static struct posix_clock *get_posix_clock(struct file *fp)\n{\n\tstruct posix_clock *clk = fp->private_data;\n\n\tdown_read(&clk->rwsem);\n\n\tif (!clk->zombie)\n\t\treturn clk;\n\n\tup_read(&clk->rwsem);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"posix-timers.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/posix-clock.h>",
      "#include <linux/file.h>",
      "#include <linux/export.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&clk->rwsem"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&clk->rwsem"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/posix-clock.h>\n#include <linux/file.h>\n#include <linux/export.h>\n#include <linux/device.h>\n\nstatic struct posix_clock *get_posix_clock(struct file *fp)\n{\n\tstruct posix_clock *clk = fp->private_data;\n\n\tdown_read(&clk->rwsem);\n\n\tif (!clk->zombie)\n\t\treturn clk;\n\n\tup_read(&clk->rwsem);\n\n\treturn NULL;\n}"
  }
]