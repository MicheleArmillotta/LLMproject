[
  {
    "function_name": "init_graph_trace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1350-1365",
    "snippet": "static __init int init_graph_trace(void)\n{\n\tmax_bytes_for_cpu = snprintf(NULL, 0, \"%u\", nr_cpu_ids - 1);\n\n\tif (!register_trace_event(&graph_trace_entry_event)) {\n\t\tpr_warn(\"Warning: could not register graph trace events\\n\");\n\t\treturn 1;\n\t}\n\n\tif (!register_trace_event(&graph_trace_ret_event)) {\n\t\tpr_warn(\"Warning: could not register graph trace events\\n\");\n\t\treturn 1;\n\t}\n\n\treturn register_tracer(&graph_trace);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int max_bytes_for_cpu;",
      "static struct trace_event graph_trace_entry_event = {\n\t.type\t\t= TRACE_GRAPH_ENT,\n\t.funcs\t\t= &graph_functions,\n};",
      "static struct trace_event graph_trace_ret_event = {\n\t.type\t\t= TRACE_GRAPH_RET,\n\t.funcs\t\t= &graph_functions\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_tracer",
          "args": [
            "&graph_trace"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "register_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2037-2120",
          "snippet": "int __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define MAX_TRACER_SIZE\t\t100"
          ],
          "globals_used": [
            "static struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};",
            "static char *default_bootup_tracer;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static struct tracer\t\t*trace_types",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void __init apply_trace_boot_options(void);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define MAX_TRACER_SIZE\t\t100\n\nstatic struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};\nstatic char *default_bootup_tracer;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic struct tracer\t\t*trace_types;\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void __init apply_trace_boot_options(void);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\tdisable_tracing_selftest(\"running a tracer\");\n\n out_unlock:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Warning: could not register graph trace events\\n\""
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_event",
          "args": [
            "&graph_trace_ret_event"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "826-833",
          "snippet": "int unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Warning: could not register graph trace events\\n\""
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "NULL",
            "0",
            "\"%u\"",
            "nr_cpu_ids - 1"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int max_bytes_for_cpu;\nstatic struct trace_event graph_trace_entry_event = {\n\t.type\t\t= TRACE_GRAPH_ENT,\n\t.funcs\t\t= &graph_functions,\n};\nstatic struct trace_event graph_trace_ret_event = {\n\t.type\t\t= TRACE_GRAPH_RET,\n\t.funcs\t\t= &graph_functions\n};\n\nstatic __init int init_graph_trace(void)\n{\n\tmax_bytes_for_cpu = snprintf(NULL, 0, \"%u\", nr_cpu_ids - 1);\n\n\tif (!register_trace_event(&graph_trace_entry_event)) {\n\t\tpr_warn(\"Warning: could not register graph trace events\\n\");\n\t\treturn 1;\n\t}\n\n\tif (!register_trace_event(&graph_trace_ret_event)) {\n\t\tpr_warn(\"Warning: could not register graph trace events\\n\");\n\t\treturn 1;\n\t}\n\n\treturn register_tracer(&graph_trace);\n}"
  },
  {
    "function_name": "init_graph_tracefs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1335-1347",
    "snippet": "static __init int init_graph_tracefs(void)\n{\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn 0;\n\n\ttrace_create_file(\"max_graph_depth\", TRACE_MODE_WRITE, NULL,\n\t\t\t  NULL, &graph_depth_fops);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations graph_depth_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.write\t\t= graph_depth_write,\n\t.read\t\t= graph_depth_read,\n\t.llseek\t\t= generic_file_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"max_graph_depth\"",
            "TRACE_MODE_WRITE",
            "NULL",
            "NULL",
            "&graph_depth_fops"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "8771-8784",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9527-9553",
          "snippet": "int tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nint tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic const struct file_operations graph_depth_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.write\t\t= graph_depth_write,\n\t.read\t\t= graph_depth_read,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic __init int init_graph_tracefs(void)\n{\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn 0;\n\n\ttrace_create_file(\"max_graph_depth\", TRACE_MODE_WRITE, NULL,\n\t\t\t  NULL, &graph_depth_fops);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "graph_depth_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1316-1326",
    "snippet": "static ssize_t\ngraph_depth_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t loff_t *ppos)\n{\n\tchar buf[15]; /* More than enough to hold UINT_MAX + \"\\n\"*/\n\tint n;\n\n\tn = sprintf(buf, \"%d\\n\", fgraph_max_depth);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, n);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int fgraph_max_depth;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "cnt",
            "ppos",
            "buf",
            "n"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "fgraph_max_depth"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nunsigned int fgraph_max_depth;\n\nstatic ssize_t\ngraph_depth_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t loff_t *ppos)\n{\n\tchar buf[15]; /* More than enough to hold UINT_MAX + \"\\n\"*/\n\tint n;\n\n\tn = sprintf(buf, \"%d\\n\", fgraph_max_depth);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, n);\n}"
  },
  {
    "function_name": "graph_depth_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1298-1314",
    "snippet": "static ssize_t\ngraph_depth_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t  loff_t *ppos)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tfgraph_max_depth = val;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int fgraph_max_depth;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul_from_user",
          "args": [
            "ubuf",
            "cnt",
            "10",
            "&val"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nunsigned int fgraph_max_depth;\n\nstatic ssize_t\ngraph_depth_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t  loff_t *ppos)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tfgraph_max_depth = val;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}"
  },
  {
    "function_name": "func_graph_set_flag",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1250-1263",
    "snippet": "static int\nfunc_graph_set_flag(struct trace_array *tr, u32 old_flags, u32 bit, int set)\n{\n\tif (bit == TRACE_GRAPH_PRINT_IRQS)\n\t\tftrace_graph_skip_irqs = !set;\n\n\tif (bit == TRACE_GRAPH_SLEEP_TIME)\n\t\tftrace_graph_sleep_time_control(set);\n\n\tif (bit == TRACE_GRAPH_GRAPH_TIME)\n\t\tftrace_graph_graph_time_control(set);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_graph_skip_irqs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_graph_graph_time_control",
          "args": [
            "set"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_graph_time_control",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "782-785",
          "snippet": "void ftrace_graph_graph_time_control(bool enable)\n{\n\tfgraph_graph_time = enable;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_graph_graph_time_control(bool enable)\n{\n\tfgraph_graph_time = enable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_sleep_time_control",
          "args": [
            "set"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_sleep_time_control",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/fgraph.c",
          "lines": "349-352",
          "snippet": "void ftrace_graph_sleep_time_control(bool enable)\n{\n\tfgraph_sleep_time = enable;\n}",
          "includes": [
            "#include \"ftrace_internal.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool fgraph_sleep_time = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ftrace_internal.h\"\n#include <trace/events/sched.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n\nstatic bool fgraph_sleep_time = true;\n\nvoid ftrace_graph_sleep_time_control(bool enable)\n{\n\tfgraph_sleep_time = enable;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int ftrace_graph_skip_irqs;\n\nstatic int\nfunc_graph_set_flag(struct trace_array *tr, u32 old_flags, u32 bit, int set)\n{\n\tif (bit == TRACE_GRAPH_PRINT_IRQS)\n\t\tftrace_graph_skip_irqs = !set;\n\n\tif (bit == TRACE_GRAPH_SLEEP_TIME)\n\t\tftrace_graph_sleep_time_control(set);\n\n\tif (bit == TRACE_GRAPH_GRAPH_TIME)\n\t\tftrace_graph_graph_time_control(set);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "graph_trace_close",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1240-1248",
    "snippet": "void graph_trace_close(struct trace_iterator *iter)\n{\n\tstruct fgraph_data *data = iter->private;\n\n\tif (data) {\n\t\tfree_percpu(data->cpu_data);\n\t\tkfree(data);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "data->cpu_data"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid graph_trace_close(struct trace_iterator *iter)\n{\n\tstruct fgraph_data *data = iter->private;\n\n\tif (data) {\n\t\tfree_percpu(data->cpu_data);\n\t\tkfree(data);\n\t}\n}"
  },
  {
    "function_name": "graph_trace_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1198-1238",
    "snippet": "void graph_trace_open(struct trace_iterator *iter)\n{\n\t/* pid and depth on the last trace processed */\n\tstruct fgraph_data *data;\n\tgfp_t gfpflags;\n\tint cpu;\n\n\titer->private = NULL;\n\n\t/* We can be called in atomic context via ftrace_dump() */\n\tgfpflags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tdata = kzalloc(sizeof(*data), gfpflags);\n\tif (!data)\n\t\tgoto out_err;\n\n\tdata->cpu_data = alloc_percpu_gfp(struct fgraph_cpu_data, gfpflags);\n\tif (!data->cpu_data)\n\t\tgoto out_err_free;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpid_t *pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\t\tint *depth = &(per_cpu_ptr(data->cpu_data, cpu)->depth);\n\t\tint *ignore = &(per_cpu_ptr(data->cpu_data, cpu)->ignore);\n\t\tint *depth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t\t*pid = -1;\n\t\t*depth = 0;\n\t\t*ignore = 0;\n\t\t*depth_irq = -1;\n\t}\n\n\titer->private = data;\n\n\treturn;\n\n out_err_free:\n\tkfree(data);\n out_err:\n\tpr_warn(\"function graph tracer: not enough memory\\n\");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"function graph tracer: not enough memory\\n\""
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu_gfp",
          "args": [
            "structfgraph_cpu_data",
            "gfpflags"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "gfpflags"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_atomic",
          "args": [],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid graph_trace_open(struct trace_iterator *iter)\n{\n\t/* pid and depth on the last trace processed */\n\tstruct fgraph_data *data;\n\tgfp_t gfpflags;\n\tint cpu;\n\n\titer->private = NULL;\n\n\t/* We can be called in atomic context via ftrace_dump() */\n\tgfpflags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tdata = kzalloc(sizeof(*data), gfpflags);\n\tif (!data)\n\t\tgoto out_err;\n\n\tdata->cpu_data = alloc_percpu_gfp(struct fgraph_cpu_data, gfpflags);\n\tif (!data->cpu_data)\n\t\tgoto out_err_free;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpid_t *pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\t\tint *depth = &(per_cpu_ptr(data->cpu_data, cpu)->depth);\n\t\tint *ignore = &(per_cpu_ptr(data->cpu_data, cpu)->ignore);\n\t\tint *depth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t\t*pid = -1;\n\t\t*depth = 0;\n\t\t*ignore = 0;\n\t\t*depth_irq = -1;\n\t}\n\n\titer->private = data;\n\n\treturn;\n\n out_err_free:\n\tkfree(data);\n out_err:\n\tpr_warn(\"function graph tracer: not enough memory\\n\");\n}"
  },
  {
    "function_name": "print_graph_headers_flags",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1179-1196",
    "snippet": "void print_graph_headers_flags(struct seq_file *s, u32 flags)\n{\n\tstruct trace_iterator *iter = s->private;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\n\t\tprint_trace_header(s, iter);\n\t}\n\n\t__print_graph_headers_flags(tr, s, flags);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__print_graph_headers_flags",
          "args": [
            "tr",
            "s",
            "flags"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "__print_graph_headers_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1133-1172",
          "snippet": "static void __print_graph_headers_flags(struct trace_array *tr,\n\t\t\t\t\tstruct seq_file *s, u32 flags)\n{\n\tint lat = tr->trace_flags & TRACE_ITER_LATENCY_FMT;\n\n\tif (lat)\n\t\tprint_lat_header(s, flags);\n\n\t/* 1st line */\n\tseq_putc(s, '#');\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tseq_puts(s, \"     TIME       \");\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tseq_puts(s, \"   REL TIME     \");\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tseq_puts(s, \" CPU\");\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tseq_puts(s, \"  TASK/PID       \");\n\tif (lat)\n\t\tseq_puts(s, \"||||   \");\n\tif (flags & TRACE_GRAPH_PRINT_DURATION)\n\t\tseq_puts(s, \"  DURATION   \");\n\tseq_puts(s, \"               FUNCTION CALLS\\n\");\n\n\t/* 2nd line */\n\tseq_putc(s, '#');\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tseq_puts(s, \"      |         \");\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tseq_puts(s, \"      |         \");\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tseq_puts(s, \" |  \");\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tseq_puts(s, \"   |    |        \");\n\tif (lat)\n\t\tseq_puts(s, \"||||   \");\n\tif (flags & TRACE_GRAPH_PRINT_DURATION)\n\t\tseq_puts(s, \"   |   |      \");\n\tseq_puts(s, \"               |   |   |   |\\n\");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void __print_graph_headers_flags(struct trace_array *tr,\n\t\t\t\t\tstruct seq_file *s, u32 flags)\n{\n\tint lat = tr->trace_flags & TRACE_ITER_LATENCY_FMT;\n\n\tif (lat)\n\t\tprint_lat_header(s, flags);\n\n\t/* 1st line */\n\tseq_putc(s, '#');\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tseq_puts(s, \"     TIME       \");\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tseq_puts(s, \"   REL TIME     \");\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tseq_puts(s, \" CPU\");\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tseq_puts(s, \"  TASK/PID       \");\n\tif (lat)\n\t\tseq_puts(s, \"||||   \");\n\tif (flags & TRACE_GRAPH_PRINT_DURATION)\n\t\tseq_puts(s, \"  DURATION   \");\n\tseq_puts(s, \"               FUNCTION CALLS\\n\");\n\n\t/* 2nd line */\n\tseq_putc(s, '#');\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tseq_puts(s, \"      |         \");\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tseq_puts(s, \"      |         \");\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tseq_puts(s, \" |  \");\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tseq_puts(s, \"   |    |        \");\n\tif (lat)\n\t\tseq_puts(s, \"||||   \");\n\tif (flags & TRACE_GRAPH_PRINT_DURATION)\n\t\tseq_puts(s, \"   |   |      \");\n\tseq_puts(s, \"               |   |   |   |\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_trace_header",
          "args": [
            "s",
            "iter"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "print_trace_header",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "4246-4308",
          "snippet": "void\nprint_trace_header(struct seq_file *m, struct trace_iterator *iter)\n{\n\tunsigned long sym_flags = (global_trace.trace_flags & TRACE_ITER_SYM_MASK);\n\tstruct array_buffer *buf = iter->array_buffer;\n\tstruct trace_array_cpu *data = per_cpu_ptr(buf->data, buf->cpu);\n\tstruct tracer *type = iter->trace;\n\tunsigned long entries;\n\tunsigned long total;\n\tconst char *name = \"preemption\";\n\n\tname = type->name;\n\n\tget_total_entries(buf, &total, &entries);\n\n\tseq_printf(m, \"# %s latency trace v1.1.5 on %s\\n\",\n\t\t   name, UTS_RELEASE);\n\tseq_puts(m, \"# -----------------------------------\"\n\t\t \"---------------------------------\\n\");\n\tseq_printf(m, \"# latency: %lu us, #%lu/%lu, CPU#%d |\"\n\t\t   \" (M:%s VP:%d, KP:%d, SP:%d HP:%d\",\n\t\t   nsecs_to_usecs(data->saved_latency),\n\t\t   entries,\n\t\t   total,\n\t\t   buf->cpu,\n#if defined(CONFIG_PREEMPT_NONE)\n\t\t   \"server\",\n#elif defined(CONFIG_PREEMPT_VOLUNTARY)\n\t\t   \"desktop\",\n#elif defined(CONFIG_PREEMPT)\n\t\t   \"preempt\",\n#elif defined(CONFIG_PREEMPT_RT)\n\t\t   \"preempt_rt\",\n#else\n\t\t   \"unknown\",\n#endif\n\t\t   /* These are reserved for later use */\n\t\t   0, 0, 0, 0);\n#ifdef CONFIG_SMP\n\tseq_printf(m, \" #P:%d)\\n\", num_online_cpus());\n#else\n\tseq_puts(m, \")\\n\");\n#endif\n\tseq_puts(m, \"#    -----------------\\n\");\n\tseq_printf(m, \"#    | task: %.16s-%d \"\n\t\t   \"(uid:%d nice:%ld policy:%ld rt_prio:%ld)\\n\",\n\t\t   data->comm, data->pid,\n\t\t   from_kuid_munged(seq_user_ns(m), data->uid), data->nice,\n\t\t   data->policy, data->rt_priority);\n\tseq_puts(m, \"#    -----------------\\n\");\n\n\tif (data->critical_start) {\n\t\tseq_puts(m, \"#  => started at: \");\n\t\tseq_print_ip_sym(&iter->seq, data->critical_start, sym_flags);\n\t\ttrace_print_seq(m, &iter->seq);\n\t\tseq_puts(m, \"\\n#  => ended at:   \");\n\t\tseq_print_ip_sym(&iter->seq, data->critical_end, sym_flags);\n\t\ttrace_print_seq(m, &iter->seq);\n\t\tseq_puts(m, \"\\n#\\n\");\n\t}\n\n\tseq_puts(m, \"#\\n\");\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nint tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nvoid\nprint_trace_header(struct seq_file *m, struct trace_iterator *iter)\n{\n\tunsigned long sym_flags = (global_trace.trace_flags & TRACE_ITER_SYM_MASK);\n\tstruct array_buffer *buf = iter->array_buffer;\n\tstruct trace_array_cpu *data = per_cpu_ptr(buf->data, buf->cpu);\n\tstruct tracer *type = iter->trace;\n\tunsigned long entries;\n\tunsigned long total;\n\tconst char *name = \"preemption\";\n\n\tname = type->name;\n\n\tget_total_entries(buf, &total, &entries);\n\n\tseq_printf(m, \"# %s latency trace v1.1.5 on %s\\n\",\n\t\t   name, UTS_RELEASE);\n\tseq_puts(m, \"# -----------------------------------\"\n\t\t \"---------------------------------\\n\");\n\tseq_printf(m, \"# latency: %lu us, #%lu/%lu, CPU#%d |\"\n\t\t   \" (M:%s VP:%d, KP:%d, SP:%d HP:%d\",\n\t\t   nsecs_to_usecs(data->saved_latency),\n\t\t   entries,\n\t\t   total,\n\t\t   buf->cpu,\n#if defined(CONFIG_PREEMPT_NONE)\n\t\t   \"server\",\n#elif defined(CONFIG_PREEMPT_VOLUNTARY)\n\t\t   \"desktop\",\n#elif defined(CONFIG_PREEMPT)\n\t\t   \"preempt\",\n#elif defined(CONFIG_PREEMPT_RT)\n\t\t   \"preempt_rt\",\n#else\n\t\t   \"unknown\",\n#endif\n\t\t   /* These are reserved for later use */\n\t\t   0, 0, 0, 0);\n#ifdef CONFIG_SMP\n\tseq_printf(m, \" #P:%d)\\n\", num_online_cpus());\n#else\n\tseq_puts(m, \")\\n\");\n#endif\n\tseq_puts(m, \"#    -----------------\\n\");\n\tseq_printf(m, \"#    | task: %.16s-%d \"\n\t\t   \"(uid:%d nice:%ld policy:%ld rt_prio:%ld)\\n\",\n\t\t   data->comm, data->pid,\n\t\t   from_kuid_munged(seq_user_ns(m), data->uid), data->nice,\n\t\t   data->policy, data->rt_priority);\n\tseq_puts(m, \"#    -----------------\\n\");\n\n\tif (data->critical_start) {\n\t\tseq_puts(m, \"#  => started at: \");\n\t\tseq_print_ip_sym(&iter->seq, data->critical_start, sym_flags);\n\t\ttrace_print_seq(m, &iter->seq);\n\t\tseq_puts(m, \"\\n#  => ended at:   \");\n\t\tseq_print_ip_sym(&iter->seq, data->critical_end, sym_flags);\n\t\ttrace_print_seq(m, &iter->seq);\n\t\tseq_puts(m, \"\\n#\\n\");\n\t}\n\n\tseq_puts(m, \"#\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_empty",
          "args": [
            "iter"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "trace_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "4446-4477",
          "snippet": "int trace_empty(struct trace_iterator *iter)\n{\n\tstruct ring_buffer_iter *buf_iter;\n\tint cpu;\n\n\t/* If we are looking at one CPU buffer, only check that one */\n\tif (iter->cpu_file != RING_BUFFER_ALL_CPUS) {\n\t\tcpu = iter->cpu_file;\n\t\tbuf_iter = trace_buffer_iter(iter, cpu);\n\t\tif (buf_iter) {\n\t\t\tif (!ring_buffer_iter_empty(buf_iter))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!ring_buffer_empty_cpu(iter->array_buffer->buffer, cpu))\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tbuf_iter = trace_buffer_iter(iter, cpu);\n\t\tif (buf_iter) {\n\t\t\tif (!ring_buffer_iter_empty(buf_iter))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!ring_buffer_empty_cpu(iter->array_buffer->buffer, cpu))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_empty(struct trace_iterator *iter)\n{\n\tstruct ring_buffer_iter *buf_iter;\n\tint cpu;\n\n\t/* If we are looking at one CPU buffer, only check that one */\n\tif (iter->cpu_file != RING_BUFFER_ALL_CPUS) {\n\t\tcpu = iter->cpu_file;\n\t\tbuf_iter = trace_buffer_iter(iter, cpu);\n\t\tif (buf_iter) {\n\t\t\tif (!ring_buffer_iter_empty(buf_iter))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!ring_buffer_empty_cpu(iter->array_buffer->buffer, cpu))\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tbuf_iter = trace_buffer_iter(iter, cpu);\n\t\tif (buf_iter) {\n\t\t\tif (!ring_buffer_iter_empty(buf_iter))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!ring_buffer_empty_cpu(iter->array_buffer->buffer, cpu))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid print_graph_headers_flags(struct seq_file *s, u32 flags)\n{\n\tstruct trace_iterator *iter = s->private;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\n\t\tprint_trace_header(s, iter);\n\t}\n\n\t__print_graph_headers_flags(tr, s, flags);\n}"
  },
  {
    "function_name": "print_graph_headers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1174-1177",
    "snippet": "static void print_graph_headers(struct seq_file *s)\n{\n\tprint_graph_headers_flags(s, tracer_flags.val);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tracer_flags tracer_flags = {\n\t/* Don't display overruns, proc, or tail by default */\n\t.val = TRACE_GRAPH_PRINT_CPU | TRACE_GRAPH_PRINT_OVERHEAD |\n\t       TRACE_GRAPH_PRINT_DURATION | TRACE_GRAPH_PRINT_IRQS |\n\t       TRACE_GRAPH_SLEEP_TIME | TRACE_GRAPH_GRAPH_TIME,\n\t.opts = trace_opts\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_graph_headers_flags",
          "args": [
            "s",
            "tracer_flags.val"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_headers_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1179-1196",
          "snippet": "void print_graph_headers_flags(struct seq_file *s, u32 flags)\n{\n\tstruct trace_iterator *iter = s->private;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\n\t\tprint_trace_header(s, iter);\n\t}\n\n\t__print_graph_headers_flags(tr, s, flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid print_graph_headers_flags(struct seq_file *s, u32 flags)\n{\n\tstruct trace_iterator *iter = s->private;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\n\t\tprint_trace_header(s, iter);\n\t}\n\n\t__print_graph_headers_flags(tr, s, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct tracer_flags tracer_flags = {\n\t/* Don't display overruns, proc, or tail by default */\n\t.val = TRACE_GRAPH_PRINT_CPU | TRACE_GRAPH_PRINT_OVERHEAD |\n\t       TRACE_GRAPH_PRINT_DURATION | TRACE_GRAPH_PRINT_IRQS |\n\t       TRACE_GRAPH_SLEEP_TIME | TRACE_GRAPH_GRAPH_TIME,\n\t.opts = trace_opts\n};\n\nstatic void print_graph_headers(struct seq_file *s)\n{\n\tprint_graph_headers_flags(s, tracer_flags.val);\n}"
  },
  {
    "function_name": "__print_graph_headers_flags",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1133-1172",
    "snippet": "static void __print_graph_headers_flags(struct trace_array *tr,\n\t\t\t\t\tstruct seq_file *s, u32 flags)\n{\n\tint lat = tr->trace_flags & TRACE_ITER_LATENCY_FMT;\n\n\tif (lat)\n\t\tprint_lat_header(s, flags);\n\n\t/* 1st line */\n\tseq_putc(s, '#');\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tseq_puts(s, \"     TIME       \");\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tseq_puts(s, \"   REL TIME     \");\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tseq_puts(s, \" CPU\");\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tseq_puts(s, \"  TASK/PID       \");\n\tif (lat)\n\t\tseq_puts(s, \"||||   \");\n\tif (flags & TRACE_GRAPH_PRINT_DURATION)\n\t\tseq_puts(s, \"  DURATION   \");\n\tseq_puts(s, \"               FUNCTION CALLS\\n\");\n\n\t/* 2nd line */\n\tseq_putc(s, '#');\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tseq_puts(s, \"      |         \");\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tseq_puts(s, \"      |         \");\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tseq_puts(s, \" |  \");\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tseq_puts(s, \"   |    |        \");\n\tif (lat)\n\t\tseq_puts(s, \"||||   \");\n\tif (flags & TRACE_GRAPH_PRINT_DURATION)\n\t\tseq_puts(s, \"   |   |      \");\n\tseq_puts(s, \"               |   |   |   |\\n\");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"               |   |   |   |\\n\""
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "s",
            "'#'"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lat_header",
          "args": [
            "s",
            "flags"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "print_lat_header",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1110-1131",
          "snippet": "static void print_lat_header(struct seq_file *s, u32 flags)\n{\n\tstatic const char spaces[] = \"                \"\t/* 16 spaces */\n\t\t\"    \"\t\t\t\t\t/* 4 spaces */\n\t\t\"                 \";\t\t\t/* 17 spaces */\n\tint size = 0;\n\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tsize += 16;\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tsize += 16;\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tsize += 4;\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tsize += 17;\n\n\tseq_printf(s, \"#%.*s  _-----=> irqs-off        \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s / _----=> need-resched    \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s| / _---=> hardirq/softirq \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s|| / _--=> preempt-depth   \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s||| /                      \\n\", size, spaces);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void print_lat_header(struct seq_file *s, u32 flags)\n{\n\tstatic const char spaces[] = \"                \"\t/* 16 spaces */\n\t\t\"    \"\t\t\t\t\t/* 4 spaces */\n\t\t\"                 \";\t\t\t/* 17 spaces */\n\tint size = 0;\n\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tsize += 16;\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tsize += 16;\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tsize += 4;\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tsize += 17;\n\n\tseq_printf(s, \"#%.*s  _-----=> irqs-off        \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s / _----=> need-resched    \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s| / _---=> hardirq/softirq \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s|| / _--=> preempt-depth   \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s||| /                      \\n\", size, spaces);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void __print_graph_headers_flags(struct trace_array *tr,\n\t\t\t\t\tstruct seq_file *s, u32 flags)\n{\n\tint lat = tr->trace_flags & TRACE_ITER_LATENCY_FMT;\n\n\tif (lat)\n\t\tprint_lat_header(s, flags);\n\n\t/* 1st line */\n\tseq_putc(s, '#');\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tseq_puts(s, \"     TIME       \");\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tseq_puts(s, \"   REL TIME     \");\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tseq_puts(s, \" CPU\");\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tseq_puts(s, \"  TASK/PID       \");\n\tif (lat)\n\t\tseq_puts(s, \"||||   \");\n\tif (flags & TRACE_GRAPH_PRINT_DURATION)\n\t\tseq_puts(s, \"  DURATION   \");\n\tseq_puts(s, \"               FUNCTION CALLS\\n\");\n\n\t/* 2nd line */\n\tseq_putc(s, '#');\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tseq_puts(s, \"      |         \");\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tseq_puts(s, \"      |         \");\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tseq_puts(s, \" |  \");\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tseq_puts(s, \"   |    |        \");\n\tif (lat)\n\t\tseq_puts(s, \"||||   \");\n\tif (flags & TRACE_GRAPH_PRINT_DURATION)\n\t\tseq_puts(s, \"   |   |      \");\n\tseq_puts(s, \"               |   |   |   |\\n\");\n}"
  },
  {
    "function_name": "print_lat_header",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1110-1131",
    "snippet": "static void print_lat_header(struct seq_file *s, u32 flags)\n{\n\tstatic const char spaces[] = \"                \"\t/* 16 spaces */\n\t\t\"    \"\t\t\t\t\t/* 4 spaces */\n\t\t\"                 \";\t\t\t/* 17 spaces */\n\tint size = 0;\n\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tsize += 16;\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tsize += 16;\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tsize += 4;\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tsize += 17;\n\n\tseq_printf(s, \"#%.*s  _-----=> irqs-off        \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s / _----=> need-resched    \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s| / _---=> hardirq/softirq \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s|| / _--=> preempt-depth   \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s||| /                      \\n\", size, spaces);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"#%.*s||| /                      \\n\"",
            "size",
            "spaces"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void print_lat_header(struct seq_file *s, u32 flags)\n{\n\tstatic const char spaces[] = \"                \"\t/* 16 spaces */\n\t\t\"    \"\t\t\t\t\t/* 4 spaces */\n\t\t\"                 \";\t\t\t/* 17 spaces */\n\tint size = 0;\n\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tsize += 16;\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tsize += 16;\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tsize += 4;\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tsize += 17;\n\n\tseq_printf(s, \"#%.*s  _-----=> irqs-off        \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s / _----=> need-resched    \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s| / _---=> hardirq/softirq \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s|| / _--=> preempt-depth   \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s||| /                      \\n\", size, spaces);\n}"
  },
  {
    "function_name": "print_graph_function_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1103-1108",
    "snippet": "static enum print_line_t\nprint_graph_function_event(struct trace_iterator *iter, int flags,\n\t\t\t   struct trace_event *event)\n{\n\treturn print_graph_function(iter);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_graph_function",
          "args": [
            "iter"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1097-1101",
          "snippet": "static enum print_line_t\nprint_graph_function(struct trace_iterator *iter)\n{\n\treturn print_graph_function_flags(iter, tracer_flags.val);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tracer_flags tracer_flags = {\n\t/* Don't display overruns, proc, or tail by default */\n\t.val = TRACE_GRAPH_PRINT_CPU | TRACE_GRAPH_PRINT_OVERHEAD |\n\t       TRACE_GRAPH_PRINT_DURATION | TRACE_GRAPH_PRINT_IRQS |\n\t       TRACE_GRAPH_SLEEP_TIME | TRACE_GRAPH_GRAPH_TIME,\n\t.opts = trace_opts\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct tracer_flags tracer_flags = {\n\t/* Don't display overruns, proc, or tail by default */\n\t.val = TRACE_GRAPH_PRINT_CPU | TRACE_GRAPH_PRINT_OVERHEAD |\n\t       TRACE_GRAPH_PRINT_DURATION | TRACE_GRAPH_PRINT_IRQS |\n\t       TRACE_GRAPH_SLEEP_TIME | TRACE_GRAPH_GRAPH_TIME,\n\t.opts = trace_opts\n};\n\nstatic enum print_line_t\nprint_graph_function(struct trace_iterator *iter)\n{\n\treturn print_graph_function_flags(iter, tracer_flags.val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_function_event(struct trace_iterator *iter, int flags,\n\t\t\t   struct trace_event *event)\n{\n\treturn print_graph_function(iter);\n}"
  },
  {
    "function_name": "print_graph_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1097-1101",
    "snippet": "static enum print_line_t\nprint_graph_function(struct trace_iterator *iter)\n{\n\treturn print_graph_function_flags(iter, tracer_flags.val);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tracer_flags tracer_flags = {\n\t/* Don't display overruns, proc, or tail by default */\n\t.val = TRACE_GRAPH_PRINT_CPU | TRACE_GRAPH_PRINT_OVERHEAD |\n\t       TRACE_GRAPH_PRINT_DURATION | TRACE_GRAPH_PRINT_IRQS |\n\t       TRACE_GRAPH_SLEEP_TIME | TRACE_GRAPH_GRAPH_TIME,\n\t.opts = trace_opts\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_graph_function_flags",
          "args": [
            "iter",
            "tracer_flags.val"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_function_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1036-1095",
          "snippet": "enum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags)\n{\n\tstruct ftrace_graph_ent_entry *field;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tint cpu = iter->cpu;\n\tint ret;\n\n\tif (data && per_cpu_ptr(data->cpu_data, cpu)->ignore) {\n\t\tper_cpu_ptr(data->cpu_data, cpu)->ignore = 0;\n\t\treturn TRACE_TYPE_HANDLED;\n\t}\n\n\t/*\n\t * If the last output failed, there's a possibility we need\n\t * to print out the missing entry which would never go out.\n\t */\n\tif (data && data->failed) {\n\t\tfield = &data->ent;\n\t\titer->cpu = data->cpu;\n\t\tret = print_graph_entry(field, s, iter, flags);\n\t\tif (ret == TRACE_TYPE_HANDLED && iter->cpu != cpu) {\n\t\t\tper_cpu_ptr(data->cpu_data, iter->cpu)->ignore = 1;\n\t\t\tret = TRACE_TYPE_NO_CONSUME;\n\t\t}\n\t\titer->cpu = cpu;\n\t\treturn ret;\n\t}\n\n\tswitch (entry->type) {\n\tcase TRACE_GRAPH_ENT: {\n\t\t/*\n\t\t * print_graph_entry() may consume the current event,\n\t\t * thus @field may become invalid, so we need to save it.\n\t\t * sizeof(struct ftrace_graph_ent_entry) is very small,\n\t\t * it can be safely saved at the stack.\n\t\t */\n\t\tstruct ftrace_graph_ent_entry saved;\n\t\ttrace_assign_type(field, entry);\n\t\tsaved = *field;\n\t\treturn print_graph_entry(&saved, s, iter, flags);\n\t}\n\tcase TRACE_GRAPH_RET: {\n\t\tstruct ftrace_graph_ret_entry *field;\n\t\ttrace_assign_type(field, entry);\n\t\treturn print_graph_return(&field->ret, s, entry, iter, flags);\n\t}\n\tcase TRACE_STACK:\n\tcase TRACE_FN:\n\t\t/* dont trace stack and functions as comments */\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\tdefault:\n\t\treturn print_graph_comment(s, entry, iter, flags);\n\t}\n\n\treturn TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nenum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags)\n{\n\tstruct ftrace_graph_ent_entry *field;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tint cpu = iter->cpu;\n\tint ret;\n\n\tif (data && per_cpu_ptr(data->cpu_data, cpu)->ignore) {\n\t\tper_cpu_ptr(data->cpu_data, cpu)->ignore = 0;\n\t\treturn TRACE_TYPE_HANDLED;\n\t}\n\n\t/*\n\t * If the last output failed, there's a possibility we need\n\t * to print out the missing entry which would never go out.\n\t */\n\tif (data && data->failed) {\n\t\tfield = &data->ent;\n\t\titer->cpu = data->cpu;\n\t\tret = print_graph_entry(field, s, iter, flags);\n\t\tif (ret == TRACE_TYPE_HANDLED && iter->cpu != cpu) {\n\t\t\tper_cpu_ptr(data->cpu_data, iter->cpu)->ignore = 1;\n\t\t\tret = TRACE_TYPE_NO_CONSUME;\n\t\t}\n\t\titer->cpu = cpu;\n\t\treturn ret;\n\t}\n\n\tswitch (entry->type) {\n\tcase TRACE_GRAPH_ENT: {\n\t\t/*\n\t\t * print_graph_entry() may consume the current event,\n\t\t * thus @field may become invalid, so we need to save it.\n\t\t * sizeof(struct ftrace_graph_ent_entry) is very small,\n\t\t * it can be safely saved at the stack.\n\t\t */\n\t\tstruct ftrace_graph_ent_entry saved;\n\t\ttrace_assign_type(field, entry);\n\t\tsaved = *field;\n\t\treturn print_graph_entry(&saved, s, iter, flags);\n\t}\n\tcase TRACE_GRAPH_RET: {\n\t\tstruct ftrace_graph_ret_entry *field;\n\t\ttrace_assign_type(field, entry);\n\t\treturn print_graph_return(&field->ret, s, entry, iter, flags);\n\t}\n\tcase TRACE_STACK:\n\tcase TRACE_FN:\n\t\t/* dont trace stack and functions as comments */\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\tdefault:\n\t\treturn print_graph_comment(s, entry, iter, flags);\n\t}\n\n\treturn TRACE_TYPE_HANDLED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct tracer_flags tracer_flags = {\n\t/* Don't display overruns, proc, or tail by default */\n\t.val = TRACE_GRAPH_PRINT_CPU | TRACE_GRAPH_PRINT_OVERHEAD |\n\t       TRACE_GRAPH_PRINT_DURATION | TRACE_GRAPH_PRINT_IRQS |\n\t       TRACE_GRAPH_SLEEP_TIME | TRACE_GRAPH_GRAPH_TIME,\n\t.opts = trace_opts\n};\n\nstatic enum print_line_t\nprint_graph_function(struct trace_iterator *iter)\n{\n\treturn print_graph_function_flags(iter, tracer_flags.val);\n}"
  },
  {
    "function_name": "print_graph_function_flags",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1036-1095",
    "snippet": "enum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags)\n{\n\tstruct ftrace_graph_ent_entry *field;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tint cpu = iter->cpu;\n\tint ret;\n\n\tif (data && per_cpu_ptr(data->cpu_data, cpu)->ignore) {\n\t\tper_cpu_ptr(data->cpu_data, cpu)->ignore = 0;\n\t\treturn TRACE_TYPE_HANDLED;\n\t}\n\n\t/*\n\t * If the last output failed, there's a possibility we need\n\t * to print out the missing entry which would never go out.\n\t */\n\tif (data && data->failed) {\n\t\tfield = &data->ent;\n\t\titer->cpu = data->cpu;\n\t\tret = print_graph_entry(field, s, iter, flags);\n\t\tif (ret == TRACE_TYPE_HANDLED && iter->cpu != cpu) {\n\t\t\tper_cpu_ptr(data->cpu_data, iter->cpu)->ignore = 1;\n\t\t\tret = TRACE_TYPE_NO_CONSUME;\n\t\t}\n\t\titer->cpu = cpu;\n\t\treturn ret;\n\t}\n\n\tswitch (entry->type) {\n\tcase TRACE_GRAPH_ENT: {\n\t\t/*\n\t\t * print_graph_entry() may consume the current event,\n\t\t * thus @field may become invalid, so we need to save it.\n\t\t * sizeof(struct ftrace_graph_ent_entry) is very small,\n\t\t * it can be safely saved at the stack.\n\t\t */\n\t\tstruct ftrace_graph_ent_entry saved;\n\t\ttrace_assign_type(field, entry);\n\t\tsaved = *field;\n\t\treturn print_graph_entry(&saved, s, iter, flags);\n\t}\n\tcase TRACE_GRAPH_RET: {\n\t\tstruct ftrace_graph_ret_entry *field;\n\t\ttrace_assign_type(field, entry);\n\t\treturn print_graph_return(&field->ret, s, entry, iter, flags);\n\t}\n\tcase TRACE_STACK:\n\tcase TRACE_FN:\n\t\t/* dont trace stack and functions as comments */\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\tdefault:\n\t\treturn print_graph_comment(s, entry, iter, flags);\n\t}\n\n\treturn TRACE_TYPE_HANDLED;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_graph_comment",
          "args": [
            "s",
            "entry",
            "iter",
            "flags"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_comment",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "967-1033",
          "snippet": "static enum print_line_t\nprint_graph_comment(struct trace_seq *s, struct trace_entry *ent,\n\t\t    struct trace_iterator *iter, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long sym_flags = (tr->trace_flags & TRACE_ITER_SYM_MASK);\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_event *event;\n\tint depth = 0;\n\tint ret;\n\tint i;\n\n\tif (data)\n\t\tdepth = per_cpu_ptr(data->cpu_data, iter->cpu)->depth;\n\n\tprint_graph_prologue(iter, s, 0, 0, flags);\n\n\t/* No time */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);\n\n\t/* Indentation */\n\tif (depth > 0)\n\t\tfor (i = 0; i < (depth + 1) * TRACE_GRAPH_INDENT; i++)\n\t\t\ttrace_seq_putc(s, ' ');\n\n\t/* The comment */\n\ttrace_seq_puts(s, \"/* \");\n\n\tswitch (iter->ent->type) {\n\tcase TRACE_BPUTS:\n\t\tret = trace_print_bputs_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TRACE_BPRINT:\n\t\tret = trace_print_bprintk_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TRACE_PRINT:\n\t\tret = trace_print_printk_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tevent = ftrace_find_event(ent->type);\n\t\tif (!event)\n\t\t\treturn TRACE_TYPE_UNHANDLED;\n\n\t\tret = event->funcs->trace(iter, sym_flags, event);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t}\n\n\tif (trace_seq_has_overflowed(s))\n\t\tgoto out;\n\n\t/* Strip ending newline */\n\tif (s->buffer[s->seq.len - 1] == '\\n') {\n\t\ts->buffer[s->seq.len - 1] = '\\0';\n\t\ts->seq.len--;\n\t}\n\n\ttrace_seq_puts(s, \" */\\n\");\n out:\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define TRACE_GRAPH_INDENT\t2"
          ],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_INDENT\t2\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_comment(struct trace_seq *s, struct trace_entry *ent,\n\t\t    struct trace_iterator *iter, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long sym_flags = (tr->trace_flags & TRACE_ITER_SYM_MASK);\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_event *event;\n\tint depth = 0;\n\tint ret;\n\tint i;\n\n\tif (data)\n\t\tdepth = per_cpu_ptr(data->cpu_data, iter->cpu)->depth;\n\n\tprint_graph_prologue(iter, s, 0, 0, flags);\n\n\t/* No time */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);\n\n\t/* Indentation */\n\tif (depth > 0)\n\t\tfor (i = 0; i < (depth + 1) * TRACE_GRAPH_INDENT; i++)\n\t\t\ttrace_seq_putc(s, ' ');\n\n\t/* The comment */\n\ttrace_seq_puts(s, \"/* \");\n\n\tswitch (iter->ent->type) {\n\tcase TRACE_BPUTS:\n\t\tret = trace_print_bputs_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TRACE_BPRINT:\n\t\tret = trace_print_bprintk_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TRACE_PRINT:\n\t\tret = trace_print_printk_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tevent = ftrace_find_event(ent->type);\n\t\tif (!event)\n\t\t\treturn TRACE_TYPE_UNHANDLED;\n\n\t\tret = event->funcs->trace(iter, sym_flags, event);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t}\n\n\tif (trace_seq_has_overflowed(s))\n\t\tgoto out;\n\n\t/* Strip ending newline */\n\tif (s->buffer[s->seq.len - 1] == '\\n') {\n\t\ts->buffer[s->seq.len - 1] = '\\0';\n\t\ts->seq.len--;\n\t}\n\n\ttrace_seq_puts(s, \" */\\n\");\n out:\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_return",
          "args": [
            "&field->ret",
            "s",
            "entry",
            "iter",
            "flags"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "898-965",
          "snippet": "static enum print_line_t\nprint_graph_return(struct ftrace_graph_ret *trace, struct trace_seq *s,\n\t\t   struct trace_entry *ent, struct trace_iterator *iter,\n\t\t   u32 flags)\n{\n\tunsigned long long duration = trace->rettime - trace->calltime;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tpid_t pid = ent->pid;\n\tint cpu = iter->cpu;\n\tint func_match = 1;\n\tint i;\n\n\tif (check_irq_return(iter, flags, trace->depth))\n\t\treturn TRACE_TYPE_HANDLED;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\t\tint cpu = iter->cpu;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\n\t\t/*\n\t\t * Comments display at + 1 to depth. This is the\n\t\t * return from a function, we now want the comments\n\t\t * to display at the same level of the bracket.\n\t\t */\n\t\tcpu_data->depth = trace->depth - 1;\n\n\t\tif (trace->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(trace->depth < 0)) {\n\t\t\tif (cpu_data->enter_funcs[trace->depth] != trace->func)\n\t\t\t\tfunc_match = 0;\n\t\t\tcpu_data->enter_funcs[trace->depth] = 0;\n\t\t}\n\t}\n\n\tprint_graph_prologue(iter, s, 0, 0, flags);\n\n\t/* Overhead and duration */\n\tprint_graph_duration(tr, duration, s, flags);\n\n\t/* Closing brace */\n\tfor (i = 0; i < trace->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\t/*\n\t * If the return function does not have a matching entry,\n\t * then the entry was lost. Instead of just printing\n\t * the '}' and letting the user guess what function this\n\t * belongs to, write out the function name. Always do\n\t * that if the funcgraph-tail option is enabled.\n\t */\n\tif (func_match && !(flags & TRACE_GRAPH_PRINT_TAIL))\n\t\ttrace_seq_puts(s, \"}\\n\");\n\telse\n\t\ttrace_seq_printf(s, \"} /* %ps */\\n\", (void *)trace->func);\n\n\t/* Overrun */\n\tif (flags & TRACE_GRAPH_PRINT_OVERRUN)\n\t\ttrace_seq_printf(s, \" (Overruns: %u)\\n\",\n\t\t\t\t trace->overrun);\n\n\tprint_graph_irq(iter, trace->func, TRACE_GRAPH_RET,\n\t\t\tcpu, pid, flags);\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define TRACE_GRAPH_INDENT\t2"
          ],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_INDENT\t2\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_return(struct ftrace_graph_ret *trace, struct trace_seq *s,\n\t\t   struct trace_entry *ent, struct trace_iterator *iter,\n\t\t   u32 flags)\n{\n\tunsigned long long duration = trace->rettime - trace->calltime;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tpid_t pid = ent->pid;\n\tint cpu = iter->cpu;\n\tint func_match = 1;\n\tint i;\n\n\tif (check_irq_return(iter, flags, trace->depth))\n\t\treturn TRACE_TYPE_HANDLED;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\t\tint cpu = iter->cpu;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\n\t\t/*\n\t\t * Comments display at + 1 to depth. This is the\n\t\t * return from a function, we now want the comments\n\t\t * to display at the same level of the bracket.\n\t\t */\n\t\tcpu_data->depth = trace->depth - 1;\n\n\t\tif (trace->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(trace->depth < 0)) {\n\t\t\tif (cpu_data->enter_funcs[trace->depth] != trace->func)\n\t\t\t\tfunc_match = 0;\n\t\t\tcpu_data->enter_funcs[trace->depth] = 0;\n\t\t}\n\t}\n\n\tprint_graph_prologue(iter, s, 0, 0, flags);\n\n\t/* Overhead and duration */\n\tprint_graph_duration(tr, duration, s, flags);\n\n\t/* Closing brace */\n\tfor (i = 0; i < trace->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\t/*\n\t * If the return function does not have a matching entry,\n\t * then the entry was lost. Instead of just printing\n\t * the '}' and letting the user guess what function this\n\t * belongs to, write out the function name. Always do\n\t * that if the funcgraph-tail option is enabled.\n\t */\n\tif (func_match && !(flags & TRACE_GRAPH_PRINT_TAIL))\n\t\ttrace_seq_puts(s, \"}\\n\");\n\telse\n\t\ttrace_seq_printf(s, \"} /* %ps */\\n\", (void *)trace->func);\n\n\t/* Overrun */\n\tif (flags & TRACE_GRAPH_PRINT_OVERRUN)\n\t\ttrace_seq_printf(s, \" (Overruns: %u)\\n\",\n\t\t\t\t trace->overrun);\n\n\tprint_graph_irq(iter, trace->func, TRACE_GRAPH_RET,\n\t\t\tcpu, pid, flags);\n\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "entry"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_graph_entry",
          "args": [
            "&saved",
            "s",
            "iter",
            "flags"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "862-896",
          "snippet": "static enum print_line_t\nprint_graph_entry(struct ftrace_graph_ent_entry *field, struct trace_seq *s,\n\t\t\tstruct trace_iterator *iter, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct ftrace_graph_ent *call = &field->graph_ent;\n\tstruct ftrace_graph_ret_entry *leaf_ret;\n\tstatic enum print_line_t ret;\n\tint cpu = iter->cpu;\n\n\tif (check_irq_entry(iter, flags, call->func, call->depth))\n\t\treturn TRACE_TYPE_HANDLED;\n\n\tprint_graph_prologue(iter, s, TRACE_GRAPH_ENT, call->func, flags);\n\n\tleaf_ret = get_return_for_leaf(iter, field);\n\tif (leaf_ret)\n\t\tret = print_graph_entry_leaf(iter, field, leaf_ret, s, flags);\n\telse\n\t\tret = print_graph_entry_nested(iter, field, s, cpu, flags);\n\n\tif (data) {\n\t\t/*\n\t\t * If we failed to write our output, then we need to make\n\t\t * note of it. Because we already consumed our entry.\n\t\t */\n\t\tif (s->full) {\n\t\t\tdata->failed = 1;\n\t\t\tdata->cpu = cpu;\n\t\t} else\n\t\t\tdata->failed = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_entry(struct ftrace_graph_ent_entry *field, struct trace_seq *s,\n\t\t\tstruct trace_iterator *iter, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct ftrace_graph_ent *call = &field->graph_ent;\n\tstruct ftrace_graph_ret_entry *leaf_ret;\n\tstatic enum print_line_t ret;\n\tint cpu = iter->cpu;\n\n\tif (check_irq_entry(iter, flags, call->func, call->depth))\n\t\treturn TRACE_TYPE_HANDLED;\n\n\tprint_graph_prologue(iter, s, TRACE_GRAPH_ENT, call->func, flags);\n\n\tleaf_ret = get_return_for_leaf(iter, field);\n\tif (leaf_ret)\n\t\tret = print_graph_entry_leaf(iter, field, leaf_ret, s, flags);\n\telse\n\t\tret = print_graph_entry_nested(iter, field, s, cpu, flags);\n\n\tif (data) {\n\t\t/*\n\t\t * If we failed to write our output, then we need to make\n\t\t * note of it. Because we already consumed our entry.\n\t\t */\n\t\tif (s->full) {\n\t\t\tdata->failed = 1;\n\t\t\tdata->cpu = cpu;\n\t\t} else\n\t\t\tdata->failed = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "entry"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "iter->cpu"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nenum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags)\n{\n\tstruct ftrace_graph_ent_entry *field;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tint cpu = iter->cpu;\n\tint ret;\n\n\tif (data && per_cpu_ptr(data->cpu_data, cpu)->ignore) {\n\t\tper_cpu_ptr(data->cpu_data, cpu)->ignore = 0;\n\t\treturn TRACE_TYPE_HANDLED;\n\t}\n\n\t/*\n\t * If the last output failed, there's a possibility we need\n\t * to print out the missing entry which would never go out.\n\t */\n\tif (data && data->failed) {\n\t\tfield = &data->ent;\n\t\titer->cpu = data->cpu;\n\t\tret = print_graph_entry(field, s, iter, flags);\n\t\tif (ret == TRACE_TYPE_HANDLED && iter->cpu != cpu) {\n\t\t\tper_cpu_ptr(data->cpu_data, iter->cpu)->ignore = 1;\n\t\t\tret = TRACE_TYPE_NO_CONSUME;\n\t\t}\n\t\titer->cpu = cpu;\n\t\treturn ret;\n\t}\n\n\tswitch (entry->type) {\n\tcase TRACE_GRAPH_ENT: {\n\t\t/*\n\t\t * print_graph_entry() may consume the current event,\n\t\t * thus @field may become invalid, so we need to save it.\n\t\t * sizeof(struct ftrace_graph_ent_entry) is very small,\n\t\t * it can be safely saved at the stack.\n\t\t */\n\t\tstruct ftrace_graph_ent_entry saved;\n\t\ttrace_assign_type(field, entry);\n\t\tsaved = *field;\n\t\treturn print_graph_entry(&saved, s, iter, flags);\n\t}\n\tcase TRACE_GRAPH_RET: {\n\t\tstruct ftrace_graph_ret_entry *field;\n\t\ttrace_assign_type(field, entry);\n\t\treturn print_graph_return(&field->ret, s, entry, iter, flags);\n\t}\n\tcase TRACE_STACK:\n\tcase TRACE_FN:\n\t\t/* dont trace stack and functions as comments */\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\tdefault:\n\t\treturn print_graph_comment(s, entry, iter, flags);\n\t}\n\n\treturn TRACE_TYPE_HANDLED;\n}"
  },
  {
    "function_name": "print_graph_comment",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "967-1033",
    "snippet": "static enum print_line_t\nprint_graph_comment(struct trace_seq *s, struct trace_entry *ent,\n\t\t    struct trace_iterator *iter, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long sym_flags = (tr->trace_flags & TRACE_ITER_SYM_MASK);\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_event *event;\n\tint depth = 0;\n\tint ret;\n\tint i;\n\n\tif (data)\n\t\tdepth = per_cpu_ptr(data->cpu_data, iter->cpu)->depth;\n\n\tprint_graph_prologue(iter, s, 0, 0, flags);\n\n\t/* No time */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);\n\n\t/* Indentation */\n\tif (depth > 0)\n\t\tfor (i = 0; i < (depth + 1) * TRACE_GRAPH_INDENT; i++)\n\t\t\ttrace_seq_putc(s, ' ');\n\n\t/* The comment */\n\ttrace_seq_puts(s, \"/* \");\n\n\tswitch (iter->ent->type) {\n\tcase TRACE_BPUTS:\n\t\tret = trace_print_bputs_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TRACE_BPRINT:\n\t\tret = trace_print_bprintk_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TRACE_PRINT:\n\t\tret = trace_print_printk_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tevent = ftrace_find_event(ent->type);\n\t\tif (!event)\n\t\t\treturn TRACE_TYPE_UNHANDLED;\n\n\t\tret = event->funcs->trace(iter, sym_flags, event);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t}\n\n\tif (trace_seq_has_overflowed(s))\n\t\tgoto out;\n\n\t/* Strip ending newline */\n\tif (s->buffer[s->seq.len - 1] == '\\n') {\n\t\ts->buffer[s->seq.len - 1] = '\\0';\n\t\ts->seq.len--;\n\t}\n\n\ttrace_seq_puts(s, \" */\\n\");\n out:\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define TRACE_GRAPH_INDENT\t2"
    ],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\" */\\n\""
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event->funcs->trace",
          "args": [
            "iter",
            "sym_flags",
            "event"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_event",
          "args": [
            "ent->type"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "676-689",
          "snippet": "struct trace_event *ftrace_find_event(int type)\n{\n\tstruct trace_event *event;\n\tunsigned key;\n\n\tkey = type & (EVENT_HASHSIZE - 1);\n\n\thlist_for_each_entry(event, &event_hash[key], node) {\n\t\tif (event->type == type)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define EVENT_HASHSIZE\t128"
          ],
          "globals_used": [
            "static struct hlist_head event_hash[EVENT_HASHSIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\n#define EVENT_HASHSIZE\t128\n\nstatic struct hlist_head event_hash[EVENT_HASHSIZE];\n\nstruct trace_event *ftrace_find_event(int type)\n{\n\tstruct trace_event *event;\n\tunsigned key;\n\n\tkey = type & (EVENT_HASHSIZE - 1);\n\n\thlist_for_each_entry(event, &event_hash[key], node) {\n\t\tif (event->type == type)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_printk_msg_only",
          "args": [
            "iter"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_printk_msg_only",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "52-63",
          "snippet": "enum print_line_t trace_print_printk_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_puts(s, field->buf);\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nenum print_line_t trace_print_printk_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_puts(s, field->buf);\n\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_bprintk_msg_only",
          "args": [
            "iter"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_bprintk_msg_only",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "39-50",
          "snippet": "enum print_line_t trace_print_bprintk_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct bprint_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nenum print_line_t trace_print_bprintk_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct bprint_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_bputs_msg_only",
          "args": [
            "iter"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_bputs_msg_only",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "26-37",
          "snippet": "enum print_line_t trace_print_bputs_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct bputs_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nenum print_line_t trace_print_bputs_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct bputs_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_duration",
          "args": [
            "tr",
            "0",
            "s",
            "flags | FLAGS_FILL_FULL"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_duration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "591-620",
          "snippet": "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_prologue",
          "args": [
            "iter",
            "s",
            "0",
            "0",
            "flags"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_prologue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "716-758",
          "snippet": "static void\nprint_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,\n\t\t     int type, unsigned long addr, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu = iter->cpu;\n\n\t/* Pid */\n\tverif_pid(s, ent->pid, cpu, data);\n\n\tif (type)\n\t\t/* Interrupt */\n\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* Absolute time */\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tprint_graph_abs_time(iter->ts, s);\n\n\t/* Relative time */\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tprint_graph_rel_time(iter, s);\n\n\t/* Cpu */\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tprint_graph_cpu(s, cpu);\n\n\t/* Proc */\n\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\tprint_graph_proc(s, ent->pid);\n\t\ttrace_seq_puts(s, \" | \");\n\t}\n\n\t/* Latency format */\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\tprint_graph_lat_fmt(s, ent);\n\n\treturn;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,\n\t\t     int type, unsigned long addr, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu = iter->cpu;\n\n\t/* Pid */\n\tverif_pid(s, ent->pid, cpu, data);\n\n\tif (type)\n\t\t/* Interrupt */\n\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* Absolute time */\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tprint_graph_abs_time(iter->ts, s);\n\n\t/* Relative time */\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tprint_graph_rel_time(iter, s);\n\n\t/* Cpu */\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tprint_graph_cpu(s, cpu);\n\n\t/* Proc */\n\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\tprint_graph_proc(s, ent->pid);\n\t\ttrace_seq_puts(s, \" | \");\n\t}\n\n\t/* Latency format */\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\tprint_graph_lat_fmt(s, ent);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "iter->cpu"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_INDENT\t2\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_comment(struct trace_seq *s, struct trace_entry *ent,\n\t\t    struct trace_iterator *iter, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long sym_flags = (tr->trace_flags & TRACE_ITER_SYM_MASK);\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_event *event;\n\tint depth = 0;\n\tint ret;\n\tint i;\n\n\tif (data)\n\t\tdepth = per_cpu_ptr(data->cpu_data, iter->cpu)->depth;\n\n\tprint_graph_prologue(iter, s, 0, 0, flags);\n\n\t/* No time */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);\n\n\t/* Indentation */\n\tif (depth > 0)\n\t\tfor (i = 0; i < (depth + 1) * TRACE_GRAPH_INDENT; i++)\n\t\t\ttrace_seq_putc(s, ' ');\n\n\t/* The comment */\n\ttrace_seq_puts(s, \"/* \");\n\n\tswitch (iter->ent->type) {\n\tcase TRACE_BPUTS:\n\t\tret = trace_print_bputs_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TRACE_BPRINT:\n\t\tret = trace_print_bprintk_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TRACE_PRINT:\n\t\tret = trace_print_printk_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tevent = ftrace_find_event(ent->type);\n\t\tif (!event)\n\t\t\treturn TRACE_TYPE_UNHANDLED;\n\n\t\tret = event->funcs->trace(iter, sym_flags, event);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t}\n\n\tif (trace_seq_has_overflowed(s))\n\t\tgoto out;\n\n\t/* Strip ending newline */\n\tif (s->buffer[s->seq.len - 1] == '\\n') {\n\t\ts->buffer[s->seq.len - 1] = '\\0';\n\t\ts->seq.len--;\n\t}\n\n\ttrace_seq_puts(s, \" */\\n\");\n out:\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "print_graph_return",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "898-965",
    "snippet": "static enum print_line_t\nprint_graph_return(struct ftrace_graph_ret *trace, struct trace_seq *s,\n\t\t   struct trace_entry *ent, struct trace_iterator *iter,\n\t\t   u32 flags)\n{\n\tunsigned long long duration = trace->rettime - trace->calltime;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tpid_t pid = ent->pid;\n\tint cpu = iter->cpu;\n\tint func_match = 1;\n\tint i;\n\n\tif (check_irq_return(iter, flags, trace->depth))\n\t\treturn TRACE_TYPE_HANDLED;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\t\tint cpu = iter->cpu;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\n\t\t/*\n\t\t * Comments display at + 1 to depth. This is the\n\t\t * return from a function, we now want the comments\n\t\t * to display at the same level of the bracket.\n\t\t */\n\t\tcpu_data->depth = trace->depth - 1;\n\n\t\tif (trace->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(trace->depth < 0)) {\n\t\t\tif (cpu_data->enter_funcs[trace->depth] != trace->func)\n\t\t\t\tfunc_match = 0;\n\t\t\tcpu_data->enter_funcs[trace->depth] = 0;\n\t\t}\n\t}\n\n\tprint_graph_prologue(iter, s, 0, 0, flags);\n\n\t/* Overhead and duration */\n\tprint_graph_duration(tr, duration, s, flags);\n\n\t/* Closing brace */\n\tfor (i = 0; i < trace->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\t/*\n\t * If the return function does not have a matching entry,\n\t * then the entry was lost. Instead of just printing\n\t * the '}' and letting the user guess what function this\n\t * belongs to, write out the function name. Always do\n\t * that if the funcgraph-tail option is enabled.\n\t */\n\tif (func_match && !(flags & TRACE_GRAPH_PRINT_TAIL))\n\t\ttrace_seq_puts(s, \"}\\n\");\n\telse\n\t\ttrace_seq_printf(s, \"} /* %ps */\\n\", (void *)trace->func);\n\n\t/* Overrun */\n\tif (flags & TRACE_GRAPH_PRINT_OVERRUN)\n\t\ttrace_seq_printf(s, \" (Overruns: %u)\\n\",\n\t\t\t\t trace->overrun);\n\n\tprint_graph_irq(iter, trace->func, TRACE_GRAPH_RET,\n\t\t\tcpu, pid, flags);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define TRACE_GRAPH_INDENT\t2"
    ],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_irq",
          "args": [
            "iter",
            "trace->func",
            "TRACE_GRAPH_RET",
            "cpu",
            "pid",
            "flags"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "510-556",
          "snippet": "static void\nprint_graph_irq(struct trace_iterator *iter, unsigned long addr,\n\t\tenum trace_type type, int cpu, pid_t pid, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\n\tif (addr < (unsigned long)__irqentry_text_start ||\n\t\taddr >= (unsigned long)__irqentry_text_end)\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\t/* Absolute time */\n\t\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\t\tprint_graph_abs_time(iter->ts, s);\n\n\t\t/* Relative time */\n\t\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\t\tprint_graph_rel_time(iter, s);\n\n\t\t/* Cpu */\n\t\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\t\tprint_graph_cpu(s, cpu);\n\n\t\t/* Proc */\n\t\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\t\tprint_graph_proc(s, pid);\n\t\t\ttrace_seq_puts(s, \" | \");\n\t\t}\n\n\t\t/* Latency format */\n\t\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\tprint_graph_lat_fmt(s, ent);\n\t}\n\n\t/* No overhead */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_START);\n\n\tif (type == TRACE_GRAPH_ENT)\n\t\ttrace_seq_puts(s, \"==========>\");\n\telse\n\t\ttrace_seq_puts(s, \"<==========\");\n\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_END);\n\ttrace_seq_putc(s, '\\n');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_irq(struct trace_iterator *iter, unsigned long addr,\n\t\tenum trace_type type, int cpu, pid_t pid, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\n\tif (addr < (unsigned long)__irqentry_text_start ||\n\t\taddr >= (unsigned long)__irqentry_text_end)\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\t/* Absolute time */\n\t\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\t\tprint_graph_abs_time(iter->ts, s);\n\n\t\t/* Relative time */\n\t\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\t\tprint_graph_rel_time(iter, s);\n\n\t\t/* Cpu */\n\t\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\t\tprint_graph_cpu(s, cpu);\n\n\t\t/* Proc */\n\t\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\t\tprint_graph_proc(s, pid);\n\t\t\ttrace_seq_puts(s, \" | \");\n\t\t}\n\n\t\t/* Latency format */\n\t\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\tprint_graph_lat_fmt(s, ent);\n\t}\n\n\t/* No overhead */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_START);\n\n\tif (type == TRACE_GRAPH_ENT)\n\t\ttrace_seq_puts(s, \"==========>\");\n\telse\n\t\ttrace_seq_puts(s, \"<==========\");\n\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_END);\n\ttrace_seq_putc(s, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\" (Overruns: %u)\\n\"",
            "trace->overrun"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"}\\n\""
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_duration",
          "args": [
            "tr",
            "duration",
            "s",
            "flags"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_duration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "591-620",
          "snippet": "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_prologue",
          "args": [
            "iter",
            "s",
            "0",
            "0",
            "flags"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_prologue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "716-758",
          "snippet": "static void\nprint_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,\n\t\t     int type, unsigned long addr, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu = iter->cpu;\n\n\t/* Pid */\n\tverif_pid(s, ent->pid, cpu, data);\n\n\tif (type)\n\t\t/* Interrupt */\n\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* Absolute time */\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tprint_graph_abs_time(iter->ts, s);\n\n\t/* Relative time */\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tprint_graph_rel_time(iter, s);\n\n\t/* Cpu */\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tprint_graph_cpu(s, cpu);\n\n\t/* Proc */\n\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\tprint_graph_proc(s, ent->pid);\n\t\ttrace_seq_puts(s, \" | \");\n\t}\n\n\t/* Latency format */\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\tprint_graph_lat_fmt(s, ent);\n\n\treturn;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,\n\t\t     int type, unsigned long addr, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu = iter->cpu;\n\n\t/* Pid */\n\tverif_pid(s, ent->pid, cpu, data);\n\n\tif (type)\n\t\t/* Interrupt */\n\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* Absolute time */\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tprint_graph_abs_time(iter->ts, s);\n\n\t/* Relative time */\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tprint_graph_rel_time(iter, s);\n\n\t/* Cpu */\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tprint_graph_cpu(s, cpu);\n\n\t/* Proc */\n\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\tprint_graph_proc(s, ent->pid);\n\t\ttrace_seq_puts(s, \" | \");\n\t}\n\n\t/* Latency format */\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\tprint_graph_lat_fmt(s, ent);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "trace->depth < 0"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irq_return",
          "args": [
            "iter",
            "flags",
            "trace->depth"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "818-860",
          "snippet": "static int\ncheck_irq_return(struct trace_iterator *iter, u32 flags, int depth)\n{\n\tint cpu = iter->cpu;\n\tint *depth_irq;\n\tstruct fgraph_data *data = iter->private;\n\n\t/*\n\t * If we are either displaying irqs, or we got called as\n\t * a graph event and private data does not exist,\n\t * then we bypass the irq check.\n\t */\n\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||\n\t    (!data))\n\t\treturn 0;\n\n\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t/*\n\t * We are not inside the irq code.\n\t */\n\tif (*depth_irq == -1)\n\t\treturn 0;\n\n\t/*\n\t * We are inside the irq code, and this is returning entry.\n\t * Let's not trace it and clear the entry depth, since\n\t * we are out of irq code.\n\t *\n\t * This condition ensures that we 'leave the irq code' once\n\t * we are out of the entry depth. Thus protecting us from\n\t * the RETURN entry loss.\n\t */\n\tif (*depth_irq >= depth) {\n\t\t*depth_irq = -1;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * We are inside the irq code, and this is not the entry.\n\t */\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic int\ncheck_irq_return(struct trace_iterator *iter, u32 flags, int depth)\n{\n\tint cpu = iter->cpu;\n\tint *depth_irq;\n\tstruct fgraph_data *data = iter->private;\n\n\t/*\n\t * If we are either displaying irqs, or we got called as\n\t * a graph event and private data does not exist,\n\t * then we bypass the irq check.\n\t */\n\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||\n\t    (!data))\n\t\treturn 0;\n\n\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t/*\n\t * We are not inside the irq code.\n\t */\n\tif (*depth_irq == -1)\n\t\treturn 0;\n\n\t/*\n\t * We are inside the irq code, and this is returning entry.\n\t * Let's not trace it and clear the entry depth, since\n\t * we are out of irq code.\n\t *\n\t * This condition ensures that we 'leave the irq code' once\n\t * we are out of the entry depth. Thus protecting us from\n\t * the RETURN entry loss.\n\t */\n\tif (*depth_irq >= depth) {\n\t\t*depth_irq = -1;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * We are inside the irq code, and this is not the entry.\n\t */\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_INDENT\t2\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_return(struct ftrace_graph_ret *trace, struct trace_seq *s,\n\t\t   struct trace_entry *ent, struct trace_iterator *iter,\n\t\t   u32 flags)\n{\n\tunsigned long long duration = trace->rettime - trace->calltime;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tpid_t pid = ent->pid;\n\tint cpu = iter->cpu;\n\tint func_match = 1;\n\tint i;\n\n\tif (check_irq_return(iter, flags, trace->depth))\n\t\treturn TRACE_TYPE_HANDLED;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\t\tint cpu = iter->cpu;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\n\t\t/*\n\t\t * Comments display at + 1 to depth. This is the\n\t\t * return from a function, we now want the comments\n\t\t * to display at the same level of the bracket.\n\t\t */\n\t\tcpu_data->depth = trace->depth - 1;\n\n\t\tif (trace->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(trace->depth < 0)) {\n\t\t\tif (cpu_data->enter_funcs[trace->depth] != trace->func)\n\t\t\t\tfunc_match = 0;\n\t\t\tcpu_data->enter_funcs[trace->depth] = 0;\n\t\t}\n\t}\n\n\tprint_graph_prologue(iter, s, 0, 0, flags);\n\n\t/* Overhead and duration */\n\tprint_graph_duration(tr, duration, s, flags);\n\n\t/* Closing brace */\n\tfor (i = 0; i < trace->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\t/*\n\t * If the return function does not have a matching entry,\n\t * then the entry was lost. Instead of just printing\n\t * the '}' and letting the user guess what function this\n\t * belongs to, write out the function name. Always do\n\t * that if the funcgraph-tail option is enabled.\n\t */\n\tif (func_match && !(flags & TRACE_GRAPH_PRINT_TAIL))\n\t\ttrace_seq_puts(s, \"}\\n\");\n\telse\n\t\ttrace_seq_printf(s, \"} /* %ps */\\n\", (void *)trace->func);\n\n\t/* Overrun */\n\tif (flags & TRACE_GRAPH_PRINT_OVERRUN)\n\t\ttrace_seq_printf(s, \" (Overruns: %u)\\n\",\n\t\t\t\t trace->overrun);\n\n\tprint_graph_irq(iter, trace->func, TRACE_GRAPH_RET,\n\t\t\tcpu, pid, flags);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "print_graph_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "862-896",
    "snippet": "static enum print_line_t\nprint_graph_entry(struct ftrace_graph_ent_entry *field, struct trace_seq *s,\n\t\t\tstruct trace_iterator *iter, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct ftrace_graph_ent *call = &field->graph_ent;\n\tstruct ftrace_graph_ret_entry *leaf_ret;\n\tstatic enum print_line_t ret;\n\tint cpu = iter->cpu;\n\n\tif (check_irq_entry(iter, flags, call->func, call->depth))\n\t\treturn TRACE_TYPE_HANDLED;\n\n\tprint_graph_prologue(iter, s, TRACE_GRAPH_ENT, call->func, flags);\n\n\tleaf_ret = get_return_for_leaf(iter, field);\n\tif (leaf_ret)\n\t\tret = print_graph_entry_leaf(iter, field, leaf_ret, s, flags);\n\telse\n\t\tret = print_graph_entry_nested(iter, field, s, cpu, flags);\n\n\tif (data) {\n\t\t/*\n\t\t * If we failed to write our output, then we need to make\n\t\t * note of it. Because we already consumed our entry.\n\t\t */\n\t\tif (s->full) {\n\t\t\tdata->failed = 1;\n\t\t\tdata->cpu = cpu;\n\t\t} else\n\t\t\tdata->failed = 0;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_graph_entry_nested",
          "args": [
            "iter",
            "field",
            "s",
            "cpu",
            "flags"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_entry_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "674-714",
          "snippet": "static enum print_line_t\nprint_graph_entry_nested(struct trace_iterator *iter,\n\t\t\t struct ftrace_graph_ent_entry *entry,\n\t\t\t struct trace_seq *s, int cpu, u32 flags)\n{\n\tstruct ftrace_graph_ent *call = &entry->graph_ent;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tint i;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\t\tint cpu = iter->cpu;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\t\tcpu_data->depth = call->depth;\n\n\t\t/* Save this function pointer to see if the exit matches */\n\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(call->depth < 0))\n\t\t\tcpu_data->enter_funcs[call->depth] = call->func;\n\t}\n\n\t/* No time */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);\n\n\t/* Function */\n\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%ps() {\\n\", (void *)call->func);\n\n\tif (trace_seq_has_overflowed(s))\n\t\treturn TRACE_TYPE_PARTIAL_LINE;\n\n\t/*\n\t * we already consumed the current entry to check the next one\n\t * and see if this is a leaf.\n\t */\n\treturn TRACE_TYPE_NO_CONSUME;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define TRACE_GRAPH_INDENT\t2"
          ],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_INDENT\t2\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_entry_nested(struct trace_iterator *iter,\n\t\t\t struct ftrace_graph_ent_entry *entry,\n\t\t\t struct trace_seq *s, int cpu, u32 flags)\n{\n\tstruct ftrace_graph_ent *call = &entry->graph_ent;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tint i;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\t\tint cpu = iter->cpu;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\t\tcpu_data->depth = call->depth;\n\n\t\t/* Save this function pointer to see if the exit matches */\n\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(call->depth < 0))\n\t\t\tcpu_data->enter_funcs[call->depth] = call->func;\n\t}\n\n\t/* No time */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);\n\n\t/* Function */\n\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%ps() {\\n\", (void *)call->func);\n\n\tif (trace_seq_has_overflowed(s))\n\t\treturn TRACE_TYPE_PARTIAL_LINE;\n\n\t/*\n\t * we already consumed the current entry to check the next one\n\t * and see if this is a leaf.\n\t */\n\treturn TRACE_TYPE_NO_CONSUME;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_entry_leaf",
          "args": [
            "iter",
            "field",
            "leaf_ret",
            "s",
            "flags"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_entry_leaf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "623-672",
          "snippet": "static enum print_line_t\nprint_graph_entry_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *entry,\n\t\tstruct ftrace_graph_ret_entry *ret_entry,\n\t\tstruct trace_seq *s, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tstruct ftrace_graph_ret *graph_ret;\n\tstruct ftrace_graph_ent *call;\n\tunsigned long long duration;\n\tint cpu = iter->cpu;\n\tint i;\n\n\tgraph_ret = &ret_entry->ret;\n\tcall = &entry->graph_ent;\n\tduration = graph_ret->rettime - graph_ret->calltime;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\n\t\t/*\n\t\t * Comments display at + 1 to depth. Since\n\t\t * this is a leaf function, keep the comments\n\t\t * equal to this depth.\n\t\t */\n\t\tcpu_data->depth = call->depth - 1;\n\n\t\t/* No need to keep this function around for this depth */\n\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(call->depth < 0))\n\t\t\tcpu_data->enter_funcs[call->depth] = 0;\n\t}\n\n\t/* Overhead and duration */\n\tprint_graph_duration(tr, duration, s, flags);\n\n\t/* Function */\n\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%ps();\\n\", (void *)call->func);\n\n\tprint_graph_irq(iter, graph_ret->func, TRACE_GRAPH_RET,\n\t\t\tcpu, iter->ent->pid, flags);\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define TRACE_GRAPH_INDENT\t2"
          ],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_INDENT\t2\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_entry_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *entry,\n\t\tstruct ftrace_graph_ret_entry *ret_entry,\n\t\tstruct trace_seq *s, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tstruct ftrace_graph_ret *graph_ret;\n\tstruct ftrace_graph_ent *call;\n\tunsigned long long duration;\n\tint cpu = iter->cpu;\n\tint i;\n\n\tgraph_ret = &ret_entry->ret;\n\tcall = &entry->graph_ent;\n\tduration = graph_ret->rettime - graph_ret->calltime;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\n\t\t/*\n\t\t * Comments display at + 1 to depth. Since\n\t\t * this is a leaf function, keep the comments\n\t\t * equal to this depth.\n\t\t */\n\t\tcpu_data->depth = call->depth - 1;\n\n\t\t/* No need to keep this function around for this depth */\n\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(call->depth < 0))\n\t\t\tcpu_data->enter_funcs[call->depth] = 0;\n\t}\n\n\t/* Overhead and duration */\n\tprint_graph_duration(tr, duration, s, flags);\n\n\t/* Function */\n\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%ps();\\n\", (void *)call->func);\n\n\tprint_graph_irq(iter, graph_ret->func, TRACE_GRAPH_RET,\n\t\t\tcpu, iter->ent->pid, flags);\n\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_return_for_leaf",
          "args": [
            "iter",
            "field"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "get_return_for_leaf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "417-486",
          "snippet": "static struct ftrace_graph_ret_entry *\nget_return_for_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *curr)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct ring_buffer_iter *ring_iter = NULL;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_graph_ret_entry *next;\n\n\t/*\n\t * If the previous output failed to write to the seq buffer,\n\t * then we just reuse the data from before.\n\t */\n\tif (data && data->failed) {\n\t\tcurr = &data->ent;\n\t\tnext = &data->ret;\n\t} else {\n\n\t\tring_iter = trace_buffer_iter(iter, iter->cpu);\n\n\t\t/* First peek to compare current entry and the next one */\n\t\tif (ring_iter)\n\t\t\tevent = ring_buffer_iter_peek(ring_iter, NULL);\n\t\telse {\n\t\t\t/*\n\t\t\t * We need to consume the current entry to see\n\t\t\t * the next one.\n\t\t\t */\n\t\t\tring_buffer_consume(iter->array_buffer->buffer, iter->cpu,\n\t\t\t\t\t    NULL, NULL);\n\t\t\tevent = ring_buffer_peek(iter->array_buffer->buffer, iter->cpu,\n\t\t\t\t\t\t NULL, NULL);\n\t\t}\n\n\t\tif (!event)\n\t\t\treturn NULL;\n\n\t\tnext = ring_buffer_event_data(event);\n\n\t\tif (data) {\n\t\t\t/*\n\t\t\t * Save current and next entries for later reference\n\t\t\t * if the output fails.\n\t\t\t */\n\t\t\tdata->ent = *curr;\n\t\t\t/*\n\t\t\t * If the next event is not a return type, then\n\t\t\t * we only care about what type it is. Otherwise we can\n\t\t\t * safely copy the entire event.\n\t\t\t */\n\t\t\tif (next->ent.type == TRACE_GRAPH_RET)\n\t\t\t\tdata->ret = *next;\n\t\t\telse\n\t\t\t\tdata->ret.ent.type = next->ent.type;\n\t\t}\n\t}\n\n\tif (next->ent.type != TRACE_GRAPH_RET)\n\t\treturn NULL;\n\n\tif (curr->ent.pid != next->ent.pid ||\n\t\t\tcurr->graph_ent.func != next->ret.func)\n\t\treturn NULL;\n\n\t/* this is a leaf, now advance the iterator */\n\tif (ring_iter)\n\t\tring_buffer_iter_advance(ring_iter);\n\n\treturn next;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct ftrace_graph_ret_entry *\nget_return_for_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *curr)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct ring_buffer_iter *ring_iter = NULL;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_graph_ret_entry *next;\n\n\t/*\n\t * If the previous output failed to write to the seq buffer,\n\t * then we just reuse the data from before.\n\t */\n\tif (data && data->failed) {\n\t\tcurr = &data->ent;\n\t\tnext = &data->ret;\n\t} else {\n\n\t\tring_iter = trace_buffer_iter(iter, iter->cpu);\n\n\t\t/* First peek to compare current entry and the next one */\n\t\tif (ring_iter)\n\t\t\tevent = ring_buffer_iter_peek(ring_iter, NULL);\n\t\telse {\n\t\t\t/*\n\t\t\t * We need to consume the current entry to see\n\t\t\t * the next one.\n\t\t\t */\n\t\t\tring_buffer_consume(iter->array_buffer->buffer, iter->cpu,\n\t\t\t\t\t    NULL, NULL);\n\t\t\tevent = ring_buffer_peek(iter->array_buffer->buffer, iter->cpu,\n\t\t\t\t\t\t NULL, NULL);\n\t\t}\n\n\t\tif (!event)\n\t\t\treturn NULL;\n\n\t\tnext = ring_buffer_event_data(event);\n\n\t\tif (data) {\n\t\t\t/*\n\t\t\t * Save current and next entries for later reference\n\t\t\t * if the output fails.\n\t\t\t */\n\t\t\tdata->ent = *curr;\n\t\t\t/*\n\t\t\t * If the next event is not a return type, then\n\t\t\t * we only care about what type it is. Otherwise we can\n\t\t\t * safely copy the entire event.\n\t\t\t */\n\t\t\tif (next->ent.type == TRACE_GRAPH_RET)\n\t\t\t\tdata->ret = *next;\n\t\t\telse\n\t\t\t\tdata->ret.ent.type = next->ent.type;\n\t\t}\n\t}\n\n\tif (next->ent.type != TRACE_GRAPH_RET)\n\t\treturn NULL;\n\n\tif (curr->ent.pid != next->ent.pid ||\n\t\t\tcurr->graph_ent.func != next->ret.func)\n\t\treturn NULL;\n\n\t/* this is a leaf, now advance the iterator */\n\tif (ring_iter)\n\t\tring_buffer_iter_advance(ring_iter);\n\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_prologue",
          "args": [
            "iter",
            "s",
            "TRACE_GRAPH_ENT",
            "call->func",
            "flags"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_prologue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "716-758",
          "snippet": "static void\nprint_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,\n\t\t     int type, unsigned long addr, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu = iter->cpu;\n\n\t/* Pid */\n\tverif_pid(s, ent->pid, cpu, data);\n\n\tif (type)\n\t\t/* Interrupt */\n\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* Absolute time */\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tprint_graph_abs_time(iter->ts, s);\n\n\t/* Relative time */\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tprint_graph_rel_time(iter, s);\n\n\t/* Cpu */\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tprint_graph_cpu(s, cpu);\n\n\t/* Proc */\n\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\tprint_graph_proc(s, ent->pid);\n\t\ttrace_seq_puts(s, \" | \");\n\t}\n\n\t/* Latency format */\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\tprint_graph_lat_fmt(s, ent);\n\n\treturn;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,\n\t\t     int type, unsigned long addr, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu = iter->cpu;\n\n\t/* Pid */\n\tverif_pid(s, ent->pid, cpu, data);\n\n\tif (type)\n\t\t/* Interrupt */\n\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* Absolute time */\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tprint_graph_abs_time(iter->ts, s);\n\n\t/* Relative time */\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tprint_graph_rel_time(iter, s);\n\n\t/* Cpu */\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tprint_graph_cpu(s, cpu);\n\n\t/* Proc */\n\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\tprint_graph_proc(s, ent->pid);\n\t\ttrace_seq_puts(s, \" | \");\n\t}\n\n\t/* Latency format */\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\tprint_graph_lat_fmt(s, ent);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_irq_entry",
          "args": [
            "iter",
            "flags",
            "call->func",
            "call->depth"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "771-805",
          "snippet": "static int\ncheck_irq_entry(struct trace_iterator *iter, u32 flags,\n\t\tunsigned long addr, int depth)\n{\n\tint cpu = iter->cpu;\n\tint *depth_irq;\n\tstruct fgraph_data *data = iter->private;\n\n\t/*\n\t * If we are either displaying irqs, or we got called as\n\t * a graph event and private data does not exist,\n\t * then we bypass the irq check.\n\t */\n\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||\n\t    (!data))\n\t\treturn 0;\n\n\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t/*\n\t * We are inside the irq code\n\t */\n\tif (*depth_irq >= 0)\n\t\treturn 1;\n\n\tif ((addr < (unsigned long)__irqentry_text_start) ||\n\t    (addr >= (unsigned long)__irqentry_text_end))\n\t\treturn 0;\n\n\t/*\n\t * We are entering irq code.\n\t */\n\t*depth_irq = depth;\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic int\ncheck_irq_entry(struct trace_iterator *iter, u32 flags,\n\t\tunsigned long addr, int depth)\n{\n\tint cpu = iter->cpu;\n\tint *depth_irq;\n\tstruct fgraph_data *data = iter->private;\n\n\t/*\n\t * If we are either displaying irqs, or we got called as\n\t * a graph event and private data does not exist,\n\t * then we bypass the irq check.\n\t */\n\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||\n\t    (!data))\n\t\treturn 0;\n\n\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t/*\n\t * We are inside the irq code\n\t */\n\tif (*depth_irq >= 0)\n\t\treturn 1;\n\n\tif ((addr < (unsigned long)__irqentry_text_start) ||\n\t    (addr >= (unsigned long)__irqentry_text_end))\n\t\treturn 0;\n\n\t/*\n\t * We are entering irq code.\n\t */\n\t*depth_irq = depth;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_entry(struct ftrace_graph_ent_entry *field, struct trace_seq *s,\n\t\t\tstruct trace_iterator *iter, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct ftrace_graph_ent *call = &field->graph_ent;\n\tstruct ftrace_graph_ret_entry *leaf_ret;\n\tstatic enum print_line_t ret;\n\tint cpu = iter->cpu;\n\n\tif (check_irq_entry(iter, flags, call->func, call->depth))\n\t\treturn TRACE_TYPE_HANDLED;\n\n\tprint_graph_prologue(iter, s, TRACE_GRAPH_ENT, call->func, flags);\n\n\tleaf_ret = get_return_for_leaf(iter, field);\n\tif (leaf_ret)\n\t\tret = print_graph_entry_leaf(iter, field, leaf_ret, s, flags);\n\telse\n\t\tret = print_graph_entry_nested(iter, field, s, cpu, flags);\n\n\tif (data) {\n\t\t/*\n\t\t * If we failed to write our output, then we need to make\n\t\t * note of it. Because we already consumed our entry.\n\t\t */\n\t\tif (s->full) {\n\t\t\tdata->failed = 1;\n\t\t\tdata->cpu = cpu;\n\t\t} else\n\t\t\tdata->failed = 0;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "check_irq_return",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "818-860",
    "snippet": "static int\ncheck_irq_return(struct trace_iterator *iter, u32 flags, int depth)\n{\n\tint cpu = iter->cpu;\n\tint *depth_irq;\n\tstruct fgraph_data *data = iter->private;\n\n\t/*\n\t * If we are either displaying irqs, or we got called as\n\t * a graph event and private data does not exist,\n\t * then we bypass the irq check.\n\t */\n\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||\n\t    (!data))\n\t\treturn 0;\n\n\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t/*\n\t * We are not inside the irq code.\n\t */\n\tif (*depth_irq == -1)\n\t\treturn 0;\n\n\t/*\n\t * We are inside the irq code, and this is returning entry.\n\t * Let's not trace it and clear the entry depth, since\n\t * we are out of irq code.\n\t *\n\t * This condition ensures that we 'leave the irq code' once\n\t * we are out of the entry depth. Thus protecting us from\n\t * the RETURN entry loss.\n\t */\n\tif (*depth_irq >= depth) {\n\t\t*depth_irq = -1;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * We are inside the irq code, and this is not the entry.\n\t */\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic int\ncheck_irq_return(struct trace_iterator *iter, u32 flags, int depth)\n{\n\tint cpu = iter->cpu;\n\tint *depth_irq;\n\tstruct fgraph_data *data = iter->private;\n\n\t/*\n\t * If we are either displaying irqs, or we got called as\n\t * a graph event and private data does not exist,\n\t * then we bypass the irq check.\n\t */\n\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||\n\t    (!data))\n\t\treturn 0;\n\n\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t/*\n\t * We are not inside the irq code.\n\t */\n\tif (*depth_irq == -1)\n\t\treturn 0;\n\n\t/*\n\t * We are inside the irq code, and this is returning entry.\n\t * Let's not trace it and clear the entry depth, since\n\t * we are out of irq code.\n\t *\n\t * This condition ensures that we 'leave the irq code' once\n\t * we are out of the entry depth. Thus protecting us from\n\t * the RETURN entry loss.\n\t */\n\tif (*depth_irq >= depth) {\n\t\t*depth_irq = -1;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * We are inside the irq code, and this is not the entry.\n\t */\n\treturn 1;\n}"
  },
  {
    "function_name": "check_irq_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "771-805",
    "snippet": "static int\ncheck_irq_entry(struct trace_iterator *iter, u32 flags,\n\t\tunsigned long addr, int depth)\n{\n\tint cpu = iter->cpu;\n\tint *depth_irq;\n\tstruct fgraph_data *data = iter->private;\n\n\t/*\n\t * If we are either displaying irqs, or we got called as\n\t * a graph event and private data does not exist,\n\t * then we bypass the irq check.\n\t */\n\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||\n\t    (!data))\n\t\treturn 0;\n\n\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t/*\n\t * We are inside the irq code\n\t */\n\tif (*depth_irq >= 0)\n\t\treturn 1;\n\n\tif ((addr < (unsigned long)__irqentry_text_start) ||\n\t    (addr >= (unsigned long)__irqentry_text_end))\n\t\treturn 0;\n\n\t/*\n\t * We are entering irq code.\n\t */\n\t*depth_irq = depth;\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic int\ncheck_irq_entry(struct trace_iterator *iter, u32 flags,\n\t\tunsigned long addr, int depth)\n{\n\tint cpu = iter->cpu;\n\tint *depth_irq;\n\tstruct fgraph_data *data = iter->private;\n\n\t/*\n\t * If we are either displaying irqs, or we got called as\n\t * a graph event and private data does not exist,\n\t * then we bypass the irq check.\n\t */\n\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||\n\t    (!data))\n\t\treturn 0;\n\n\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t/*\n\t * We are inside the irq code\n\t */\n\tif (*depth_irq >= 0)\n\t\treturn 1;\n\n\tif ((addr < (unsigned long)__irqentry_text_start) ||\n\t    (addr >= (unsigned long)__irqentry_text_end))\n\t\treturn 0;\n\n\t/*\n\t * We are entering irq code.\n\t */\n\t*depth_irq = depth;\n\treturn 1;\n}"
  },
  {
    "function_name": "print_graph_prologue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "716-758",
    "snippet": "static void\nprint_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,\n\t\t     int type, unsigned long addr, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu = iter->cpu;\n\n\t/* Pid */\n\tverif_pid(s, ent->pid, cpu, data);\n\n\tif (type)\n\t\t/* Interrupt */\n\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* Absolute time */\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tprint_graph_abs_time(iter->ts, s);\n\n\t/* Relative time */\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tprint_graph_rel_time(iter, s);\n\n\t/* Cpu */\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tprint_graph_cpu(s, cpu);\n\n\t/* Proc */\n\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\tprint_graph_proc(s, ent->pid);\n\t\ttrace_seq_puts(s, \" | \");\n\t}\n\n\t/* Latency format */\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\tprint_graph_lat_fmt(s, ent);\n\n\treturn;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_graph_lat_fmt",
          "args": [
            "s",
            "ent"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_lat_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "374-379",
          "snippet": "static void print_graph_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\ttrace_seq_putc(s, ' ');\n\ttrace_print_lat_fmt(s, entry);\n\ttrace_seq_puts(s, \" | \");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void print_graph_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\ttrace_seq_putc(s, ' ');\n\ttrace_print_lat_fmt(s, entry);\n\ttrace_seq_puts(s, \" | \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\" | \""
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_proc",
          "args": [
            "s",
            "ent->pid"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_proc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "343-371",
          "snippet": "static void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[TASK_COMM_LEN];\n\t/* sign + log10(MAX_INT) + '\\0' */\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t/* 1 stands for the \"-\" character */\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < TRACE_GRAPH_PROCINFO_LENGTH)\n\t\tspaces = TRACE_GRAPH_PROCINFO_LENGTH - len;\n\n\t/* First spaces to align center */\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t/* Last spaces to align center */\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define TRACE_GRAPH_PROCINFO_LENGTH\t14"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_PROCINFO_LENGTH\t14\n\nstatic void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[TASK_COMM_LEN];\n\t/* sign + log10(MAX_INT) + '\\0' */\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t/* 1 stands for the \"-\" character */\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < TRACE_GRAPH_PROCINFO_LENGTH)\n\t\tspaces = TRACE_GRAPH_PROCINFO_LENGTH - len;\n\n\t/* First spaces to align center */\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t/* Last spaces to align center */\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_cpu",
          "args": [
            "s",
            "cpu"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "331-339",
          "snippet": "static void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t/*\n\t * Start with a space character - to make it stand out\n\t * to the right a bit when trace output is pasted into\n\t * email:\n\t */\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int max_bytes_for_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int max_bytes_for_cpu;\n\nstatic void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t/*\n\t * Start with a space character - to make it stand out\n\t * to the right a bit when trace output is pasted into\n\t * email:\n\t */\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_rel_time",
          "args": [
            "iter",
            "s"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_rel_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "499-508",
          "snippet": "static void\nprint_graph_rel_time(struct trace_iterator *iter, struct trace_seq *s)\n{\n\tunsigned long long usecs;\n\n\tusecs = iter->ts - iter->array_buffer->time_start;\n\tdo_div(usecs, NSEC_PER_USEC);\n\n\ttrace_seq_printf(s, \"%9llu us |  \", usecs);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_rel_time(struct trace_iterator *iter, struct trace_seq *s)\n{\n\tunsigned long long usecs;\n\n\tusecs = iter->ts - iter->array_buffer->time_start;\n\tdo_div(usecs, NSEC_PER_USEC);\n\n\ttrace_seq_printf(s, \"%9llu us |  \", usecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_abs_time",
          "args": [
            "iter->ts",
            "s"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_abs_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "488-497",
          "snippet": "static void print_graph_abs_time(u64 t, struct trace_seq *s)\n{\n\tunsigned long usecs_rem;\n\n\tusecs_rem = do_div(t, NSEC_PER_SEC);\n\tusecs_rem /= 1000;\n\n\ttrace_seq_printf(s, \"%5lu.%06lu |  \",\n\t\t\t (unsigned long)t, usecs_rem);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void print_graph_abs_time(u64 t, struct trace_seq *s)\n{\n\tunsigned long usecs_rem;\n\n\tusecs_rem = do_div(t, NSEC_PER_SEC);\n\tusecs_rem /= 1000;\n\n\ttrace_seq_printf(s, \"%5lu.%06lu |  \",\n\t\t\t (unsigned long)t, usecs_rem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_irq",
          "args": [
            "iter",
            "addr",
            "type",
            "cpu",
            "ent->pid",
            "flags"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "510-556",
          "snippet": "static void\nprint_graph_irq(struct trace_iterator *iter, unsigned long addr,\n\t\tenum trace_type type, int cpu, pid_t pid, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\n\tif (addr < (unsigned long)__irqentry_text_start ||\n\t\taddr >= (unsigned long)__irqentry_text_end)\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\t/* Absolute time */\n\t\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\t\tprint_graph_abs_time(iter->ts, s);\n\n\t\t/* Relative time */\n\t\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\t\tprint_graph_rel_time(iter, s);\n\n\t\t/* Cpu */\n\t\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\t\tprint_graph_cpu(s, cpu);\n\n\t\t/* Proc */\n\t\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\t\tprint_graph_proc(s, pid);\n\t\t\ttrace_seq_puts(s, \" | \");\n\t\t}\n\n\t\t/* Latency format */\n\t\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\tprint_graph_lat_fmt(s, ent);\n\t}\n\n\t/* No overhead */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_START);\n\n\tif (type == TRACE_GRAPH_ENT)\n\t\ttrace_seq_puts(s, \"==========>\");\n\telse\n\t\ttrace_seq_puts(s, \"<==========\");\n\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_END);\n\ttrace_seq_putc(s, '\\n');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_irq(struct trace_iterator *iter, unsigned long addr,\n\t\tenum trace_type type, int cpu, pid_t pid, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\n\tif (addr < (unsigned long)__irqentry_text_start ||\n\t\taddr >= (unsigned long)__irqentry_text_end)\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\t/* Absolute time */\n\t\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\t\tprint_graph_abs_time(iter->ts, s);\n\n\t\t/* Relative time */\n\t\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\t\tprint_graph_rel_time(iter, s);\n\n\t\t/* Cpu */\n\t\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\t\tprint_graph_cpu(s, cpu);\n\n\t\t/* Proc */\n\t\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\t\tprint_graph_proc(s, pid);\n\t\t\ttrace_seq_puts(s, \" | \");\n\t\t}\n\n\t\t/* Latency format */\n\t\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\tprint_graph_lat_fmt(s, ent);\n\t}\n\n\t/* No overhead */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_START);\n\n\tif (type == TRACE_GRAPH_ENT)\n\t\ttrace_seq_puts(s, \"==========>\");\n\telse\n\t\ttrace_seq_puts(s, \"<==========\");\n\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_END);\n\ttrace_seq_putc(s, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "verif_pid",
          "args": [
            "s",
            "ent->pid",
            "cpu",
            "data"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "verif_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "382-415",
          "snippet": "static void\nverif_pid(struct trace_seq *s, pid_t pid, int cpu, struct fgraph_data *data)\n{\n\tpid_t prev_pid;\n\tpid_t *last_pid;\n\n\tif (!data)\n\t\treturn;\n\n\tlast_pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\n\tif (*last_pid == pid)\n\t\treturn;\n\n\tprev_pid = *last_pid;\n\t*last_pid = pid;\n\n\tif (prev_pid == -1)\n\t\treturn;\n/*\n * Context-switch trace line:\n\n ------------------------------------------\n | 1)  migration/0--1  =>  sshd-1755\n ------------------------------------------\n\n */\n\ttrace_seq_puts(s, \" ------------------------------------------\\n\");\n\tprint_graph_cpu(s, cpu);\n\tprint_graph_proc(s, prev_pid);\n\ttrace_seq_puts(s, \" => \");\n\tprint_graph_proc(s, pid);\n\ttrace_seq_puts(s, \"\\n ------------------------------------------\\n\\n\");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nverif_pid(struct trace_seq *s, pid_t pid, int cpu, struct fgraph_data *data)\n{\n\tpid_t prev_pid;\n\tpid_t *last_pid;\n\n\tif (!data)\n\t\treturn;\n\n\tlast_pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\n\tif (*last_pid == pid)\n\t\treturn;\n\n\tprev_pid = *last_pid;\n\t*last_pid = pid;\n\n\tif (prev_pid == -1)\n\t\treturn;\n/*\n * Context-switch trace line:\n\n ------------------------------------------\n | 1)  migration/0--1  =>  sshd-1755\n ------------------------------------------\n\n */\n\ttrace_seq_puts(s, \" ------------------------------------------\\n\");\n\tprint_graph_cpu(s, cpu);\n\tprint_graph_proc(s, prev_pid);\n\ttrace_seq_puts(s, \" => \");\n\tprint_graph_proc(s, pid);\n\ttrace_seq_puts(s, \"\\n ------------------------------------------\\n\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,\n\t\t     int type, unsigned long addr, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu = iter->cpu;\n\n\t/* Pid */\n\tverif_pid(s, ent->pid, cpu, data);\n\n\tif (type)\n\t\t/* Interrupt */\n\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* Absolute time */\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tprint_graph_abs_time(iter->ts, s);\n\n\t/* Relative time */\n\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\tprint_graph_rel_time(iter, s);\n\n\t/* Cpu */\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tprint_graph_cpu(s, cpu);\n\n\t/* Proc */\n\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\tprint_graph_proc(s, ent->pid);\n\t\ttrace_seq_puts(s, \" | \");\n\t}\n\n\t/* Latency format */\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\tprint_graph_lat_fmt(s, ent);\n\n\treturn;\n}"
  },
  {
    "function_name": "print_graph_entry_nested",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "674-714",
    "snippet": "static enum print_line_t\nprint_graph_entry_nested(struct trace_iterator *iter,\n\t\t\t struct ftrace_graph_ent_entry *entry,\n\t\t\t struct trace_seq *s, int cpu, u32 flags)\n{\n\tstruct ftrace_graph_ent *call = &entry->graph_ent;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tint i;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\t\tint cpu = iter->cpu;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\t\tcpu_data->depth = call->depth;\n\n\t\t/* Save this function pointer to see if the exit matches */\n\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(call->depth < 0))\n\t\t\tcpu_data->enter_funcs[call->depth] = call->func;\n\t}\n\n\t/* No time */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);\n\n\t/* Function */\n\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%ps() {\\n\", (void *)call->func);\n\n\tif (trace_seq_has_overflowed(s))\n\t\treturn TRACE_TYPE_PARTIAL_LINE;\n\n\t/*\n\t * we already consumed the current entry to check the next one\n\t * and see if this is a leaf.\n\t */\n\treturn TRACE_TYPE_NO_CONSUME;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define TRACE_GRAPH_INDENT\t2"
    ],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%ps() {\\n\"",
            "(void *)call->func"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_duration",
          "args": [
            "tr",
            "0",
            "s",
            "flags | FLAGS_FILL_FULL"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_duration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "591-620",
          "snippet": "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "call->depth < 0"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_INDENT\t2\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_entry_nested(struct trace_iterator *iter,\n\t\t\t struct ftrace_graph_ent_entry *entry,\n\t\t\t struct trace_seq *s, int cpu, u32 flags)\n{\n\tstruct ftrace_graph_ent *call = &entry->graph_ent;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tint i;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\t\tint cpu = iter->cpu;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\t\tcpu_data->depth = call->depth;\n\n\t\t/* Save this function pointer to see if the exit matches */\n\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(call->depth < 0))\n\t\t\tcpu_data->enter_funcs[call->depth] = call->func;\n\t}\n\n\t/* No time */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);\n\n\t/* Function */\n\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%ps() {\\n\", (void *)call->func);\n\n\tif (trace_seq_has_overflowed(s))\n\t\treturn TRACE_TYPE_PARTIAL_LINE;\n\n\t/*\n\t * we already consumed the current entry to check the next one\n\t * and see if this is a leaf.\n\t */\n\treturn TRACE_TYPE_NO_CONSUME;\n}"
  },
  {
    "function_name": "print_graph_entry_leaf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "623-672",
    "snippet": "static enum print_line_t\nprint_graph_entry_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *entry,\n\t\tstruct ftrace_graph_ret_entry *ret_entry,\n\t\tstruct trace_seq *s, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tstruct ftrace_graph_ret *graph_ret;\n\tstruct ftrace_graph_ent *call;\n\tunsigned long long duration;\n\tint cpu = iter->cpu;\n\tint i;\n\n\tgraph_ret = &ret_entry->ret;\n\tcall = &entry->graph_ent;\n\tduration = graph_ret->rettime - graph_ret->calltime;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\n\t\t/*\n\t\t * Comments display at + 1 to depth. Since\n\t\t * this is a leaf function, keep the comments\n\t\t * equal to this depth.\n\t\t */\n\t\tcpu_data->depth = call->depth - 1;\n\n\t\t/* No need to keep this function around for this depth */\n\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(call->depth < 0))\n\t\t\tcpu_data->enter_funcs[call->depth] = 0;\n\t}\n\n\t/* Overhead and duration */\n\tprint_graph_duration(tr, duration, s, flags);\n\n\t/* Function */\n\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%ps();\\n\", (void *)call->func);\n\n\tprint_graph_irq(iter, graph_ret->func, TRACE_GRAPH_RET,\n\t\t\tcpu, iter->ent->pid, flags);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define TRACE_GRAPH_INDENT\t2"
    ],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2577-2581",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_irq",
          "args": [
            "iter",
            "graph_ret->func",
            "TRACE_GRAPH_RET",
            "cpu",
            "iter->ent->pid",
            "flags"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "510-556",
          "snippet": "static void\nprint_graph_irq(struct trace_iterator *iter, unsigned long addr,\n\t\tenum trace_type type, int cpu, pid_t pid, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\n\tif (addr < (unsigned long)__irqentry_text_start ||\n\t\taddr >= (unsigned long)__irqentry_text_end)\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\t/* Absolute time */\n\t\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\t\tprint_graph_abs_time(iter->ts, s);\n\n\t\t/* Relative time */\n\t\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\t\tprint_graph_rel_time(iter, s);\n\n\t\t/* Cpu */\n\t\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\t\tprint_graph_cpu(s, cpu);\n\n\t\t/* Proc */\n\t\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\t\tprint_graph_proc(s, pid);\n\t\t\ttrace_seq_puts(s, \" | \");\n\t\t}\n\n\t\t/* Latency format */\n\t\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\tprint_graph_lat_fmt(s, ent);\n\t}\n\n\t/* No overhead */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_START);\n\n\tif (type == TRACE_GRAPH_ENT)\n\t\ttrace_seq_puts(s, \"==========>\");\n\telse\n\t\ttrace_seq_puts(s, \"<==========\");\n\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_END);\n\ttrace_seq_putc(s, '\\n');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_irq(struct trace_iterator *iter, unsigned long addr,\n\t\tenum trace_type type, int cpu, pid_t pid, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\n\tif (addr < (unsigned long)__irqentry_text_start ||\n\t\taddr >= (unsigned long)__irqentry_text_end)\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\t/* Absolute time */\n\t\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\t\tprint_graph_abs_time(iter->ts, s);\n\n\t\t/* Relative time */\n\t\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\t\tprint_graph_rel_time(iter, s);\n\n\t\t/* Cpu */\n\t\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\t\tprint_graph_cpu(s, cpu);\n\n\t\t/* Proc */\n\t\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\t\tprint_graph_proc(s, pid);\n\t\t\ttrace_seq_puts(s, \" | \");\n\t\t}\n\n\t\t/* Latency format */\n\t\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\tprint_graph_lat_fmt(s, ent);\n\t}\n\n\t/* No overhead */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_START);\n\n\tif (type == TRACE_GRAPH_ENT)\n\t\ttrace_seq_puts(s, \"==========>\");\n\telse\n\t\ttrace_seq_puts(s, \"<==========\");\n\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_END);\n\ttrace_seq_putc(s, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%ps();\\n\"",
            "(void *)call->func"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_duration",
          "args": [
            "tr",
            "duration",
            "s",
            "flags"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_duration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "591-620",
          "snippet": "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "call->depth < 0"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_INDENT\t2\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_entry_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *entry,\n\t\tstruct ftrace_graph_ret_entry *ret_entry,\n\t\tstruct trace_seq *s, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tstruct ftrace_graph_ret *graph_ret;\n\tstruct ftrace_graph_ent *call;\n\tunsigned long long duration;\n\tint cpu = iter->cpu;\n\tint i;\n\n\tgraph_ret = &ret_entry->ret;\n\tcall = &entry->graph_ent;\n\tduration = graph_ret->rettime - graph_ret->calltime;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\n\t\t/*\n\t\t * Comments display at + 1 to depth. Since\n\t\t * this is a leaf function, keep the comments\n\t\t * equal to this depth.\n\t\t */\n\t\tcpu_data->depth = call->depth - 1;\n\n\t\t/* No need to keep this function around for this depth */\n\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(call->depth < 0))\n\t\t\tcpu_data->enter_funcs[call->depth] = 0;\n\t}\n\n\t/* Overhead and duration */\n\tprint_graph_duration(tr, duration, s, flags);\n\n\t/* Function */\n\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%ps();\\n\", (void *)call->func);\n\n\tprint_graph_irq(iter, graph_ret->func, TRACE_GRAPH_RET,\n\t\t\tcpu, iter->ent->pid, flags);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "print_graph_duration",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "591-620",
    "snippet": "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"|  \""
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_graph_duration",
          "args": [
            "duration",
            "s"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_graph_duration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "558-589",
          "snippet": "void\ntrace_print_graph_duration(unsigned long long duration, struct trace_seq *s)\n{\n\tunsigned long nsecs_rem = do_div(duration, 1000);\n\t/* log10(ULONG_MAX) + '\\0' */\n\tchar usecs_str[21];\n\tchar nsecs_str[5];\n\tint len;\n\tint i;\n\n\tsprintf(usecs_str, \"%lu\", (unsigned long) duration);\n\n\t/* Print msecs */\n\ttrace_seq_printf(s, \"%s\", usecs_str);\n\n\tlen = strlen(usecs_str);\n\n\t/* Print nsecs (we don't want to exceed 7 numbers) */\n\tif (len < 7) {\n\t\tsize_t slen = min_t(size_t, sizeof(nsecs_str), 8UL - len);\n\n\t\tsnprintf(nsecs_str, slen, \"%03lu\", nsecs_rem);\n\t\ttrace_seq_printf(s, \".%s\", nsecs_str);\n\t\tlen += strlen(nsecs_str) + 1;\n\t}\n\n\ttrace_seq_puts(s, \" us \");\n\n\t/* Print remaining spaces to fit the row's width */\n\tfor (i = len; i < 8; i++)\n\t\ttrace_seq_putc(s, ' ');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid\ntrace_print_graph_duration(unsigned long long duration, struct trace_seq *s)\n{\n\tunsigned long nsecs_rem = do_div(duration, 1000);\n\t/* log10(ULONG_MAX) + '\\0' */\n\tchar usecs_str[21];\n\tchar nsecs_str[5];\n\tint len;\n\tint i;\n\n\tsprintf(usecs_str, \"%lu\", (unsigned long) duration);\n\n\t/* Print msecs */\n\ttrace_seq_printf(s, \"%s\", usecs_str);\n\n\tlen = strlen(usecs_str);\n\n\t/* Print nsecs (we don't want to exceed 7 numbers) */\n\tif (len < 7) {\n\t\tsize_t slen = min_t(size_t, sizeof(nsecs_str), 8UL - len);\n\n\t\tsnprintf(nsecs_str, slen, \"%03lu\", nsecs_rem);\n\t\ttrace_seq_printf(s, \".%s\", nsecs_str);\n\t\tlen += strlen(nsecs_str) + 1;\n\t}\n\n\ttrace_seq_puts(s, \" us \");\n\n\t/* Print remaining spaces to fit the row's width */\n\tfor (i = len; i < 8; i++)\n\t\ttrace_seq_putc(s, ' ');\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%c \"",
            "trace_find_mark(duration)"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_mark",
          "args": [
            "duration"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_mark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "532-543",
          "snippet": "char trace_find_mark(unsigned long long d)\n{\n\tint i;\n\tint size = ARRAY_SIZE(mark);\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (d > mark[i].val)\n\t\t\tbreak;\n\t}\n\n\treturn (i == size) ? ' ' : mark[i].sym;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct trace_mark {\n\tunsigned long long\tval; /* unit: nsec */\n\tchar\t\t\tsym;\n} mark[] = {\n\tMARK(1000000000ULL\t, '$'), /* 1 sec */\n\tMARK(100000000ULL\t, '@'), /* 100 msec */\n\tMARK(10000000ULL\t, '*'), /* 10 msec */\n\tMARK(1000000ULL\t\t, '#'), /* 1000 usecs */\n\tMARK(100000ULL\t\t, '!'), /* 100 usecs */\n\tMARK(10000ULL\t\t, '+'), /* 10 usecs */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic const struct trace_mark {\n\tunsigned long long\tval; /* unit: nsec */\n\tchar\t\t\tsym;\n} mark[] = {\n\tMARK(1000000000ULL\t, '$'), /* 1 sec */\n\tMARK(100000000ULL\t, '@'), /* 100 msec */\n\tMARK(10000000ULL\t, '*'), /* 10 msec */\n\tMARK(1000000ULL\t\t, '#'), /* 1000 usecs */\n\tMARK(100000ULL\t\t, '!'), /* 100 usecs */\n\tMARK(10000ULL\t\t, '+'), /* 10 usecs */\n};\n\nchar trace_find_mark(unsigned long long d)\n{\n\tint i;\n\tint size = ARRAY_SIZE(mark);\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (d > mark[i].val)\n\t\t\tbreak;\n\t}\n\n\treturn (i == size) ? ' ' : mark[i].sym;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}"
  },
  {
    "function_name": "trace_print_graph_duration",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "558-589",
    "snippet": "void\ntrace_print_graph_duration(unsigned long long duration, struct trace_seq *s)\n{\n\tunsigned long nsecs_rem = do_div(duration, 1000);\n\t/* log10(ULONG_MAX) + '\\0' */\n\tchar usecs_str[21];\n\tchar nsecs_str[5];\n\tint len;\n\tint i;\n\n\tsprintf(usecs_str, \"%lu\", (unsigned long) duration);\n\n\t/* Print msecs */\n\ttrace_seq_printf(s, \"%s\", usecs_str);\n\n\tlen = strlen(usecs_str);\n\n\t/* Print nsecs (we don't want to exceed 7 numbers) */\n\tif (len < 7) {\n\t\tsize_t slen = min_t(size_t, sizeof(nsecs_str), 8UL - len);\n\n\t\tsnprintf(nsecs_str, slen, \"%03lu\", nsecs_rem);\n\t\ttrace_seq_printf(s, \".%s\", nsecs_str);\n\t\tlen += strlen(nsecs_str) + 1;\n\t}\n\n\ttrace_seq_puts(s, \" us \");\n\n\t/* Print remaining spaces to fit the row's width */\n\tfor (i = len; i < 8; i++)\n\t\ttrace_seq_putc(s, ' ');\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\" us \""
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nsecs_str"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\".%s\"",
            "nsecs_str"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "nsecs_str",
            "slen",
            "\"%03lu\"",
            "nsecs_rem"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "sizeof(nsecs_str)",
            "8UL - len"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "usecs_str",
            "\"%lu\"",
            "(unsigned long) duration"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "duration",
            "1000"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid\ntrace_print_graph_duration(unsigned long long duration, struct trace_seq *s)\n{\n\tunsigned long nsecs_rem = do_div(duration, 1000);\n\t/* log10(ULONG_MAX) + '\\0' */\n\tchar usecs_str[21];\n\tchar nsecs_str[5];\n\tint len;\n\tint i;\n\n\tsprintf(usecs_str, \"%lu\", (unsigned long) duration);\n\n\t/* Print msecs */\n\ttrace_seq_printf(s, \"%s\", usecs_str);\n\n\tlen = strlen(usecs_str);\n\n\t/* Print nsecs (we don't want to exceed 7 numbers) */\n\tif (len < 7) {\n\t\tsize_t slen = min_t(size_t, sizeof(nsecs_str), 8UL - len);\n\n\t\tsnprintf(nsecs_str, slen, \"%03lu\", nsecs_rem);\n\t\ttrace_seq_printf(s, \".%s\", nsecs_str);\n\t\tlen += strlen(nsecs_str) + 1;\n\t}\n\n\ttrace_seq_puts(s, \" us \");\n\n\t/* Print remaining spaces to fit the row's width */\n\tfor (i = len; i < 8; i++)\n\t\ttrace_seq_putc(s, ' ');\n}"
  },
  {
    "function_name": "print_graph_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "510-556",
    "snippet": "static void\nprint_graph_irq(struct trace_iterator *iter, unsigned long addr,\n\t\tenum trace_type type, int cpu, pid_t pid, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\n\tif (addr < (unsigned long)__irqentry_text_start ||\n\t\taddr >= (unsigned long)__irqentry_text_end)\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\t/* Absolute time */\n\t\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\t\tprint_graph_abs_time(iter->ts, s);\n\n\t\t/* Relative time */\n\t\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\t\tprint_graph_rel_time(iter, s);\n\n\t\t/* Cpu */\n\t\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\t\tprint_graph_cpu(s, cpu);\n\n\t\t/* Proc */\n\t\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\t\tprint_graph_proc(s, pid);\n\t\t\ttrace_seq_puts(s, \" | \");\n\t\t}\n\n\t\t/* Latency format */\n\t\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\tprint_graph_lat_fmt(s, ent);\n\t}\n\n\t/* No overhead */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_START);\n\n\tif (type == TRACE_GRAPH_ENT)\n\t\ttrace_seq_puts(s, \"==========>\");\n\telse\n\t\ttrace_seq_puts(s, \"<==========\");\n\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_END);\n\ttrace_seq_putc(s, '\\n');\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_duration",
          "args": [
            "tr",
            "0",
            "s",
            "flags | FLAGS_FILL_END"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_duration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "591-620",
          "snippet": "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"<==========\""
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_lat_fmt",
          "args": [
            "s",
            "ent"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_lat_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "374-379",
          "snippet": "static void print_graph_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\ttrace_seq_putc(s, ' ');\n\ttrace_print_lat_fmt(s, entry);\n\ttrace_seq_puts(s, \" | \");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void print_graph_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\ttrace_seq_putc(s, ' ');\n\ttrace_print_lat_fmt(s, entry);\n\ttrace_seq_puts(s, \" | \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_proc",
          "args": [
            "s",
            "pid"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_proc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "343-371",
          "snippet": "static void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[TASK_COMM_LEN];\n\t/* sign + log10(MAX_INT) + '\\0' */\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t/* 1 stands for the \"-\" character */\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < TRACE_GRAPH_PROCINFO_LENGTH)\n\t\tspaces = TRACE_GRAPH_PROCINFO_LENGTH - len;\n\n\t/* First spaces to align center */\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t/* Last spaces to align center */\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define TRACE_GRAPH_PROCINFO_LENGTH\t14"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_PROCINFO_LENGTH\t14\n\nstatic void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[TASK_COMM_LEN];\n\t/* sign + log10(MAX_INT) + '\\0' */\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t/* 1 stands for the \"-\" character */\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < TRACE_GRAPH_PROCINFO_LENGTH)\n\t\tspaces = TRACE_GRAPH_PROCINFO_LENGTH - len;\n\n\t/* First spaces to align center */\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t/* Last spaces to align center */\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_cpu",
          "args": [
            "s",
            "cpu"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "331-339",
          "snippet": "static void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t/*\n\t * Start with a space character - to make it stand out\n\t * to the right a bit when trace output is pasted into\n\t * email:\n\t */\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int max_bytes_for_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int max_bytes_for_cpu;\n\nstatic void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t/*\n\t * Start with a space character - to make it stand out\n\t * to the right a bit when trace output is pasted into\n\t * email:\n\t */\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_rel_time",
          "args": [
            "iter",
            "s"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_rel_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "499-508",
          "snippet": "static void\nprint_graph_rel_time(struct trace_iterator *iter, struct trace_seq *s)\n{\n\tunsigned long long usecs;\n\n\tusecs = iter->ts - iter->array_buffer->time_start;\n\tdo_div(usecs, NSEC_PER_USEC);\n\n\ttrace_seq_printf(s, \"%9llu us |  \", usecs);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_rel_time(struct trace_iterator *iter, struct trace_seq *s)\n{\n\tunsigned long long usecs;\n\n\tusecs = iter->ts - iter->array_buffer->time_start;\n\tdo_div(usecs, NSEC_PER_USEC);\n\n\ttrace_seq_printf(s, \"%9llu us |  \", usecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_abs_time",
          "args": [
            "iter->ts",
            "s"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_abs_time",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "488-497",
          "snippet": "static void print_graph_abs_time(u64 t, struct trace_seq *s)\n{\n\tunsigned long usecs_rem;\n\n\tusecs_rem = do_div(t, NSEC_PER_SEC);\n\tusecs_rem /= 1000;\n\n\ttrace_seq_printf(s, \"%5lu.%06lu |  \",\n\t\t\t (unsigned long)t, usecs_rem);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void print_graph_abs_time(u64 t, struct trace_seq *s)\n{\n\tunsigned long usecs_rem;\n\n\tusecs_rem = do_div(t, NSEC_PER_SEC);\n\tusecs_rem /= 1000;\n\n\ttrace_seq_printf(s, \"%5lu.%06lu |  \",\n\t\t\t (unsigned long)t, usecs_rem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_irq(struct trace_iterator *iter, unsigned long addr,\n\t\tenum trace_type type, int cpu, pid_t pid, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\n\tif (addr < (unsigned long)__irqentry_text_start ||\n\t\taddr >= (unsigned long)__irqentry_text_end)\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\t/* Absolute time */\n\t\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\t\tprint_graph_abs_time(iter->ts, s);\n\n\t\t/* Relative time */\n\t\tif (flags & TRACE_GRAPH_PRINT_REL_TIME)\n\t\t\tprint_graph_rel_time(iter, s);\n\n\t\t/* Cpu */\n\t\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\t\tprint_graph_cpu(s, cpu);\n\n\t\t/* Proc */\n\t\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\t\tprint_graph_proc(s, pid);\n\t\t\ttrace_seq_puts(s, \" | \");\n\t\t}\n\n\t\t/* Latency format */\n\t\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\tprint_graph_lat_fmt(s, ent);\n\t}\n\n\t/* No overhead */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_START);\n\n\tif (type == TRACE_GRAPH_ENT)\n\t\ttrace_seq_puts(s, \"==========>\");\n\telse\n\t\ttrace_seq_puts(s, \"<==========\");\n\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_END);\n\ttrace_seq_putc(s, '\\n');\n}"
  },
  {
    "function_name": "print_graph_rel_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "499-508",
    "snippet": "static void\nprint_graph_rel_time(struct trace_iterator *iter, struct trace_seq *s)\n{\n\tunsigned long long usecs;\n\n\tusecs = iter->ts - iter->array_buffer->time_start;\n\tdo_div(usecs, NSEC_PER_USEC);\n\n\ttrace_seq_printf(s, \"%9llu us |  \", usecs);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%9llu us |  \"",
            "usecs"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "usecs",
            "NSEC_PER_USEC"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_rel_time(struct trace_iterator *iter, struct trace_seq *s)\n{\n\tunsigned long long usecs;\n\n\tusecs = iter->ts - iter->array_buffer->time_start;\n\tdo_div(usecs, NSEC_PER_USEC);\n\n\ttrace_seq_printf(s, \"%9llu us |  \", usecs);\n}"
  },
  {
    "function_name": "print_graph_abs_time",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "488-497",
    "snippet": "static void print_graph_abs_time(u64 t, struct trace_seq *s)\n{\n\tunsigned long usecs_rem;\n\n\tusecs_rem = do_div(t, NSEC_PER_SEC);\n\tusecs_rem /= 1000;\n\n\ttrace_seq_printf(s, \"%5lu.%06lu |  \",\n\t\t\t (unsigned long)t, usecs_rem);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%5lu.%06lu |  \"",
            "(unsigned long)t",
            "usecs_rem"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "t",
            "NSEC_PER_SEC"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void print_graph_abs_time(u64 t, struct trace_seq *s)\n{\n\tunsigned long usecs_rem;\n\n\tusecs_rem = do_div(t, NSEC_PER_SEC);\n\tusecs_rem /= 1000;\n\n\ttrace_seq_printf(s, \"%5lu.%06lu |  \",\n\t\t\t (unsigned long)t, usecs_rem);\n}"
  },
  {
    "function_name": "get_return_for_leaf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "417-486",
    "snippet": "static struct ftrace_graph_ret_entry *\nget_return_for_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *curr)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct ring_buffer_iter *ring_iter = NULL;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_graph_ret_entry *next;\n\n\t/*\n\t * If the previous output failed to write to the seq buffer,\n\t * then we just reuse the data from before.\n\t */\n\tif (data && data->failed) {\n\t\tcurr = &data->ent;\n\t\tnext = &data->ret;\n\t} else {\n\n\t\tring_iter = trace_buffer_iter(iter, iter->cpu);\n\n\t\t/* First peek to compare current entry and the next one */\n\t\tif (ring_iter)\n\t\t\tevent = ring_buffer_iter_peek(ring_iter, NULL);\n\t\telse {\n\t\t\t/*\n\t\t\t * We need to consume the current entry to see\n\t\t\t * the next one.\n\t\t\t */\n\t\t\tring_buffer_consume(iter->array_buffer->buffer, iter->cpu,\n\t\t\t\t\t    NULL, NULL);\n\t\t\tevent = ring_buffer_peek(iter->array_buffer->buffer, iter->cpu,\n\t\t\t\t\t\t NULL, NULL);\n\t\t}\n\n\t\tif (!event)\n\t\t\treturn NULL;\n\n\t\tnext = ring_buffer_event_data(event);\n\n\t\tif (data) {\n\t\t\t/*\n\t\t\t * Save current and next entries for later reference\n\t\t\t * if the output fails.\n\t\t\t */\n\t\t\tdata->ent = *curr;\n\t\t\t/*\n\t\t\t * If the next event is not a return type, then\n\t\t\t * we only care about what type it is. Otherwise we can\n\t\t\t * safely copy the entire event.\n\t\t\t */\n\t\t\tif (next->ent.type == TRACE_GRAPH_RET)\n\t\t\t\tdata->ret = *next;\n\t\t\telse\n\t\t\t\tdata->ret.ent.type = next->ent.type;\n\t\t}\n\t}\n\n\tif (next->ent.type != TRACE_GRAPH_RET)\n\t\treturn NULL;\n\n\tif (curr->ent.pid != next->ent.pid ||\n\t\t\tcurr->graph_ent.func != next->ret.func)\n\t\treturn NULL;\n\n\t/* this is a leaf, now advance the iterator */\n\tif (ring_iter)\n\t\tring_buffer_iter_advance(ring_iter);\n\n\treturn next;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_iter_advance",
          "args": [
            "ring_iter"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_iter_advance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "5056-5066",
          "snippet": "void ring_buffer_iter_advance(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\n\trb_advance_iter(iter);\n\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid ring_buffer_iter_advance(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\n\trb_advance_iter(iter);\n\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_peek",
          "args": [
            "iter->array_buffer->buffer",
            "iter->cpu",
            "NULL",
            "NULL"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_peek",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "4809-4834",
          "snippet": "struct ring_buffer_event *\nring_buffer_peek(struct trace_buffer *buffer, int cpu, u64 *ts,\n\t\t unsigned long *lost_events)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[cpu];\n\tstruct ring_buffer_event *event;\n\tunsigned long flags;\n\tbool dolock;\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn NULL;\n\n again:\n\tlocal_irq_save(flags);\n\tdolock = rb_reader_lock(cpu_buffer);\n\tevent = rb_buffer_peek(cpu_buffer, ts, lost_events);\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\trb_advance_reader(cpu_buffer);\n\trb_reader_unlock(cpu_buffer, dolock);\n\tlocal_irq_restore(flags);\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\nring_buffer_peek(struct trace_buffer *buffer, int cpu, u64 *ts,\n\t\t unsigned long *lost_events)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[cpu];\n\tstruct ring_buffer_event *event;\n\tunsigned long flags;\n\tbool dolock;\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn NULL;\n\n again:\n\tlocal_irq_save(flags);\n\tdolock = rb_reader_lock(cpu_buffer);\n\tevent = rb_buffer_peek(cpu_buffer, ts, lost_events);\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\trb_advance_reader(cpu_buffer);\n\trb_reader_unlock(cpu_buffer, dolock);\n\tlocal_irq_restore(flags);\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_consume",
          "args": [
            "iter->array_buffer->buffer",
            "iter->cpu",
            "NULL",
            "NULL"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_consume",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "4887-4923",
          "snippet": "struct ring_buffer_event *\nring_buffer_consume(struct trace_buffer *buffer, int cpu, u64 *ts,\n\t\t    unsigned long *lost_events)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event = NULL;\n\tunsigned long flags;\n\tbool dolock;\n\n again:\n\t/* might be called in atomic */\n\tpreempt_disable();\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\tgoto out;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\tlocal_irq_save(flags);\n\tdolock = rb_reader_lock(cpu_buffer);\n\n\tevent = rb_buffer_peek(cpu_buffer, ts, lost_events);\n\tif (event) {\n\t\tcpu_buffer->lost_events = 0;\n\t\trb_advance_reader(cpu_buffer);\n\t}\n\n\trb_reader_unlock(cpu_buffer, dolock);\n\tlocal_irq_restore(flags);\n\n out:\n\tpreempt_enable();\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\nring_buffer_consume(struct trace_buffer *buffer, int cpu, u64 *ts,\n\t\t    unsigned long *lost_events)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event = NULL;\n\tunsigned long flags;\n\tbool dolock;\n\n again:\n\t/* might be called in atomic */\n\tpreempt_disable();\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\tgoto out;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\tlocal_irq_save(flags);\n\tdolock = rb_reader_lock(cpu_buffer);\n\n\tevent = rb_buffer_peek(cpu_buffer, ts, lost_events);\n\tif (event) {\n\t\tcpu_buffer->lost_events = 0;\n\t\trb_advance_reader(cpu_buffer);\n\t}\n\n\trb_reader_unlock(cpu_buffer, dolock);\n\tlocal_irq_restore(flags);\n\n out:\n\tpreempt_enable();\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_iter_peek",
          "args": [
            "ring_iter",
            "NULL"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_iter_peek",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "4858-4874",
          "snippet": "struct ring_buffer_event *\nring_buffer_iter_peek(struct ring_buffer_iter *iter, u64 *ts)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tunsigned long flags;\n\n again:\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\tevent = rb_iter_peek(iter, ts);\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\nring_buffer_iter_peek(struct ring_buffer_iter *iter, u64 *ts)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tunsigned long flags;\n\n again:\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\tevent = rb_iter_peek(iter, ts);\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_iter",
          "args": [
            "iter",
            "iter->cpu"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_iter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "573-577",
          "snippet": "static inline struct ring_buffer_iter *\ntrace_buffer_iter(struct trace_iterator *iter, int cpu)\n{\n\treturn iter->buffer_iter ? iter->buffer_iter[cpu] : NULL;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct ring_buffer_iter *\ntrace_buffer_iter(struct trace_iterator *iter, int cpu)\n{\n\treturn iter->buffer_iter ? iter->buffer_iter[cpu] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct ftrace_graph_ret_entry *\nget_return_for_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *curr)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct ring_buffer_iter *ring_iter = NULL;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_graph_ret_entry *next;\n\n\t/*\n\t * If the previous output failed to write to the seq buffer,\n\t * then we just reuse the data from before.\n\t */\n\tif (data && data->failed) {\n\t\tcurr = &data->ent;\n\t\tnext = &data->ret;\n\t} else {\n\n\t\tring_iter = trace_buffer_iter(iter, iter->cpu);\n\n\t\t/* First peek to compare current entry and the next one */\n\t\tif (ring_iter)\n\t\t\tevent = ring_buffer_iter_peek(ring_iter, NULL);\n\t\telse {\n\t\t\t/*\n\t\t\t * We need to consume the current entry to see\n\t\t\t * the next one.\n\t\t\t */\n\t\t\tring_buffer_consume(iter->array_buffer->buffer, iter->cpu,\n\t\t\t\t\t    NULL, NULL);\n\t\t\tevent = ring_buffer_peek(iter->array_buffer->buffer, iter->cpu,\n\t\t\t\t\t\t NULL, NULL);\n\t\t}\n\n\t\tif (!event)\n\t\t\treturn NULL;\n\n\t\tnext = ring_buffer_event_data(event);\n\n\t\tif (data) {\n\t\t\t/*\n\t\t\t * Save current and next entries for later reference\n\t\t\t * if the output fails.\n\t\t\t */\n\t\t\tdata->ent = *curr;\n\t\t\t/*\n\t\t\t * If the next event is not a return type, then\n\t\t\t * we only care about what type it is. Otherwise we can\n\t\t\t * safely copy the entire event.\n\t\t\t */\n\t\t\tif (next->ent.type == TRACE_GRAPH_RET)\n\t\t\t\tdata->ret = *next;\n\t\t\telse\n\t\t\t\tdata->ret.ent.type = next->ent.type;\n\t\t}\n\t}\n\n\tif (next->ent.type != TRACE_GRAPH_RET)\n\t\treturn NULL;\n\n\tif (curr->ent.pid != next->ent.pid ||\n\t\t\tcurr->graph_ent.func != next->ret.func)\n\t\treturn NULL;\n\n\t/* this is a leaf, now advance the iterator */\n\tif (ring_iter)\n\t\tring_buffer_iter_advance(ring_iter);\n\n\treturn next;\n}"
  },
  {
    "function_name": "verif_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "382-415",
    "snippet": "static void\nverif_pid(struct trace_seq *s, pid_t pid, int cpu, struct fgraph_data *data)\n{\n\tpid_t prev_pid;\n\tpid_t *last_pid;\n\n\tif (!data)\n\t\treturn;\n\n\tlast_pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\n\tif (*last_pid == pid)\n\t\treturn;\n\n\tprev_pid = *last_pid;\n\t*last_pid = pid;\n\n\tif (prev_pid == -1)\n\t\treturn;\n/*\n * Context-switch trace line:\n\n ------------------------------------------\n | 1)  migration/0--1  =>  sshd-1755\n ------------------------------------------\n\n */\n\ttrace_seq_puts(s, \" ------------------------------------------\\n\");\n\tprint_graph_cpu(s, cpu);\n\tprint_graph_proc(s, prev_pid);\n\ttrace_seq_puts(s, \" => \");\n\tprint_graph_proc(s, pid);\n\ttrace_seq_puts(s, \"\\n ------------------------------------------\\n\\n\");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"\\n ------------------------------------------\\n\\n\""
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_proc",
          "args": [
            "s",
            "pid"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_proc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "343-371",
          "snippet": "static void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[TASK_COMM_LEN];\n\t/* sign + log10(MAX_INT) + '\\0' */\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t/* 1 stands for the \"-\" character */\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < TRACE_GRAPH_PROCINFO_LENGTH)\n\t\tspaces = TRACE_GRAPH_PROCINFO_LENGTH - len;\n\n\t/* First spaces to align center */\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t/* Last spaces to align center */\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define TRACE_GRAPH_PROCINFO_LENGTH\t14"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_PROCINFO_LENGTH\t14\n\nstatic void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[TASK_COMM_LEN];\n\t/* sign + log10(MAX_INT) + '\\0' */\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t/* 1 stands for the \"-\" character */\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < TRACE_GRAPH_PROCINFO_LENGTH)\n\t\tspaces = TRACE_GRAPH_PROCINFO_LENGTH - len;\n\n\t/* First spaces to align center */\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t/* Last spaces to align center */\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_cpu",
          "args": [
            "s",
            "cpu"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "331-339",
          "snippet": "static void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t/*\n\t * Start with a space character - to make it stand out\n\t * to the right a bit when trace output is pasted into\n\t * email:\n\t */\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int max_bytes_for_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int max_bytes_for_cpu;\n\nstatic void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t/*\n\t * Start with a space character - to make it stand out\n\t * to the right a bit when trace output is pasted into\n\t * email:\n\t */\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nverif_pid(struct trace_seq *s, pid_t pid, int cpu, struct fgraph_data *data)\n{\n\tpid_t prev_pid;\n\tpid_t *last_pid;\n\n\tif (!data)\n\t\treturn;\n\n\tlast_pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\n\tif (*last_pid == pid)\n\t\treturn;\n\n\tprev_pid = *last_pid;\n\t*last_pid = pid;\n\n\tif (prev_pid == -1)\n\t\treturn;\n/*\n * Context-switch trace line:\n\n ------------------------------------------\n | 1)  migration/0--1  =>  sshd-1755\n ------------------------------------------\n\n */\n\ttrace_seq_puts(s, \" ------------------------------------------\\n\");\n\tprint_graph_cpu(s, cpu);\n\tprint_graph_proc(s, prev_pid);\n\ttrace_seq_puts(s, \" => \");\n\tprint_graph_proc(s, pid);\n\ttrace_seq_puts(s, \"\\n ------------------------------------------\\n\\n\");\n}"
  },
  {
    "function_name": "print_graph_lat_fmt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "374-379",
    "snippet": "static void print_graph_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\ttrace_seq_putc(s, ' ');\n\ttrace_print_lat_fmt(s, entry);\n\ttrace_seq_puts(s, \" | \");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\" | \""
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_lat_fmt",
          "args": [
            "s",
            "entry"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_lat_fmt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_output.c",
          "lines": "441-501",
          "snippet": "int trace_print_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\tchar hardsoft_irq;\n\tchar need_resched;\n\tchar irqs_off;\n\tint hardirq;\n\tint softirq;\n\tint bh_off;\n\tint nmi;\n\n\tnmi = entry->flags & TRACE_FLAG_NMI;\n\thardirq = entry->flags & TRACE_FLAG_HARDIRQ;\n\tsoftirq = entry->flags & TRACE_FLAG_SOFTIRQ;\n\tbh_off = entry->flags & TRACE_FLAG_BH_OFF;\n\n\tirqs_off =\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF && bh_off) ? 'D' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF) ? 'd' :\n\t\tbh_off ? 'b' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_NOSUPPORT) ? 'X' :\n\t\t'.';\n\n\tswitch (entry->flags & (TRACE_FLAG_NEED_RESCHED |\n\t\t\t\tTRACE_FLAG_PREEMPT_RESCHED)) {\n\tcase TRACE_FLAG_NEED_RESCHED | TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'N';\n\t\tbreak;\n\tcase TRACE_FLAG_NEED_RESCHED:\n\t\tneed_resched = 'n';\n\t\tbreak;\n\tcase TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'p';\n\t\tbreak;\n\tdefault:\n\t\tneed_resched = '.';\n\t\tbreak;\n\t}\n\n\thardsoft_irq =\n\t\t(nmi && hardirq)     ? 'Z' :\n\t\tnmi                  ? 'z' :\n\t\t(hardirq && softirq) ? 'H' :\n\t\thardirq              ? 'h' :\n\t\tsoftirq              ? 's' :\n\t\t                       '.' ;\n\n\ttrace_seq_printf(s, \"%c%c%c\",\n\t\t\t irqs_off, need_resched, hardsoft_irq);\n\n\tif (entry->preempt_count & 0xf)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count & 0xf);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\tif (entry->preempt_count & 0xf0)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count >> 4);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\treturn !trace_seq_has_overflowed(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint trace_print_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\tchar hardsoft_irq;\n\tchar need_resched;\n\tchar irqs_off;\n\tint hardirq;\n\tint softirq;\n\tint bh_off;\n\tint nmi;\n\n\tnmi = entry->flags & TRACE_FLAG_NMI;\n\thardirq = entry->flags & TRACE_FLAG_HARDIRQ;\n\tsoftirq = entry->flags & TRACE_FLAG_SOFTIRQ;\n\tbh_off = entry->flags & TRACE_FLAG_BH_OFF;\n\n\tirqs_off =\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF && bh_off) ? 'D' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF) ? 'd' :\n\t\tbh_off ? 'b' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_NOSUPPORT) ? 'X' :\n\t\t'.';\n\n\tswitch (entry->flags & (TRACE_FLAG_NEED_RESCHED |\n\t\t\t\tTRACE_FLAG_PREEMPT_RESCHED)) {\n\tcase TRACE_FLAG_NEED_RESCHED | TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'N';\n\t\tbreak;\n\tcase TRACE_FLAG_NEED_RESCHED:\n\t\tneed_resched = 'n';\n\t\tbreak;\n\tcase TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'p';\n\t\tbreak;\n\tdefault:\n\t\tneed_resched = '.';\n\t\tbreak;\n\t}\n\n\thardsoft_irq =\n\t\t(nmi && hardirq)     ? 'Z' :\n\t\tnmi                  ? 'z' :\n\t\t(hardirq && softirq) ? 'H' :\n\t\thardirq              ? 'h' :\n\t\tsoftirq              ? 's' :\n\t\t                       '.' ;\n\n\ttrace_seq_printf(s, \"%c%c%c\",\n\t\t\t irqs_off, need_resched, hardsoft_irq);\n\n\tif (entry->preempt_count & 0xf)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count & 0xf);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\tif (entry->preempt_count & 0xf0)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count >> 4);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\treturn !trace_seq_has_overflowed(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void print_graph_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\ttrace_seq_putc(s, ' ');\n\ttrace_print_lat_fmt(s, entry);\n\ttrace_seq_puts(s, \" | \");\n}"
  },
  {
    "function_name": "print_graph_proc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "343-371",
    "snippet": "static void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[TASK_COMM_LEN];\n\t/* sign + log10(MAX_INT) + '\\0' */\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t/* 1 stands for the \"-\" character */\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < TRACE_GRAPH_PROCINFO_LENGTH)\n\t\tspaces = TRACE_GRAPH_PROCINFO_LENGTH - len;\n\n\t/* First spaces to align center */\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t/* Last spaces to align center */\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define TRACE_GRAPH_PROCINFO_LENGTH\t14"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s-%s\"",
            "comm",
            "pid_str"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pid_str"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "pid_str",
            "\"%d\"",
            "pid"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_find_cmdline",
          "args": [
            "pid",
            "comm"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_cmdline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2443-2452",
          "snippet": "void trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_PROCINFO_LENGTH\t14\n\nstatic void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[TASK_COMM_LEN];\n\t/* sign + log10(MAX_INT) + '\\0' */\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t/* 1 stands for the \"-\" character */\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < TRACE_GRAPH_PROCINFO_LENGTH)\n\t\tspaces = TRACE_GRAPH_PROCINFO_LENGTH - len;\n\n\t/* First spaces to align center */\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t/* Last spaces to align center */\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}"
  },
  {
    "function_name": "print_graph_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "331-339",
    "snippet": "static void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t/*\n\t * Start with a space character - to make it stand out\n\t * to the right a bit when trace output is pasted into\n\t * email:\n\t */\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int max_bytes_for_cpu;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\" %*d) \"",
            "max_bytes_for_cpu",
            "cpu"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int max_bytes_for_cpu;\n\nstatic void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t/*\n\t * Start with a space character - to make it stand out\n\t * to the right a bit when trace output is pasted into\n\t * email:\n\t */\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}"
  },
  {
    "function_name": "graph_trace_update_thresh",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "323-327",
    "snippet": "static int graph_trace_update_thresh(struct trace_array *tr)\n{\n\tgraph_trace_reset(tr);\n\treturn graph_trace_init(tr);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "graph_trace_init",
          "args": [
            "tr"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "graph_trace_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "298-312",
          "snippet": "static int graph_trace_init(struct trace_array *tr)\n{\n\tint ret;\n\n\tset_graph_array(tr);\n\tif (tracing_thresh)\n\t\tret = register_ftrace_graph(&funcgraph_thresh_ops);\n\telse\n\t\tret = register_ftrace_graph(&funcgraph_ops);\n\tif (ret)\n\t\treturn ret;\n\ttracing_start_cmdline_record();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fgraph_ops funcgraph_thresh_ops = {\n\t.entryfunc = &trace_graph_entry,\n\t.retfunc = &trace_graph_thresh_return,\n};",
            "static struct fgraph_ops funcgraph_ops = {\n\t.entryfunc = &trace_graph_entry,\n\t.retfunc = &trace_graph_return,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct fgraph_ops funcgraph_thresh_ops = {\n\t.entryfunc = &trace_graph_entry,\n\t.retfunc = &trace_graph_thresh_return,\n};\nstatic struct fgraph_ops funcgraph_ops = {\n\t.entryfunc = &trace_graph_entry,\n\t.retfunc = &trace_graph_return,\n};\n\nstatic int graph_trace_init(struct trace_array *tr)\n{\n\tint ret;\n\n\tset_graph_array(tr);\n\tif (tracing_thresh)\n\t\tret = register_ftrace_graph(&funcgraph_thresh_ops);\n\telse\n\t\tret = register_ftrace_graph(&funcgraph_ops);\n\tif (ret)\n\t\treturn ret;\n\ttracing_start_cmdline_record();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "graph_trace_reset",
          "args": [
            "tr"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "graph_trace_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "314-321",
          "snippet": "static void graph_trace_reset(struct trace_array *tr)\n{\n\ttracing_stop_cmdline_record();\n\tif (tracing_thresh)\n\t\tunregister_ftrace_graph(&funcgraph_thresh_ops);\n\telse\n\t\tunregister_ftrace_graph(&funcgraph_ops);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fgraph_ops funcgraph_thresh_ops = {\n\t.entryfunc = &trace_graph_entry,\n\t.retfunc = &trace_graph_thresh_return,\n};",
            "static struct fgraph_ops funcgraph_ops = {\n\t.entryfunc = &trace_graph_entry,\n\t.retfunc = &trace_graph_return,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct fgraph_ops funcgraph_thresh_ops = {\n\t.entryfunc = &trace_graph_entry,\n\t.retfunc = &trace_graph_thresh_return,\n};\nstatic struct fgraph_ops funcgraph_ops = {\n\t.entryfunc = &trace_graph_entry,\n\t.retfunc = &trace_graph_return,\n};\n\nstatic void graph_trace_reset(struct trace_array *tr)\n{\n\ttracing_stop_cmdline_record();\n\tif (tracing_thresh)\n\t\tunregister_ftrace_graph(&funcgraph_thresh_ops);\n\telse\n\t\tunregister_ftrace_graph(&funcgraph_ops);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int graph_trace_update_thresh(struct trace_array *tr)\n{\n\tgraph_trace_reset(tr);\n\treturn graph_trace_init(tr);\n}"
  },
  {
    "function_name": "graph_trace_reset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "314-321",
    "snippet": "static void graph_trace_reset(struct trace_array *tr)\n{\n\ttracing_stop_cmdline_record();\n\tif (tracing_thresh)\n\t\tunregister_ftrace_graph(&funcgraph_thresh_ops);\n\telse\n\t\tunregister_ftrace_graph(&funcgraph_ops);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fgraph_ops funcgraph_thresh_ops = {\n\t.entryfunc = &trace_graph_entry,\n\t.retfunc = &trace_graph_thresh_return,\n};",
      "static struct fgraph_ops funcgraph_ops = {\n\t.entryfunc = &trace_graph_entry,\n\t.retfunc = &trace_graph_return,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_graph",
          "args": [
            "&funcgraph_ops"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_graph",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/fgraph.c",
          "lines": "636-653",
          "snippet": "void unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"ftrace_internal.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_graph_active;",
            "static struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};",
            "static struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};",
            "trace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;",
            "trace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;",
            "static trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ftrace_internal.h\"\n#include <trace/events/sched.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n\nint ftrace_graph_active;\nstatic struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};\nstatic struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};\ntrace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;\ntrace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;\nstatic trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;\n\nvoid unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop_cmdline_record",
          "args": [],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_cmdline_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "136-139",
          "snippet": "void tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct fgraph_ops funcgraph_thresh_ops = {\n\t.entryfunc = &trace_graph_entry,\n\t.retfunc = &trace_graph_thresh_return,\n};\nstatic struct fgraph_ops funcgraph_ops = {\n\t.entryfunc = &trace_graph_entry,\n\t.retfunc = &trace_graph_return,\n};\n\nstatic void graph_trace_reset(struct trace_array *tr)\n{\n\ttracing_stop_cmdline_record();\n\tif (tracing_thresh)\n\t\tunregister_ftrace_graph(&funcgraph_thresh_ops);\n\telse\n\t\tunregister_ftrace_graph(&funcgraph_ops);\n}"
  },
  {
    "function_name": "graph_trace_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "298-312",
    "snippet": "static int graph_trace_init(struct trace_array *tr)\n{\n\tint ret;\n\n\tset_graph_array(tr);\n\tif (tracing_thresh)\n\t\tret = register_ftrace_graph(&funcgraph_thresh_ops);\n\telse\n\t\tret = register_ftrace_graph(&funcgraph_ops);\n\tif (ret)\n\t\treturn ret;\n\ttracing_start_cmdline_record();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fgraph_ops funcgraph_thresh_ops = {\n\t.entryfunc = &trace_graph_entry,\n\t.retfunc = &trace_graph_thresh_return,\n};",
      "static struct fgraph_ops funcgraph_ops = {\n\t.entryfunc = &trace_graph_entry,\n\t.retfunc = &trace_graph_return,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_start_cmdline_record",
          "args": [],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_cmdline_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "131-134",
          "snippet": "void tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_ftrace_graph",
          "args": [
            "&funcgraph_ops"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_graph",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/fgraph.c",
          "lines": "636-653",
          "snippet": "void unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"ftrace_internal.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_graph_active;",
            "static struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};",
            "static struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};",
            "trace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;",
            "trace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;",
            "static trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ftrace_internal.h\"\n#include <trace/events/sched.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n\nint ftrace_graph_active;\nstatic struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};\nstatic struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};\ntrace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;\ntrace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;\nstatic trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;\n\nvoid unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_graph_array",
          "args": [
            "tr"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "set_graph_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "263-270",
          "snippet": "void set_graph_array(struct trace_array *tr)\n{\n\tgraph_array = tr;\n\n\t/* Make graph_array visible before we start tracing */\n\n\tsmp_mb();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array *graph_array;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct trace_array *graph_array;\n\nvoid set_graph_array(struct trace_array *tr)\n{\n\tgraph_array = tr;\n\n\t/* Make graph_array visible before we start tracing */\n\n\tsmp_mb();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct fgraph_ops funcgraph_thresh_ops = {\n\t.entryfunc = &trace_graph_entry,\n\t.retfunc = &trace_graph_thresh_return,\n};\nstatic struct fgraph_ops funcgraph_ops = {\n\t.entryfunc = &trace_graph_entry,\n\t.retfunc = &trace_graph_return,\n};\n\nstatic int graph_trace_init(struct trace_array *tr)\n{\n\tint ret;\n\n\tset_graph_array(tr);\n\tif (tracing_thresh)\n\t\tret = register_ftrace_graph(&funcgraph_thresh_ops);\n\telse\n\t\tret = register_ftrace_graph(&funcgraph_ops);\n\tif (ret)\n\t\treturn ret;\n\ttracing_start_cmdline_record();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_graph_thresh_return",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "272-286",
    "snippet": "static void trace_graph_thresh_return(struct ftrace_graph_ret *trace)\n{\n\tftrace_graph_addr_finish(trace);\n\n\tif (trace_recursion_test(TRACE_GRAPH_NOTRACE_BIT)) {\n\t\ttrace_recursion_clear(TRACE_GRAPH_NOTRACE_BIT);\n\t\treturn;\n\t}\n\n\tif (tracing_thresh &&\n\t    (trace->rettime - trace->calltime < tracing_thresh))\n\t\treturn;\n\telse\n\t\ttrace_graph_return(trace);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_graph_return",
          "args": [
            "trace"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "trace_graph_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "235-261",
          "snippet": "void trace_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct trace_array *tr = graph_array;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\tlong disabled;\n\tint cpu;\n\n\tftrace_graph_addr_finish(trace);\n\n\tif (trace_recursion_test(TRACE_GRAPH_NOTRACE_BIT)) {\n\t\ttrace_recursion_clear(TRACE_GRAPH_NOTRACE_BIT);\n\t\treturn;\n\t}\n\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\tif (likely(disabled == 1)) {\n\t\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\t\t__trace_graph_return(tr, trace, trace_ctx);\n\t}\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array *graph_array;",
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct trace_array *graph_array;\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid trace_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct trace_array *tr = graph_array;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\tlong disabled;\n\tint cpu;\n\n\tftrace_graph_addr_finish(trace);\n\n\tif (trace_recursion_test(TRACE_GRAPH_NOTRACE_BIT)) {\n\t\ttrace_recursion_clear(TRACE_GRAPH_NOTRACE_BIT);\n\t\treturn;\n\t}\n\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\tif (likely(disabled == 1)) {\n\t\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\t\t__trace_graph_return(tr, trace, trace_ctx);\n\t}\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_recursion_clear",
          "args": [
            "TRACE_GRAPH_NOTRACE_BIT"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_recursion_test",
          "args": [
            "TRACE_GRAPH_NOTRACE_BIT"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_graph_addr_finish",
          "args": [
            "trace"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_addr_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "947-948",
          "snippet": "static inline void ftrace_graph_addr_finish(struct ftrace_graph_ret *trace)\n{ }",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void ftrace_graph_addr_finish(struct ftrace_graph_ret *trace)\n{ }"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void trace_graph_thresh_return(struct ftrace_graph_ret *trace)\n{\n\tftrace_graph_addr_finish(trace);\n\n\tif (trace_recursion_test(TRACE_GRAPH_NOTRACE_BIT)) {\n\t\ttrace_recursion_clear(TRACE_GRAPH_NOTRACE_BIT);\n\t\treturn;\n\t}\n\n\tif (tracing_thresh &&\n\t    (trace->rettime - trace->calltime < tracing_thresh))\n\t\treturn;\n\telse\n\t\ttrace_graph_return(trace);\n}"
  },
  {
    "function_name": "set_graph_array",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "263-270",
    "snippet": "void set_graph_array(struct trace_array *tr)\n{\n\tgraph_array = tr;\n\n\t/* Make graph_array visible before we start tracing */\n\n\tsmp_mb();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array *graph_array;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct trace_array *graph_array;\n\nvoid set_graph_array(struct trace_array *tr)\n{\n\tgraph_array = tr;\n\n\t/* Make graph_array visible before we start tracing */\n\n\tsmp_mb();\n}"
  },
  {
    "function_name": "trace_graph_return",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "235-261",
    "snippet": "void trace_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct trace_array *tr = graph_array;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\tlong disabled;\n\tint cpu;\n\n\tftrace_graph_addr_finish(trace);\n\n\tif (trace_recursion_test(TRACE_GRAPH_NOTRACE_BIT)) {\n\t\ttrace_recursion_clear(TRACE_GRAPH_NOTRACE_BIT);\n\t\treturn;\n\t}\n\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\tif (likely(disabled == 1)) {\n\t\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\t\t__trace_graph_return(tr, trace, trace_ctx);\n\t}\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array *graph_array;",
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_graph_return",
          "args": [
            "tr",
            "trace",
            "trace_ctx"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_graph_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "216-233",
          "snippet": "void __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx_flags",
          "args": [
            "flags"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "disabled == 1"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&data->disabled"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->array_buffer.data",
            "cpu"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_recursion_clear",
          "args": [
            "TRACE_GRAPH_NOTRACE_BIT"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_recursion_test",
          "args": [
            "TRACE_GRAPH_NOTRACE_BIT"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_graph_addr_finish",
          "args": [
            "trace"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_addr_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "947-948",
          "snippet": "static inline void ftrace_graph_addr_finish(struct ftrace_graph_ret *trace)\n{ }",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void ftrace_graph_addr_finish(struct ftrace_graph_ret *trace)\n{ }"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct trace_array *graph_array;\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid trace_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct trace_array *tr = graph_array;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\tlong disabled;\n\tint cpu;\n\n\tftrace_graph_addr_finish(trace);\n\n\tif (trace_recursion_test(TRACE_GRAPH_NOTRACE_BIT)) {\n\t\ttrace_recursion_clear(TRACE_GRAPH_NOTRACE_BIT);\n\t\treturn;\n\t}\n\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\tif (likely(disabled == 1)) {\n\t\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\t\t__trace_graph_return(tr, trace, trace_ctx);\n\t}\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "__trace_graph_return",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "216-233",
    "snippet": "void __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit_nostack",
          "args": [
            "buffer",
            "event"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit_nostack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2948-2953",
          "snippet": "void\ntrace_buffer_unlock_commit_nostack(struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\ntrace_buffer_unlock_commit_nostack(struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "502-513",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_GRAPH_RET",
            "sizeof(*entry)",
            "trace_ctx"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2617-2624",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
  },
  {
    "function_name": "trace_graph_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "208-214",
    "snippet": "void\ntrace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned long parent_ip,\n\t\tunsigned int trace_ctx)\n{\n\t__trace_graph_function(tr, ip, trace_ctx);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__trace_graph_function",
          "args": [
            "tr",
            "ip",
            "trace_ctx"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_graph_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "188-206",
          "snippet": "static void\n__trace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned int trace_ctx)\n{\n\tu64 time = trace_clock_local();\n\tstruct ftrace_graph_ent ent = {\n\t\t.func  = ip,\n\t\t.depth = 0,\n\t};\n\tstruct ftrace_graph_ret ret = {\n\t\t.func     = ip,\n\t\t.depth    = 0,\n\t\t.calltime = time,\n\t\t.rettime  = time,\n\t};\n\n\t__trace_graph_entry(tr, &ent, trace_ctx);\n\t__trace_graph_return(tr, &ret, trace_ctx);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\n__trace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned int trace_ctx)\n{\n\tu64 time = trace_clock_local();\n\tstruct ftrace_graph_ent ent = {\n\t\t.func  = ip,\n\t\t.depth = 0,\n\t};\n\tstruct ftrace_graph_ret ret = {\n\t\t.func     = ip,\n\t\t.depth    = 0,\n\t\t.calltime = time,\n\t\t.rettime  = time,\n\t};\n\n\t__trace_graph_entry(tr, &ent, trace_ctx);\n\t__trace_graph_return(tr, &ret, trace_ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid\ntrace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned long parent_ip,\n\t\tunsigned int trace_ctx)\n{\n\t__trace_graph_function(tr, ip, trace_ctx);\n}"
  },
  {
    "function_name": "__trace_graph_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "188-206",
    "snippet": "static void\n__trace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned int trace_ctx)\n{\n\tu64 time = trace_clock_local();\n\tstruct ftrace_graph_ent ent = {\n\t\t.func  = ip,\n\t\t.depth = 0,\n\t};\n\tstruct ftrace_graph_ret ret = {\n\t\t.func     = ip,\n\t\t.depth    = 0,\n\t\t.calltime = time,\n\t\t.rettime  = time,\n\t};\n\n\t__trace_graph_entry(tr, &ent, trace_ctx);\n\t__trace_graph_return(tr, &ret, trace_ctx);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__trace_graph_return",
          "args": [
            "tr",
            "&ret",
            "trace_ctx"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_graph_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "216-233",
          "snippet": "void __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_graph_entry",
          "args": [
            "tr",
            "&ent",
            "trace_ctx"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_graph_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "97-116",
          "snippet": "int __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nint __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_clock_local",
          "args": [],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "trace_clock_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_clock.c",
          "lines": "32-46",
          "snippet": "u64 notrace trace_clock_local(void)\n{\n\tu64 clock;\n\n\t/*\n\t * sched_clock() is an architecture implemented, fast, scalable,\n\t * lockless clock. It is not guaranteed to be coherent across\n\t * CPUs, nor across CPU idle events.\n\t */\n\tpreempt_disable_notrace();\n\tclock = sched_clock();\n\tpreempt_enable_notrace();\n\n\treturn clock;\n}",
          "includes": [
            "#include <linux/trace_clock.h>",
            "#include <linux/ktime.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_clock.h>\n#include <linux/ktime.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/hardirq.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n\nu64 notrace trace_clock_local(void)\n{\n\tu64 clock;\n\n\t/*\n\t * sched_clock() is an architecture implemented, fast, scalable,\n\t * lockless clock. It is not guaranteed to be coherent across\n\t * CPUs, nor across CPU idle events.\n\t */\n\tpreempt_disable_notrace();\n\tclock = sched_clock();\n\tpreempt_enable_notrace();\n\n\treturn clock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\n__trace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned int trace_ctx)\n{\n\tu64 time = trace_clock_local();\n\tstruct ftrace_graph_ent ent = {\n\t\t.func  = ip,\n\t\t.depth = 0,\n\t};\n\tstruct ftrace_graph_ret ret = {\n\t\t.func     = ip,\n\t\t.depth    = 0,\n\t\t.calltime = time,\n\t\t.rettime  = time,\n\t};\n\n\t__trace_graph_entry(tr, &ent, trace_ctx);\n\t__trace_graph_return(tr, &ret, trace_ctx);\n}"
  },
  {
    "function_name": "trace_graph_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "126-186",
    "snippet": "int trace_graph_entry(struct ftrace_graph_ent *trace)\n{\n\tstruct trace_array *tr = graph_array;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\tlong disabled;\n\tint ret;\n\tint cpu;\n\n\tif (trace_recursion_test(TRACE_GRAPH_NOTRACE_BIT))\n\t\treturn 0;\n\n\t/*\n\t * Do not trace a function if it's filtered by set_graph_notrace.\n\t * Make the index of ret stack negative to indicate that it should\n\t * ignore further functions.  But it needs its own ret stack entry\n\t * to recover the original index in order to continue tracing after\n\t * returning from the function.\n\t */\n\tif (ftrace_graph_notrace_addr(trace->func)) {\n\t\ttrace_recursion_set(TRACE_GRAPH_NOTRACE_BIT);\n\t\t/*\n\t\t * Need to return 1 to have the return called\n\t\t * that will clear the NOTRACE bit.\n\t\t */\n\t\treturn 1;\n\t}\n\n\tif (!ftrace_trace_task(tr))\n\t\treturn 0;\n\n\tif (ftrace_graph_ignore_func(trace))\n\t\treturn 0;\n\n\tif (ftrace_graph_ignore_irqs())\n\t\treturn 0;\n\n\t/*\n\t * Stop here if tracing_threshold is set. We only write function return\n\t * events to the ring buffer.\n\t */\n\tif (tracing_thresh)\n\t\treturn 1;\n\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\tif (likely(disabled == 1)) {\n\t\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\t\tret = __trace_graph_entry(tr, trace, trace_ctx);\n\t} else {\n\t\tret = 0;\n\t}\n\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array *graph_array;",
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_graph_entry",
          "args": [
            "tr",
            "trace",
            "trace_ctx"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_graph_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "97-116",
          "snippet": "int __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nint __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_gen_ctx_flags",
          "args": [
            "flags"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "disabled == 1"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&data->disabled"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->array_buffer.data",
            "cpu"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_graph_ignore_irqs",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_ignore_irqs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "118-124",
          "snippet": "static inline int ftrace_graph_ignore_irqs(void)\n{\n\tif (!ftrace_graph_skip_irqs || trace_recursion_test(TRACE_IRQ_BIT))\n\t\treturn 0;\n\n\treturn in_hardirq();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_graph_skip_irqs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int ftrace_graph_skip_irqs;\n\nstatic inline int ftrace_graph_ignore_irqs(void)\n{\n\tif (!ftrace_graph_skip_irqs || trace_recursion_test(TRACE_IRQ_BIT))\n\t\treturn 0;\n\n\treturn in_hardirq();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_ignore_func",
          "args": [
            "trace"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_ignore_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "953-960",
          "snippet": "static inline bool ftrace_graph_ignore_func(struct ftrace_graph_ent *trace)\n{\n\t/* trace it when it is-nested-in or is a function enabled. */\n\treturn !(trace_recursion_test(TRACE_GRAPH_BIT) ||\n\t\t ftrace_graph_addr(trace)) ||\n\t\t(trace->depth < 0) ||\n\t\t(fgraph_max_depth && trace->depth >= fgraph_max_depth);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool ftrace_graph_ignore_func(struct ftrace_graph_ent *trace)\n{\n\t/* trace it when it is-nested-in or is a function enabled. */\n\treturn !(trace_recursion_test(TRACE_GRAPH_BIT) ||\n\t\t ftrace_graph_addr(trace)) ||\n\t\t(trace->depth < 0) ||\n\t\t(fgraph_max_depth && trace->depth >= fgraph_max_depth);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_trace_task",
          "args": [
            "tr"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_trace_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1007-1010",
          "snippet": "static inline int ftrace_trace_task(struct trace_array *tr)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline int ftrace_trace_task(struct trace_array *tr)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_recursion_set",
          "args": [
            "TRACE_GRAPH_NOTRACE_BIT"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_graph_notrace_addr",
          "args": [
            "trace->func"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_notrace_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "943-946",
          "snippet": "static inline int ftrace_graph_notrace_addr(unsigned long addr)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline int ftrace_graph_notrace_addr(unsigned long addr)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_recursion_test",
          "args": [
            "TRACE_GRAPH_NOTRACE_BIT"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct trace_array *graph_array;\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nint trace_graph_entry(struct ftrace_graph_ent *trace)\n{\n\tstruct trace_array *tr = graph_array;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tunsigned int trace_ctx;\n\tlong disabled;\n\tint ret;\n\tint cpu;\n\n\tif (trace_recursion_test(TRACE_GRAPH_NOTRACE_BIT))\n\t\treturn 0;\n\n\t/*\n\t * Do not trace a function if it's filtered by set_graph_notrace.\n\t * Make the index of ret stack negative to indicate that it should\n\t * ignore further functions.  But it needs its own ret stack entry\n\t * to recover the original index in order to continue tracing after\n\t * returning from the function.\n\t */\n\tif (ftrace_graph_notrace_addr(trace->func)) {\n\t\ttrace_recursion_set(TRACE_GRAPH_NOTRACE_BIT);\n\t\t/*\n\t\t * Need to return 1 to have the return called\n\t\t * that will clear the NOTRACE bit.\n\t\t */\n\t\treturn 1;\n\t}\n\n\tif (!ftrace_trace_task(tr))\n\t\treturn 0;\n\n\tif (ftrace_graph_ignore_func(trace))\n\t\treturn 0;\n\n\tif (ftrace_graph_ignore_irqs())\n\t\treturn 0;\n\n\t/*\n\t * Stop here if tracing_threshold is set. We only write function return\n\t * events to the ring buffer.\n\t */\n\tif (tracing_thresh)\n\t\treturn 1;\n\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->array_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\tif (likely(disabled == 1)) {\n\t\ttrace_ctx = tracing_gen_ctx_flags(flags);\n\t\tret = __trace_graph_entry(tr, trace, trace_ctx);\n\t} else {\n\t\tret = 0;\n\t}\n\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_graph_ignore_irqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "118-124",
    "snippet": "static inline int ftrace_graph_ignore_irqs(void)\n{\n\tif (!ftrace_graph_skip_irqs || trace_recursion_test(TRACE_IRQ_BIT))\n\t\treturn 0;\n\n\treturn in_hardirq();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_graph_skip_irqs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_hardirq",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_recursion_test",
          "args": [
            "TRACE_IRQ_BIT"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int ftrace_graph_skip_irqs;\n\nstatic inline int ftrace_graph_ignore_irqs(void)\n{\n\tif (!ftrace_graph_skip_irqs || trace_recursion_test(TRACE_IRQ_BIT))\n\t\treturn 0;\n\n\treturn in_hardirq();\n}"
  },
  {
    "function_name": "__trace_graph_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
    "lines": "97-116",
    "snippet": "int __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit_nostack",
          "args": [
            "buffer",
            "event"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit_nostack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2948-2953",
          "snippet": "void\ntrace_buffer_unlock_commit_nostack(struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\ntrace_buffer_unlock_commit_nostack(struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "502-513",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_GRAPH_ENT",
            "sizeof(*entry)",
            "trace_ctx"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2617-2624",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic void ftrace_trace_userstack(struct trace_array *tr,\n\t\t\t\t   struct trace_buffer *buffer,\n\t\t\t\t   unsigned int trace_ctx);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned int trace_ctx)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, trace_ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nint __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned int trace_ctx)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), trace_ctx);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}"
  }
]