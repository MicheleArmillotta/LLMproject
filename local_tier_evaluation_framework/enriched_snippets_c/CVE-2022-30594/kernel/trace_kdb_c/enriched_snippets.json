[
  {
    "function_name": "kdb_ftrace_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kdb.c",
    "lines": "158-162",
    "snippet": "static __init int kdb_ftrace_register(void)\n{\n\tkdb_register(&ftdump_cmd);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static kdbtab_t ftdump_cmd = {\n\t.name = \"ftdump\",\n\t.func = kdb_ftdump,\n\t.usage = \"[skip_#entries] [cpu]\",\n\t.help = \"Dump ftrace log; -skip dumps last #entries\",\n\t.flags = KDB_ENABLE_ALWAYS_SAFE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_register",
          "args": [
            "&ftdump_cmd"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2630-2644",
          "snippet": "int kdb_register(kdbtab_t *cmd)\n{\n\tkdbtab_t *kp;\n\n\tlist_for_each_entry(kp, &kdb_cmds_head, list_node) {\n\t\tif (strcmp(kp->name, cmd->name) == 0) {\n\t\t\tkdb_printf(\"Duplicate kdb cmd: %s, func %p help %s\\n\",\n\t\t\t\t   cmd->name, cmd->func, cmd->help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tlist_add_tail(&cmd->list_node, &kdb_cmds_head);\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kdb_cmds_head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic LIST_HEAD(kdb_cmds_head);\n\nint kdb_register(kdbtab_t *cmd)\n{\n\tkdbtab_t *kp;\n\n\tlist_for_each_entry(kp, &kdb_cmds_head, list_node) {\n\t\tif (strcmp(kp->name, cmd->name) == 0) {\n\t\t\tkdb_printf(\"Duplicate kdb cmd: %s, func %p help %s\\n\",\n\t\t\t\t   cmd->name, cmd->func, cmd->help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tlist_add_tail(&cmd->list_node, &kdb_cmds_head);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n\nstatic kdbtab_t ftdump_cmd = {\n\t.name = \"ftdump\",\n\t.func = kdb_ftdump,\n\t.usage = \"[skip_#entries] [cpu]\",\n\t.help = \"Dump ftrace log; -skip dumps last #entries\",\n\t.flags = KDB_ENABLE_ALWAYS_SAFE,\n};\n\nstatic __init int kdb_ftrace_register(void)\n{\n\tkdb_register(&ftdump_cmd);\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_ftdump",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kdb.c",
    "lines": "95-148",
    "snippet": "static int kdb_ftdump(int argc, const char **argv)\n{\n\tint skip_entries = 0;\n\tlong cpu_file;\n\tchar *cp;\n\tint cnt;\n\tint cpu;\n\n\tif (argc > 2)\n\t\treturn KDB_ARGCOUNT;\n\n\tif (argc) {\n\t\tskip_entries = simple_strtol(argv[1], &cp, 0);\n\t\tif (*cp)\n\t\t\tskip_entries = 0;\n\t}\n\n\tif (argc == 2) {\n\t\tcpu_file = simple_strtol(argv[2], &cp, 0);\n\t\tif (*cp || cpu_file >= NR_CPUS || cpu_file < 0 ||\n\t\t    !cpu_online(cpu_file))\n\t\t\treturn KDB_BADINT;\n\t} else {\n\t\tcpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tkdb_trap_printk++;\n\n\ttrace_init_global_iter(&iter);\n\titer.buffer_iter = buffer_iter;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\n\t/* A negative skip_entries means skip all but the last entries */\n\tif (skip_entries < 0) {\n\t\tif (cpu_file == RING_BUFFER_ALL_CPUS)\n\t\t\tcnt = trace_total_entries(NULL);\n\t\telse\n\t\t\tcnt = trace_total_entries_cpu(NULL, cpu_file);\n\t\tskip_entries = max(cnt + skip_entries, 0);\n\t}\n\n\tftrace_dump_buf(skip_entries, cpu_file);\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\n\tkdb_trap_printk--;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_iterator iter;",
      "static struct ring_buffer_iter *buffer_iter[CONFIG_NR_CPUS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "iter.array_buffer->data",
            "cpu"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_dump_buf",
          "args": [
            "skip_entries",
            "cpu_file"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_dump_buf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kdb.c",
          "lines": "23-90",
          "snippet": "static void ftrace_dump_buf(int skip_entries, long cpu_file)\n{\n\tstruct trace_array *tr;\n\tunsigned int old_userobj;\n\tint cnt = 0, cpu;\n\n\ttr = iter.tr;\n\n\told_userobj = tr->trace_flags;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tkdb_printf(\"Dumping ftrace buffer:\\n\");\n\tif (skip_entries)\n\t\tkdb_printf(\"(skipping %d entries)\\n\", skip_entries);\n\n\ttrace_iterator_reset(&iter);\n\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\n\tif (cpu_file == RING_BUFFER_ALL_CPUS) {\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\titer.buffer_iter[cpu] =\n\t\t\tring_buffer_read_prepare(iter.array_buffer->buffer,\n\t\t\t\t\t\t cpu, GFP_ATOMIC);\n\t\t\tring_buffer_read_start(iter.buffer_iter[cpu]);\n\t\t\ttracing_iter_reset(&iter, cpu);\n\t\t}\n\t} else {\n\t\titer.cpu_file = cpu_file;\n\t\titer.buffer_iter[cpu_file] =\n\t\t\tring_buffer_read_prepare(iter.array_buffer->buffer,\n\t\t\t\t\t\t cpu_file, GFP_ATOMIC);\n\t\tring_buffer_read_start(iter.buffer_iter[cpu_file]);\n\t\ttracing_iter_reset(&iter, cpu_file);\n\t}\n\n\twhile (trace_find_next_entry_inc(&iter)) {\n\t\tif (!cnt)\n\t\t\tkdb_printf(\"---------------------------------\\n\");\n\t\tcnt++;\n\n\t\tif (!skip_entries) {\n\t\t\tprint_trace_line(&iter);\n\t\t\ttrace_printk_seq(&iter.seq);\n\t\t} else {\n\t\t\tskip_entries--;\n\t\t}\n\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\tgoto out;\n\t}\n\n\tif (!cnt)\n\t\tkdb_printf(\"   (ftrace buffer empty)\\n\");\n\telse\n\t\tkdb_printf(\"---------------------------------\\n\");\n\nout:\n\ttr->trace_flags = old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tif (iter.buffer_iter[cpu]) {\n\t\t\tring_buffer_read_finish(iter.buffer_iter[cpu]);\n\t\t\titer.buffer_iter[cpu] = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_iterator iter;",
            "static struct ring_buffer_iter *buffer_iter[CONFIG_NR_CPUS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n\nstatic struct trace_iterator iter;\nstatic struct ring_buffer_iter *buffer_iter[CONFIG_NR_CPUS];\n\nstatic void ftrace_dump_buf(int skip_entries, long cpu_file)\n{\n\tstruct trace_array *tr;\n\tunsigned int old_userobj;\n\tint cnt = 0, cpu;\n\n\ttr = iter.tr;\n\n\told_userobj = tr->trace_flags;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tkdb_printf(\"Dumping ftrace buffer:\\n\");\n\tif (skip_entries)\n\t\tkdb_printf(\"(skipping %d entries)\\n\", skip_entries);\n\n\ttrace_iterator_reset(&iter);\n\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\n\tif (cpu_file == RING_BUFFER_ALL_CPUS) {\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\titer.buffer_iter[cpu] =\n\t\t\tring_buffer_read_prepare(iter.array_buffer->buffer,\n\t\t\t\t\t\t cpu, GFP_ATOMIC);\n\t\t\tring_buffer_read_start(iter.buffer_iter[cpu]);\n\t\t\ttracing_iter_reset(&iter, cpu);\n\t\t}\n\t} else {\n\t\titer.cpu_file = cpu_file;\n\t\titer.buffer_iter[cpu_file] =\n\t\t\tring_buffer_read_prepare(iter.array_buffer->buffer,\n\t\t\t\t\t\t cpu_file, GFP_ATOMIC);\n\t\tring_buffer_read_start(iter.buffer_iter[cpu_file]);\n\t\ttracing_iter_reset(&iter, cpu_file);\n\t}\n\n\twhile (trace_find_next_entry_inc(&iter)) {\n\t\tif (!cnt)\n\t\t\tkdb_printf(\"---------------------------------\\n\");\n\t\tcnt++;\n\n\t\tif (!skip_entries) {\n\t\t\tprint_trace_line(&iter);\n\t\t\ttrace_printk_seq(&iter.seq);\n\t\t} else {\n\t\t\tskip_entries--;\n\t\t}\n\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\tgoto out;\n\t}\n\n\tif (!cnt)\n\t\tkdb_printf(\"   (ftrace buffer empty)\\n\");\n\telse\n\t\tkdb_printf(\"---------------------------------\\n\");\n\nout:\n\ttr->trace_flags = old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tif (iter.buffer_iter[cpu]) {\n\t\t\tring_buffer_read_finish(iter.buffer_iter[cpu]);\n\t\t\titer.buffer_iter[cpu] = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "cnt + skip_entries",
            "0"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "check_track_val_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "3212-3218",
          "snippet": "static bool check_track_val_max(u64 track_val, u64 var_val)\n{\n\tif (var_val <= track_val)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool check_track_val_max(u64 track_val, u64 var_val)\n{\n\tif (var_val <= track_val)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_total_entries_cpu",
          "args": [
            "NULL",
            "cpu_file"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "trace_total_entries_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "4168-4178",
          "snippet": "unsigned long trace_total_entries_cpu(struct trace_array *tr, int cpu)\n{\n\tunsigned long total, entries;\n\n\tif (!tr)\n\t\ttr = &global_trace;\n\n\tget_total_entries_cpu(&tr->array_buffer, &total, &entries, cpu);\n\n\treturn entries;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nunsigned long trace_total_entries_cpu(struct trace_array *tr, int cpu)\n{\n\tunsigned long total, entries;\n\n\tif (!tr)\n\t\ttr = &global_trace;\n\n\tget_total_entries_cpu(&tr->array_buffer, &total, &entries, cpu);\n\n\treturn entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_total_entries",
          "args": [
            "NULL"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "trace_total_entries",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "4180-4190",
          "snippet": "unsigned long trace_total_entries(struct trace_array *tr)\n{\n\tunsigned long total, entries;\n\n\tif (!tr)\n\t\ttr = &global_trace;\n\n\tget_total_entries(&tr->array_buffer, &total, &entries);\n\n\treturn entries;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nunsigned long trace_total_entries(struct trace_array *tr)\n{\n\tunsigned long total, entries;\n\n\tif (!tr)\n\t\ttr = &global_trace;\n\n\tget_total_entries(&tr->array_buffer, &total, &entries);\n\n\treturn entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "iter.array_buffer->data",
            "cpu"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_init_global_iter",
          "args": [
            "&iter"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "trace_init_global_iter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9789-9806",
          "snippet": "void trace_init_global_iter(struct trace_iterator *iter)\n{\n\titer->tr = &global_trace;\n\titer->trace = iter->tr->current_trace;\n\titer->cpu_file = RING_BUFFER_ALL_CPUS;\n\titer->array_buffer = &global_trace.array_buffer;\n\n\tif (iter->trace && iter->trace->open)\n\t\titer->trace->open(iter);\n\n\t/* Annotate start of buffers if we had overruns */\n\tif (ring_buffer_overruns(iter->array_buffer->buffer))\n\t\titer->iter_flags |= TRACE_FILE_ANNOTATE;\n\n\t/* Output in nanoseconds only if we are using a clock in nanoseconds. */\n\tif (trace_clocks[iter->tr->clock_id].in_ns)\n\t\titer->iter_flags |= TRACE_FILE_TIME_IN_NS;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct",
            "static struct {\n\tu64 (*func)(void);\n\tconst char *name;\n\tint in_ns;\t\t/* is this clock in nanoseconds? */\n} trace_clocks[] = {\n\t{ trace_clock_local,\t\t\"local\",\t1 },\n\t{ trace_clock_global,\t\t\"global\",\t1 },\n\t{ trace_clock_counter,\t\t\"counter\",\t0 },\n\t{ trace_clock_jiffies,\t\t\"uptime\",\t0 },\n\t{ trace_clock,\t\t\t\"perf\",\t\t1 },\n\t{ ktime_get_mono_fast_ns,\t\"mono\",\t\t1 },\n\t{ ktime_get_raw_fast_ns,\t\"mono_raw\",\t1 },\n\t{ ktime_get_boot_fast_ns,\t\"boot\",\t\t1 },\n\tARCH_TRACE_CLOCKS\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\nstatic struct {\n\tu64 (*func)(void);\n\tconst char *name;\n\tint in_ns;\t\t/* is this clock in nanoseconds? */\n} trace_clocks[] = {\n\t{ trace_clock_local,\t\t\"local\",\t1 },\n\t{ trace_clock_global,\t\t\"global\",\t1 },\n\t{ trace_clock_counter,\t\t\"counter\",\t0 },\n\t{ trace_clock_jiffies,\t\t\"uptime\",\t0 },\n\t{ trace_clock,\t\t\t\"perf\",\t\t1 },\n\t{ ktime_get_mono_fast_ns,\t\"mono\",\t\t1 },\n\t{ ktime_get_raw_fast_ns,\t\"mono_raw\",\t1 },\n\t{ ktime_get_boot_fast_ns,\t\"boot\",\t\t1 },\n\tARCH_TRACE_CLOCKS\n};\n\nvoid trace_init_global_iter(struct trace_iterator *iter)\n{\n\titer->tr = &global_trace;\n\titer->trace = iter->tr->current_trace;\n\titer->cpu_file = RING_BUFFER_ALL_CPUS;\n\titer->array_buffer = &global_trace.array_buffer;\n\n\tif (iter->trace && iter->trace->open)\n\t\titer->trace->open(iter);\n\n\t/* Annotate start of buffers if we had overruns */\n\tif (ring_buffer_overruns(iter->array_buffer->buffer))\n\t\titer->iter_flags |= TRACE_FILE_ANNOTATE;\n\n\t/* Output in nanoseconds only if we are using a clock in nanoseconds. */\n\tif (trace_clocks[iter->tr->clock_id].in_ns)\n\t\titer->iter_flags |= TRACE_FILE_TIME_IN_NS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu_file"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "argv[2]",
            "&cp",
            "0"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "argv[1]",
            "&cp",
            "0"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n\nstatic struct trace_iterator iter;\nstatic struct ring_buffer_iter *buffer_iter[CONFIG_NR_CPUS];\n\nstatic int kdb_ftdump(int argc, const char **argv)\n{\n\tint skip_entries = 0;\n\tlong cpu_file;\n\tchar *cp;\n\tint cnt;\n\tint cpu;\n\n\tif (argc > 2)\n\t\treturn KDB_ARGCOUNT;\n\n\tif (argc) {\n\t\tskip_entries = simple_strtol(argv[1], &cp, 0);\n\t\tif (*cp)\n\t\t\tskip_entries = 0;\n\t}\n\n\tif (argc == 2) {\n\t\tcpu_file = simple_strtol(argv[2], &cp, 0);\n\t\tif (*cp || cpu_file >= NR_CPUS || cpu_file < 0 ||\n\t\t    !cpu_online(cpu_file))\n\t\t\treturn KDB_BADINT;\n\t} else {\n\t\tcpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tkdb_trap_printk++;\n\n\ttrace_init_global_iter(&iter);\n\titer.buffer_iter = buffer_iter;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\n\t/* A negative skip_entries means skip all but the last entries */\n\tif (skip_entries < 0) {\n\t\tif (cpu_file == RING_BUFFER_ALL_CPUS)\n\t\t\tcnt = trace_total_entries(NULL);\n\t\telse\n\t\t\tcnt = trace_total_entries_cpu(NULL, cpu_file);\n\t\tskip_entries = max(cnt + skip_entries, 0);\n\t}\n\n\tftrace_dump_buf(skip_entries, cpu_file);\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\n\tkdb_trap_printk--;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_dump_buf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_kdb.c",
    "lines": "23-90",
    "snippet": "static void ftrace_dump_buf(int skip_entries, long cpu_file)\n{\n\tstruct trace_array *tr;\n\tunsigned int old_userobj;\n\tint cnt = 0, cpu;\n\n\ttr = iter.tr;\n\n\told_userobj = tr->trace_flags;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tkdb_printf(\"Dumping ftrace buffer:\\n\");\n\tif (skip_entries)\n\t\tkdb_printf(\"(skipping %d entries)\\n\", skip_entries);\n\n\ttrace_iterator_reset(&iter);\n\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\n\tif (cpu_file == RING_BUFFER_ALL_CPUS) {\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\titer.buffer_iter[cpu] =\n\t\t\tring_buffer_read_prepare(iter.array_buffer->buffer,\n\t\t\t\t\t\t cpu, GFP_ATOMIC);\n\t\t\tring_buffer_read_start(iter.buffer_iter[cpu]);\n\t\t\ttracing_iter_reset(&iter, cpu);\n\t\t}\n\t} else {\n\t\titer.cpu_file = cpu_file;\n\t\titer.buffer_iter[cpu_file] =\n\t\t\tring_buffer_read_prepare(iter.array_buffer->buffer,\n\t\t\t\t\t\t cpu_file, GFP_ATOMIC);\n\t\tring_buffer_read_start(iter.buffer_iter[cpu_file]);\n\t\ttracing_iter_reset(&iter, cpu_file);\n\t}\n\n\twhile (trace_find_next_entry_inc(&iter)) {\n\t\tif (!cnt)\n\t\t\tkdb_printf(\"---------------------------------\\n\");\n\t\tcnt++;\n\n\t\tif (!skip_entries) {\n\t\t\tprint_trace_line(&iter);\n\t\t\ttrace_printk_seq(&iter.seq);\n\t\t} else {\n\t\t\tskip_entries--;\n\t\t}\n\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\tgoto out;\n\t}\n\n\tif (!cnt)\n\t\tkdb_printf(\"   (ftrace buffer empty)\\n\");\n\telse\n\t\tkdb_printf(\"---------------------------------\\n\");\n\nout:\n\ttr->trace_flags = old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tif (iter.buffer_iter[cpu]) {\n\t\t\tring_buffer_read_finish(iter.buffer_iter[cpu]);\n\t\t\titer.buffer_iter[cpu] = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_iterator iter;",
      "static struct ring_buffer_iter *buffer_iter[CONFIG_NR_CPUS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_read_finish",
          "args": [
            "iter.buffer_iter[cpu]"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_read_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "5027-5046",
          "snippet": "void\nring_buffer_read_finish(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tunsigned long flags;\n\n\t/*\n\t * Ring buffer is disabled from recording, here's a good place\n\t * to check the integrity of the ring buffer.\n\t * Must prevent readers from trying to read, as the check\n\t * clears the HEAD page and readers require it.\n\t */\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\trb_check_pages(cpu_buffer);\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\n\tatomic_dec(&cpu_buffer->resize_disabled);\n\tkfree(iter->event);\n\tkfree(iter);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid\nring_buffer_read_finish(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tunsigned long flags;\n\n\t/*\n\t * Ring buffer is disabled from recording, here's a good place\n\t * to check the integrity of the ring buffer.\n\t * Must prevent readers from trying to read, as the check\n\t * clears the HEAD page and readers require it.\n\t */\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\trb_check_pages(cpu_buffer);\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\n\tatomic_dec(&cpu_buffer->resize_disabled);\n\tkfree(iter->event);\n\tkfree(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"---------------------------------\\n\""
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_printk_seq",
          "args": [
            "&iter.seq"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_trace_line",
          "args": [
            "&iter"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "print_trace_line",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "4480-4528",
          "snippet": "enum print_line_t print_trace_line(struct trace_iterator *iter)\n{\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long trace_flags = tr->trace_flags;\n\tenum print_line_t ret;\n\n\tif (iter->lost_events) {\n\t\tif (iter->lost_events == (unsigned long)-1)\n\t\t\ttrace_seq_printf(&iter->seq, \"CPU:%d [LOST EVENTS]\\n\",\n\t\t\t\t\t iter->cpu);\n\t\telse\n\t\t\ttrace_seq_printf(&iter->seq, \"CPU:%d [LOST %lu EVENTS]\\n\",\n\t\t\t\t\t iter->cpu, iter->lost_events);\n\t\tif (trace_seq_has_overflowed(&iter->seq))\n\t\t\treturn TRACE_TYPE_PARTIAL_LINE;\n\t}\n\n\tif (iter->trace && iter->trace->print_line) {\n\t\tret = iter->trace->print_line(iter);\n\t\tif (ret != TRACE_TYPE_UNHANDLED)\n\t\t\treturn ret;\n\t}\n\n\tif (iter->ent->type == TRACE_BPUTS &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK_MSGONLY)\n\t\treturn trace_print_bputs_msg_only(iter);\n\n\tif (iter->ent->type == TRACE_BPRINT &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK_MSGONLY)\n\t\treturn trace_print_bprintk_msg_only(iter);\n\n\tif (iter->ent->type == TRACE_PRINT &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK_MSGONLY)\n\t\treturn trace_print_printk_msg_only(iter);\n\n\tif (trace_flags & TRACE_ITER_BIN)\n\t\treturn print_bin_fmt(iter);\n\n\tif (trace_flags & TRACE_ITER_HEX)\n\t\treturn print_hex_fmt(iter);\n\n\tif (trace_flags & TRACE_ITER_RAW)\n\t\treturn print_raw_fmt(iter);\n\n\treturn print_trace_fmt(iter);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t print_trace_line(struct trace_iterator *iter)\n{\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long trace_flags = tr->trace_flags;\n\tenum print_line_t ret;\n\n\tif (iter->lost_events) {\n\t\tif (iter->lost_events == (unsigned long)-1)\n\t\t\ttrace_seq_printf(&iter->seq, \"CPU:%d [LOST EVENTS]\\n\",\n\t\t\t\t\t iter->cpu);\n\t\telse\n\t\t\ttrace_seq_printf(&iter->seq, \"CPU:%d [LOST %lu EVENTS]\\n\",\n\t\t\t\t\t iter->cpu, iter->lost_events);\n\t\tif (trace_seq_has_overflowed(&iter->seq))\n\t\t\treturn TRACE_TYPE_PARTIAL_LINE;\n\t}\n\n\tif (iter->trace && iter->trace->print_line) {\n\t\tret = iter->trace->print_line(iter);\n\t\tif (ret != TRACE_TYPE_UNHANDLED)\n\t\t\treturn ret;\n\t}\n\n\tif (iter->ent->type == TRACE_BPUTS &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK_MSGONLY)\n\t\treturn trace_print_bputs_msg_only(iter);\n\n\tif (iter->ent->type == TRACE_BPRINT &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK_MSGONLY)\n\t\treturn trace_print_bprintk_msg_only(iter);\n\n\tif (iter->ent->type == TRACE_PRINT &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK_MSGONLY)\n\t\treturn trace_print_printk_msg_only(iter);\n\n\tif (trace_flags & TRACE_ITER_BIN)\n\t\treturn print_bin_fmt(iter);\n\n\tif (trace_flags & TRACE_ITER_HEX)\n\t\treturn print_hex_fmt(iter);\n\n\tif (trace_flags & TRACE_ITER_RAW)\n\t\treturn print_raw_fmt(iter);\n\n\treturn print_trace_fmt(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_next_entry_inc",
          "args": [
            "&iter"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_next_entry_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3981-3990",
          "snippet": "void *trace_find_next_entry_inc(struct trace_iterator *iter)\n{\n\titer->ent = __find_next_entry(iter, &iter->cpu,\n\t\t\t\t      &iter->lost_events, &iter->ts);\n\n\tif (iter->ent)\n\t\ttrace_iterator_increment(iter);\n\n\treturn iter->ent ? iter : NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid *trace_find_next_entry_inc(struct trace_iterator *iter)\n{\n\titer->ent = __find_next_entry(iter, &iter->cpu,\n\t\t\t\t      &iter->lost_events, &iter->ts);\n\n\tif (iter->ent)\n\t\ttrace_iterator_increment(iter);\n\n\treturn iter->ent ? iter : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_iter_reset",
          "args": [
            "&iter",
            "cpu_file"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_iter_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "4025-4052",
          "snippet": "void tracing_iter_reset(struct trace_iterator *iter, int cpu)\n{\n\tstruct ring_buffer_iter *buf_iter;\n\tunsigned long entries = 0;\n\tu64 ts;\n\n\tper_cpu_ptr(iter->array_buffer->data, cpu)->skipped_entries = 0;\n\n\tbuf_iter = trace_buffer_iter(iter, cpu);\n\tif (!buf_iter)\n\t\treturn;\n\n\tring_buffer_iter_reset(buf_iter);\n\n\t/*\n\t * We could have the case with the max latency tracers\n\t * that a reset never took place on a cpu. This is evident\n\t * by the timestamp being before the start of the buffer.\n\t */\n\twhile (ring_buffer_iter_peek(buf_iter, &ts)) {\n\t\tif (ts >= iter->array_buffer->time_start)\n\t\t\tbreak;\n\t\tentries++;\n\t\tring_buffer_iter_advance(buf_iter);\n\t}\n\n\tper_cpu_ptr(iter->array_buffer->data, cpu)->skipped_entries = entries;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid tracing_iter_reset(struct trace_iterator *iter, int cpu)\n{\n\tstruct ring_buffer_iter *buf_iter;\n\tunsigned long entries = 0;\n\tu64 ts;\n\n\tper_cpu_ptr(iter->array_buffer->data, cpu)->skipped_entries = 0;\n\n\tbuf_iter = trace_buffer_iter(iter, cpu);\n\tif (!buf_iter)\n\t\treturn;\n\n\tring_buffer_iter_reset(buf_iter);\n\n\t/*\n\t * We could have the case with the max latency tracers\n\t * that a reset never took place on a cpu. This is evident\n\t * by the timestamp being before the start of the buffer.\n\t */\n\twhile (ring_buffer_iter_peek(buf_iter, &ts)) {\n\t\tif (ts >= iter->array_buffer->time_start)\n\t\t\tbreak;\n\t\tentries++;\n\t\tring_buffer_iter_advance(buf_iter);\n\t}\n\n\tper_cpu_ptr(iter->array_buffer->data, cpu)->skipped_entries = entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_read_start",
          "args": [
            "iter.buffer_iter[cpu_file]"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_read_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "5001-5017",
          "snippet": "void\nring_buffer_read_start(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long flags;\n\n\tif (!iter)\n\t\treturn;\n\n\tcpu_buffer = iter->cpu_buffer;\n\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\tarch_spin_lock(&cpu_buffer->lock);\n\trb_iter_reset(iter);\n\tarch_spin_unlock(&cpu_buffer->lock);\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid\nring_buffer_read_start(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long flags;\n\n\tif (!iter)\n\t\treturn;\n\n\tcpu_buffer = iter->cpu_buffer;\n\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\tarch_spin_lock(&cpu_buffer->lock);\n\trb_iter_reset(iter);\n\tarch_spin_unlock(&cpu_buffer->lock);\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_read_prepare",
          "args": [
            "iter.array_buffer->buffer",
            "cpu_file",
            "GFP_ATOMIC"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_read_prepare",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "4947-4973",
          "snippet": "struct ring_buffer_iter *\nring_buffer_read_prepare(struct trace_buffer *buffer, int cpu, gfp_t flags)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_iter *iter;\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn NULL;\n\n\titer = kzalloc(sizeof(*iter), flags);\n\tif (!iter)\n\t\treturn NULL;\n\n\titer->event = kmalloc(BUF_MAX_DATA_SIZE, flags);\n\tif (!iter->event) {\n\t\tkfree(iter);\n\t\treturn NULL;\n\t}\n\n\tcpu_buffer = buffer->buffers[cpu];\n\n\titer->cpu_buffer = cpu_buffer;\n\n\tatomic_inc(&cpu_buffer->resize_disabled);\n\n\treturn iter;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [
            "#define BUF_MAX_DATA_SIZE (BUF_PAGE_SIZE - (sizeof(u32) * 2))"
          ],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\n#define BUF_MAX_DATA_SIZE (BUF_PAGE_SIZE - (sizeof(u32) * 2))\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nstruct ring_buffer_iter *\nring_buffer_read_prepare(struct trace_buffer *buffer, int cpu, gfp_t flags)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_iter *iter;\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn NULL;\n\n\titer = kzalloc(sizeof(*iter), flags);\n\tif (!iter)\n\t\treturn NULL;\n\n\titer->event = kmalloc(BUF_MAX_DATA_SIZE, flags);\n\tif (!iter->event) {\n\t\tkfree(iter);\n\t\treturn NULL;\n\t}\n\n\tcpu_buffer = buffer->buffers[cpu];\n\n\titer->cpu_buffer = cpu_buffer;\n\n\tatomic_inc(&cpu_buffer->resize_disabled);\n\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_iterator_reset",
          "args": [
            "&iter"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "trace_iterator_reset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1969-1973",
          "snippet": "static __always_inline void trace_iterator_reset(struct trace_iterator *iter)\n{\n\tmemset_startat(iter, 0, seq);\n\titer->pos = -1;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic __always_inline void trace_iterator_reset(struct trace_iterator *iter)\n{\n\tmemset_startat(iter, 0, seq);\n\titer->pos = -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n\nstatic struct trace_iterator iter;\nstatic struct ring_buffer_iter *buffer_iter[CONFIG_NR_CPUS];\n\nstatic void ftrace_dump_buf(int skip_entries, long cpu_file)\n{\n\tstruct trace_array *tr;\n\tunsigned int old_userobj;\n\tint cnt = 0, cpu;\n\n\ttr = iter.tr;\n\n\told_userobj = tr->trace_flags;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tkdb_printf(\"Dumping ftrace buffer:\\n\");\n\tif (skip_entries)\n\t\tkdb_printf(\"(skipping %d entries)\\n\", skip_entries);\n\n\ttrace_iterator_reset(&iter);\n\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\n\tif (cpu_file == RING_BUFFER_ALL_CPUS) {\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\titer.buffer_iter[cpu] =\n\t\t\tring_buffer_read_prepare(iter.array_buffer->buffer,\n\t\t\t\t\t\t cpu, GFP_ATOMIC);\n\t\t\tring_buffer_read_start(iter.buffer_iter[cpu]);\n\t\t\ttracing_iter_reset(&iter, cpu);\n\t\t}\n\t} else {\n\t\titer.cpu_file = cpu_file;\n\t\titer.buffer_iter[cpu_file] =\n\t\t\tring_buffer_read_prepare(iter.array_buffer->buffer,\n\t\t\t\t\t\t cpu_file, GFP_ATOMIC);\n\t\tring_buffer_read_start(iter.buffer_iter[cpu_file]);\n\t\ttracing_iter_reset(&iter, cpu_file);\n\t}\n\n\twhile (trace_find_next_entry_inc(&iter)) {\n\t\tif (!cnt)\n\t\t\tkdb_printf(\"---------------------------------\\n\");\n\t\tcnt++;\n\n\t\tif (!skip_entries) {\n\t\t\tprint_trace_line(&iter);\n\t\t\ttrace_printk_seq(&iter.seq);\n\t\t} else {\n\t\t\tskip_entries--;\n\t\t}\n\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\tgoto out;\n\t}\n\n\tif (!cnt)\n\t\tkdb_printf(\"   (ftrace buffer empty)\\n\");\n\telse\n\t\tkdb_printf(\"---------------------------------\\n\");\n\nout:\n\ttr->trace_flags = old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tif (iter.buffer_iter[cpu]) {\n\t\t\tring_buffer_read_finish(iter.buffer_iter[cpu]);\n\t\t\titer.buffer_iter[cpu] = NULL;\n\t\t}\n\t}\n}"
  }
]