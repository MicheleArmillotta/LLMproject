[
  {
    "function_name": "kdb_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2913-2932",
    "snippet": "void __init kdb_init(int lvl)\n{\n\tstatic int kdb_init_lvl = KDB_NOT_INITIALIZED;\n\tint i;\n\n\tif (kdb_init_lvl == KDB_INIT_FULL || lvl <= kdb_init_lvl)\n\t\treturn;\n\tfor (i = kdb_init_lvl; i < lvl; i++) {\n\t\tswitch (i) {\n\t\tcase KDB_NOT_INITIALIZED:\n\t\t\tkdb_inittab();\t\t/* Initialize Command Table */\n\t\t\tkdb_initbptab();\t/* Initialize Breakpoints */\n\t\t\tbreak;\n\t\tcase KDB_INIT_EARLY:\n\t\t\tkdb_cmd_init();\t\t/* Build kdb_cmds tables */\n\t\t\tbreak;\n\t\t}\n\t}\n\tkdb_init_lvl = lvl;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_cmd_init",
          "args": [],
          "line": 2927
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_cmd_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2897-2910",
          "snippet": "static void __init kdb_cmd_init(void)\n{\n\tint i, diag;\n\tfor (i = 0; kdb_cmds[i]; ++i) {\n\t\tdiag = kdb_parse(kdb_cmds[i]);\n\t\tif (diag)\n\t\t\tkdb_printf(\"kdb command %s failed, kdb diag %d\\n\",\n\t\t\t\tkdb_cmds[i], diag);\n\t}\n\tif (defcmd_in_progress) {\n\t\tkdb_printf(\"Incomplete 'defcmd' set, forcing endefcmd\\n\");\n\t\tkdb_parse(\"endefcmd\");\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void __init kdb_cmd_init(void)\n{\n\tint i, diag;\n\tfor (i = 0; kdb_cmds[i]; ++i) {\n\t\tdiag = kdb_parse(kdb_cmds[i]);\n\t\tif (diag)\n\t\t\tkdb_printf(\"kdb command %s failed, kdb diag %d\\n\",\n\t\t\t\tkdb_cmds[i], diag);\n\t}\n\tif (defcmd_in_progress) {\n\t\tkdb_printf(\"Incomplete 'defcmd' set, forcing endefcmd\\n\");\n\t\tkdb_parse(\"endefcmd\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_initbptab",
          "args": [],
          "line": 2924
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_initbptab",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_bp.c",
          "lines": "575-591",
          "snippet": "void __init kdb_initbptab(void)\n{\n\tint i;\n\tkdb_bp_t *bp;\n\n\t/*\n\t * First time initialization.\n\t */\n\tmemset(&kdb_breakpoints, '\\0', sizeof(kdb_breakpoints));\n\n\tfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT; i++, bp++)\n\t\tbp->bp_free = 1;\n\n\tkdb_register_table(bptab, ARRAY_SIZE(bptab));\n\tif (arch_kgdb_ops.flags & KGDB_HW_BREAKPOINT)\n\t\tkdb_register_table(&bphcmd, 1);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kdb.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kdb_bp_t kdb_breakpoints[KDB_MAXBPT];",
            "static kdbtab_t bptab[] = {\n\t{\t.name = \"bp\",\n\t\t.func = kdb_bp,\n\t\t.usage = \"[<vaddr>]\",\n\t\t.help = \"Set/Display breakpoints\",\n\t\t.flags = KDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS,\n\t},\n\t{\t.name = \"bl\",\n\t\t.func = kdb_bp,\n\t\t.usage = \"[<vaddr>]\",\n\t\t.help = \"Display breakpoints\",\n\t\t.flags = KDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS,\n\t},\n\t{\t.name = \"bc\",\n\t\t.func = kdb_bc,\n\t\t.usage = \"<bpnum>\",\n\t\t.help = \"Clear Breakpoint\",\n\t\t.flags = KDB_ENABLE_FLOW_CTRL,\n\t},\n\t{\t.name = \"be\",\n\t\t.func = kdb_bc,\n\t\t.usage = \"<bpnum>\",\n\t\t.help = \"Enable Breakpoint\",\n\t\t.flags = KDB_ENABLE_FLOW_CTRL,\n\t},\n\t{\t.name = \"bd\",\n\t\t.func = kdb_bc,\n\t\t.usage = \"<bpnum>\",\n\t\t.help = \"Disable Breakpoint\",\n\t\t.flags = KDB_ENABLE_FLOW_CTRL,\n\t},\n\t{\t.name = \"ss\",\n\t\t.func = kdb_ss,\n\t\t.usage = \"\",\n\t\t.help = \"Single Step\",\n\t\t.minlen = 1,\n\t\t.flags = KDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS,\n\t},\n};",
            "static kdbtab_t bphcmd = {\n\t.name = \"bph\",\n\t.func = kdb_bp,\n\t.usage = \"[<vaddr>]\",\n\t.help = \"[datar [length]|dataw [length]]   Set hw brk\",\n\t.flags = KDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nkdb_bp_t kdb_breakpoints[KDB_MAXBPT];\nstatic kdbtab_t bptab[] = {\n\t{\t.name = \"bp\",\n\t\t.func = kdb_bp,\n\t\t.usage = \"[<vaddr>]\",\n\t\t.help = \"Set/Display breakpoints\",\n\t\t.flags = KDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS,\n\t},\n\t{\t.name = \"bl\",\n\t\t.func = kdb_bp,\n\t\t.usage = \"[<vaddr>]\",\n\t\t.help = \"Display breakpoints\",\n\t\t.flags = KDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS,\n\t},\n\t{\t.name = \"bc\",\n\t\t.func = kdb_bc,\n\t\t.usage = \"<bpnum>\",\n\t\t.help = \"Clear Breakpoint\",\n\t\t.flags = KDB_ENABLE_FLOW_CTRL,\n\t},\n\t{\t.name = \"be\",\n\t\t.func = kdb_bc,\n\t\t.usage = \"<bpnum>\",\n\t\t.help = \"Enable Breakpoint\",\n\t\t.flags = KDB_ENABLE_FLOW_CTRL,\n\t},\n\t{\t.name = \"bd\",\n\t\t.func = kdb_bc,\n\t\t.usage = \"<bpnum>\",\n\t\t.help = \"Disable Breakpoint\",\n\t\t.flags = KDB_ENABLE_FLOW_CTRL,\n\t},\n\t{\t.name = \"ss\",\n\t\t.func = kdb_ss,\n\t\t.usage = \"\",\n\t\t.help = \"Single Step\",\n\t\t.minlen = 1,\n\t\t.flags = KDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS,\n\t},\n};\nstatic kdbtab_t bphcmd = {\n\t.name = \"bph\",\n\t.func = kdb_bp,\n\t.usage = \"[<vaddr>]\",\n\t.help = \"[datar [length]|dataw [length]]   Set hw brk\",\n\t.flags = KDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS,\n};\n\nvoid __init kdb_initbptab(void)\n{\n\tint i;\n\tkdb_bp_t *bp;\n\n\t/*\n\t * First time initialization.\n\t */\n\tmemset(&kdb_breakpoints, '\\0', sizeof(kdb_breakpoints));\n\n\tfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT; i++, bp++)\n\t\tbp->bp_free = 1;\n\n\tkdb_register_table(bptab, ARRAY_SIZE(bptab));\n\tif (arch_kgdb_ops.flags & KGDB_HW_BREAKPOINT)\n\t\tkdb_register_table(&bphcmd, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_inittab",
          "args": [],
          "line": 2923
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_inittab",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2889-2894",
          "snippet": "static void __init kdb_inittab(void)\n{\n\tkdb_register_table(maintab, ARRAY_SIZE(maintab));\n\tif (arch_kgdb_ops.enable_nmi)\n\t\tkdb_register_table(&nmicmd, 1);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void __init kdb_inittab(void)\n{\n\tkdb_register_table(maintab, ARRAY_SIZE(maintab));\n\tif (arch_kgdb_ops.enable_nmi)\n\t\tkdb_register_table(&nmicmd, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid __init kdb_init(int lvl)\n{\n\tstatic int kdb_init_lvl = KDB_NOT_INITIALIZED;\n\tint i;\n\n\tif (kdb_init_lvl == KDB_INIT_FULL || lvl <= kdb_init_lvl)\n\t\treturn;\n\tfor (i = kdb_init_lvl; i < lvl; i++) {\n\t\tswitch (i) {\n\t\tcase KDB_NOT_INITIALIZED:\n\t\t\tkdb_inittab();\t\t/* Initialize Command Table */\n\t\t\tkdb_initbptab();\t/* Initialize Breakpoints */\n\t\t\tbreak;\n\t\tcase KDB_INIT_EARLY:\n\t\t\tkdb_cmd_init();\t\t/* Build kdb_cmds tables */\n\t\t\tbreak;\n\t\t}\n\t}\n\tkdb_init_lvl = lvl;\n}"
  },
  {
    "function_name": "kdb_cmd_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2897-2910",
    "snippet": "static void __init kdb_cmd_init(void)\n{\n\tint i, diag;\n\tfor (i = 0; kdb_cmds[i]; ++i) {\n\t\tdiag = kdb_parse(kdb_cmds[i]);\n\t\tif (diag)\n\t\t\tkdb_printf(\"kdb command %s failed, kdb diag %d\\n\",\n\t\t\t\tkdb_cmds[i], diag);\n\t}\n\tif (defcmd_in_progress) {\n\t\tkdb_printf(\"Incomplete 'defcmd' set, forcing endefcmd\\n\");\n\t\tkdb_parse(\"endefcmd\");\n\t}\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_parse",
          "args": [
            "\"endefcmd\""
          ],
          "line": 2908
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_parse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "915-1082",
          "snippet": "int kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t/*\n\t\t * If this command is allowed to be abbreviated,\n\t\t * check to see if this is it.\n\t\t */\n\t\tif (tp->minlen && (strlen(argv[0]) <= tp->minlen) &&\n\t\t    (strncmp(argv[0], tp->name, tp->minlen) == 0))\n\t\t\tbreak;\n\n\t\tif (strcmp(argv[0], tp->name) == 0)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t\tif (strncmp(argv[0], tp->name, strlen(tp->name)) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define MAXARGC\t20",
            "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */"
          ],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;",
            "static LIST_HEAD(kdb_cmds_head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define MAXARGC\t20\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\nstatic LIST_HEAD(kdb_cmds_head);\n\nint kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t/*\n\t\t * If this command is allowed to be abbreviated,\n\t\t * check to see if this is it.\n\t\t */\n\t\tif (tp->minlen && (strlen(argv[0]) <= tp->minlen) &&\n\t\t    (strncmp(argv[0], tp->name, tp->minlen) == 0))\n\t\t\tbreak;\n\n\t\tif (strcmp(argv[0], tp->name) == 0)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t\tif (strncmp(argv[0], tp->name, strlen(tp->name)) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Incomplete 'defcmd' set, forcing endefcmd\\n\""
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void __init kdb_cmd_init(void)\n{\n\tint i, diag;\n\tfor (i = 0; kdb_cmds[i]; ++i) {\n\t\tdiag = kdb_parse(kdb_cmds[i]);\n\t\tif (diag)\n\t\t\tkdb_printf(\"kdb command %s failed, kdb diag %d\\n\",\n\t\t\t\tkdb_cmds[i], diag);\n\t}\n\tif (defcmd_in_progress) {\n\t\tkdb_printf(\"Incomplete 'defcmd' set, forcing endefcmd\\n\");\n\t\tkdb_parse(\"endefcmd\");\n\t}\n}"
  },
  {
    "function_name": "kdb_inittab",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2889-2894",
    "snippet": "static void __init kdb_inittab(void)\n{\n\tkdb_register_table(maintab, ARRAY_SIZE(maintab));\n\tif (arch_kgdb_ops.enable_nmi)\n\t\tkdb_register_table(&nmicmd, 1);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_register_table",
          "args": [
            "&nmicmd",
            "1"
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_register_table",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2653-2659",
          "snippet": "void kdb_register_table(kdbtab_t *kp, size_t len)\n{\n\twhile (len--) {\n\t\tlist_add_tail(&kp->list_node, &kdb_cmds_head);\n\t\tkp++;\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kdb_cmds_head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic LIST_HEAD(kdb_cmds_head);\n\nvoid kdb_register_table(kdbtab_t *kp, size_t len)\n{\n\twhile (len--) {\n\t\tlist_add_tail(&kp->list_node, &kdb_cmds_head);\n\t\tkp++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "maintab"
          ],
          "line": 2891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void __init kdb_inittab(void)\n{\n\tkdb_register_table(maintab, ARRAY_SIZE(maintab));\n\tif (arch_kgdb_ops.enable_nmi)\n\t\tkdb_register_table(&nmicmd, 1);\n}"
  },
  {
    "function_name": "kdb_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2667-2670",
    "snippet": "void kdb_unregister(kdbtab_t *cmd)\n{\n\tlist_del(&cmd->list_node);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cmd->list_node"
          ],
          "line": 2669
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid kdb_unregister(kdbtab_t *cmd)\n{\n\tlist_del(&cmd->list_node);\n}"
  },
  {
    "function_name": "kdb_register_table",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2653-2659",
    "snippet": "void kdb_register_table(kdbtab_t *kp, size_t len)\n{\n\twhile (len--) {\n\t\tlist_add_tail(&kp->list_node, &kdb_cmds_head);\n\t\tkp++;\n\t}\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(kdb_cmds_head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&kp->list_node",
            "&kdb_cmds_head"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic LIST_HEAD(kdb_cmds_head);\n\nvoid kdb_register_table(kdbtab_t *kp, size_t len)\n{\n\twhile (len--) {\n\t\tlist_add_tail(&kp->list_node, &kdb_cmds_head);\n\t\tkp++;\n\t}\n}"
  },
  {
    "function_name": "kdb_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2630-2644",
    "snippet": "int kdb_register(kdbtab_t *cmd)\n{\n\tkdbtab_t *kp;\n\n\tlist_for_each_entry(kp, &kdb_cmds_head, list_node) {\n\t\tif (strcmp(kp->name, cmd->name) == 0) {\n\t\t\tkdb_printf(\"Duplicate kdb cmd: %s, func %p help %s\\n\",\n\t\t\t\t   cmd->name, cmd->func, cmd->help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tlist_add_tail(&cmd->list_node, &kdb_cmds_head);\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(kdb_cmds_head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cmd->list_node",
            "&kdb_cmds_head"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Duplicate kdb cmd: %s, func %p help %s\\n\"",
            "cmd->name",
            "cmd->func",
            "cmd->help"
          ],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "kp->name",
            "cmd->name"
          ],
          "line": 2635
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kp",
            "&kdb_cmds_head",
            "list_node"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic LIST_HEAD(kdb_cmds_head);\n\nint kdb_register(kdbtab_t *cmd)\n{\n\tkdbtab_t *kp;\n\n\tlist_for_each_entry(kp, &kdb_cmds_head, list_node) {\n\t\tif (strcmp(kp->name, cmd->name) == 0) {\n\t\t\tkdb_printf(\"Duplicate kdb cmd: %s, func %p help %s\\n\",\n\t\t\t\t   cmd->name, cmd->func, cmd->help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tlist_add_tail(&cmd->list_node, &kdb_cmds_head);\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_grep_help",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2606-2620",
    "snippet": "static int kdb_grep_help(int argc, const char **argv)\n{\n\tkdb_printf(\"Usage of  cmd args | grep pattern:\\n\");\n\tkdb_printf(\"  Any command's output may be filtered through an \");\n\tkdb_printf(\"emulated 'pipe'.\\n\");\n\tkdb_printf(\"  'grep' is just a key word.\\n\");\n\tkdb_printf(\"  The pattern may include a very limited set of \"\n\t\t   \"metacharacters:\\n\");\n\tkdb_printf(\"   pattern or ^pattern or pattern$ or ^pattern$\\n\");\n\tkdb_printf(\"  And if there are spaces in the pattern, you may \"\n\t\t   \"quote it:\\n\");\n\tkdb_printf(\"   \\\"pat tern\\\" or \\\"^pat tern\\\" or \\\"pat tern$\\\"\"\n\t\t   \" or \\\"^pat tern$\\\"\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"   \\\"pat tern\\\" or \\\"^pat tern\\\" or \\\"pat tern$\\\"\"\n\t\t   \" or \\\"^pat tern$\\\"\\n\""
          ],
          "line": 2617
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_grep_help(int argc, const char **argv)\n{\n\tkdb_printf(\"Usage of  cmd args | grep pattern:\\n\");\n\tkdb_printf(\"  Any command's output may be filtered through an \");\n\tkdb_printf(\"emulated 'pipe'.\\n\");\n\tkdb_printf(\"  'grep' is just a key word.\\n\");\n\tkdb_printf(\"  The pattern may include a very limited set of \"\n\t\t   \"metacharacters:\\n\");\n\tkdb_printf(\"   pattern or ^pattern or pattern$ or ^pattern$\\n\");\n\tkdb_printf(\"  And if there are spaces in the pattern, you may \"\n\t\t   \"quote it:\\n\");\n\tkdb_printf(\"   \\\"pat tern\\\" or \\\"^pat tern\\\" or \\\"pat tern$\\\"\"\n\t\t   \" or \\\"^pat tern$\\\"\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_per_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2536-2601",
    "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (whichcpu >= nr_cpu_ids || !cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_md_line",
          "args": [
            "fmtstr",
            "addr",
            "bytesperword == KDB_WORD_SIZE",
            "1",
            "bytesperword",
            "1",
            "1",
            "0"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_md_line",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1476-1539",
          "snippet": "static void kdb_md_line(const char *fmtstr, unsigned long addr,\n\t\t\tint symbolic, int nosect, int bytesperword,\n\t\t\tint num, int repeat, int phys)\n{\n\t/* print just one line of data */\n\tkdb_symtab_t symtab;\n\tchar cbuf[32];\n\tchar *c = cbuf;\n\tint i;\n\tint j;\n\tunsigned long word;\n\n\tmemset(cbuf, '\\0', sizeof(cbuf));\n\tif (phys)\n\t\tkdb_printf(\"phys \" kdb_machreg_fmt0 \" \", addr);\n\telse\n\t\tkdb_printf(kdb_machreg_fmt0 \" \", addr);\n\n\tfor (i = 0; i < num && repeat--; i++) {\n\t\tif (phys) {\n\t\t\tif (kdb_getphysword(&word, addr, bytesperword))\n\t\t\t\tbreak;\n\t\t} else if (kdb_getword(&word, addr, bytesperword))\n\t\t\tbreak;\n\t\tkdb_printf(fmtstr, word);\n\t\tif (symbolic)\n\t\t\tkdbnearsym(word, &symtab);\n\t\telse\n\t\t\tmemset(&symtab, 0, sizeof(symtab));\n\t\tif (symtab.sym_name) {\n\t\t\tkdb_symbol_print(word, &symtab, 0);\n\t\t\tif (!nosect) {\n\t\t\t\tkdb_printf(\"\\n\");\n\t\t\t\tkdb_printf(\"                       %s %s \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt, symtab.mod_name,\n\t\t\t\t\t   symtab.sec_name, symtab.sec_start,\n\t\t\t\t\t   symtab.sym_start, symtab.sym_end);\n\t\t\t}\n\t\t\taddr += bytesperword;\n\t\t} else {\n\t\t\tunion {\n\t\t\t\tu64 word;\n\t\t\t\tunsigned char c[8];\n\t\t\t} wc;\n\t\t\tunsigned char *cp;\n#ifdef\t__BIG_ENDIAN\n\t\t\tcp = wc.c + 8 - bytesperword;\n#else\n\t\t\tcp = wc.c;\n#endif\n\t\t\twc.word = word;\n#define printable_char(c) \\\n\t({unsigned char __c = c; isascii(__c) && isprint(__c) ? __c : '.'; })\n\t\t\tfor (j = 0; j < bytesperword; j++)\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\taddr += bytesperword;\n#undef printable_char\n\t\t}\n\t}\n\tkdb_printf(\"%*s %s\\n\", (int)((num-i)*(2*bytesperword + 1)+1),\n\t\t   \" \", cbuf);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_md_line(const char *fmtstr, unsigned long addr,\n\t\t\tint symbolic, int nosect, int bytesperword,\n\t\t\tint num, int repeat, int phys)\n{\n\t/* print just one line of data */\n\tkdb_symtab_t symtab;\n\tchar cbuf[32];\n\tchar *c = cbuf;\n\tint i;\n\tint j;\n\tunsigned long word;\n\n\tmemset(cbuf, '\\0', sizeof(cbuf));\n\tif (phys)\n\t\tkdb_printf(\"phys \" kdb_machreg_fmt0 \" \", addr);\n\telse\n\t\tkdb_printf(kdb_machreg_fmt0 \" \", addr);\n\n\tfor (i = 0; i < num && repeat--; i++) {\n\t\tif (phys) {\n\t\t\tif (kdb_getphysword(&word, addr, bytesperword))\n\t\t\t\tbreak;\n\t\t} else if (kdb_getword(&word, addr, bytesperword))\n\t\t\tbreak;\n\t\tkdb_printf(fmtstr, word);\n\t\tif (symbolic)\n\t\t\tkdbnearsym(word, &symtab);\n\t\telse\n\t\t\tmemset(&symtab, 0, sizeof(symtab));\n\t\tif (symtab.sym_name) {\n\t\t\tkdb_symbol_print(word, &symtab, 0);\n\t\t\tif (!nosect) {\n\t\t\t\tkdb_printf(\"\\n\");\n\t\t\t\tkdb_printf(\"                       %s %s \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt, symtab.mod_name,\n\t\t\t\t\t   symtab.sec_name, symtab.sec_start,\n\t\t\t\t\t   symtab.sym_start, symtab.sym_end);\n\t\t\t}\n\t\t\taddr += bytesperword;\n\t\t} else {\n\t\t\tunion {\n\t\t\t\tu64 word;\n\t\t\t\tunsigned char c[8];\n\t\t\t} wc;\n\t\t\tunsigned char *cp;\n#ifdef\t__BIG_ENDIAN\n\t\t\tcp = wc.c + 8 - bytesperword;\n#else\n\t\t\tcp = wc.c;\n#endif\n\t\t\twc.word = word;\n#define printable_char(c) \\\n\t({unsigned char __c = c; isascii(__c) && isprint(__c) ? __c : '.'; })\n\t\t\tfor (j = 0; j < bytesperword; j++)\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\taddr += bytesperword;\n#undef printable_char\n\t\t}\n\t}\n\tkdb_printf(\"%*s %s\\n\", (int)((num-i)*(2*bytesperword + 1)+1),\n\t\t   \" \", cbuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%5d \"",
            "cpu"
          ],
          "line": 2594
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getword",
          "args": [
            "&val",
            "addr",
            "bytesperword"
          ],
          "line": 2588
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getword",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "394-431",
          "snippet": "int kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_PCU",
          "args": [
            "cpu"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "whichcpu"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetularg",
          "args": [
            "argv[3]",
            "&whichcpu"
          ],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetularg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "362-382",
          "snippet": "int kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fmtstr",
            "\"%%0%dlx \"",
            "(int)(2*bytesperword)"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetaddrarg",
          "args": [
            "argc",
            "argv",
            "&nextarg",
            "&symaddr",
            "NULL",
            "NULL"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetaddrarg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "491-623",
          "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (whichcpu >= nr_cpu_ids || !cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_summary",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2494-2531",
    "snippet": "static int kdb_summary(int argc, const char **argv)\n{\n\ttime64_t now;\n\tstruct sysinfo val;\n\n\tif (argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tkdb_printf(\"sysname    %s\\n\", init_uts_ns.name.sysname);\n\tkdb_printf(\"release    %s\\n\", init_uts_ns.name.release);\n\tkdb_printf(\"version    %s\\n\", init_uts_ns.name.version);\n\tkdb_printf(\"machine    %s\\n\", init_uts_ns.name.machine);\n\tkdb_printf(\"nodename   %s\\n\", init_uts_ns.name.nodename);\n\tkdb_printf(\"domainname %s\\n\", init_uts_ns.name.domainname);\n\n\tnow = __ktime_get_real_seconds();\n\tkdb_printf(\"date       %ptTs tz_minuteswest %d\\n\", &now, sys_tz.tz_minuteswest);\n\tkdb_sysinfo(&val);\n\tkdb_printf(\"uptime     \");\n\tif (val.uptime > (24*60*60)) {\n\t\tint days = val.uptime / (24*60*60);\n\t\tval.uptime %= (24*60*60);\n\t\tkdb_printf(\"%d day%s \", days, days == 1 ? \"\" : \"s\");\n\t}\n\tkdb_printf(\"%02ld:%02ld\\n\", val.uptime/(60*60), (val.uptime/60)%60);\n\n\tkdb_printf(\"load avg   %ld.%02ld %ld.%02ld %ld.%02ld\\n\",\n\t\tLOAD_INT(val.loads[0]), LOAD_FRAC(val.loads[0]),\n\t\tLOAD_INT(val.loads[1]), LOAD_FRAC(val.loads[1]),\n\t\tLOAD_INT(val.loads[2]), LOAD_FRAC(val.loads[2]));\n\n\t/* Display in kilobytes */\n#define K(x) ((x) << (PAGE_SHIFT - 10))\n\tkdb_printf(\"\\nMemTotal:       %8lu kB\\nMemFree:        %8lu kB\\n\"\n\t\t   \"Buffers:        %8lu kB\\n\",\n\t\t   K(val.totalram), K(val.freeram), K(val.bufferram));\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\nMemTotal:       %8lu kB\\nMemFree:        %8lu kB\\n\"\n\t\t   \"Buffers:        %8lu kB\\n\"",
            "K(val.totalram)",
            "K(val.freeram)",
            "K(val.bufferram)"
          ],
          "line": 2527
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "val.bufferram"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "val.freeram"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "val.totalram"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_FRAC",
          "args": [
            "val.loads[2]"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_INT",
          "args": [
            "val.loads[2]"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_FRAC",
          "args": [
            "val.loads[1]"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_INT",
          "args": [
            "val.loads[1]"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_FRAC",
          "args": [
            "val.loads[0]"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_INT",
          "args": [
            "val.loads[0]"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_sysinfo",
          "args": [
            "&val"
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_sysinfo",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2476-2489",
          "snippet": "static void kdb_sysinfo(struct sysinfo *val)\n{\n\tu64 uptime = ktime_get_mono_fast_ns();\n\n\tmemset(val, 0, sizeof(*val));\n\tval->uptime = div_u64(uptime, NSEC_PER_SEC);\n\tval->loads[0] = avenrun[0];\n\tval->loads[1] = avenrun[1];\n\tval->loads[2] = avenrun[2];\n\tval->procs = nr_threads-1;\n\tsi_meminfo(val);\n\n\treturn;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_sysinfo(struct sysinfo *val)\n{\n\tu64 uptime = ktime_get_mono_fast_ns();\n\n\tmemset(val, 0, sizeof(*val));\n\tval->uptime = div_u64(uptime, NSEC_PER_SEC);\n\tval->loads[0] = avenrun[0];\n\tval->loads[1] = avenrun[1];\n\tval->loads[2] = avenrun[2];\n\tval->procs = nr_threads-1;\n\tsi_meminfo(val);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ktime_get_real_seconds",
          "args": [],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_summary(int argc, const char **argv)\n{\n\ttime64_t now;\n\tstruct sysinfo val;\n\n\tif (argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tkdb_printf(\"sysname    %s\\n\", init_uts_ns.name.sysname);\n\tkdb_printf(\"release    %s\\n\", init_uts_ns.name.release);\n\tkdb_printf(\"version    %s\\n\", init_uts_ns.name.version);\n\tkdb_printf(\"machine    %s\\n\", init_uts_ns.name.machine);\n\tkdb_printf(\"nodename   %s\\n\", init_uts_ns.name.nodename);\n\tkdb_printf(\"domainname %s\\n\", init_uts_ns.name.domainname);\n\n\tnow = __ktime_get_real_seconds();\n\tkdb_printf(\"date       %ptTs tz_minuteswest %d\\n\", &now, sys_tz.tz_minuteswest);\n\tkdb_sysinfo(&val);\n\tkdb_printf(\"uptime     \");\n\tif (val.uptime > (24*60*60)) {\n\t\tint days = val.uptime / (24*60*60);\n\t\tval.uptime %= (24*60*60);\n\t\tkdb_printf(\"%d day%s \", days, days == 1 ? \"\" : \"s\");\n\t}\n\tkdb_printf(\"%02ld:%02ld\\n\", val.uptime/(60*60), (val.uptime/60)%60);\n\n\tkdb_printf(\"load avg   %ld.%02ld %ld.%02ld %ld.%02ld\\n\",\n\t\tLOAD_INT(val.loads[0]), LOAD_FRAC(val.loads[0]),\n\t\tLOAD_INT(val.loads[1]), LOAD_FRAC(val.loads[1]),\n\t\tLOAD_INT(val.loads[2]), LOAD_FRAC(val.loads[2]));\n\n\t/* Display in kilobytes */\n#define K(x) ((x) << (PAGE_SHIFT - 10))\n\tkdb_printf(\"\\nMemTotal:       %8lu kB\\nMemFree:        %8lu kB\\n\"\n\t\t   \"Buffers:        %8lu kB\\n\",\n\t\t   K(val.totalram), K(val.freeram), K(val.bufferram));\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_sysinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2476-2489",
    "snippet": "static void kdb_sysinfo(struct sysinfo *val)\n{\n\tu64 uptime = ktime_get_mono_fast_ns();\n\n\tmemset(val, 0, sizeof(*val));\n\tval->uptime = div_u64(uptime, NSEC_PER_SEC);\n\tval->loads[0] = avenrun[0];\n\tval->loads[1] = avenrun[1];\n\tval->loads[2] = avenrun[2];\n\tval->procs = nr_threads-1;\n\tsi_meminfo(val);\n\n\treturn;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "si_meminfo",
          "args": [
            "val"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "uptime",
            "NSEC_PER_SEC"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "val",
            "0",
            "sizeof(*val)"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_mono_fast_ns",
          "args": [],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_mono_fast_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "485-488",
          "snippet": "u64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_sysinfo(struct sysinfo *val)\n{\n\tu64 uptime = ktime_get_mono_fast_ns();\n\n\tmemset(val, 0, sizeof(*val));\n\tval->uptime = div_u64(uptime, NSEC_PER_SEC);\n\tval->loads[0] = avenrun[0];\n\tval->loads[1] = avenrun[1];\n\tval->loads[2] = avenrun[2];\n\tval->procs = nr_threads-1;\n\tsi_meminfo(val);\n\n\treturn;\n}"
  },
  {
    "function_name": "kdb_kill",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2434-2469",
    "snippet": "static int kdb_kill(int argc, const char **argv)\n{\n\tlong sig, pid;\n\tchar *endp;\n\tstruct task_struct *p;\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\n\tsig = simple_strtol(argv[1], &endp, 0);\n\tif (*endp)\n\t\treturn KDB_BADINT;\n\tif ((sig >= 0) || !valid_signal(-sig)) {\n\t\tkdb_printf(\"Invalid signal parameter.<-signal>\\n\");\n\t\treturn 0;\n\t}\n\tsig = -sig;\n\n\tpid = simple_strtol(argv[2], &endp, 0);\n\tif (*endp)\n\t\treturn KDB_BADINT;\n\tif (pid <= 0) {\n\t\tkdb_printf(\"Process ID must be large than 0.\\n\");\n\t\treturn 0;\n\t}\n\n\t/* Find the process. */\n\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\tif (!p) {\n\t\tkdb_printf(\"The specified process isn't found.\\n\");\n\t\treturn 0;\n\t}\n\tp = p->group_leader;\n\tkdb_send_sig(p, sig);\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_send_sig",
          "args": [
            "p",
            "sig"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_send_sig",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "4773-4802",
          "snippet": "void kdb_send_sig(struct task_struct *t, int sig)\n{\n\tstatic struct task_struct *kdb_prev_t;\n\tint new_t, ret;\n\tif (!spin_trylock(&t->sighand->siglock)) {\n\t\tkdb_printf(\"Can't do kill command now.\\n\"\n\t\t\t   \"The sigmask lock is held somewhere else in \"\n\t\t\t   \"kernel, try again later\\n\");\n\t\treturn;\n\t}\n\tnew_t = kdb_prev_t != t;\n\tkdb_prev_t = t;\n\tif (!task_is_running(t) && new_t) {\n\t\tspin_unlock(&t->sighand->siglock);\n\t\tkdb_printf(\"Process is not RUNNING, sending a signal from \"\n\t\t\t   \"kdb risks deadlock\\n\"\n\t\t\t   \"on the run queue locks. \"\n\t\t\t   \"The signal has _not_ been sent.\\n\"\n\t\t\t   \"Reissue the kill command if you want to risk \"\n\t\t\t   \"the deadlock.\\n\");\n\t\treturn;\n\t}\n\tret = send_signal(sig, SEND_SIG_PRIV, t, PIDTYPE_PID);\n\tspin_unlock(&t->sighand->siglock);\n\tif (ret)\n\t\tkdb_printf(\"Fail to deliver Signal %d to process %d.\\n\",\n\t\t\t   sig, t->pid);\n\telse\n\t\tkdb_printf(\"Signal %d is sent to process %d.\\n\", sig, t->pid);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid kdb_send_sig(struct task_struct *t, int sig)\n{\n\tstatic struct task_struct *kdb_prev_t;\n\tint new_t, ret;\n\tif (!spin_trylock(&t->sighand->siglock)) {\n\t\tkdb_printf(\"Can't do kill command now.\\n\"\n\t\t\t   \"The sigmask lock is held somewhere else in \"\n\t\t\t   \"kernel, try again later\\n\");\n\t\treturn;\n\t}\n\tnew_t = kdb_prev_t != t;\n\tkdb_prev_t = t;\n\tif (!task_is_running(t) && new_t) {\n\t\tspin_unlock(&t->sighand->siglock);\n\t\tkdb_printf(\"Process is not RUNNING, sending a signal from \"\n\t\t\t   \"kdb risks deadlock\\n\"\n\t\t\t   \"on the run queue locks. \"\n\t\t\t   \"The signal has _not_ been sent.\\n\"\n\t\t\t   \"Reissue the kill command if you want to risk \"\n\t\t\t   \"the deadlock.\\n\");\n\t\treturn;\n\t}\n\tret = send_signal(sig, SEND_SIG_PRIV, t, PIDTYPE_PID);\n\tspin_unlock(&t->sighand->siglock);\n\tif (ret)\n\t\tkdb_printf(\"Fail to deliver Signal %d to process %d.\\n\",\n\t\t\t   sig, t->pid);\n\telse\n\t\tkdb_printf(\"Signal %d is sent to process %d.\\n\", sig, t->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"The specified process isn't found.\\n\""
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_task_by_pid_ns",
          "args": [
            "pid",
            "&init_pid_ns"
          ],
          "line": 2461
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "413-418",
          "snippet": "struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "argv[2]",
            "&endp",
            "0"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_signal",
          "args": [
            "-sig"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "argv[1]",
            "&endp",
            "0"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_kill(int argc, const char **argv)\n{\n\tlong sig, pid;\n\tchar *endp;\n\tstruct task_struct *p;\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\n\tsig = simple_strtol(argv[1], &endp, 0);\n\tif (*endp)\n\t\treturn KDB_BADINT;\n\tif ((sig >= 0) || !valid_signal(-sig)) {\n\t\tkdb_printf(\"Invalid signal parameter.<-signal>\\n\");\n\t\treturn 0;\n\t}\n\tsig = -sig;\n\n\tpid = simple_strtol(argv[2], &endp, 0);\n\tif (*endp)\n\t\treturn KDB_BADINT;\n\tif (pid <= 0) {\n\t\tkdb_printf(\"Process ID must be large than 0.\\n\");\n\t\treturn 0;\n\t}\n\n\t/* Find the process. */\n\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\tif (!p) {\n\t\tkdb_printf(\"The specified process isn't found.\\n\");\n\t\treturn 0;\n\t}\n\tp = p->group_leader;\n\tkdb_send_sig(p, sig);\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_help",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2410-2429",
    "snippet": "static int kdb_help(int argc, const char **argv)\n{\n\tkdbtab_t *kt;\n\n\tkdb_printf(\"%-15.15s %-20.20s %s\\n\", \"Command\", \"Usage\", \"Description\");\n\tkdb_printf(\"-----------------------------\"\n\t\t   \"-----------------------------\\n\");\n\tlist_for_each_entry(kt, &kdb_cmds_head, list_node) {\n\t\tchar *space = \"\";\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tif (!kdb_check_flags(kt->flags, kdb_cmd_enabled, true))\n\t\t\tcontinue;\n\t\tif (strlen(kt->usage) > 20)\n\t\t\tspace = \"\\n                                    \";\n\t\tkdb_printf(\"%-15.15s %-20s%s%s\\n\", kt->name,\n\t\t\t   kt->usage, space, kt->help);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;",
      "static LIST_HEAD(kdb_cmds_head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%-15.15s %-20s%s%s\\n\"",
            "kt->name",
            "kt->usage",
            "space",
            "kt->help"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "kt->usage"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_check_flags",
          "args": [
            "kt->flags",
            "kdb_cmd_enabled",
            "true"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_check_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "172-186",
          "snippet": "static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kt",
            "&kdb_cmds_head",
            "list_node"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\nstatic LIST_HEAD(kdb_cmds_head);\n\nstatic int kdb_help(int argc, const char **argv)\n{\n\tkdbtab_t *kt;\n\n\tkdb_printf(\"%-15.15s %-20.20s %s\\n\", \"Command\", \"Usage\", \"Description\");\n\tkdb_printf(\"-----------------------------\"\n\t\t   \"-----------------------------\\n\");\n\tlist_for_each_entry(kt, &kdb_cmds_head, list_node) {\n\t\tchar *space = \"\";\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tif (!kdb_check_flags(kt->flags, kdb_cmd_enabled, true))\n\t\t\tcontinue;\n\t\tif (strlen(kt->usage) > 20)\n\t\t\tspace = \"\\n                                    \";\n\t\tkdb_printf(\"%-15.15s %-20s%s%s\\n\", kt->name,\n\t\t\t   kt->usage, space, kt->help);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_kgdb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2402-2405",
    "snippet": "static int kdb_kgdb(int argc, const char **argv)\n{\n\treturn KDB_CMD_KGDB;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_kgdb(int argc, const char **argv)\n{\n\treturn KDB_CMD_KGDB;\n}"
  },
  {
    "function_name": "kdb_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2370-2400",
    "snippet": "static int kdb_pid(int argc, const char **argv)\n{\n\tstruct task_struct *p;\n\tunsigned long val;\n\tint diag;\n\n\tif (argc > 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tif (argc) {\n\t\tif (strcmp(argv[1], \"R\") == 0) {\n\t\t\tp = KDB_TSK(kdb_initial_cpu);\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[1], &val);\n\t\t\tif (diag)\n\t\t\t\treturn KDB_BADINT;\n\n\t\t\tp = find_task_by_pid_ns((pid_t)val,\t&init_pid_ns);\n\t\t\tif (!p) {\n\t\t\t\tkdb_printf(\"No task with pid=%d\\n\", (pid_t)val);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tkdb_set_current_task(p);\n\t}\n\tkdb_printf(\"KDB current process is %s(pid=%d)\\n\",\n\t\t   kdb_current_task->comm,\n\t\t   kdb_current_task->pid);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int kdb_initial_cpu = -1;",
      "struct task_struct *kdb_current_task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"KDB current process is %s(pid=%d)\\n\"",
            "kdb_current_task->comm",
            "kdb_current_task->pid"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_set_current_task",
          "args": [
            "p"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_set_current_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1134-1143",
          "snippet": "static void kdb_set_current_task(struct task_struct *p)\n{\n\tkdb_current_task = p;\n\n\tif (kdb_task_has_cpu(p)) {\n\t\tkdb_current_regs = KDB_TSKREGS(kdb_process_cpu(p));\n\t\treturn;\n\t}\n\tkdb_current_regs = NULL;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *kdb_current_task;",
            "struct pt_regs *kdb_current_regs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_current_task;\nstruct pt_regs *kdb_current_regs;\n\nstatic void kdb_set_current_task(struct task_struct *p)\n{\n\tkdb_current_task = p;\n\n\tif (kdb_task_has_cpu(p)) {\n\t\tkdb_current_regs = KDB_TSKREGS(kdb_process_cpu(p));\n\t\treturn;\n\t}\n\tkdb_current_regs = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_task_by_pid_ns",
          "args": [
            "(pid_t)val",
            "&init_pid_ns"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "413-418",
          "snippet": "struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetularg",
          "args": [
            "argv[1]",
            "&val"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetularg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "362-382",
          "snippet": "int kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_TSK",
          "args": [
            "kdb_initial_cpu"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"R\""
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdb_initial_cpu = -1;\nstruct task_struct *kdb_current_task;\n\nstatic int kdb_pid(int argc, const char **argv)\n{\n\tstruct task_struct *p;\n\tunsigned long val;\n\tint diag;\n\n\tif (argc > 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tif (argc) {\n\t\tif (strcmp(argv[1], \"R\") == 0) {\n\t\t\tp = KDB_TSK(kdb_initial_cpu);\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[1], &val);\n\t\t\tif (diag)\n\t\t\t\treturn KDB_BADINT;\n\n\t\t\tp = find_task_by_pid_ns((pid_t)val,\t&init_pid_ns);\n\t\t\tif (!p) {\n\t\t\t\tkdb_printf(\"No task with pid=%d\\n\", (pid_t)val);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tkdb_set_current_task(p);\n\t}\n\tkdb_printf(\"KDB current process is %s(pid=%d)\\n\",\n\t\t   kdb_current_task->comm,\n\t\t   kdb_current_task->pid);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_ps",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2333-2363",
    "snippet": "static int kdb_ps(int argc, const char **argv)\n{\n\tstruct task_struct *g, *p;\n\tconst char *mask;\n\tunsigned long cpu;\n\n\tif (argc == 0)\n\t\tkdb_ps_suppressed();\n\tkdb_printf(\"%-*s      Pid   Parent [*] cpu State %-*s Command\\n\",\n\t\t(int)(2*sizeof(void *))+2, \"Task Addr\",\n\t\t(int)(2*sizeof(void *))+2, \"Thread\");\n\tmask = argc ? argv[1] : kdbgetenv(\"PS\");\n\t/* Run the active tasks first */\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, mask))\n\t\t\tkdb_ps1(p);\n\t}\n\tkdb_printf(\"\\n\");\n\t/* Now the real tasks */\n\tfor_each_process_thread(g, p) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tif (kdb_task_state(p, mask))\n\t\t\tkdb_ps1(p);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_ps1",
          "args": [
            "p"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_ps1",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2298-2324",
          "snippet": "void kdb_ps1(const struct task_struct *p)\n{\n\tint cpu;\n\tunsigned long tmp;\n\n\tif (!p ||\n\t    copy_from_kernel_nofault(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn;\n\n\tcpu = kdb_process_cpu(p);\n\tkdb_printf(\"0x%px %8d %8d  %d %4d   %c  0x%px %c%s\\n\",\n\t\t   (void *)p, p->pid, p->parent->pid,\n\t\t   kdb_task_has_cpu(p), kdb_process_cpu(p),\n\t\t   kdb_task_state_char(p),\n\t\t   (void *)(&p->thread),\n\t\t   p == kdb_curr_task(raw_smp_processor_id()) ? '*' : ' ',\n\t\t   p->comm);\n\tif (kdb_task_has_cpu(p)) {\n\t\tif (!KDB_TSK(cpu)) {\n\t\t\tkdb_printf(\"  Error: no saved data for this cpu\\n\");\n\t\t} else {\n\t\t\tif (KDB_TSK(cpu) != p)\n\t\t\t\tkdb_printf(\"  Error: does not match running \"\n\t\t\t\t   \"process table (0x%px)\\n\", KDB_TSK(cpu));\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid kdb_ps1(const struct task_struct *p)\n{\n\tint cpu;\n\tunsigned long tmp;\n\n\tif (!p ||\n\t    copy_from_kernel_nofault(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn;\n\n\tcpu = kdb_process_cpu(p);\n\tkdb_printf(\"0x%px %8d %8d  %d %4d   %c  0x%px %c%s\\n\",\n\t\t   (void *)p, p->pid, p->parent->pid,\n\t\t   kdb_task_has_cpu(p), kdb_process_cpu(p),\n\t\t   kdb_task_state_char(p),\n\t\t   (void *)(&p->thread),\n\t\t   p == kdb_curr_task(raw_smp_processor_id()) ? '*' : ' ',\n\t\t   p->comm);\n\tif (kdb_task_has_cpu(p)) {\n\t\tif (!KDB_TSK(cpu)) {\n\t\t\tkdb_printf(\"  Error: no saved data for this cpu\\n\");\n\t\t} else {\n\t\t\tif (KDB_TSK(cpu) != p)\n\t\t\t\tkdb_printf(\"  Error: does not match running \"\n\t\t\t\t   \"process table (0x%px)\\n\", KDB_TSK(cpu));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_task_state",
          "args": [
            "p",
            "mask"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_task_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "523-539",
          "snippet": "bool kdb_task_state(const struct task_struct *p, const char *mask)\n{\n\tchar state = kdb_task_state_char(p);\n\n\t/* If there is no mask, then we will filter code that runs when the\n\t * scheduler is idling and any system daemons that are currently\n\t * sleeping.\n\t */\n\tif (!mask || mask[0] == '\\0')\n\t\treturn !strchr(\"-ims\", state);\n\n\t/* A is a special case that matches all states */\n\tif (strchr(mask, 'A'))\n\t\treturn true;\n\n\treturn strchr(mask, state);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nbool kdb_task_state(const struct task_struct *p, const char *mask)\n{\n\tchar state = kdb_task_state_char(p);\n\n\t/* If there is no mask, then we will filter code that runs when the\n\t * scheduler is idling and any system daemons that are currently\n\t * sleeping.\n\t */\n\tif (!mask || mask[0] == '\\0')\n\t\treturn !strchr(\"-ims\", state);\n\n\t/* A is a special case that matches all states */\n\tif (strchr(mask, 'A'))\n\t\treturn true;\n\n\treturn strchr(mask, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_curr_task",
          "args": [
            "cpu"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_curr_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "158-166",
          "snippet": "struct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetenv",
          "args": [
            "\"PS\""
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetenv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "197-217",
          "snippet": "char *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nchar *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_ps_suppressed",
          "args": [],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_ps_suppressed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2271-2296",
          "snippet": "void kdb_ps_suppressed(void)\n{\n\tint idle = 0, daemon = 0;\n\tunsigned long cpu;\n\tconst struct task_struct *p, *g;\n\tfor_each_online_cpu(cpu) {\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, \"-\"))\n\t\t\t++idle;\n\t}\n\tfor_each_process_thread(g, p) {\n\t\tif (kdb_task_state(p, \"ims\"))\n\t\t\t++daemon;\n\t}\n\tif (idle || daemon) {\n\t\tif (idle)\n\t\t\tkdb_printf(\"%d idle process%s (state -)%s\\n\",\n\t\t\t\t   idle, idle == 1 ? \"\" : \"es\",\n\t\t\t\t   daemon ? \" and \" : \"\");\n\t\tif (daemon)\n\t\t\tkdb_printf(\"%d sleeping system daemon (state [ims]) \"\n\t\t\t\t   \"process%s\", daemon,\n\t\t\t\t   daemon == 1 ? \"\" : \"es\");\n\t\tkdb_printf(\" suppressed,\\nuse 'ps A' to see all.\\n\");\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid kdb_ps_suppressed(void)\n{\n\tint idle = 0, daemon = 0;\n\tunsigned long cpu;\n\tconst struct task_struct *p, *g;\n\tfor_each_online_cpu(cpu) {\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, \"-\"))\n\t\t\t++idle;\n\t}\n\tfor_each_process_thread(g, p) {\n\t\tif (kdb_task_state(p, \"ims\"))\n\t\t\t++daemon;\n\t}\n\tif (idle || daemon) {\n\t\tif (idle)\n\t\t\tkdb_printf(\"%d idle process%s (state -)%s\\n\",\n\t\t\t\t   idle, idle == 1 ? \"\" : \"es\",\n\t\t\t\t   daemon ? \" and \" : \"\");\n\t\tif (daemon)\n\t\t\tkdb_printf(\"%d sleeping system daemon (state [ims]) \"\n\t\t\t\t   \"process%s\", daemon,\n\t\t\t\t   daemon == 1 ? \"\" : \"es\");\n\t\tkdb_printf(\" suppressed,\\nuse 'ps A' to see all.\\n\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_ps(int argc, const char **argv)\n{\n\tstruct task_struct *g, *p;\n\tconst char *mask;\n\tunsigned long cpu;\n\n\tif (argc == 0)\n\t\tkdb_ps_suppressed();\n\tkdb_printf(\"%-*s      Pid   Parent [*] cpu State %-*s Command\\n\",\n\t\t(int)(2*sizeof(void *))+2, \"Task Addr\",\n\t\t(int)(2*sizeof(void *))+2, \"Thread\");\n\tmask = argc ? argv[1] : kdbgetenv(\"PS\");\n\t/* Run the active tasks first */\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, mask))\n\t\t\tkdb_ps1(p);\n\t}\n\tkdb_printf(\"\\n\");\n\t/* Now the real tasks */\n\tfor_each_process_thread(g, p) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tif (kdb_task_state(p, mask))\n\t\t\tkdb_ps1(p);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_ps1",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2298-2324",
    "snippet": "void kdb_ps1(const struct task_struct *p)\n{\n\tint cpu;\n\tunsigned long tmp;\n\n\tif (!p ||\n\t    copy_from_kernel_nofault(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn;\n\n\tcpu = kdb_process_cpu(p);\n\tkdb_printf(\"0x%px %8d %8d  %d %4d   %c  0x%px %c%s\\n\",\n\t\t   (void *)p, p->pid, p->parent->pid,\n\t\t   kdb_task_has_cpu(p), kdb_process_cpu(p),\n\t\t   kdb_task_state_char(p),\n\t\t   (void *)(&p->thread),\n\t\t   p == kdb_curr_task(raw_smp_processor_id()) ? '*' : ' ',\n\t\t   p->comm);\n\tif (kdb_task_has_cpu(p)) {\n\t\tif (!KDB_TSK(cpu)) {\n\t\t\tkdb_printf(\"  Error: no saved data for this cpu\\n\");\n\t\t} else {\n\t\t\tif (KDB_TSK(cpu) != p)\n\t\t\t\tkdb_printf(\"  Error: does not match running \"\n\t\t\t\t   \"process table (0x%px)\\n\", KDB_TSK(cpu));\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"  Error: does not match running \"\n\t\t\t\t   \"process table (0x%px)\\n\"",
            "KDB_TSK(cpu)"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_TSK",
          "args": [
            "cpu"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_TSK",
          "args": [
            "cpu"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_TSK",
          "args": [
            "cpu"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_task_has_cpu",
          "args": [
            "p"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_curr_task",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_curr_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "158-166",
          "snippet": "struct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_task_state_char",
          "args": [
            "p"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_task_state_char",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "486-510",
          "snippet": "char kdb_task_state_char (const struct task_struct *p)\n{\n\tunsigned long tmp;\n\tchar state;\n\tint cpu;\n\n\tif (!p ||\n\t    copy_from_kernel_nofault(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tstate = task_state_to_char((struct task_struct *) p);\n\n\tif (is_idle_task(p)) {\n\t\t/* Idle task.  Is it really idle, apart from the kdb\n\t\t * interrupt? */\n\t\tcpu = kdb_process_cpu(p);\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = '-';\t/* idle task */\n\t\t}\n\t} else if (!p->mm && strchr(\"IMS\", state)) {\n\t\tstate = tolower(state);\t\t/* sleeping system daemon */\n\t}\n\treturn state;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nchar kdb_task_state_char (const struct task_struct *p)\n{\n\tunsigned long tmp;\n\tchar state;\n\tint cpu;\n\n\tif (!p ||\n\t    copy_from_kernel_nofault(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tstate = task_state_to_char((struct task_struct *) p);\n\n\tif (is_idle_task(p)) {\n\t\t/* Idle task.  Is it really idle, apart from the kdb\n\t\t * interrupt? */\n\t\tcpu = kdb_process_cpu(p);\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = '-';\t/* idle task */\n\t\t}\n\t} else if (!p->mm && strchr(\"IMS\", state)) {\n\t\tstate = tolower(state);\t\t/* sleeping system daemon */\n\t}\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_process_cpu",
          "args": [
            "p"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_task_has_cpu",
          "args": [
            "p"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_process_cpu",
          "args": [
            "p"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "&tmp",
            "(char *)p",
            "sizeof(unsigned long)"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid kdb_ps1(const struct task_struct *p)\n{\n\tint cpu;\n\tunsigned long tmp;\n\n\tif (!p ||\n\t    copy_from_kernel_nofault(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn;\n\n\tcpu = kdb_process_cpu(p);\n\tkdb_printf(\"0x%px %8d %8d  %d %4d   %c  0x%px %c%s\\n\",\n\t\t   (void *)p, p->pid, p->parent->pid,\n\t\t   kdb_task_has_cpu(p), kdb_process_cpu(p),\n\t\t   kdb_task_state_char(p),\n\t\t   (void *)(&p->thread),\n\t\t   p == kdb_curr_task(raw_smp_processor_id()) ? '*' : ' ',\n\t\t   p->comm);\n\tif (kdb_task_has_cpu(p)) {\n\t\tif (!KDB_TSK(cpu)) {\n\t\t\tkdb_printf(\"  Error: no saved data for this cpu\\n\");\n\t\t} else {\n\t\t\tif (KDB_TSK(cpu) != p)\n\t\t\t\tkdb_printf(\"  Error: does not match running \"\n\t\t\t\t   \"process table (0x%px)\\n\", KDB_TSK(cpu));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "kdb_ps_suppressed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2271-2296",
    "snippet": "void kdb_ps_suppressed(void)\n{\n\tint idle = 0, daemon = 0;\n\tunsigned long cpu;\n\tconst struct task_struct *p, *g;\n\tfor_each_online_cpu(cpu) {\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, \"-\"))\n\t\t\t++idle;\n\t}\n\tfor_each_process_thread(g, p) {\n\t\tif (kdb_task_state(p, \"ims\"))\n\t\t\t++daemon;\n\t}\n\tif (idle || daemon) {\n\t\tif (idle)\n\t\t\tkdb_printf(\"%d idle process%s (state -)%s\\n\",\n\t\t\t\t   idle, idle == 1 ? \"\" : \"es\",\n\t\t\t\t   daemon ? \" and \" : \"\");\n\t\tif (daemon)\n\t\t\tkdb_printf(\"%d sleeping system daemon (state [ims]) \"\n\t\t\t\t   \"process%s\", daemon,\n\t\t\t\t   daemon == 1 ? \"\" : \"es\");\n\t\tkdb_printf(\" suppressed,\\nuse 'ps A' to see all.\\n\");\n\t}\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\" suppressed,\\nuse 'ps A' to see all.\\n\""
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_task_state",
          "args": [
            "p",
            "\"ims\""
          ],
          "line": 2282
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_task_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "523-539",
          "snippet": "bool kdb_task_state(const struct task_struct *p, const char *mask)\n{\n\tchar state = kdb_task_state_char(p);\n\n\t/* If there is no mask, then we will filter code that runs when the\n\t * scheduler is idling and any system daemons that are currently\n\t * sleeping.\n\t */\n\tif (!mask || mask[0] == '\\0')\n\t\treturn !strchr(\"-ims\", state);\n\n\t/* A is a special case that matches all states */\n\tif (strchr(mask, 'A'))\n\t\treturn true;\n\n\treturn strchr(mask, state);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nbool kdb_task_state(const struct task_struct *p, const char *mask)\n{\n\tchar state = kdb_task_state_char(p);\n\n\t/* If there is no mask, then we will filter code that runs when the\n\t * scheduler is idling and any system daemons that are currently\n\t * sleeping.\n\t */\n\tif (!mask || mask[0] == '\\0')\n\t\treturn !strchr(\"-ims\", state);\n\n\t/* A is a special case that matches all states */\n\tif (strchr(mask, 'A'))\n\t\treturn true;\n\n\treturn strchr(mask, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_curr_task",
          "args": [
            "cpu"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_curr_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "158-166",
          "snippet": "struct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid kdb_ps_suppressed(void)\n{\n\tint idle = 0, daemon = 0;\n\tunsigned long cpu;\n\tconst struct task_struct *p, *g;\n\tfor_each_online_cpu(cpu) {\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, \"-\"))\n\t\t\t++idle;\n\t}\n\tfor_each_process_thread(g, p) {\n\t\tif (kdb_task_state(p, \"ims\"))\n\t\t\t++daemon;\n\t}\n\tif (idle || daemon) {\n\t\tif (idle)\n\t\t\tkdb_printf(\"%d idle process%s (state -)%s\\n\",\n\t\t\t\t   idle, idle == 1 ? \"\" : \"es\",\n\t\t\t\t   daemon ? \" and \" : \"\");\n\t\tif (daemon)\n\t\t\tkdb_printf(\"%d sleeping system daemon (state [ims]) \"\n\t\t\t\t   \"process%s\", daemon,\n\t\t\t\t   daemon == 1 ? \"\" : \"es\");\n\t\tkdb_printf(\" suppressed,\\nuse 'ps A' to see all.\\n\");\n\t}\n}"
  },
  {
    "function_name": "kdb_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2237-2266",
    "snippet": "static int kdb_cpu(int argc, const char **argv)\n{\n\tunsigned long cpunum;\n\tint diag;\n\n\tif (argc == 0) {\n\t\tkdb_cpu_status();\n\t\treturn 0;\n\t}\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetularg(argv[1], &cpunum);\n\tif (diag)\n\t\treturn diag;\n\n\t/*\n\t * Validate cpunum\n\t */\n\tif ((cpunum >= CONFIG_NR_CPUS) || !kgdb_info[cpunum].enter_kgdb)\n\t\treturn KDB_BADCPUNUM;\n\n\tdbg_switch_cpu = cpunum;\n\n\t/*\n\t * Switch to other cpu\n\t */\n\treturn KDB_CMD_CPU;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdbgetularg",
          "args": [
            "argv[1]",
            "&cpunum"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetularg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "362-382",
          "snippet": "int kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_cpu_status",
          "args": [],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_cpu_status",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2192-2235",
          "snippet": "static void kdb_cpu_status(void)\n{\n\tint i, start_cpu, first_print = 1;\n\tchar state, prev_state = '?';\n\n\tkdb_printf(\"Currently on cpu %d\\n\", raw_smp_processor_id());\n\tkdb_printf(\"Available cpus: \");\n\tfor (start_cpu = -1, i = 0; i < NR_CPUS; i++) {\n\t\tif (!cpu_online(i)) {\n\t\t\tstate = 'F';\t/* cpu is offline */\n\t\t} else if (!kgdb_info[i].enter_kgdb) {\n\t\t\tstate = 'D';\t/* cpu is online but unresponsive */\n\t\t} else {\n\t\t\tstate = ' ';\t/* cpu is responding to kdb */\n\t\t\tif (kdb_task_state_char(KDB_TSK(i)) == '-')\n\t\t\t\tstate = '-';\t/* idle task */\n\t\t}\n\t\tif (state != prev_state) {\n\t\t\tif (prev_state != '?') {\n\t\t\t\tif (!first_print)\n\t\t\t\t\tkdb_printf(\", \");\n\t\t\t\tfirst_print = 0;\n\t\t\t\tkdb_printf(\"%d\", start_cpu);\n\t\t\t\tif (start_cpu < i-1)\n\t\t\t\t\tkdb_printf(\"-%d\", i-1);\n\t\t\t\tif (prev_state != ' ')\n\t\t\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t\t\t}\n\t\t\tprev_state = state;\n\t\t\tstart_cpu = i;\n\t\t}\n\t}\n\t/* print the trailing cpus, ignoring them if they are all offline */\n\tif (prev_state != 'F') {\n\t\tif (!first_print)\n\t\t\tkdb_printf(\", \");\n\t\tkdb_printf(\"%d\", start_cpu);\n\t\tif (start_cpu < i-1)\n\t\t\tkdb_printf(\"-%d\", i-1);\n\t\tif (prev_state != ' ')\n\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t}\n\tkdb_printf(\"\\n\");\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_cpu_status(void)\n{\n\tint i, start_cpu, first_print = 1;\n\tchar state, prev_state = '?';\n\n\tkdb_printf(\"Currently on cpu %d\\n\", raw_smp_processor_id());\n\tkdb_printf(\"Available cpus: \");\n\tfor (start_cpu = -1, i = 0; i < NR_CPUS; i++) {\n\t\tif (!cpu_online(i)) {\n\t\t\tstate = 'F';\t/* cpu is offline */\n\t\t} else if (!kgdb_info[i].enter_kgdb) {\n\t\t\tstate = 'D';\t/* cpu is online but unresponsive */\n\t\t} else {\n\t\t\tstate = ' ';\t/* cpu is responding to kdb */\n\t\t\tif (kdb_task_state_char(KDB_TSK(i)) == '-')\n\t\t\t\tstate = '-';\t/* idle task */\n\t\t}\n\t\tif (state != prev_state) {\n\t\t\tif (prev_state != '?') {\n\t\t\t\tif (!first_print)\n\t\t\t\t\tkdb_printf(\", \");\n\t\t\t\tfirst_print = 0;\n\t\t\t\tkdb_printf(\"%d\", start_cpu);\n\t\t\t\tif (start_cpu < i-1)\n\t\t\t\t\tkdb_printf(\"-%d\", i-1);\n\t\t\t\tif (prev_state != ' ')\n\t\t\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t\t\t}\n\t\t\tprev_state = state;\n\t\t\tstart_cpu = i;\n\t\t}\n\t}\n\t/* print the trailing cpus, ignoring them if they are all offline */\n\tif (prev_state != 'F') {\n\t\tif (!first_print)\n\t\t\tkdb_printf(\", \");\n\t\tkdb_printf(\"%d\", start_cpu);\n\t\tif (start_cpu < i-1)\n\t\t\tkdb_printf(\"-%d\", i-1);\n\t\tif (prev_state != ' ')\n\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t}\n\tkdb_printf(\"\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cpu(int argc, const char **argv)\n{\n\tunsigned long cpunum;\n\tint diag;\n\n\tif (argc == 0) {\n\t\tkdb_cpu_status();\n\t\treturn 0;\n\t}\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetularg(argv[1], &cpunum);\n\tif (diag)\n\t\treturn diag;\n\n\t/*\n\t * Validate cpunum\n\t */\n\tif ((cpunum >= CONFIG_NR_CPUS) || !kgdb_info[cpunum].enter_kgdb)\n\t\treturn KDB_BADCPUNUM;\n\n\tdbg_switch_cpu = cpunum;\n\n\t/*\n\t * Switch to other cpu\n\t */\n\treturn KDB_CMD_CPU;\n}"
  },
  {
    "function_name": "kdb_cpu_status",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2192-2235",
    "snippet": "static void kdb_cpu_status(void)\n{\n\tint i, start_cpu, first_print = 1;\n\tchar state, prev_state = '?';\n\n\tkdb_printf(\"Currently on cpu %d\\n\", raw_smp_processor_id());\n\tkdb_printf(\"Available cpus: \");\n\tfor (start_cpu = -1, i = 0; i < NR_CPUS; i++) {\n\t\tif (!cpu_online(i)) {\n\t\t\tstate = 'F';\t/* cpu is offline */\n\t\t} else if (!kgdb_info[i].enter_kgdb) {\n\t\t\tstate = 'D';\t/* cpu is online but unresponsive */\n\t\t} else {\n\t\t\tstate = ' ';\t/* cpu is responding to kdb */\n\t\t\tif (kdb_task_state_char(KDB_TSK(i)) == '-')\n\t\t\t\tstate = '-';\t/* idle task */\n\t\t}\n\t\tif (state != prev_state) {\n\t\t\tif (prev_state != '?') {\n\t\t\t\tif (!first_print)\n\t\t\t\t\tkdb_printf(\", \");\n\t\t\t\tfirst_print = 0;\n\t\t\t\tkdb_printf(\"%d\", start_cpu);\n\t\t\t\tif (start_cpu < i-1)\n\t\t\t\t\tkdb_printf(\"-%d\", i-1);\n\t\t\t\tif (prev_state != ' ')\n\t\t\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t\t\t}\n\t\t\tprev_state = state;\n\t\t\tstart_cpu = i;\n\t\t}\n\t}\n\t/* print the trailing cpus, ignoring them if they are all offline */\n\tif (prev_state != 'F') {\n\t\tif (!first_print)\n\t\t\tkdb_printf(\", \");\n\t\tkdb_printf(\"%d\", start_cpu);\n\t\tif (start_cpu < i-1)\n\t\t\tkdb_printf(\"-%d\", i-1);\n\t\tif (prev_state != ' ')\n\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t}\n\tkdb_printf(\"\\n\");\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_task_state_char",
          "args": [
            "KDB_TSK(i)"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_task_state_char",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "486-510",
          "snippet": "char kdb_task_state_char (const struct task_struct *p)\n{\n\tunsigned long tmp;\n\tchar state;\n\tint cpu;\n\n\tif (!p ||\n\t    copy_from_kernel_nofault(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tstate = task_state_to_char((struct task_struct *) p);\n\n\tif (is_idle_task(p)) {\n\t\t/* Idle task.  Is it really idle, apart from the kdb\n\t\t * interrupt? */\n\t\tcpu = kdb_process_cpu(p);\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = '-';\t/* idle task */\n\t\t}\n\t} else if (!p->mm && strchr(\"IMS\", state)) {\n\t\tstate = tolower(state);\t\t/* sleeping system daemon */\n\t}\n\treturn state;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nchar kdb_task_state_char (const struct task_struct *p)\n{\n\tunsigned long tmp;\n\tchar state;\n\tint cpu;\n\n\tif (!p ||\n\t    copy_from_kernel_nofault(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tstate = task_state_to_char((struct task_struct *) p);\n\n\tif (is_idle_task(p)) {\n\t\t/* Idle task.  Is it really idle, apart from the kdb\n\t\t * interrupt? */\n\t\tcpu = kdb_process_cpu(p);\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = '-';\t/* idle task */\n\t\t}\n\t} else if (!p->mm && strchr(\"IMS\", state)) {\n\t\tstate = tolower(state);\t\t/* sleeping system daemon */\n\t}\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_TSK",
          "args": [
            "i"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "i"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_cpu_status(void)\n{\n\tint i, start_cpu, first_print = 1;\n\tchar state, prev_state = '?';\n\n\tkdb_printf(\"Currently on cpu %d\\n\", raw_smp_processor_id());\n\tkdb_printf(\"Available cpus: \");\n\tfor (start_cpu = -1, i = 0; i < NR_CPUS; i++) {\n\t\tif (!cpu_online(i)) {\n\t\t\tstate = 'F';\t/* cpu is offline */\n\t\t} else if (!kgdb_info[i].enter_kgdb) {\n\t\t\tstate = 'D';\t/* cpu is online but unresponsive */\n\t\t} else {\n\t\t\tstate = ' ';\t/* cpu is responding to kdb */\n\t\t\tif (kdb_task_state_char(KDB_TSK(i)) == '-')\n\t\t\t\tstate = '-';\t/* idle task */\n\t\t}\n\t\tif (state != prev_state) {\n\t\t\tif (prev_state != '?') {\n\t\t\t\tif (!first_print)\n\t\t\t\t\tkdb_printf(\", \");\n\t\t\t\tfirst_print = 0;\n\t\t\t\tkdb_printf(\"%d\", start_cpu);\n\t\t\t\tif (start_cpu < i-1)\n\t\t\t\t\tkdb_printf(\"-%d\", i-1);\n\t\t\t\tif (prev_state != ' ')\n\t\t\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t\t\t}\n\t\t\tprev_state = state;\n\t\t\tstart_cpu = i;\n\t\t}\n\t}\n\t/* print the trailing cpus, ignoring them if they are all offline */\n\tif (prev_state != 'F') {\n\t\tif (!first_print)\n\t\t\tkdb_printf(\", \");\n\t\tkdb_printf(\"%d\", start_cpu);\n\t\tif (start_cpu < i-1)\n\t\t\tkdb_printf(\"-%d\", i-1);\n\t\tif (prev_state != ' ')\n\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t}\n\tkdb_printf(\"\\n\");\n}"
  },
  {
    "function_name": "kdb_param_enable_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2173-2179",
    "snippet": "static int kdb_param_enable_nmi(const char *val, const struct kernel_param *kp)\n{\n\tif (!atomic_add_unless(&kdb_nmi_disabled, -1, 0))\n\t\treturn -EINVAL;\n\tarch_kgdb_ops.enable_nmi(1);\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_kgdb_ops.enable_nmi",
          "args": [
            "1"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "enable_nmi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "834-837",
          "snippet": "void enable_nmi(unsigned int irq)\n{\n\tenable_irq(irq);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid enable_nmi(unsigned int irq)\n{\n\tenable_irq(irq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add_unless",
          "args": [
            "&kdb_nmi_disabled",
            "-1",
            "0"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_param_enable_nmi(const char *val, const struct kernel_param *kp)\n{\n\tif (!atomic_add_unless(&kdb_nmi_disabled, -1, 0))\n\t\treturn -EINVAL;\n\tarch_kgdb_ops.enable_nmi(1);\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_disable_nmi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2164-2171",
    "snippet": "static int kdb_disable_nmi(int argc, const char *argv[])\n{\n\tif (atomic_read(&kdb_nmi_disabled))\n\t\treturn 0;\n\tatomic_set(&kdb_nmi_disabled, 1);\n\tarch_kgdb_ops.enable_nmi(0);\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_kgdb_ops.enable_nmi",
          "args": [
            "0"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "enable_nmi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "834-837",
          "snippet": "void enable_nmi(unsigned int irq)\n{\n\tenable_irq(irq);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid enable_nmi(unsigned int irq)\n{\n\tenable_irq(irq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&kdb_nmi_disabled",
            "1"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kdb_nmi_disabled"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_disable_nmi(int argc, const char *argv[])\n{\n\tif (atomic_read(&kdb_nmi_disabled))\n\t\treturn 0;\n\tatomic_set(&kdb_nmi_disabled, 1);\n\tarch_kgdb_ops.enable_nmi(0);\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_dmesg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2077-2158",
    "snippet": "static int kdb_dmesg(int argc, const char **argv)\n{\n\tint diag;\n\tint logging;\n\tint lines = 0;\n\tint adjust = 0;\n\tint n = 0;\n\tint skip = 0;\n\tstruct kmsg_dump_iter iter;\n\tsize_t len;\n\tchar buf[201];\n\n\tif (argc > 2)\n\t\treturn KDB_ARGCOUNT;\n\tif (argc) {\n\t\tchar *cp;\n\t\tlines = simple_strtol(argv[1], &cp, 0);\n\t\tif (*cp)\n\t\t\tlines = 0;\n\t\tif (argc > 1) {\n\t\t\tadjust = simple_strtoul(argv[2], &cp, 0);\n\t\t\tif (*cp || adjust < 0)\n\t\t\t\tadjust = 0;\n\t\t}\n\t}\n\n\t/* disable LOGGING if set */\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (!diag && logging) {\n\t\tconst char *setargs[] = { \"set\", \"LOGGING\", \"0\" };\n\t\tkdb_set(2, setargs);\n\t}\n\n\tkmsg_dump_rewind(&iter);\n\twhile (kmsg_dump_get_line(&iter, 1, NULL, 0, NULL))\n\t\tn++;\n\n\tif (lines < 0) {\n\t\tif (adjust >= n)\n\t\t\tkdb_printf(\"buffer only contains %d lines, nothing \"\n\t\t\t\t   \"printed\\n\", n);\n\t\telse if (adjust - lines >= n)\n\t\t\tkdb_printf(\"buffer only contains %d lines, last %d \"\n\t\t\t\t   \"lines printed\\n\", n, n - adjust);\n\t\tskip = adjust;\n\t\tlines = abs(lines);\n\t} else if (lines > 0) {\n\t\tskip = n - lines - adjust;\n\t\tlines = abs(lines);\n\t\tif (adjust >= n) {\n\t\t\tkdb_printf(\"buffer only contains %d lines, \"\n\t\t\t\t   \"nothing printed\\n\", n);\n\t\t\tskip = n;\n\t\t} else if (skip < 0) {\n\t\t\tlines += skip;\n\t\t\tskip = 0;\n\t\t\tkdb_printf(\"buffer only contains %d lines, first \"\n\t\t\t\t   \"%d lines printed\\n\", n, lines);\n\t\t}\n\t} else {\n\t\tlines = n;\n\t}\n\n\tif (skip >= n || skip < 0)\n\t\treturn 0;\n\n\tkmsg_dump_rewind(&iter);\n\twhile (kmsg_dump_get_line(&iter, 1, buf, sizeof(buf), &len)) {\n\t\tif (skip) {\n\t\t\tskip--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!lines--)\n\t\t\tbreak;\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tkdb_printf(\"%.*s\\n\", (int)len - 1, buf);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%.*s\\n\"",
            "(int)len - 1",
            "buf"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmsg_dump_get_line",
          "args": [
            "&iter",
            "1",
            "buf",
            "sizeof(buf)",
            "&len"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "kmsg_dump_get_line",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3461-3497",
          "snippet": "bool kmsg_dump_get_line(struct kmsg_dump_iter *iter, bool syslog,\n\t\t\tchar *line, size_t size, size_t *len)\n{\n\tu64 min_seq = latched_seq_read_nolock(&clear_seq);\n\tstruct printk_info info;\n\tunsigned int line_count;\n\tstruct printk_record r;\n\tsize_t l = 0;\n\tbool ret = false;\n\n\tif (iter->cur_seq < min_seq)\n\t\titer->cur_seq = min_seq;\n\n\tprb_rec_init_rd(&r, &info, line, size);\n\n\t/* Read text or count text lines? */\n\tif (line) {\n\t\tif (!prb_read_valid(prb, iter->cur_seq, &r))\n\t\t\tgoto out;\n\t\tl = record_print_text(&r, syslog, printk_time);\n\t} else {\n\t\tif (!prb_read_valid_info(prb, iter->cur_seq,\n\t\t\t\t\t &info, &line_count)) {\n\t\t\tgoto out;\n\t\t}\n\t\tl = get_record_print_text_size(&info, line_count, syslog,\n\t\t\t\t\t       printk_time);\n\n\t}\n\n\titer->cur_seq = r.info->seq + 1;\n\tret = true;\nout:\n\tif (len)\n\t\t*len = l;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define printk_time\t\tfalse"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define printk_time\t\tfalse\n\nbool kmsg_dump_get_line(struct kmsg_dump_iter *iter, bool syslog,\n\t\t\tchar *line, size_t size, size_t *len)\n{\n\tu64 min_seq = latched_seq_read_nolock(&clear_seq);\n\tstruct printk_info info;\n\tunsigned int line_count;\n\tstruct printk_record r;\n\tsize_t l = 0;\n\tbool ret = false;\n\n\tif (iter->cur_seq < min_seq)\n\t\titer->cur_seq = min_seq;\n\n\tprb_rec_init_rd(&r, &info, line, size);\n\n\t/* Read text or count text lines? */\n\tif (line) {\n\t\tif (!prb_read_valid(prb, iter->cur_seq, &r))\n\t\t\tgoto out;\n\t\tl = record_print_text(&r, syslog, printk_time);\n\t} else {\n\t\tif (!prb_read_valid_info(prb, iter->cur_seq,\n\t\t\t\t\t &info, &line_count)) {\n\t\t\tgoto out;\n\t\t}\n\t\tl = get_record_print_text_size(&info, line_count, syslog,\n\t\t\t\t\t       printk_time);\n\n\t}\n\n\titer->cur_seq = r.info->seq + 1;\n\tret = true;\nout:\n\tif (len)\n\t\t*len = l;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmsg_dump_rewind",
          "args": [
            "&iter"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "kmsg_dump_rewind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3593-3597",
          "snippet": "void kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid kmsg_dump_rewind(struct kmsg_dump_iter *iter)\n{\n\titer->cur_seq = latched_seq_read_nolock(&clear_seq);\n\titer->next_seq = prb_next_seq(prb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "lines"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "608-615",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_set",
          "args": [
            "2",
            "setargs"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "407-454",
          "snippet": "int kdb_set(int argc, const char **argv)\n{\n\t/*\n\t * we can be invoked two ways:\n\t *   set var=value    argv[1]=\"var\", argv[2]=\"value\"\n\t *   set var = value  argv[1]=\"var\", argv[2]=\"=\", argv[3]=\"value\"\n\t * - if the latter, shift 'em down.\n\t */\n\tif (argc == 3) {\n\t\targv[2] = argv[3];\n\t\targc--;\n\t}\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\n\t/*\n\t * Censor sensitive variables\n\t */\n\tif (strcmp(argv[1], \"PROMPT\") == 0 &&\n\t    !kdb_check_flags(KDB_ENABLE_MEM_READ, kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Check for internal variables\n\t */\n\tif (strcmp(argv[1], \"KDBDEBUG\") == 0) {\n\t\tunsigned int debugflags;\n\t\tchar *cp;\n\n\t\tdebugflags = simple_strtoul(argv[2], &cp, 0);\n\t\tif (cp == argv[2] || debugflags & ~KDB_DEBUG_FLAG_MASK) {\n\t\t\tkdb_printf(\"kdb: illegal debug flags '%s'\\n\",\n\t\t\t\t    argv[2]);\n\t\t\treturn 0;\n\t\t}\n\t\tkdb_flags = (kdb_flags & ~KDB_DEBUG(MASK))\n\t\t\t| (debugflags << KDB_DEBUG_FLAG_SHIFT);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Tokenizer squashed the '=' sign.  argv[1] is variable\n\t * name, argv[2] = value.\n\t */\n\treturn kdb_setenv(argv[1], argv[2]);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;",
            "unsigned int kdb_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\nunsigned int kdb_flags;\n\nint kdb_set(int argc, const char **argv)\n{\n\t/*\n\t * we can be invoked two ways:\n\t *   set var=value    argv[1]=\"var\", argv[2]=\"value\"\n\t *   set var = value  argv[1]=\"var\", argv[2]=\"=\", argv[3]=\"value\"\n\t * - if the latter, shift 'em down.\n\t */\n\tif (argc == 3) {\n\t\targv[2] = argv[3];\n\t\targc--;\n\t}\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\n\t/*\n\t * Censor sensitive variables\n\t */\n\tif (strcmp(argv[1], \"PROMPT\") == 0 &&\n\t    !kdb_check_flags(KDB_ENABLE_MEM_READ, kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Check for internal variables\n\t */\n\tif (strcmp(argv[1], \"KDBDEBUG\") == 0) {\n\t\tunsigned int debugflags;\n\t\tchar *cp;\n\n\t\tdebugflags = simple_strtoul(argv[2], &cp, 0);\n\t\tif (cp == argv[2] || debugflags & ~KDB_DEBUG_FLAG_MASK) {\n\t\t\tkdb_printf(\"kdb: illegal debug flags '%s'\\n\",\n\t\t\t\t    argv[2]);\n\t\t\treturn 0;\n\t\t}\n\t\tkdb_flags = (kdb_flags & ~KDB_DEBUG(MASK))\n\t\t\t| (debugflags << KDB_DEBUG_FLAG_SHIFT);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Tokenizer squashed the '=' sign.  argv[1] is variable\n\t * name, argv[2] = value.\n\t */\n\treturn kdb_setenv(argv[1], argv[2]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetintenv",
          "args": [
            "\"LOGGING\"",
            "&logging"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetintenv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "284-293",
          "snippet": "int kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "argv[2]",
            "&cp",
            "0"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "argv[1]",
            "&cp",
            "0"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_dmesg(int argc, const char **argv)\n{\n\tint diag;\n\tint logging;\n\tint lines = 0;\n\tint adjust = 0;\n\tint n = 0;\n\tint skip = 0;\n\tstruct kmsg_dump_iter iter;\n\tsize_t len;\n\tchar buf[201];\n\n\tif (argc > 2)\n\t\treturn KDB_ARGCOUNT;\n\tif (argc) {\n\t\tchar *cp;\n\t\tlines = simple_strtol(argv[1], &cp, 0);\n\t\tif (*cp)\n\t\t\tlines = 0;\n\t\tif (argc > 1) {\n\t\t\tadjust = simple_strtoul(argv[2], &cp, 0);\n\t\t\tif (*cp || adjust < 0)\n\t\t\t\tadjust = 0;\n\t\t}\n\t}\n\n\t/* disable LOGGING if set */\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (!diag && logging) {\n\t\tconst char *setargs[] = { \"set\", \"LOGGING\", \"0\" };\n\t\tkdb_set(2, setargs);\n\t}\n\n\tkmsg_dump_rewind(&iter);\n\twhile (kmsg_dump_get_line(&iter, 1, NULL, 0, NULL))\n\t\tn++;\n\n\tif (lines < 0) {\n\t\tif (adjust >= n)\n\t\t\tkdb_printf(\"buffer only contains %d lines, nothing \"\n\t\t\t\t   \"printed\\n\", n);\n\t\telse if (adjust - lines >= n)\n\t\t\tkdb_printf(\"buffer only contains %d lines, last %d \"\n\t\t\t\t   \"lines printed\\n\", n, n - adjust);\n\t\tskip = adjust;\n\t\tlines = abs(lines);\n\t} else if (lines > 0) {\n\t\tskip = n - lines - adjust;\n\t\tlines = abs(lines);\n\t\tif (adjust >= n) {\n\t\t\tkdb_printf(\"buffer only contains %d lines, \"\n\t\t\t\t   \"nothing printed\\n\", n);\n\t\t\tskip = n;\n\t\t} else if (skip < 0) {\n\t\t\tlines += skip;\n\t\t\tskip = 0;\n\t\t\tkdb_printf(\"buffer only contains %d lines, first \"\n\t\t\t\t   \"%d lines printed\\n\", n, lines);\n\t\t}\n\t} else {\n\t\tlines = n;\n\t}\n\n\tif (skip >= n || skip < 0)\n\t\treturn 0;\n\n\tkmsg_dump_rewind(&iter);\n\twhile (kmsg_dump_get_line(&iter, 1, buf, sizeof(buf), &len)) {\n\t\tif (skip) {\n\t\t\tskip--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!lines--)\n\t\t\tbreak;\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tkdb_printf(\"%.*s\\n\", (int)len - 1, buf);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_env",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2060-2069",
    "snippet": "static int kdb_env(int argc, const char **argv)\n{\n\tkdb_printenv();\n\n\tif (KDB_DEBUG(MASK))\n\t\tkdb_printf(\"KDBDEBUG=0x%x\\n\",\n\t\t\t(kdb_flags & KDB_DEBUG(MASK)) >> KDB_DEBUG_FLAG_SHIFT);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int kdb_flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"KDBDEBUG=0x%x\\n\"",
            "(kdb_flags & KDB_DEBUG(MASK)) >> KDB_DEBUG_FLAG_SHIFT"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG",
          "args": [
            "MASK"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG",
          "args": [
            "MASK"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printenv",
          "args": [],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printenv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "342-350",
          "snippet": "static void kdb_printenv(void)\n{\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i])\n\t\t\tkdb_printf(\"%s\\n\", __env[i]);\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_printenv(void)\n{\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i])\n\t\t\tkdb_printf(\"%s\\n\", __env[i]);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nunsigned int kdb_flags;\n\nstatic int kdb_env(int argc, const char **argv)\n{\n\tkdb_printenv();\n\n\tif (KDB_DEBUG(MASK))\n\t\tkdb_printf(\"KDBDEBUG=0x%x\\n\",\n\t\t\t(kdb_flags & KDB_DEBUG(MASK)) >> KDB_DEBUG_FLAG_SHIFT);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_lsmod",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2013-2051",
    "snippet": "static int kdb_lsmod(int argc, const char **argv)\n{\n\tstruct module *mod;\n\n\tif (argc != 0)\n\t\treturn KDB_ARGCOUNT;\n\n\tkdb_printf(\"Module                  Size  modstruct     Used by\\n\");\n\tlist_for_each_entry(mod, kdb_modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\n\t\tkdb_printf(\"%-20s%8u  0x%px \", mod->name,\n\t\t\t   mod->core_layout.size, (void *)mod);\n#ifdef CONFIG_MODULE_UNLOAD\n\t\tkdb_printf(\"%4d \", module_refcount(mod));\n#endif\n\t\tif (mod->state == MODULE_STATE_GOING)\n\t\t\tkdb_printf(\" (Unloading)\");\n\t\telse if (mod->state == MODULE_STATE_COMING)\n\t\t\tkdb_printf(\" (Loading)\");\n\t\telse\n\t\t\tkdb_printf(\" (Live)\");\n\t\tkdb_printf(\" 0x%px\", mod->core_layout.base);\n\n#ifdef CONFIG_MODULE_UNLOAD\n\t\t{\n\t\t\tstruct module_use *use;\n\t\t\tkdb_printf(\" [ \");\n\t\t\tlist_for_each_entry(use, &mod->source_list,\n\t\t\t\t\t    source_list)\n\t\t\t\tkdb_printf(\"%s \", use->target->name);\n\t\t\tkdb_printf(\"]\\n\");\n\t\t}\n#endif\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"]\\n\""
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "use",
            "&mod->source_list",
            "source_list"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_refcount",
          "args": [
            "mod"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "module_refcount",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "903-906",
          "snippet": "int module_refcount(struct module *mod)\n{\n\treturn atomic_read(&mod->refcnt) - MODULE_REF_BASE;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define MODULE_REF_BASE\t1"
          ],
          "globals_used": [
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\n#define MODULE_REF_BASE\t1\n\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nint module_refcount(struct module *mod)\n{\n\treturn atomic_read(&mod->refcnt) - MODULE_REF_BASE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "mod",
            "kdb_modules",
            "list"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_lsmod(int argc, const char **argv)\n{\n\tstruct module *mod;\n\n\tif (argc != 0)\n\t\treturn KDB_ARGCOUNT;\n\n\tkdb_printf(\"Module                  Size  modstruct     Used by\\n\");\n\tlist_for_each_entry(mod, kdb_modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\n\t\tkdb_printf(\"%-20s%8u  0x%px \", mod->name,\n\t\t\t   mod->core_layout.size, (void *)mod);\n#ifdef CONFIG_MODULE_UNLOAD\n\t\tkdb_printf(\"%4d \", module_refcount(mod));\n#endif\n\t\tif (mod->state == MODULE_STATE_GOING)\n\t\t\tkdb_printf(\" (Unloading)\");\n\t\telse if (mod->state == MODULE_STATE_COMING)\n\t\t\tkdb_printf(\" (Loading)\");\n\t\telse\n\t\t\tkdb_printf(\" (Live)\");\n\t\tkdb_printf(\" 0x%px\", mod->core_layout.base);\n\n#ifdef CONFIG_MODULE_UNLOAD\n\t\t{\n\t\t\tstruct module_use *use;\n\t\t\tkdb_printf(\" [ \");\n\t\t\tlist_for_each_entry(use, &mod->source_list,\n\t\t\t\t\t    source_list)\n\t\t\t\tkdb_printf(\"%s \", use->target->name);\n\t\t\tkdb_printf(\"]\\n\");\n\t\t}\n#endif\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_ef",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1989-2005",
    "snippet": "static int kdb_ef(int argc, const char **argv)\n{\n\tint diag;\n\tunsigned long addr;\n\tlong offset;\n\tint nextarg;\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);\n\tif (diag)\n\t\treturn diag;\n\tshow_regs((struct pt_regs *)addr);\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_regs",
          "args": [
            "(struct pt_regs *)addr"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetaddrarg",
          "args": [
            "argc",
            "argv",
            "&nextarg",
            "&addr",
            "&offset",
            "NULL"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetaddrarg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "491-623",
          "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_ef(int argc, const char **argv)\n{\n\tint diag;\n\tunsigned long addr;\n\tlong offset;\n\tint nextarg;\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);\n\tif (diag)\n\t\treturn diag;\n\tshow_regs((struct pt_regs *)addr);\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_sr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1964-1977",
    "snippet": "static int kdb_sr(int argc, const char **argv)\n{\n\tbool check_mask =\n\t    !kdb_check_flags(KDB_ENABLE_ALL, kdb_cmd_enabled, false);\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tkdb_trap_printk++;\n\t__handle_sysrq(*argv[1], check_mask);\n\tkdb_trap_printk--;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__handle_sysrq",
          "args": [
            "*argv[1]",
            "check_mask"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_check_flags",
          "args": [
            "KDB_ENABLE_ALL",
            "kdb_cmd_enabled",
            "false"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_check_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "172-186",
          "snippet": "static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nstatic int kdb_sr(int argc, const char **argv)\n{\n\tbool check_mask =\n\t    !kdb_check_flags(KDB_ENABLE_ALL, kdb_cmd_enabled, false);\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tkdb_trap_printk++;\n\t__handle_sysrq(*argv[1], check_mask);\n\tkdb_trap_printk--;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_rm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1897-1956",
    "snippet": "static int kdb_rm(int argc, const char **argv)\n{\n#if DBG_MAX_REG_NUM > 0\n\tint diag;\n\tconst char *rname;\n\tint i;\n\tu64 reg64;\n\tu32 reg32;\n\tu16 reg16;\n\tu8 reg8;\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\t/*\n\t * Allow presence or absence of leading '%' symbol.\n\t */\n\trname = argv[1];\n\tif (*rname == '%')\n\t\trname++;\n\n\tdiag = kdbgetu64arg(argv[2], &reg64);\n\tif (diag)\n\t\treturn diag;\n\n\tdiag = kdb_check_regs();\n\tif (diag)\n\t\treturn diag;\n\n\tdiag = KDB_BADREG;\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\tif (strcmp(rname, dbg_reg_def[i].name) == 0) {\n\t\t\tdiag = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!diag) {\n\t\tswitch(dbg_reg_def[i].size * 8) {\n\t\tcase 8:\n\t\t\treg8 = reg64;\n\t\t\tdbg_set_reg(i, &reg8, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\treg16 = reg64;\n\t\t\tdbg_set_reg(i, &reg16, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\treg32 = reg64;\n\t\t\tdbg_set_reg(i, &reg32, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tdbg_set_reg(i, &reg64, kdb_current_regs);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn diag;\n#else\n\tkdb_printf(\"ERROR: Register set currently not implemented\\n\");\n    return 0;\n#endif\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pt_regs *kdb_current_regs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"ERROR: Register set currently not implemented\\n\""
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_set_reg",
          "args": [
            "i",
            "&reg64",
            "kdb_current_regs"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_set_reg",
          "args": [
            "i",
            "&reg32",
            "kdb_current_regs"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_set_reg",
          "args": [
            "i",
            "&reg16",
            "kdb_current_regs"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_set_reg",
          "args": [
            "i",
            "&reg8",
            "kdb_current_regs"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rname",
            "dbg_reg_def[i].name"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_check_regs",
          "args": [],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_check_regs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "456-464",
          "snippet": "static int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pt_regs *kdb_current_regs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct pt_regs *kdb_current_regs;\n\nstatic int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetu64arg",
          "args": [
            "argv[2]",
            "&reg64"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetu64arg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "384-401",
          "snippet": "int kdbgetu64arg(const char *arg, u64 *value)\n{\n\tchar *endp;\n\tu64 val;\n\n\tval = simple_strtoull(arg, &endp, 0);\n\n\tif (endp == arg) {\n\n\t\tval = simple_strtoull(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetu64arg(const char *arg, u64 *value)\n{\n\tchar *endp;\n\tu64 val;\n\n\tval = simple_strtoull(arg, &endp, 0);\n\n\tif (endp == arg) {\n\n\t\tval = simple_strtoull(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct pt_regs *kdb_current_regs;\n\nstatic int kdb_rm(int argc, const char **argv)\n{\n#if DBG_MAX_REG_NUM > 0\n\tint diag;\n\tconst char *rname;\n\tint i;\n\tu64 reg64;\n\tu32 reg32;\n\tu16 reg16;\n\tu8 reg8;\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\t/*\n\t * Allow presence or absence of leading '%' symbol.\n\t */\n\trname = argv[1];\n\tif (*rname == '%')\n\t\trname++;\n\n\tdiag = kdbgetu64arg(argv[2], &reg64);\n\tif (diag)\n\t\treturn diag;\n\n\tdiag = kdb_check_regs();\n\tif (diag)\n\t\treturn diag;\n\n\tdiag = KDB_BADREG;\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\tif (strcmp(rname, dbg_reg_def[i].name) == 0) {\n\t\t\tdiag = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!diag) {\n\t\tswitch(dbg_reg_def[i].size * 8) {\n\t\tcase 8:\n\t\t\treg8 = reg64;\n\t\t\tdbg_set_reg(i, &reg8, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\treg16 = reg64;\n\t\t\tdbg_set_reg(i, &reg16, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\treg32 = reg64;\n\t\t\tdbg_set_reg(i, &reg32, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tdbg_set_reg(i, &reg64, kdb_current_regs);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn diag;\n#else\n\tkdb_printf(\"ERROR: Register set currently not implemented\\n\");\n    return 0;\n#endif\n}"
  },
  {
    "function_name": "kdb_rd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1827-1889",
    "snippet": "static int kdb_rd(int argc, const char **argv)\n{\n\tint len = kdb_check_regs();\n#if DBG_MAX_REG_NUM > 0\n\tint i;\n\tchar *rname;\n\tint rsize;\n\tu64 reg64;\n\tu32 reg32;\n\tu16 reg16;\n\tu8 reg8;\n\n\tif (len)\n\t\treturn len;\n\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\trsize = dbg_reg_def[i].size * 2;\n\t\tif (rsize > 16)\n\t\t\trsize = 2;\n\t\tif (len + strlen(dbg_reg_def[i].name) + 4 + rsize > 80) {\n\t\t\tlen = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tif (len)\n\t\t\tlen += kdb_printf(\"  \");\n\t\tswitch(dbg_reg_def[i].size * 8) {\n\t\tcase 8:\n\t\t\trname = dbg_get_reg(i, &reg8, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %02x\", rname, reg8);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\trname = dbg_get_reg(i, &reg16, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %04x\", rname, reg16);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\trname = dbg_get_reg(i, &reg32, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %08x\", rname, reg32);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\trname = dbg_get_reg(i, &reg64, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %016llx\", rname, reg64);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen += kdb_printf(\"%s: ??\", dbg_reg_def[i].name);\n\t\t}\n\t}\n\tkdb_printf(\"\\n\");\n#else\n\tif (len)\n\t\treturn len;\n\n\tkdb_dumpregs(kdb_current_regs);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pt_regs *kdb_current_regs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_dumpregs",
          "args": [
            "kdb_current_regs"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_dumpregs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1123-1132",
          "snippet": "static void kdb_dumpregs(struct pt_regs *regs)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tshow_regs(regs);\n\tkdb_trap_printk--;\n\tkdb_printf(\"\\n\");\n\tconsole_loglevel = old_lvl;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_dumpregs(struct pt_regs *regs)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tshow_regs(regs);\n\tkdb_trap_printk--;\n\tkdb_printf(\"\\n\");\n\tconsole_loglevel = old_lvl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_get_reg",
          "args": [
            "i",
            "&reg64",
            "kdb_current_regs"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_get_reg",
          "args": [
            "i",
            "&reg32",
            "kdb_current_regs"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_get_reg",
          "args": [
            "i",
            "&reg16",
            "kdb_current_regs"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_get_reg",
          "args": [
            "i",
            "&reg8",
            "kdb_current_regs"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbg_reg_def[i].name"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_check_regs",
          "args": [],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_check_regs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "456-464",
          "snippet": "static int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pt_regs *kdb_current_regs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct pt_regs *kdb_current_regs;\n\nstatic int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct pt_regs *kdb_current_regs;\n\nstatic int kdb_rd(int argc, const char **argv)\n{\n\tint len = kdb_check_regs();\n#if DBG_MAX_REG_NUM > 0\n\tint i;\n\tchar *rname;\n\tint rsize;\n\tu64 reg64;\n\tu32 reg32;\n\tu16 reg16;\n\tu8 reg8;\n\n\tif (len)\n\t\treturn len;\n\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\trsize = dbg_reg_def[i].size * 2;\n\t\tif (rsize > 16)\n\t\t\trsize = 2;\n\t\tif (len + strlen(dbg_reg_def[i].name) + 4 + rsize > 80) {\n\t\t\tlen = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tif (len)\n\t\t\tlen += kdb_printf(\"  \");\n\t\tswitch(dbg_reg_def[i].size * 8) {\n\t\tcase 8:\n\t\t\trname = dbg_get_reg(i, &reg8, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %02x\", rname, reg8);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\trname = dbg_get_reg(i, &reg16, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %04x\", rname, reg16);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\trname = dbg_get_reg(i, &reg32, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %08x\", rname, reg32);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\trname = dbg_get_reg(i, &reg64, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %016llx\", rname, reg64);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen += kdb_printf(\"%s: ??\", dbg_reg_def[i].name);\n\t\t}\n\t}\n\tkdb_printf(\"\\n\");\n#else\n\tif (len)\n\t\treturn len;\n\n\tkdb_dumpregs(kdb_current_regs);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_go",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1782-1822",
    "snippet": "static int kdb_go(int argc, const char **argv)\n{\n\tunsigned long addr;\n\tint diag;\n\tint nextarg;\n\tlong offset;\n\n\tif (raw_smp_processor_id() != kdb_initial_cpu) {\n\t\tkdb_printf(\"go must execute on the entry cpu, \"\n\t\t\t   \"please use \\\"cpu %d\\\" and then execute go\\n\",\n\t\t\t   kdb_initial_cpu);\n\t\treturn KDB_BADCPUNUM;\n\t}\n\tif (argc == 1) {\n\t\tnextarg = 1;\n\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg,\n\t\t\t\t     &addr, &offset, NULL);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (argc) {\n\t\treturn KDB_ARGCOUNT;\n\t}\n\n\tdiag = KDB_CMD_GO;\n\tif (KDB_FLAG(CATASTROPHIC)) {\n\t\tkdb_printf(\"Catastrophic error detected\\n\");\n\t\tkdb_printf(\"kdb_continue_catastrophic=%d, \",\n\t\t\tkdb_continue_catastrophic);\n\t\tif (kdb_continue_catastrophic == 0 && kdb_go_count++ == 0) {\n\t\t\tkdb_printf(\"type go a second time if you really want \"\n\t\t\t\t   \"to continue\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (kdb_continue_catastrophic == 2) {\n\t\t\tkdb_printf(\"forcing reboot\\n\");\n\t\t\tkdb_reboot(0, NULL);\n\t\t}\n\t\tkdb_printf(\"attempting to continue\\n\");\n\t}\n\treturn diag;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int kdb_initial_cpu = -1;",
      "static int kdb_go_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"attempting to continue\\n\""
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_reboot",
          "args": [
            "0",
            "NULL"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_reboot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1113-1121",
          "snippet": "static int kdb_reboot(int argc, const char **argv)\n{\n\temergency_restart();\n\tkdb_printf(\"Hmm, kdb_reboot did not reboot, spinning here\\n\");\n\twhile (1)\n\t\tcpu_relax();\n\t/* NOTREACHED */\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_reboot(int argc, const char **argv)\n{\n\temergency_restart();\n\tkdb_printf(\"Hmm, kdb_reboot did not reboot, spinning here\\n\");\n\twhile (1)\n\t\tcpu_relax();\n\t/* NOTREACHED */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CATASTROPHIC"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetaddrarg",
          "args": [
            "argc",
            "argv",
            "&nextarg",
            "&addr",
            "&offset",
            "NULL"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetaddrarg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "491-623",
          "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdb_initial_cpu = -1;\nstatic int kdb_go_count;\n\nstatic int kdb_go(int argc, const char **argv)\n{\n\tunsigned long addr;\n\tint diag;\n\tint nextarg;\n\tlong offset;\n\n\tif (raw_smp_processor_id() != kdb_initial_cpu) {\n\t\tkdb_printf(\"go must execute on the entry cpu, \"\n\t\t\t   \"please use \\\"cpu %d\\\" and then execute go\\n\",\n\t\t\t   kdb_initial_cpu);\n\t\treturn KDB_BADCPUNUM;\n\t}\n\tif (argc == 1) {\n\t\tnextarg = 1;\n\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg,\n\t\t\t\t     &addr, &offset, NULL);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (argc) {\n\t\treturn KDB_ARGCOUNT;\n\t}\n\n\tdiag = KDB_CMD_GO;\n\tif (KDB_FLAG(CATASTROPHIC)) {\n\t\tkdb_printf(\"Catastrophic error detected\\n\");\n\t\tkdb_printf(\"kdb_continue_catastrophic=%d, \",\n\t\t\tkdb_continue_catastrophic);\n\t\tif (kdb_continue_catastrophic == 0 && kdb_go_count++ == 0) {\n\t\t\tkdb_printf(\"type go a second time if you really want \"\n\t\t\t\t   \"to continue\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (kdb_continue_catastrophic == 2) {\n\t\t\tkdb_printf(\"forcing reboot\\n\");\n\t\t\tkdb_reboot(0, NULL);\n\t\t}\n\t\tkdb_printf(\"attempting to continue\\n\");\n\t}\n\treturn diag;\n}"
  },
  {
    "function_name": "kdb_mm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1739-1776",
    "snippet": "static int kdb_mm(int argc, const char **argv)\n{\n\tint diag;\n\tunsigned long addr;\n\tlong offset = 0;\n\tunsigned long contents;\n\tint nextarg;\n\tint width;\n\n\tif (argv[0][2] && !isdigit(argv[0][2]))\n\t\treturn KDB_NOTFOUND;\n\n\tif (argc < 2)\n\t\treturn KDB_ARGCOUNT;\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &contents, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (nextarg != argc + 1)\n\t\treturn KDB_ARGCOUNT;\n\n\twidth = argv[0][2] ? (argv[0][2] - '0') : (KDB_WORD_SIZE);\n\tdiag = kdb_putword(addr, contents, width);\n\tif (diag)\n\t\treturn diag;\n\n\tkdb_printf(kdb_machreg_fmt \" = \" kdb_machreg_fmt \"\\n\", addr, contents);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "kdb_machreg_fmt \" = \" kdb_machreg_fmt \"\\n\"",
            "addr",
            "contents"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_putword",
          "args": [
            "addr",
            "contents",
            "width"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_putword",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "443-475",
          "snippet": "int kdb_putword(unsigned long addr, unsigned long word, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\tswitch (size) {\n\tcase 1:\n\t\tw1 = word;\n\t\tdiag = kdb_putarea(addr, w1);\n\t\tbreak;\n\tcase 2:\n\t\tw2 = word;\n\t\tdiag = kdb_putarea(addr, w2);\n\t\tbreak;\n\tcase 4:\n\t\tw4 = word;\n\t\tdiag = kdb_putarea(addr, w4);\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(word)) {\n\t\t\tw8 = word;\n\t\t\tdiag = kdb_putarea(addr, w8);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdb_putword(unsigned long addr, unsigned long word, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\tswitch (size) {\n\tcase 1:\n\t\tw1 = word;\n\t\tdiag = kdb_putarea(addr, w1);\n\t\tbreak;\n\tcase 2:\n\t\tw2 = word;\n\t\tdiag = kdb_putarea(addr, w2);\n\t\tbreak;\n\tcase 4:\n\t\tw4 = word;\n\t\tdiag = kdb_putarea(addr, w4);\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(word)) {\n\t\t\tw8 = word;\n\t\t\tdiag = kdb_putarea(addr, w8);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetaddrarg",
          "args": [
            "argc",
            "argv",
            "&nextarg",
            "&contents",
            "NULL",
            "NULL"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetaddrarg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "491-623",
          "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "argv[0][2]"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_mm(int argc, const char **argv)\n{\n\tint diag;\n\tunsigned long addr;\n\tlong offset = 0;\n\tunsigned long contents;\n\tint nextarg;\n\tint width;\n\n\tif (argv[0][2] && !isdigit(argv[0][2]))\n\t\treturn KDB_NOTFOUND;\n\n\tif (argc < 2)\n\t\treturn KDB_ARGCOUNT;\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &contents, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (nextarg != argc + 1)\n\t\treturn KDB_ARGCOUNT;\n\n\twidth = argv[0][2] ? (argv[0][2] - '0') : (KDB_WORD_SIZE);\n\tdiag = kdb_putword(addr, contents, width);\n\tif (diag)\n\t\treturn diag;\n\n\tkdb_printf(kdb_machreg_fmt \" = \" kdb_machreg_fmt \"\\n\", addr, contents);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_md",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1541-1731",
    "snippet": "static int kdb_md(int argc, const char **argv)\n{\n\tstatic unsigned long last_addr;\n\tstatic int last_radix, last_bytesperword, last_repeat;\n\tint radix = 16, mdcount = 8, bytesperword = KDB_WORD_SIZE, repeat;\n\tint nosect = 0;\n\tchar fmtchar, fmtstr[64];\n\tunsigned long addr;\n\tunsigned long word;\n\tlong offset = 0;\n\tint symbolic = 0;\n\tint valid = 0;\n\tint phys = 0;\n\tint raw = 0;\n\n\tkdbgetintenv(\"MDCOUNT\", &mdcount);\n\tkdbgetintenv(\"RADIX\", &radix);\n\tkdbgetintenv(\"BYTESPERWORD\", &bytesperword);\n\n\t/* Assume 'md <addr>' and start with environment values */\n\trepeat = mdcount * 16 / bytesperword;\n\n\tif (strcmp(argv[0], \"mdr\") == 0) {\n\t\tif (argc == 2 || (argc == 0 && last_addr != 0))\n\t\t\tvalid = raw = 1;\n\t\telse\n\t\t\treturn KDB_ARGCOUNT;\n\t} else if (isdigit(argv[0][2])) {\n\t\tbytesperword = (int)(argv[0][2] - '0');\n\t\tif (bytesperword == 0) {\n\t\t\tbytesperword = last_bytesperword;\n\t\t\tif (bytesperword == 0)\n\t\t\t\tbytesperword = 4;\n\t\t}\n\t\tlast_bytesperword = bytesperword;\n\t\trepeat = mdcount * 16 / bytesperword;\n\t\tif (!argv[0][3])\n\t\t\tvalid = 1;\n\t\telse if (argv[0][3] == 'c' && argv[0][4]) {\n\t\t\tchar *p;\n\t\t\trepeat = simple_strtoul(argv[0] + 4, &p, 10);\n\t\t\tmdcount = ((repeat * bytesperword) + 15) / 16;\n\t\t\tvalid = !*p;\n\t\t}\n\t\tlast_repeat = repeat;\n\t} else if (strcmp(argv[0], \"md\") == 0)\n\t\tvalid = 1;\n\telse if (strcmp(argv[0], \"mds\") == 0)\n\t\tvalid = 1;\n\telse if (strcmp(argv[0], \"mdp\") == 0) {\n\t\tphys = valid = 1;\n\t}\n\tif (!valid)\n\t\treturn KDB_NOTFOUND;\n\n\tif (argc == 0) {\n\t\tif (last_addr == 0)\n\t\t\treturn KDB_ARGCOUNT;\n\t\taddr = last_addr;\n\t\tradix = last_radix;\n\t\tbytesperword = last_bytesperword;\n\t\trepeat = last_repeat;\n\t\tif (raw)\n\t\t\tmdcount = repeat;\n\t\telse\n\t\t\tmdcount = ((repeat * bytesperword) + 15) / 16;\n\t}\n\n\tif (argc) {\n\t\tunsigned long val;\n\t\tint diag, nextarg = 1;\n\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr,\n\t\t\t\t     &offset, NULL);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (argc > nextarg+2)\n\t\t\treturn KDB_ARGCOUNT;\n\n\t\tif (argc >= nextarg) {\n\t\t\tdiag = kdbgetularg(argv[nextarg], &val);\n\t\t\tif (!diag) {\n\t\t\t\tmdcount = (int) val;\n\t\t\t\tif (raw)\n\t\t\t\t\trepeat = mdcount;\n\t\t\t\telse\n\t\t\t\t\trepeat = mdcount * 16 / bytesperword;\n\t\t\t}\n\t\t}\n\t\tif (argc >= nextarg+1) {\n\t\t\tdiag = kdbgetularg(argv[nextarg+1], &val);\n\t\t\tif (!diag)\n\t\t\t\tradix = (int) val;\n\t\t}\n\t}\n\n\tif (strcmp(argv[0], \"mdr\") == 0) {\n\t\tint ret;\n\t\tlast_addr = addr;\n\t\tret = kdb_mdr(addr, mdcount);\n\t\tlast_addr += mdcount;\n\t\tlast_repeat = mdcount;\n\t\tlast_bytesperword = bytesperword; // to make REPEAT happy\n\t\treturn ret;\n\t}\n\n\tswitch (radix) {\n\tcase 10:\n\t\tfmtchar = 'd';\n\t\tbreak;\n\tcase 16:\n\t\tfmtchar = 'x';\n\t\tbreak;\n\tcase 8:\n\t\tfmtchar = 'o';\n\t\tbreak;\n\tdefault:\n\t\treturn KDB_BADRADIX;\n\t}\n\n\tlast_radix = radix;\n\n\tif (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\n\tswitch (bytesperword) {\n\tcase 8:\n\t\tsprintf(fmtstr, \"%%16.16l%c \", fmtchar);\n\t\tbreak;\n\tcase 4:\n\t\tsprintf(fmtstr, \"%%8.8l%c \", fmtchar);\n\t\tbreak;\n\tcase 2:\n\t\tsprintf(fmtstr, \"%%4.4l%c \", fmtchar);\n\t\tbreak;\n\tcase 1:\n\t\tsprintf(fmtstr, \"%%2.2l%c \", fmtchar);\n\t\tbreak;\n\tdefault:\n\t\treturn KDB_BADWIDTH;\n\t}\n\n\tlast_repeat = repeat;\n\tlast_bytesperword = bytesperword;\n\n\tif (strcmp(argv[0], \"mds\") == 0) {\n\t\tsymbolic = 1;\n\t\t/* Do not save these changes as last_*, they are temporary mds\n\t\t * overrides.\n\t\t */\n\t\tbytesperword = KDB_WORD_SIZE;\n\t\trepeat = mdcount;\n\t\tkdbgetintenv(\"NOSECT\", &nosect);\n\t}\n\n\t/* Round address down modulo BYTESPERWORD */\n\n\taddr &= ~(bytesperword-1);\n\n\twhile (repeat > 0) {\n\t\tunsigned long a;\n\t\tint n, z, num = (symbolic ? 1 : (16 / bytesperword));\n\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tfor (a = addr, z = 0; z < repeat; a += bytesperword, ++z) {\n\t\t\tif (phys) {\n\t\t\t\tif (kdb_getphysword(&word, a, bytesperword)\n\t\t\t\t\t\t|| word)\n\t\t\t\t\tbreak;\n\t\t\t} else if (kdb_getword(&word, a, bytesperword) || word)\n\t\t\t\tbreak;\n\t\t}\n\t\tn = min(num, repeat);\n\t\tkdb_md_line(fmtstr, addr, symbolic, nosect, bytesperword,\n\t\t\t    num, repeat, phys);\n\t\taddr += bytesperword * n;\n\t\trepeat -= n;\n\t\tz = (z + num - 1) / num;\n\t\tif (z > 2) {\n\t\t\tint s = num * (z-2);\n\t\t\tkdb_printf(kdb_machreg_fmt0 \"-\" kdb_machreg_fmt0\n\t\t\t\t   \" zero suppressed\\n\",\n\t\t\t\taddr, addr + bytesperword * s - 1);\n\t\t\taddr += bytesperword * s;\n\t\t\trepeat -= s;\n\t\t}\n\t}\n\tlast_addr = addr;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "kdb_machreg_fmt0 \"-\" kdb_machreg_fmt0\n\t\t\t\t   \" zero suppressed\\n\"",
            "addr",
            "addr + bytesperword * s - 1"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_md_line",
          "args": [
            "fmtstr",
            "addr",
            "symbolic",
            "nosect",
            "bytesperword",
            "num",
            "repeat",
            "phys"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_md_line",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1476-1539",
          "snippet": "static void kdb_md_line(const char *fmtstr, unsigned long addr,\n\t\t\tint symbolic, int nosect, int bytesperword,\n\t\t\tint num, int repeat, int phys)\n{\n\t/* print just one line of data */\n\tkdb_symtab_t symtab;\n\tchar cbuf[32];\n\tchar *c = cbuf;\n\tint i;\n\tint j;\n\tunsigned long word;\n\n\tmemset(cbuf, '\\0', sizeof(cbuf));\n\tif (phys)\n\t\tkdb_printf(\"phys \" kdb_machreg_fmt0 \" \", addr);\n\telse\n\t\tkdb_printf(kdb_machreg_fmt0 \" \", addr);\n\n\tfor (i = 0; i < num && repeat--; i++) {\n\t\tif (phys) {\n\t\t\tif (kdb_getphysword(&word, addr, bytesperword))\n\t\t\t\tbreak;\n\t\t} else if (kdb_getword(&word, addr, bytesperword))\n\t\t\tbreak;\n\t\tkdb_printf(fmtstr, word);\n\t\tif (symbolic)\n\t\t\tkdbnearsym(word, &symtab);\n\t\telse\n\t\t\tmemset(&symtab, 0, sizeof(symtab));\n\t\tif (symtab.sym_name) {\n\t\t\tkdb_symbol_print(word, &symtab, 0);\n\t\t\tif (!nosect) {\n\t\t\t\tkdb_printf(\"\\n\");\n\t\t\t\tkdb_printf(\"                       %s %s \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt, symtab.mod_name,\n\t\t\t\t\t   symtab.sec_name, symtab.sec_start,\n\t\t\t\t\t   symtab.sym_start, symtab.sym_end);\n\t\t\t}\n\t\t\taddr += bytesperword;\n\t\t} else {\n\t\t\tunion {\n\t\t\t\tu64 word;\n\t\t\t\tunsigned char c[8];\n\t\t\t} wc;\n\t\t\tunsigned char *cp;\n#ifdef\t__BIG_ENDIAN\n\t\t\tcp = wc.c + 8 - bytesperword;\n#else\n\t\t\tcp = wc.c;\n#endif\n\t\t\twc.word = word;\n#define printable_char(c) \\\n\t({unsigned char __c = c; isascii(__c) && isprint(__c) ? __c : '.'; })\n\t\t\tfor (j = 0; j < bytesperword; j++)\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\taddr += bytesperword;\n#undef printable_char\n\t\t}\n\t}\n\tkdb_printf(\"%*s %s\\n\", (int)((num-i)*(2*bytesperword + 1)+1),\n\t\t   \" \", cbuf);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_md_line(const char *fmtstr, unsigned long addr,\n\t\t\tint symbolic, int nosect, int bytesperword,\n\t\t\tint num, int repeat, int phys)\n{\n\t/* print just one line of data */\n\tkdb_symtab_t symtab;\n\tchar cbuf[32];\n\tchar *c = cbuf;\n\tint i;\n\tint j;\n\tunsigned long word;\n\n\tmemset(cbuf, '\\0', sizeof(cbuf));\n\tif (phys)\n\t\tkdb_printf(\"phys \" kdb_machreg_fmt0 \" \", addr);\n\telse\n\t\tkdb_printf(kdb_machreg_fmt0 \" \", addr);\n\n\tfor (i = 0; i < num && repeat--; i++) {\n\t\tif (phys) {\n\t\t\tif (kdb_getphysword(&word, addr, bytesperword))\n\t\t\t\tbreak;\n\t\t} else if (kdb_getword(&word, addr, bytesperword))\n\t\t\tbreak;\n\t\tkdb_printf(fmtstr, word);\n\t\tif (symbolic)\n\t\t\tkdbnearsym(word, &symtab);\n\t\telse\n\t\t\tmemset(&symtab, 0, sizeof(symtab));\n\t\tif (symtab.sym_name) {\n\t\t\tkdb_symbol_print(word, &symtab, 0);\n\t\t\tif (!nosect) {\n\t\t\t\tkdb_printf(\"\\n\");\n\t\t\t\tkdb_printf(\"                       %s %s \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt, symtab.mod_name,\n\t\t\t\t\t   symtab.sec_name, symtab.sec_start,\n\t\t\t\t\t   symtab.sym_start, symtab.sym_end);\n\t\t\t}\n\t\t\taddr += bytesperword;\n\t\t} else {\n\t\t\tunion {\n\t\t\t\tu64 word;\n\t\t\t\tunsigned char c[8];\n\t\t\t} wc;\n\t\t\tunsigned char *cp;\n#ifdef\t__BIG_ENDIAN\n\t\t\tcp = wc.c + 8 - bytesperword;\n#else\n\t\t\tcp = wc.c;\n#endif\n\t\t\twc.word = word;\n#define printable_char(c) \\\n\t({unsigned char __c = c; isascii(__c) && isprint(__c) ? __c : '.'; })\n\t\t\tfor (j = 0; j < bytesperword; j++)\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\taddr += bytesperword;\n#undef printable_char\n\t\t}\n\t}\n\tkdb_printf(\"%*s %s\\n\", (int)((num-i)*(2*bytesperword + 1)+1),\n\t\t   \" \", cbuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "num",
            "repeat"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getword",
          "args": [
            "&word",
            "a",
            "bytesperword"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getword",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "394-431",
          "snippet": "int kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getphysword",
          "args": [
            "&word",
            "a",
            "bytesperword"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getphysword",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "344-382",
          "snippet": "int kdb_getphysword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getphys(&w1, addr, sizeof(w1));\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getphys(&w2, addr, sizeof(w2));\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getphys(&w4, addr, sizeof(w4));\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdb_getphysword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getphys(&w1, addr, sizeof(w1));\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getphys(&w2, addr, sizeof(w2));\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getphys(&w4, addr, sizeof(w4));\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetintenv",
          "args": [
            "\"NOSECT\"",
            "&nosect"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetintenv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "284-293",
          "snippet": "int kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "\"mds\""
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fmtstr",
            "\"%%2.2l%c \"",
            "fmtchar"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fmtstr",
            "\"%%4.4l%c \"",
            "fmtchar"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fmtstr",
            "\"%%8.8l%c \"",
            "fmtchar"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fmtstr",
            "\"%%16.16l%c \"",
            "fmtchar"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_mdr",
          "args": [
            "addr",
            "mdcount"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_mdr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1453-1464",
          "snippet": "static int kdb_mdr(unsigned long addr, unsigned int count)\n{\n\tunsigned char c;\n\twhile (count--) {\n\t\tif (kdb_getarea(c, addr))\n\t\t\treturn 0;\n\t\tkdb_printf(\"%02x\", c);\n\t\taddr++;\n\t}\n\tkdb_printf(\"\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_mdr(unsigned long addr, unsigned int count)\n{\n\tunsigned char c;\n\twhile (count--) {\n\t\tif (kdb_getarea(c, addr))\n\t\t\treturn 0;\n\t\tkdb_printf(\"%02x\", c);\n\t\taddr++;\n\t}\n\tkdb_printf(\"\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetularg",
          "args": [
            "argv[nextarg+1]",
            "&val"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetularg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "362-382",
          "snippet": "int kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetaddrarg",
          "args": [
            "argc",
            "argv",
            "&nextarg",
            "&addr",
            "&offset",
            "NULL"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetaddrarg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "491-623",
          "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "argv[0] + 4",
            "&p",
            "10"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "argv[0][2]"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_md(int argc, const char **argv)\n{\n\tstatic unsigned long last_addr;\n\tstatic int last_radix, last_bytesperword, last_repeat;\n\tint radix = 16, mdcount = 8, bytesperword = KDB_WORD_SIZE, repeat;\n\tint nosect = 0;\n\tchar fmtchar, fmtstr[64];\n\tunsigned long addr;\n\tunsigned long word;\n\tlong offset = 0;\n\tint symbolic = 0;\n\tint valid = 0;\n\tint phys = 0;\n\tint raw = 0;\n\n\tkdbgetintenv(\"MDCOUNT\", &mdcount);\n\tkdbgetintenv(\"RADIX\", &radix);\n\tkdbgetintenv(\"BYTESPERWORD\", &bytesperword);\n\n\t/* Assume 'md <addr>' and start with environment values */\n\trepeat = mdcount * 16 / bytesperword;\n\n\tif (strcmp(argv[0], \"mdr\") == 0) {\n\t\tif (argc == 2 || (argc == 0 && last_addr != 0))\n\t\t\tvalid = raw = 1;\n\t\telse\n\t\t\treturn KDB_ARGCOUNT;\n\t} else if (isdigit(argv[0][2])) {\n\t\tbytesperword = (int)(argv[0][2] - '0');\n\t\tif (bytesperword == 0) {\n\t\t\tbytesperword = last_bytesperword;\n\t\t\tif (bytesperword == 0)\n\t\t\t\tbytesperword = 4;\n\t\t}\n\t\tlast_bytesperword = bytesperword;\n\t\trepeat = mdcount * 16 / bytesperword;\n\t\tif (!argv[0][3])\n\t\t\tvalid = 1;\n\t\telse if (argv[0][3] == 'c' && argv[0][4]) {\n\t\t\tchar *p;\n\t\t\trepeat = simple_strtoul(argv[0] + 4, &p, 10);\n\t\t\tmdcount = ((repeat * bytesperword) + 15) / 16;\n\t\t\tvalid = !*p;\n\t\t}\n\t\tlast_repeat = repeat;\n\t} else if (strcmp(argv[0], \"md\") == 0)\n\t\tvalid = 1;\n\telse if (strcmp(argv[0], \"mds\") == 0)\n\t\tvalid = 1;\n\telse if (strcmp(argv[0], \"mdp\") == 0) {\n\t\tphys = valid = 1;\n\t}\n\tif (!valid)\n\t\treturn KDB_NOTFOUND;\n\n\tif (argc == 0) {\n\t\tif (last_addr == 0)\n\t\t\treturn KDB_ARGCOUNT;\n\t\taddr = last_addr;\n\t\tradix = last_radix;\n\t\tbytesperword = last_bytesperword;\n\t\trepeat = last_repeat;\n\t\tif (raw)\n\t\t\tmdcount = repeat;\n\t\telse\n\t\t\tmdcount = ((repeat * bytesperword) + 15) / 16;\n\t}\n\n\tif (argc) {\n\t\tunsigned long val;\n\t\tint diag, nextarg = 1;\n\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr,\n\t\t\t\t     &offset, NULL);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (argc > nextarg+2)\n\t\t\treturn KDB_ARGCOUNT;\n\n\t\tif (argc >= nextarg) {\n\t\t\tdiag = kdbgetularg(argv[nextarg], &val);\n\t\t\tif (!diag) {\n\t\t\t\tmdcount = (int) val;\n\t\t\t\tif (raw)\n\t\t\t\t\trepeat = mdcount;\n\t\t\t\telse\n\t\t\t\t\trepeat = mdcount * 16 / bytesperword;\n\t\t\t}\n\t\t}\n\t\tif (argc >= nextarg+1) {\n\t\t\tdiag = kdbgetularg(argv[nextarg+1], &val);\n\t\t\tif (!diag)\n\t\t\t\tradix = (int) val;\n\t\t}\n\t}\n\n\tif (strcmp(argv[0], \"mdr\") == 0) {\n\t\tint ret;\n\t\tlast_addr = addr;\n\t\tret = kdb_mdr(addr, mdcount);\n\t\tlast_addr += mdcount;\n\t\tlast_repeat = mdcount;\n\t\tlast_bytesperword = bytesperword; // to make REPEAT happy\n\t\treturn ret;\n\t}\n\n\tswitch (radix) {\n\tcase 10:\n\t\tfmtchar = 'd';\n\t\tbreak;\n\tcase 16:\n\t\tfmtchar = 'x';\n\t\tbreak;\n\tcase 8:\n\t\tfmtchar = 'o';\n\t\tbreak;\n\tdefault:\n\t\treturn KDB_BADRADIX;\n\t}\n\n\tlast_radix = radix;\n\n\tif (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\n\tswitch (bytesperword) {\n\tcase 8:\n\t\tsprintf(fmtstr, \"%%16.16l%c \", fmtchar);\n\t\tbreak;\n\tcase 4:\n\t\tsprintf(fmtstr, \"%%8.8l%c \", fmtchar);\n\t\tbreak;\n\tcase 2:\n\t\tsprintf(fmtstr, \"%%4.4l%c \", fmtchar);\n\t\tbreak;\n\tcase 1:\n\t\tsprintf(fmtstr, \"%%2.2l%c \", fmtchar);\n\t\tbreak;\n\tdefault:\n\t\treturn KDB_BADWIDTH;\n\t}\n\n\tlast_repeat = repeat;\n\tlast_bytesperword = bytesperword;\n\n\tif (strcmp(argv[0], \"mds\") == 0) {\n\t\tsymbolic = 1;\n\t\t/* Do not save these changes as last_*, they are temporary mds\n\t\t * overrides.\n\t\t */\n\t\tbytesperword = KDB_WORD_SIZE;\n\t\trepeat = mdcount;\n\t\tkdbgetintenv(\"NOSECT\", &nosect);\n\t}\n\n\t/* Round address down modulo BYTESPERWORD */\n\n\taddr &= ~(bytesperword-1);\n\n\twhile (repeat > 0) {\n\t\tunsigned long a;\n\t\tint n, z, num = (symbolic ? 1 : (16 / bytesperword));\n\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tfor (a = addr, z = 0; z < repeat; a += bytesperword, ++z) {\n\t\t\tif (phys) {\n\t\t\t\tif (kdb_getphysword(&word, a, bytesperword)\n\t\t\t\t\t\t|| word)\n\t\t\t\t\tbreak;\n\t\t\t} else if (kdb_getword(&word, a, bytesperword) || word)\n\t\t\t\tbreak;\n\t\t}\n\t\tn = min(num, repeat);\n\t\tkdb_md_line(fmtstr, addr, symbolic, nosect, bytesperword,\n\t\t\t    num, repeat, phys);\n\t\taddr += bytesperword * n;\n\t\trepeat -= n;\n\t\tz = (z + num - 1) / num;\n\t\tif (z > 2) {\n\t\t\tint s = num * (z-2);\n\t\t\tkdb_printf(kdb_machreg_fmt0 \"-\" kdb_machreg_fmt0\n\t\t\t\t   \" zero suppressed\\n\",\n\t\t\t\taddr, addr + bytesperword * s - 1);\n\t\t\taddr += bytesperword * s;\n\t\t\trepeat -= s;\n\t\t}\n\t}\n\tlast_addr = addr;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_md_line",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1476-1539",
    "snippet": "static void kdb_md_line(const char *fmtstr, unsigned long addr,\n\t\t\tint symbolic, int nosect, int bytesperword,\n\t\t\tint num, int repeat, int phys)\n{\n\t/* print just one line of data */\n\tkdb_symtab_t symtab;\n\tchar cbuf[32];\n\tchar *c = cbuf;\n\tint i;\n\tint j;\n\tunsigned long word;\n\n\tmemset(cbuf, '\\0', sizeof(cbuf));\n\tif (phys)\n\t\tkdb_printf(\"phys \" kdb_machreg_fmt0 \" \", addr);\n\telse\n\t\tkdb_printf(kdb_machreg_fmt0 \" \", addr);\n\n\tfor (i = 0; i < num && repeat--; i++) {\n\t\tif (phys) {\n\t\t\tif (kdb_getphysword(&word, addr, bytesperword))\n\t\t\t\tbreak;\n\t\t} else if (kdb_getword(&word, addr, bytesperword))\n\t\t\tbreak;\n\t\tkdb_printf(fmtstr, word);\n\t\tif (symbolic)\n\t\t\tkdbnearsym(word, &symtab);\n\t\telse\n\t\t\tmemset(&symtab, 0, sizeof(symtab));\n\t\tif (symtab.sym_name) {\n\t\t\tkdb_symbol_print(word, &symtab, 0);\n\t\t\tif (!nosect) {\n\t\t\t\tkdb_printf(\"\\n\");\n\t\t\t\tkdb_printf(\"                       %s %s \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt, symtab.mod_name,\n\t\t\t\t\t   symtab.sec_name, symtab.sec_start,\n\t\t\t\t\t   symtab.sym_start, symtab.sym_end);\n\t\t\t}\n\t\t\taddr += bytesperword;\n\t\t} else {\n\t\t\tunion {\n\t\t\t\tu64 word;\n\t\t\t\tunsigned char c[8];\n\t\t\t} wc;\n\t\t\tunsigned char *cp;\n#ifdef\t__BIG_ENDIAN\n\t\t\tcp = wc.c + 8 - bytesperword;\n#else\n\t\t\tcp = wc.c;\n#endif\n\t\t\twc.word = word;\n#define printable_char(c) \\\n\t({unsigned char __c = c; isascii(__c) && isprint(__c) ? __c : '.'; })\n\t\t\tfor (j = 0; j < bytesperword; j++)\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\taddr += bytesperword;\n#undef printable_char\n\t\t}\n\t}\n\tkdb_printf(\"%*s %s\\n\", (int)((num-i)*(2*bytesperword + 1)+1),\n\t\t   \" \", cbuf);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%*s %s\\n\"",
            "(int)((num-i)*(2*bytesperword + 1)+1)",
            "\" \"",
            "cbuf"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printable_char",
          "args": [
            "*cp++"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_symbol_print",
          "args": [
            "word",
            "&symtab",
            "0"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_symbol_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "199-235",
          "snippet": "void kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nvoid kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&symtab",
            "0",
            "sizeof(symtab)"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbnearsym",
          "args": [
            "word",
            "&symtab"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "kdbnearsym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "82-111",
          "snippet": "int kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n\tstatic char namebuf[KSYM_NAME_LEN];\n\n\tkdb_dbg_printf(AR, \"addr=0x%lx, symtab=%px\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), namebuf);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tkdb_dbg_printf(AR, \"returns %d symtab->sym_start=0x%lx, symtab->mod_name=%px, symtab->sym_name=%px (%s)\\n\",\n\t\t       ret, symtab->sym_start, symtab->mod_name, symtab->sym_name, symtab->sym_name);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n\tstatic char namebuf[KSYM_NAME_LEN];\n\n\tkdb_dbg_printf(AR, \"addr=0x%lx, symtab=%px\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), namebuf);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tkdb_dbg_printf(AR, \"returns %d symtab->sym_start=0x%lx, symtab->mod_name=%px, symtab->sym_name=%px (%s)\\n\",\n\t\t       ret, symtab->sym_start, symtab->mod_name, symtab->sym_name, symtab->sym_name);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getword",
          "args": [
            "&word",
            "addr",
            "bytesperword"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getword",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "394-431",
          "snippet": "int kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getphysword",
          "args": [
            "&word",
            "addr",
            "bytesperword"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getphysword",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "344-382",
          "snippet": "int kdb_getphysword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getphys(&w1, addr, sizeof(w1));\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getphys(&w2, addr, sizeof(w2));\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getphys(&w4, addr, sizeof(w4));\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdb_getphysword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getphys(&w1, addr, sizeof(w1));\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getphys(&w2, addr, sizeof(w2));\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getphys(&w4, addr, sizeof(w4));\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cbuf",
            "'\\0'",
            "sizeof(cbuf)"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_md_line(const char *fmtstr, unsigned long addr,\n\t\t\tint symbolic, int nosect, int bytesperword,\n\t\t\tint num, int repeat, int phys)\n{\n\t/* print just one line of data */\n\tkdb_symtab_t symtab;\n\tchar cbuf[32];\n\tchar *c = cbuf;\n\tint i;\n\tint j;\n\tunsigned long word;\n\n\tmemset(cbuf, '\\0', sizeof(cbuf));\n\tif (phys)\n\t\tkdb_printf(\"phys \" kdb_machreg_fmt0 \" \", addr);\n\telse\n\t\tkdb_printf(kdb_machreg_fmt0 \" \", addr);\n\n\tfor (i = 0; i < num && repeat--; i++) {\n\t\tif (phys) {\n\t\t\tif (kdb_getphysword(&word, addr, bytesperword))\n\t\t\t\tbreak;\n\t\t} else if (kdb_getword(&word, addr, bytesperword))\n\t\t\tbreak;\n\t\tkdb_printf(fmtstr, word);\n\t\tif (symbolic)\n\t\t\tkdbnearsym(word, &symtab);\n\t\telse\n\t\t\tmemset(&symtab, 0, sizeof(symtab));\n\t\tif (symtab.sym_name) {\n\t\t\tkdb_symbol_print(word, &symtab, 0);\n\t\t\tif (!nosect) {\n\t\t\t\tkdb_printf(\"\\n\");\n\t\t\t\tkdb_printf(\"                       %s %s \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt, symtab.mod_name,\n\t\t\t\t\t   symtab.sec_name, symtab.sec_start,\n\t\t\t\t\t   symtab.sym_start, symtab.sym_end);\n\t\t\t}\n\t\t\taddr += bytesperword;\n\t\t} else {\n\t\t\tunion {\n\t\t\t\tu64 word;\n\t\t\t\tunsigned char c[8];\n\t\t\t} wc;\n\t\t\tunsigned char *cp;\n#ifdef\t__BIG_ENDIAN\n\t\t\tcp = wc.c + 8 - bytesperword;\n#else\n\t\t\tcp = wc.c;\n#endif\n\t\t\twc.word = word;\n#define printable_char(c) \\\n\t({unsigned char __c = c; isascii(__c) && isprint(__c) ? __c : '.'; })\n\t\t\tfor (j = 0; j < bytesperword; j++)\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\taddr += bytesperword;\n#undef printable_char\n\t\t}\n\t}\n\tkdb_printf(\"%*s %s\\n\", (int)((num-i)*(2*bytesperword + 1)+1),\n\t\t   \" \", cbuf);\n}"
  },
  {
    "function_name": "kdb_mdr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1453-1464",
    "snippet": "static int kdb_mdr(unsigned long addr, unsigned int count)\n{\n\tunsigned char c;\n\twhile (count--) {\n\t\tif (kdb_getarea(c, addr))\n\t\t\treturn 0;\n\t\tkdb_printf(\"%02x\", c);\n\t\taddr++;\n\t}\n\tkdb_printf(\"\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getarea",
          "args": [
            "c",
            "addr"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_mdr(unsigned long addr, unsigned int count)\n{\n\tunsigned char c;\n\twhile (count--) {\n\t\tif (kdb_getarea(c, addr))\n\t\t\treturn 0;\n\t\tkdb_printf(\"%02x\", c);\n\t\taddr++;\n\t}\n\tkdb_printf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_main_loop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1386-1441",
    "snippet": "int kdb_main_loop(kdb_reason_t reason, kdb_reason_t reason2, int error,\n\t      kdb_dbtrap_t db_result, struct pt_regs *regs)\n{\n\tint result = 1;\n\t/* Stay in kdb() until 'go', 'ss[b]' or an error */\n\twhile (1) {\n\t\t/*\n\t\t * All processors except the one that is in control\n\t\t * will spin here.\n\t\t */\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 1\", reason);\n\t\twhile (KDB_STATE(HOLD_CPU)) {\n\t\t\t/* state KDB is turned off by kdb_cpu to see if the\n\t\t\t * other cpus are still live, each cpu in this loop\n\t\t\t * turns it back on.\n\t\t\t */\n\t\t\tif (!KDB_STATE(KDB))\n\t\t\t\tKDB_STATE_SET(KDB);\n\t\t}\n\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 2\", reason);\n\t\tif (KDB_STATE(LEAVING))\n\t\t\tbreak;\t/* Another cpu said 'go' */\n\t\t/* Still using kdb, this processor is in control */\n\t\tresult = kdb_local(reason2, error, regs, db_result);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 3\", result);\n\n\t\tif (result == KDB_CMD_CPU)\n\t\t\tbreak;\n\n\t\tif (result == KDB_CMD_SS) {\n\t\t\tKDB_STATE_SET(DOING_SS);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (result == KDB_CMD_KGDB) {\n\t\t\tif (!KDB_STATE(DOING_KGDB))\n\t\t\t\tkdb_printf(\"Entering please attach debugger \"\n\t\t\t\t\t   \"or use $D#44+ or $3#33\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (result && result != 1 && result != KDB_CMD_GO)\n\t\t\tkdb_printf(\"\\nUnexpected kdb_local return code %d\\n\",\n\t\t\t\t   result);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 4\", reason);\n\t\tbreak;\n\t}\n\tif (KDB_STATE(DOING_SS))\n\t\tKDB_STATE_CLEAR(SSBPT);\n\n\t/* Clean up any keyboard devices before leaving */\n\tkdb_kbd_cleanup_state();\n\n\treturn result;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_kbd_cleanup_state",
          "args": [],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_kbd_cleanup_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_keyboard.c",
          "lines": "199-263",
          "snippet": "void kdb_kbd_cleanup_state(void)\n{\n\tint scancode, scanstatus;\n\n\t/*\n\t * Nothing to clean up, since either\n\t * ENTER was never pressed, or has already\n\t * gotten cleaned up.\n\t */\n\tif (!kbd_last_ret)\n\t\treturn;\n\n\tkbd_last_ret = 0;\n\t/*\n\t * Enter key. Need to absorb the break code here, lest it gets\n\t * leaked out if we exit KDB as the result of processing 'g'.\n\t *\n\t * This has several interesting implications:\n\t * + Need to handle KP ENTER, which has break code 0xe0 0x9c.\n\t * + Need to handle repeat ENTER and repeat KP ENTER. Repeats\n\t *   only get a break code at the end of the repeated\n\t *   sequence. This means we can't propagate the repeated key\n\t *   press, and must swallow it away.\n\t * + Need to handle possible PS/2 mouse input.\n\t * + Need to handle mashed keys.\n\t */\n\n\twhile (1) {\n\t\twhile ((inb(KBD_STATUS_REG) & KBD_STAT_OBF) == 0)\n\t\t\tcpu_relax();\n\n\t\t/*\n\t\t * Fetch the scancode.\n\t\t */\n\t\tscancode = inb(KBD_DATA_REG);\n\t\tscanstatus = inb(KBD_STATUS_REG);\n\n\t\t/*\n\t\t * Skip mouse input.\n\t\t */\n\t\tif (scanstatus & KBD_STAT_MOUSE_OBF)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If we see 0xe0, this is either a break code for KP\n\t\t * ENTER, or a repeat make for KP ENTER. Either way,\n\t\t * since the second byte is equivalent to an ENTER,\n\t\t * skip the 0xe0 and try again.\n\t\t *\n\t\t * If we see 0x1c, this must be a repeat ENTER or KP\n\t\t * ENTER (and we swallowed 0xe0 before). Try again.\n\t\t *\n\t\t * We can also see make and break codes for other keys\n\t\t * mashed before or after pressing ENTER. Thus, if we\n\t\t * see anything other than 0x9c, we have to try again.\n\t\t *\n\t\t * Note, if you held some key as ENTER was depressed,\n\t\t * that break code would get leaked out.\n\t\t */\n\t\tif (scancode != 0x9c)\n\t\t\tcontinue;\n\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <linux/io.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/keyboard.h>",
            "#include <linux/kdb.h>"
          ],
          "macros_used": [
            "#define KBD_STAT_MOUSE_OBF\t0x20\t/* Mouse output buffer full */",
            "#define KBD_STAT_OBF \t\t0x01\t/* Keyboard output buffer full */",
            "#define KBD_DATA_REG\t\t0x60\t/* Keyboard data register (R/W) */",
            "#define KBD_STATUS_REG\t\t0x64\t/* Status register (R) */"
          ],
          "globals_used": [
            "static int kbd_last_ret;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/keyboard.h>\n#include <linux/kdb.h>\n\n#define KBD_STAT_MOUSE_OBF\t0x20\t/* Mouse output buffer full */\n#define KBD_STAT_OBF \t\t0x01\t/* Keyboard output buffer full */\n#define KBD_DATA_REG\t\t0x60\t/* Keyboard data register (R/W) */\n#define KBD_STATUS_REG\t\t0x64\t/* Status register (R) */\n\nstatic int kbd_last_ret;\n\nvoid kdb_kbd_cleanup_state(void)\n{\n\tint scancode, scanstatus;\n\n\t/*\n\t * Nothing to clean up, since either\n\t * ENTER was never pressed, or has already\n\t * gotten cleaned up.\n\t */\n\tif (!kbd_last_ret)\n\t\treturn;\n\n\tkbd_last_ret = 0;\n\t/*\n\t * Enter key. Need to absorb the break code here, lest it gets\n\t * leaked out if we exit KDB as the result of processing 'g'.\n\t *\n\t * This has several interesting implications:\n\t * + Need to handle KP ENTER, which has break code 0xe0 0x9c.\n\t * + Need to handle repeat ENTER and repeat KP ENTER. Repeats\n\t *   only get a break code at the end of the repeated\n\t *   sequence. This means we can't propagate the repeated key\n\t *   press, and must swallow it away.\n\t * + Need to handle possible PS/2 mouse input.\n\t * + Need to handle mashed keys.\n\t */\n\n\twhile (1) {\n\t\twhile ((inb(KBD_STATUS_REG) & KBD_STAT_OBF) == 0)\n\t\t\tcpu_relax();\n\n\t\t/*\n\t\t * Fetch the scancode.\n\t\t */\n\t\tscancode = inb(KBD_DATA_REG);\n\t\tscanstatus = inb(KBD_STATUS_REG);\n\n\t\t/*\n\t\t * Skip mouse input.\n\t\t */\n\t\tif (scanstatus & KBD_STAT_MOUSE_OBF)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If we see 0xe0, this is either a break code for KP\n\t\t * ENTER, or a repeat make for KP ENTER. Either way,\n\t\t * since the second byte is equivalent to an ENTER,\n\t\t * skip the 0xe0 and try again.\n\t\t *\n\t\t * If we see 0x1c, this must be a repeat ENTER or KP\n\t\t * ENTER (and we swallowed 0xe0 before). Try again.\n\t\t *\n\t\t * We can also see make and break codes for other keys\n\t\t * mashed before or after pressing ENTER. Thus, if we\n\t\t * see anything other than 0x9c, we have to try again.\n\t\t *\n\t\t * Note, if you held some key as ENTER was depressed,\n\t\t * that break code would get leaked out.\n\t\t */\n\t\tif (scancode != 0x9c)\n\t\t\tcontinue;\n\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "SSBPT"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "DOING_SS"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_main_loop 4\"",
            "reason"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\nUnexpected kdb_local return code %d\\n\"",
            "result"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "DOING_KGDB"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "DOING_SS"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_main_loop 3\"",
            "result"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_local",
          "args": [
            "reason2",
            "error",
            "regs",
            "db_result"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1174-1344",
          "snippet": "static int kdb_local(kdb_reason_t reason, int error, struct pt_regs *regs,\n\t\t     kdb_dbtrap_t db_result)\n{\n\tchar *cmdbuf;\n\tint diag;\n\tstruct task_struct *kdb_current =\n\t\tkdb_curr_task(raw_smp_processor_id());\n\n\tKDB_DEBUG_STATE(\"kdb_local 1\", reason);\n\tkdb_go_count = 0;\n\tif (reason == KDB_REASON_DEBUG) {\n\t\t/* special case below */\n\t} else {\n\t\tkdb_printf(\"\\nEntering kdb (current=0x%px, pid %d) \",\n\t\t\t   kdb_current, kdb_current ? kdb_current->pid : 0);\n#if defined(CONFIG_SMP)\n\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t}\n\n\tswitch (reason) {\n\tcase KDB_REASON_DEBUG:\n\t{\n\t\t/*\n\t\t * If re-entering kdb after a single step\n\t\t * command, don't print the message.\n\t\t */\n\t\tswitch (db_result) {\n\t\tcase KDB_DB_BPT:\n\t\t\tkdb_printf(\"\\nEntering kdb (0x%px, pid %d) \",\n\t\t\t\t   kdb_current, kdb_current->pid);\n#if defined(CONFIG_SMP)\n\t\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t\t\tkdb_printf(\"due to Debug @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t\t   instruction_pointer(regs));\n\t\t\tbreak;\n\t\tcase KDB_DB_SS:\n\t\t\tbreak;\n\t\tcase KDB_DB_SSBPT:\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 4\", reason);\n\t\t\treturn 1;\t/* kdba_db_trap did the work */\n\t\tdefault:\n\t\t\tkdb_printf(\"kdb: Bad result from kdba_db_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\t\tbreak;\n\tcase KDB_REASON_ENTER:\n\t\tif (KDB_STATE(KEYBOARD))\n\t\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\telse\n\t\t\tkdb_printf(\"due to KDB_ENTER()\\n\");\n\t\tbreak;\n\tcase KDB_REASON_KEYBOARD:\n\t\tKDB_STATE_SET(KEYBOARD);\n\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\tbreak;\n\tcase KDB_REASON_ENTER_SLAVE:\n\t\t/* drop through, slaves only get released via cpu switch */\n\tcase KDB_REASON_SWITCH:\n\t\tkdb_printf(\"due to cpu switch\\n\");\n\t\tbreak;\n\tcase KDB_REASON_OOPS:\n\t\tkdb_printf(\"Oops: %s\\n\", kdb_diemsg);\n\t\tkdb_printf(\"due to oops @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tkdb_dumpregs(regs);\n\t\tbreak;\n\tcase KDB_REASON_SYSTEM_NMI:\n\t\tkdb_printf(\"due to System NonMaskable Interrupt\\n\");\n\t\tbreak;\n\tcase KDB_REASON_NMI:\n\t\tkdb_printf(\"due to NonMaskable Interrupt @ \"\n\t\t\t   kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tcase KDB_REASON_SSTEP:\n\tcase KDB_REASON_BREAK:\n\t\tkdb_printf(\"due to %s @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   reason == KDB_REASON_BREAK ?\n\t\t\t   \"Breakpoint\" : \"SS trap\", instruction_pointer(regs));\n\t\t/*\n\t\t * Determine if this breakpoint is one that we\n\t\t * are interested in.\n\t\t */\n\t\tif (db_result != KDB_DB_BPT) {\n\t\t\tkdb_printf(\"kdb: error return from kdba_bp_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 6\", reason);\n\t\t\treturn 0;\t/* Not for us, dismiss it */\n\t\t}\n\t\tbreak;\n\tcase KDB_REASON_RECURSE:\n\t\tkdb_printf(\"due to Recursion @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tdefault:\n\t\tkdb_printf(\"kdb: unexpected reason code: %d\\n\", reason);\n\t\tKDB_DEBUG_STATE(\"kdb_local 8\", reason);\n\t\treturn 0;\t/* Not for us, dismiss it */\n\t}\n\n\twhile (1) {\n\t\t/*\n\t\t * Initialize pager context.\n\t\t */\n\t\tkdb_nextline = 1;\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t\tkdb_grepping_flag = 0;\n\t\t/* ensure the old search does not leak into '/' commands */\n\t\tkdb_grep_string[0] = '\\0';\n\n\t\tcmdbuf = cmd_cur;\n\t\t*cmdbuf = '\\0';\n\t\t*(cmd_hist[cmd_head]) = '\\0';\n\ndo_full_getstr:\n\t\t/* PROMPT can only be set if we have MEM_READ permission. */\n\t\tsnprintf(kdb_prompt_str, CMD_BUFLEN, kdbgetenv(\"PROMPT\"),\n\t\t\t raw_smp_processor_id());\n\t\tif (defcmd_in_progress)\n\t\t\tstrncat(kdb_prompt_str, \"[defcmd]\", CMD_BUFLEN);\n\n\t\t/*\n\t\t * Fetch command from keyboard\n\t\t */\n\t\tcmdbuf = kdb_getstr(cmdbuf, CMD_BUFLEN, kdb_prompt_str);\n\t\tif (*cmdbuf != '\\n') {\n\t\t\tif (*cmdbuf < 32) {\n\t\t\t\tif (cmdptr == cmd_head) {\n\t\t\t\t\tstrscpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\t\tCMD_BUFLEN);\n\t\t\t\t\t*(cmd_hist[cmd_head] +\n\t\t\t\t\t  strlen(cmd_hist[cmd_head])-1) = '\\0';\n\t\t\t\t}\n\t\t\t\tif (!handle_ctrl_cmd(cmdbuf))\n\t\t\t\t\t*(cmd_cur+strlen(cmd_cur)-1) = '\\0';\n\t\t\t\tcmdbuf = cmd_cur;\n\t\t\t\tgoto do_full_getstr;\n\t\t\t} else {\n\t\t\t\tstrscpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\tCMD_BUFLEN);\n\t\t\t}\n\n\t\t\tcmd_head = (cmd_head+1) % KDB_CMD_HISTORY_COUNT;\n\t\t\tif (cmd_head == cmd_tail)\n\t\t\t\tcmd_tail = (cmd_tail+1) % KDB_CMD_HISTORY_COUNT;\n\t\t}\n\n\t\tcmdptr = cmd_head;\n\t\tdiag = kdb_parse(cmdbuf);\n\t\tif (diag == KDB_NOTFOUND) {\n\t\t\tdrop_newline(cmdbuf);\n\t\t\tkdb_printf(\"Unknown kdb command: '%s'\\n\", cmdbuf);\n\t\t\tdiag = 0;\n\t\t}\n\t\tif (diag == KDB_CMD_GO\n\t\t || diag == KDB_CMD_CPU\n\t\t || diag == KDB_CMD_SS\n\t\t || diag == KDB_CMD_KGDB)\n\t\t\tbreak;\n\n\t\tif (diag)\n\t\t\tkdb_cmderror(diag);\n\t}\n\tKDB_DEBUG_STATE(\"kdb_local 9\", diag);\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */",
            "#define KDB_CMD_HISTORY_COUNT\t32"
          ],
          "globals_used": [
            "char kdb_grep_string[KDB_GREP_STRLEN];",
            "int kdb_grepping_flag;",
            "int kdb_nextline = 1;",
            "const char *kdb_diemsg;",
            "static int kdb_go_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n#define KDB_CMD_HISTORY_COUNT\t32\n\nchar kdb_grep_string[KDB_GREP_STRLEN];\nint kdb_grepping_flag;\nint kdb_nextline = 1;\nconst char *kdb_diemsg;\nstatic int kdb_go_count;\n\nstatic int kdb_local(kdb_reason_t reason, int error, struct pt_regs *regs,\n\t\t     kdb_dbtrap_t db_result)\n{\n\tchar *cmdbuf;\n\tint diag;\n\tstruct task_struct *kdb_current =\n\t\tkdb_curr_task(raw_smp_processor_id());\n\n\tKDB_DEBUG_STATE(\"kdb_local 1\", reason);\n\tkdb_go_count = 0;\n\tif (reason == KDB_REASON_DEBUG) {\n\t\t/* special case below */\n\t} else {\n\t\tkdb_printf(\"\\nEntering kdb (current=0x%px, pid %d) \",\n\t\t\t   kdb_current, kdb_current ? kdb_current->pid : 0);\n#if defined(CONFIG_SMP)\n\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t}\n\n\tswitch (reason) {\n\tcase KDB_REASON_DEBUG:\n\t{\n\t\t/*\n\t\t * If re-entering kdb after a single step\n\t\t * command, don't print the message.\n\t\t */\n\t\tswitch (db_result) {\n\t\tcase KDB_DB_BPT:\n\t\t\tkdb_printf(\"\\nEntering kdb (0x%px, pid %d) \",\n\t\t\t\t   kdb_current, kdb_current->pid);\n#if defined(CONFIG_SMP)\n\t\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t\t\tkdb_printf(\"due to Debug @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t\t   instruction_pointer(regs));\n\t\t\tbreak;\n\t\tcase KDB_DB_SS:\n\t\t\tbreak;\n\t\tcase KDB_DB_SSBPT:\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 4\", reason);\n\t\t\treturn 1;\t/* kdba_db_trap did the work */\n\t\tdefault:\n\t\t\tkdb_printf(\"kdb: Bad result from kdba_db_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\t\tbreak;\n\tcase KDB_REASON_ENTER:\n\t\tif (KDB_STATE(KEYBOARD))\n\t\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\telse\n\t\t\tkdb_printf(\"due to KDB_ENTER()\\n\");\n\t\tbreak;\n\tcase KDB_REASON_KEYBOARD:\n\t\tKDB_STATE_SET(KEYBOARD);\n\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\tbreak;\n\tcase KDB_REASON_ENTER_SLAVE:\n\t\t/* drop through, slaves only get released via cpu switch */\n\tcase KDB_REASON_SWITCH:\n\t\tkdb_printf(\"due to cpu switch\\n\");\n\t\tbreak;\n\tcase KDB_REASON_OOPS:\n\t\tkdb_printf(\"Oops: %s\\n\", kdb_diemsg);\n\t\tkdb_printf(\"due to oops @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tkdb_dumpregs(regs);\n\t\tbreak;\n\tcase KDB_REASON_SYSTEM_NMI:\n\t\tkdb_printf(\"due to System NonMaskable Interrupt\\n\");\n\t\tbreak;\n\tcase KDB_REASON_NMI:\n\t\tkdb_printf(\"due to NonMaskable Interrupt @ \"\n\t\t\t   kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tcase KDB_REASON_SSTEP:\n\tcase KDB_REASON_BREAK:\n\t\tkdb_printf(\"due to %s @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   reason == KDB_REASON_BREAK ?\n\t\t\t   \"Breakpoint\" : \"SS trap\", instruction_pointer(regs));\n\t\t/*\n\t\t * Determine if this breakpoint is one that we\n\t\t * are interested in.\n\t\t */\n\t\tif (db_result != KDB_DB_BPT) {\n\t\t\tkdb_printf(\"kdb: error return from kdba_bp_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 6\", reason);\n\t\t\treturn 0;\t/* Not for us, dismiss it */\n\t\t}\n\t\tbreak;\n\tcase KDB_REASON_RECURSE:\n\t\tkdb_printf(\"due to Recursion @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tdefault:\n\t\tkdb_printf(\"kdb: unexpected reason code: %d\\n\", reason);\n\t\tKDB_DEBUG_STATE(\"kdb_local 8\", reason);\n\t\treturn 0;\t/* Not for us, dismiss it */\n\t}\n\n\twhile (1) {\n\t\t/*\n\t\t * Initialize pager context.\n\t\t */\n\t\tkdb_nextline = 1;\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t\tkdb_grepping_flag = 0;\n\t\t/* ensure the old search does not leak into '/' commands */\n\t\tkdb_grep_string[0] = '\\0';\n\n\t\tcmdbuf = cmd_cur;\n\t\t*cmdbuf = '\\0';\n\t\t*(cmd_hist[cmd_head]) = '\\0';\n\ndo_full_getstr:\n\t\t/* PROMPT can only be set if we have MEM_READ permission. */\n\t\tsnprintf(kdb_prompt_str, CMD_BUFLEN, kdbgetenv(\"PROMPT\"),\n\t\t\t raw_smp_processor_id());\n\t\tif (defcmd_in_progress)\n\t\t\tstrncat(kdb_prompt_str, \"[defcmd]\", CMD_BUFLEN);\n\n\t\t/*\n\t\t * Fetch command from keyboard\n\t\t */\n\t\tcmdbuf = kdb_getstr(cmdbuf, CMD_BUFLEN, kdb_prompt_str);\n\t\tif (*cmdbuf != '\\n') {\n\t\t\tif (*cmdbuf < 32) {\n\t\t\t\tif (cmdptr == cmd_head) {\n\t\t\t\t\tstrscpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\t\tCMD_BUFLEN);\n\t\t\t\t\t*(cmd_hist[cmd_head] +\n\t\t\t\t\t  strlen(cmd_hist[cmd_head])-1) = '\\0';\n\t\t\t\t}\n\t\t\t\tif (!handle_ctrl_cmd(cmdbuf))\n\t\t\t\t\t*(cmd_cur+strlen(cmd_cur)-1) = '\\0';\n\t\t\t\tcmdbuf = cmd_cur;\n\t\t\t\tgoto do_full_getstr;\n\t\t\t} else {\n\t\t\t\tstrscpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\tCMD_BUFLEN);\n\t\t\t}\n\n\t\t\tcmd_head = (cmd_head+1) % KDB_CMD_HISTORY_COUNT;\n\t\t\tif (cmd_head == cmd_tail)\n\t\t\t\tcmd_tail = (cmd_tail+1) % KDB_CMD_HISTORY_COUNT;\n\t\t}\n\n\t\tcmdptr = cmd_head;\n\t\tdiag = kdb_parse(cmdbuf);\n\t\tif (diag == KDB_NOTFOUND) {\n\t\t\tdrop_newline(cmdbuf);\n\t\t\tkdb_printf(\"Unknown kdb command: '%s'\\n\", cmdbuf);\n\t\t\tdiag = 0;\n\t\t}\n\t\tif (diag == KDB_CMD_GO\n\t\t || diag == KDB_CMD_CPU\n\t\t || diag == KDB_CMD_SS\n\t\t || diag == KDB_CMD_KGDB)\n\t\t\tbreak;\n\n\t\tif (diag)\n\t\t\tkdb_cmderror(diag);\n\t}\n\tKDB_DEBUG_STATE(\"kdb_local 9\", diag);\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "LEAVING"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_main_loop 2\"",
            "reason"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "SUPPRESS"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "KDB"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "KDB"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "HOLD_CPU"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_main_loop 1\"",
            "reason"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdb_main_loop(kdb_reason_t reason, kdb_reason_t reason2, int error,\n\t      kdb_dbtrap_t db_result, struct pt_regs *regs)\n{\n\tint result = 1;\n\t/* Stay in kdb() until 'go', 'ss[b]' or an error */\n\twhile (1) {\n\t\t/*\n\t\t * All processors except the one that is in control\n\t\t * will spin here.\n\t\t */\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 1\", reason);\n\t\twhile (KDB_STATE(HOLD_CPU)) {\n\t\t\t/* state KDB is turned off by kdb_cpu to see if the\n\t\t\t * other cpus are still live, each cpu in this loop\n\t\t\t * turns it back on.\n\t\t\t */\n\t\t\tif (!KDB_STATE(KDB))\n\t\t\t\tKDB_STATE_SET(KDB);\n\t\t}\n\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 2\", reason);\n\t\tif (KDB_STATE(LEAVING))\n\t\t\tbreak;\t/* Another cpu said 'go' */\n\t\t/* Still using kdb, this processor is in control */\n\t\tresult = kdb_local(reason2, error, regs, db_result);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 3\", result);\n\n\t\tif (result == KDB_CMD_CPU)\n\t\t\tbreak;\n\n\t\tif (result == KDB_CMD_SS) {\n\t\t\tKDB_STATE_SET(DOING_SS);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (result == KDB_CMD_KGDB) {\n\t\t\tif (!KDB_STATE(DOING_KGDB))\n\t\t\t\tkdb_printf(\"Entering please attach debugger \"\n\t\t\t\t\t   \"or use $D#44+ or $3#33\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (result && result != 1 && result != KDB_CMD_GO)\n\t\t\tkdb_printf(\"\\nUnexpected kdb_local return code %d\\n\",\n\t\t\t\t   result);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 4\", reason);\n\t\tbreak;\n\t}\n\tif (KDB_STATE(DOING_SS))\n\t\tKDB_STATE_CLEAR(SSBPT);\n\n\t/* Clean up any keyboard devices before leaving */\n\tkdb_kbd_cleanup_state();\n\n\treturn result;\n}"
  },
  {
    "function_name": "kdb_print_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1354-1359",
    "snippet": "void kdb_print_state(const char *text, int value)\n{\n\tkdb_printf(\"state: %s cpu %d value %d initial %d state %x\\n\",\n\t\t   text, raw_smp_processor_id(), value, kdb_initial_cpu,\n\t\t   kdb_state);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int kdb_initial_cpu = -1;",
      "int kdb_state;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"state: %s cpu %d value %d initial %d state %x\\n\"",
            "text",
            "raw_smp_processor_id()",
            "value",
            "kdb_initial_cpu",
            "kdb_state"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdb_initial_cpu = -1;\nint kdb_state;\n\nvoid kdb_print_state(const char *text, int value)\n{\n\tkdb_printf(\"state: %s cpu %d value %d initial %d state %x\\n\",\n\t\t   text, raw_smp_processor_id(), value, kdb_initial_cpu,\n\t\t   kdb_state);\n}"
  },
  {
    "function_name": "kdb_local",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1174-1344",
    "snippet": "static int kdb_local(kdb_reason_t reason, int error, struct pt_regs *regs,\n\t\t     kdb_dbtrap_t db_result)\n{\n\tchar *cmdbuf;\n\tint diag;\n\tstruct task_struct *kdb_current =\n\t\tkdb_curr_task(raw_smp_processor_id());\n\n\tKDB_DEBUG_STATE(\"kdb_local 1\", reason);\n\tkdb_go_count = 0;\n\tif (reason == KDB_REASON_DEBUG) {\n\t\t/* special case below */\n\t} else {\n\t\tkdb_printf(\"\\nEntering kdb (current=0x%px, pid %d) \",\n\t\t\t   kdb_current, kdb_current ? kdb_current->pid : 0);\n#if defined(CONFIG_SMP)\n\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t}\n\n\tswitch (reason) {\n\tcase KDB_REASON_DEBUG:\n\t{\n\t\t/*\n\t\t * If re-entering kdb after a single step\n\t\t * command, don't print the message.\n\t\t */\n\t\tswitch (db_result) {\n\t\tcase KDB_DB_BPT:\n\t\t\tkdb_printf(\"\\nEntering kdb (0x%px, pid %d) \",\n\t\t\t\t   kdb_current, kdb_current->pid);\n#if defined(CONFIG_SMP)\n\t\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t\t\tkdb_printf(\"due to Debug @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t\t   instruction_pointer(regs));\n\t\t\tbreak;\n\t\tcase KDB_DB_SS:\n\t\t\tbreak;\n\t\tcase KDB_DB_SSBPT:\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 4\", reason);\n\t\t\treturn 1;\t/* kdba_db_trap did the work */\n\t\tdefault:\n\t\t\tkdb_printf(\"kdb: Bad result from kdba_db_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\t\tbreak;\n\tcase KDB_REASON_ENTER:\n\t\tif (KDB_STATE(KEYBOARD))\n\t\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\telse\n\t\t\tkdb_printf(\"due to KDB_ENTER()\\n\");\n\t\tbreak;\n\tcase KDB_REASON_KEYBOARD:\n\t\tKDB_STATE_SET(KEYBOARD);\n\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\tbreak;\n\tcase KDB_REASON_ENTER_SLAVE:\n\t\t/* drop through, slaves only get released via cpu switch */\n\tcase KDB_REASON_SWITCH:\n\t\tkdb_printf(\"due to cpu switch\\n\");\n\t\tbreak;\n\tcase KDB_REASON_OOPS:\n\t\tkdb_printf(\"Oops: %s\\n\", kdb_diemsg);\n\t\tkdb_printf(\"due to oops @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tkdb_dumpregs(regs);\n\t\tbreak;\n\tcase KDB_REASON_SYSTEM_NMI:\n\t\tkdb_printf(\"due to System NonMaskable Interrupt\\n\");\n\t\tbreak;\n\tcase KDB_REASON_NMI:\n\t\tkdb_printf(\"due to NonMaskable Interrupt @ \"\n\t\t\t   kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tcase KDB_REASON_SSTEP:\n\tcase KDB_REASON_BREAK:\n\t\tkdb_printf(\"due to %s @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   reason == KDB_REASON_BREAK ?\n\t\t\t   \"Breakpoint\" : \"SS trap\", instruction_pointer(regs));\n\t\t/*\n\t\t * Determine if this breakpoint is one that we\n\t\t * are interested in.\n\t\t */\n\t\tif (db_result != KDB_DB_BPT) {\n\t\t\tkdb_printf(\"kdb: error return from kdba_bp_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 6\", reason);\n\t\t\treturn 0;\t/* Not for us, dismiss it */\n\t\t}\n\t\tbreak;\n\tcase KDB_REASON_RECURSE:\n\t\tkdb_printf(\"due to Recursion @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tdefault:\n\t\tkdb_printf(\"kdb: unexpected reason code: %d\\n\", reason);\n\t\tKDB_DEBUG_STATE(\"kdb_local 8\", reason);\n\t\treturn 0;\t/* Not for us, dismiss it */\n\t}\n\n\twhile (1) {\n\t\t/*\n\t\t * Initialize pager context.\n\t\t */\n\t\tkdb_nextline = 1;\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t\tkdb_grepping_flag = 0;\n\t\t/* ensure the old search does not leak into '/' commands */\n\t\tkdb_grep_string[0] = '\\0';\n\n\t\tcmdbuf = cmd_cur;\n\t\t*cmdbuf = '\\0';\n\t\t*(cmd_hist[cmd_head]) = '\\0';\n\ndo_full_getstr:\n\t\t/* PROMPT can only be set if we have MEM_READ permission. */\n\t\tsnprintf(kdb_prompt_str, CMD_BUFLEN, kdbgetenv(\"PROMPT\"),\n\t\t\t raw_smp_processor_id());\n\t\tif (defcmd_in_progress)\n\t\t\tstrncat(kdb_prompt_str, \"[defcmd]\", CMD_BUFLEN);\n\n\t\t/*\n\t\t * Fetch command from keyboard\n\t\t */\n\t\tcmdbuf = kdb_getstr(cmdbuf, CMD_BUFLEN, kdb_prompt_str);\n\t\tif (*cmdbuf != '\\n') {\n\t\t\tif (*cmdbuf < 32) {\n\t\t\t\tif (cmdptr == cmd_head) {\n\t\t\t\t\tstrscpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\t\tCMD_BUFLEN);\n\t\t\t\t\t*(cmd_hist[cmd_head] +\n\t\t\t\t\t  strlen(cmd_hist[cmd_head])-1) = '\\0';\n\t\t\t\t}\n\t\t\t\tif (!handle_ctrl_cmd(cmdbuf))\n\t\t\t\t\t*(cmd_cur+strlen(cmd_cur)-1) = '\\0';\n\t\t\t\tcmdbuf = cmd_cur;\n\t\t\t\tgoto do_full_getstr;\n\t\t\t} else {\n\t\t\t\tstrscpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\tCMD_BUFLEN);\n\t\t\t}\n\n\t\t\tcmd_head = (cmd_head+1) % KDB_CMD_HISTORY_COUNT;\n\t\t\tif (cmd_head == cmd_tail)\n\t\t\t\tcmd_tail = (cmd_tail+1) % KDB_CMD_HISTORY_COUNT;\n\t\t}\n\n\t\tcmdptr = cmd_head;\n\t\tdiag = kdb_parse(cmdbuf);\n\t\tif (diag == KDB_NOTFOUND) {\n\t\t\tdrop_newline(cmdbuf);\n\t\t\tkdb_printf(\"Unknown kdb command: '%s'\\n\", cmdbuf);\n\t\t\tdiag = 0;\n\t\t}\n\t\tif (diag == KDB_CMD_GO\n\t\t || diag == KDB_CMD_CPU\n\t\t || diag == KDB_CMD_SS\n\t\t || diag == KDB_CMD_KGDB)\n\t\t\tbreak;\n\n\t\tif (diag)\n\t\t\tkdb_cmderror(diag);\n\t}\n\tKDB_DEBUG_STATE(\"kdb_local 9\", diag);\n\treturn diag;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */",
      "#define KDB_CMD_HISTORY_COUNT\t32"
    ],
    "globals_used": [
      "char kdb_grep_string[KDB_GREP_STRLEN];",
      "int kdb_grepping_flag;",
      "int kdb_nextline = 1;",
      "const char *kdb_diemsg;",
      "static int kdb_go_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_local 9\"",
            "diag"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_cmderror",
          "args": [
            "diag"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_cmderror",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "625-642",
          "snippet": "static void kdb_cmderror(int diag)\n{\n\tint i;\n\n\tif (diag >= 0) {\n\t\tkdb_printf(\"no error detected (diagnostic is %d)\\n\", diag);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < __nkdb_err; i++) {\n\t\tif (kdbmsgs[i].km_diag == diag) {\n\t\t\tkdb_printf(\"diag: %d: %s\\n\", diag, kdbmsgs[i].km_msg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tkdb_printf(\"Unknown diag %d\\n\", -diag);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static kdbmsg_t kdbmsgs[] = {\n\tKDBMSG(NOTFOUND, \"Command Not Found\"),\n\tKDBMSG(ARGCOUNT, \"Improper argument count, see usage.\"),\n\tKDBMSG(BADWIDTH, \"Illegal value for BYTESPERWORD use 1, 2, 4 or 8, \"\n\t       \"8 is only allowed on 64 bit systems\"),\n\tKDBMSG(BADRADIX, \"Illegal value for RADIX use 8, 10 or 16\"),\n\tKDBMSG(NOTENV, \"Cannot find environment variable\"),\n\tKDBMSG(NOENVVALUE, \"Environment variable should have value\"),\n\tKDBMSG(NOTIMP, \"Command not implemented\"),\n\tKDBMSG(ENVFULL, \"Environment full\"),\n\tKDBMSG(ENVBUFFULL, \"Environment buffer full\"),\n\tKDBMSG(TOOMANYBPT, \"Too many breakpoints defined\"),\n#ifdef CONFIG_CPU_XSCALE\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than ibcr registers defined\"),\n#else\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than db registers defined\"),\n#endif\n\tKDBMSG(DUPBPT, \"Duplicate breakpoint address\"),\n\tKDBMSG(BPTNOTFOUND, \"Breakpoint not found\"),\n\tKDBMSG(BADMODE, \"Invalid IDMODE\"),\n\tKDBMSG(BADINT, \"Illegal numeric value\"),\n\tKDBMSG(INVADDRFMT, \"Invalid symbolic address format\"),\n\tKDBMSG(BADREG, \"Invalid register name\"),\n\tKDBMSG(BADCPUNUM, \"Invalid cpu number\"),\n\tKDBMSG(BADLENGTH, \"Invalid length field\"),\n\tKDBMSG(NOBP, \"No Breakpoint exists\"),\n\tKDBMSG(BADADDR, \"Invalid address\"),\n\tKDBMSG(NOPERM, \"Permission denied\"),\n};",
            "static const int __nkdb_err = ARRAY_SIZE(kdbmsgs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic kdbmsg_t kdbmsgs[] = {\n\tKDBMSG(NOTFOUND, \"Command Not Found\"),\n\tKDBMSG(ARGCOUNT, \"Improper argument count, see usage.\"),\n\tKDBMSG(BADWIDTH, \"Illegal value for BYTESPERWORD use 1, 2, 4 or 8, \"\n\t       \"8 is only allowed on 64 bit systems\"),\n\tKDBMSG(BADRADIX, \"Illegal value for RADIX use 8, 10 or 16\"),\n\tKDBMSG(NOTENV, \"Cannot find environment variable\"),\n\tKDBMSG(NOENVVALUE, \"Environment variable should have value\"),\n\tKDBMSG(NOTIMP, \"Command not implemented\"),\n\tKDBMSG(ENVFULL, \"Environment full\"),\n\tKDBMSG(ENVBUFFULL, \"Environment buffer full\"),\n\tKDBMSG(TOOMANYBPT, \"Too many breakpoints defined\"),\n#ifdef CONFIG_CPU_XSCALE\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than ibcr registers defined\"),\n#else\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than db registers defined\"),\n#endif\n\tKDBMSG(DUPBPT, \"Duplicate breakpoint address\"),\n\tKDBMSG(BPTNOTFOUND, \"Breakpoint not found\"),\n\tKDBMSG(BADMODE, \"Invalid IDMODE\"),\n\tKDBMSG(BADINT, \"Illegal numeric value\"),\n\tKDBMSG(INVADDRFMT, \"Invalid symbolic address format\"),\n\tKDBMSG(BADREG, \"Invalid register name\"),\n\tKDBMSG(BADCPUNUM, \"Invalid cpu number\"),\n\tKDBMSG(BADLENGTH, \"Invalid length field\"),\n\tKDBMSG(NOBP, \"No Breakpoint exists\"),\n\tKDBMSG(BADADDR, \"Invalid address\"),\n\tKDBMSG(NOPERM, \"Permission denied\"),\n};\nstatic const int __nkdb_err = ARRAY_SIZE(kdbmsgs);\n\nstatic void kdb_cmderror(int diag)\n{\n\tint i;\n\n\tif (diag >= 0) {\n\t\tkdb_printf(\"no error detected (diagnostic is %d)\\n\", diag);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < __nkdb_err; i++) {\n\t\tif (kdbmsgs[i].km_diag == diag) {\n\t\t\tkdb_printf(\"diag: %d: %s\\n\", diag, kdbmsgs[i].km_msg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tkdb_printf(\"Unknown diag %d\\n\", -diag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Unknown kdb command: '%s'\\n\"",
            "cmdbuf"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_newline",
          "args": [
            "cmdbuf"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "drop_newline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1145-1153",
          "snippet": "static void drop_newline(char *buf)\n{\n\tsize_t len = strlen(buf);\n\n\tif (len == 0)\n\t\treturn;\n\tif (*(buf + len - 1) == '\\n')\n\t\t*(buf + len - 1) = '\\0';\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void drop_newline(char *buf)\n{\n\tsize_t len = strlen(buf);\n\n\tif (len == 0)\n\t\treturn;\n\tif (*(buf + len - 1) == '\\n')\n\t\t*(buf + len - 1) = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_parse",
          "args": [
            "cmdbuf"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_parse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "915-1082",
          "snippet": "int kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t/*\n\t\t * If this command is allowed to be abbreviated,\n\t\t * check to see if this is it.\n\t\t */\n\t\tif (tp->minlen && (strlen(argv[0]) <= tp->minlen) &&\n\t\t    (strncmp(argv[0], tp->name, tp->minlen) == 0))\n\t\t\tbreak;\n\n\t\tif (strcmp(argv[0], tp->name) == 0)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t\tif (strncmp(argv[0], tp->name, strlen(tp->name)) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define MAXARGC\t20",
            "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */"
          ],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;",
            "static LIST_HEAD(kdb_cmds_head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define MAXARGC\t20\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\nstatic LIST_HEAD(kdb_cmds_head);\n\nint kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t/*\n\t\t * If this command is allowed to be abbreviated,\n\t\t * check to see if this is it.\n\t\t */\n\t\tif (tp->minlen && (strlen(argv[0]) <= tp->minlen) &&\n\t\t    (strncmp(argv[0], tp->name, tp->minlen) == 0))\n\t\t\tbreak;\n\n\t\tif (strcmp(argv[0], tp->name) == 0)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t\tif (strncmp(argv[0], tp->name, strlen(tp->name)) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "cmd_hist[cmd_head]",
            "cmd_cur",
            "CMD_BUFLEN"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd_cur"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_ctrl_cmd",
          "args": [
            "cmdbuf"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "handle_ctrl_cmd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1085-1107",
          "snippet": "static int handle_ctrl_cmd(char *cmd)\n{\n#define CTRL_P\t16\n#define CTRL_N\t14\n\n\t/* initial situation */\n\tif (cmd_head == cmd_tail)\n\t\treturn 0;\n\tswitch (*cmd) {\n\tcase CTRL_P:\n\t\tif (cmdptr != cmd_tail)\n\t\t\tcmdptr = (cmdptr + KDB_CMD_HISTORY_COUNT - 1) %\n\t\t\t\t KDB_CMD_HISTORY_COUNT;\n\t\tstrscpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\tcase CTRL_N:\n\t\tif (cmdptr != cmd_head)\n\t\t\tcmdptr = (cmdptr+1) % KDB_CMD_HISTORY_COUNT;\n\t\tstrscpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define CTRL_N\t14",
            "#define CTRL_P\t16",
            "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */",
            "#define KDB_CMD_HISTORY_COUNT\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define CTRL_N\t14\n#define CTRL_P\t16\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n#define KDB_CMD_HISTORY_COUNT\t32\n\nstatic int handle_ctrl_cmd(char *cmd)\n{\n#define CTRL_P\t16\n#define CTRL_N\t14\n\n\t/* initial situation */\n\tif (cmd_head == cmd_tail)\n\t\treturn 0;\n\tswitch (*cmd) {\n\tcase CTRL_P:\n\t\tif (cmdptr != cmd_tail)\n\t\t\tcmdptr = (cmdptr + KDB_CMD_HISTORY_COUNT - 1) %\n\t\t\t\t KDB_CMD_HISTORY_COUNT;\n\t\tstrscpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\tcase CTRL_N:\n\t\tif (cmdptr != cmd_head)\n\t\t\tcmdptr = (cmdptr+1) % KDB_CMD_HISTORY_COUNT;\n\t\tstrscpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "cmd_hist[cmd_head]",
            "cmd_cur",
            "CMD_BUFLEN"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getstr",
          "args": [
            "cmdbuf",
            "CMD_BUFLEN",
            "kdb_prompt_str"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getstr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "436-443",
          "snippet": "char *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrscpy(kdb_prompt_str, prompt, CMD_BUFLEN);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t/* Prompt and input resets line number */\n\treturn kdb_read(buffer, bufsize);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CMD_BUFLEN 256"
          ],
          "globals_used": [
            "char kdb_prompt_str[CMD_BUFLEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define CMD_BUFLEN 256\n\nchar kdb_prompt_str[CMD_BUFLEN];\n\nchar *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrscpy(kdb_prompt_str, prompt, CMD_BUFLEN);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t/* Prompt and input resets line number */\n\treturn kdb_read(buffer, bufsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "kdb_prompt_str",
            "\"[defcmd]\"",
            "CMD_BUFLEN"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "kdb_prompt_str",
            "CMD_BUFLEN",
            "kdbgetenv(\"PROMPT\")",
            "raw_smp_processor_id()"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetenv",
          "args": [
            "\"PROMPT\""
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetenv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "197-217",
          "snippet": "char *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nchar *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "SUPPRESS"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_local 8\"",
            "reason"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_local 6\"",
            "reason"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_dumpregs",
          "args": [
            "regs"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_dumpregs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1123-1132",
          "snippet": "static void kdb_dumpregs(struct pt_regs *regs)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tshow_regs(regs);\n\tkdb_trap_printk--;\n\tkdb_printf(\"\\n\");\n\tconsole_loglevel = old_lvl;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_dumpregs(struct pt_regs *regs)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tshow_regs(regs);\n\tkdb_trap_printk--;\n\tkdb_printf(\"\\n\");\n\tconsole_loglevel = old_lvl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "KEYBOARD"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "KEYBOARD"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_local 4\"",
            "reason"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_local 1\"",
            "reason"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_curr_task",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_curr_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "158-166",
          "snippet": "struct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n#define KDB_CMD_HISTORY_COUNT\t32\n\nchar kdb_grep_string[KDB_GREP_STRLEN];\nint kdb_grepping_flag;\nint kdb_nextline = 1;\nconst char *kdb_diemsg;\nstatic int kdb_go_count;\n\nstatic int kdb_local(kdb_reason_t reason, int error, struct pt_regs *regs,\n\t\t     kdb_dbtrap_t db_result)\n{\n\tchar *cmdbuf;\n\tint diag;\n\tstruct task_struct *kdb_current =\n\t\tkdb_curr_task(raw_smp_processor_id());\n\n\tKDB_DEBUG_STATE(\"kdb_local 1\", reason);\n\tkdb_go_count = 0;\n\tif (reason == KDB_REASON_DEBUG) {\n\t\t/* special case below */\n\t} else {\n\t\tkdb_printf(\"\\nEntering kdb (current=0x%px, pid %d) \",\n\t\t\t   kdb_current, kdb_current ? kdb_current->pid : 0);\n#if defined(CONFIG_SMP)\n\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t}\n\n\tswitch (reason) {\n\tcase KDB_REASON_DEBUG:\n\t{\n\t\t/*\n\t\t * If re-entering kdb after a single step\n\t\t * command, don't print the message.\n\t\t */\n\t\tswitch (db_result) {\n\t\tcase KDB_DB_BPT:\n\t\t\tkdb_printf(\"\\nEntering kdb (0x%px, pid %d) \",\n\t\t\t\t   kdb_current, kdb_current->pid);\n#if defined(CONFIG_SMP)\n\t\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t\t\tkdb_printf(\"due to Debug @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t\t   instruction_pointer(regs));\n\t\t\tbreak;\n\t\tcase KDB_DB_SS:\n\t\t\tbreak;\n\t\tcase KDB_DB_SSBPT:\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 4\", reason);\n\t\t\treturn 1;\t/* kdba_db_trap did the work */\n\t\tdefault:\n\t\t\tkdb_printf(\"kdb: Bad result from kdba_db_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\t\tbreak;\n\tcase KDB_REASON_ENTER:\n\t\tif (KDB_STATE(KEYBOARD))\n\t\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\telse\n\t\t\tkdb_printf(\"due to KDB_ENTER()\\n\");\n\t\tbreak;\n\tcase KDB_REASON_KEYBOARD:\n\t\tKDB_STATE_SET(KEYBOARD);\n\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\tbreak;\n\tcase KDB_REASON_ENTER_SLAVE:\n\t\t/* drop through, slaves only get released via cpu switch */\n\tcase KDB_REASON_SWITCH:\n\t\tkdb_printf(\"due to cpu switch\\n\");\n\t\tbreak;\n\tcase KDB_REASON_OOPS:\n\t\tkdb_printf(\"Oops: %s\\n\", kdb_diemsg);\n\t\tkdb_printf(\"due to oops @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tkdb_dumpregs(regs);\n\t\tbreak;\n\tcase KDB_REASON_SYSTEM_NMI:\n\t\tkdb_printf(\"due to System NonMaskable Interrupt\\n\");\n\t\tbreak;\n\tcase KDB_REASON_NMI:\n\t\tkdb_printf(\"due to NonMaskable Interrupt @ \"\n\t\t\t   kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tcase KDB_REASON_SSTEP:\n\tcase KDB_REASON_BREAK:\n\t\tkdb_printf(\"due to %s @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   reason == KDB_REASON_BREAK ?\n\t\t\t   \"Breakpoint\" : \"SS trap\", instruction_pointer(regs));\n\t\t/*\n\t\t * Determine if this breakpoint is one that we\n\t\t * are interested in.\n\t\t */\n\t\tif (db_result != KDB_DB_BPT) {\n\t\t\tkdb_printf(\"kdb: error return from kdba_bp_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 6\", reason);\n\t\t\treturn 0;\t/* Not for us, dismiss it */\n\t\t}\n\t\tbreak;\n\tcase KDB_REASON_RECURSE:\n\t\tkdb_printf(\"due to Recursion @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tdefault:\n\t\tkdb_printf(\"kdb: unexpected reason code: %d\\n\", reason);\n\t\tKDB_DEBUG_STATE(\"kdb_local 8\", reason);\n\t\treturn 0;\t/* Not for us, dismiss it */\n\t}\n\n\twhile (1) {\n\t\t/*\n\t\t * Initialize pager context.\n\t\t */\n\t\tkdb_nextline = 1;\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t\tkdb_grepping_flag = 0;\n\t\t/* ensure the old search does not leak into '/' commands */\n\t\tkdb_grep_string[0] = '\\0';\n\n\t\tcmdbuf = cmd_cur;\n\t\t*cmdbuf = '\\0';\n\t\t*(cmd_hist[cmd_head]) = '\\0';\n\ndo_full_getstr:\n\t\t/* PROMPT can only be set if we have MEM_READ permission. */\n\t\tsnprintf(kdb_prompt_str, CMD_BUFLEN, kdbgetenv(\"PROMPT\"),\n\t\t\t raw_smp_processor_id());\n\t\tif (defcmd_in_progress)\n\t\t\tstrncat(kdb_prompt_str, \"[defcmd]\", CMD_BUFLEN);\n\n\t\t/*\n\t\t * Fetch command from keyboard\n\t\t */\n\t\tcmdbuf = kdb_getstr(cmdbuf, CMD_BUFLEN, kdb_prompt_str);\n\t\tif (*cmdbuf != '\\n') {\n\t\t\tif (*cmdbuf < 32) {\n\t\t\t\tif (cmdptr == cmd_head) {\n\t\t\t\t\tstrscpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\t\tCMD_BUFLEN);\n\t\t\t\t\t*(cmd_hist[cmd_head] +\n\t\t\t\t\t  strlen(cmd_hist[cmd_head])-1) = '\\0';\n\t\t\t\t}\n\t\t\t\tif (!handle_ctrl_cmd(cmdbuf))\n\t\t\t\t\t*(cmd_cur+strlen(cmd_cur)-1) = '\\0';\n\t\t\t\tcmdbuf = cmd_cur;\n\t\t\t\tgoto do_full_getstr;\n\t\t\t} else {\n\t\t\t\tstrscpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\tCMD_BUFLEN);\n\t\t\t}\n\n\t\t\tcmd_head = (cmd_head+1) % KDB_CMD_HISTORY_COUNT;\n\t\t\tif (cmd_head == cmd_tail)\n\t\t\t\tcmd_tail = (cmd_tail+1) % KDB_CMD_HISTORY_COUNT;\n\t\t}\n\n\t\tcmdptr = cmd_head;\n\t\tdiag = kdb_parse(cmdbuf);\n\t\tif (diag == KDB_NOTFOUND) {\n\t\t\tdrop_newline(cmdbuf);\n\t\t\tkdb_printf(\"Unknown kdb command: '%s'\\n\", cmdbuf);\n\t\t\tdiag = 0;\n\t\t}\n\t\tif (diag == KDB_CMD_GO\n\t\t || diag == KDB_CMD_CPU\n\t\t || diag == KDB_CMD_SS\n\t\t || diag == KDB_CMD_KGDB)\n\t\t\tbreak;\n\n\t\tif (diag)\n\t\t\tkdb_cmderror(diag);\n\t}\n\tKDB_DEBUG_STATE(\"kdb_local 9\", diag);\n\treturn diag;\n}"
  },
  {
    "function_name": "drop_newline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1145-1153",
    "snippet": "static void drop_newline(char *buf)\n{\n\tsize_t len = strlen(buf);\n\n\tif (len == 0)\n\t\treturn;\n\tif (*(buf + len - 1) == '\\n')\n\t\t*(buf + len - 1) = '\\0';\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void drop_newline(char *buf)\n{\n\tsize_t len = strlen(buf);\n\n\tif (len == 0)\n\t\treturn;\n\tif (*(buf + len - 1) == '\\n')\n\t\t*(buf + len - 1) = '\\0';\n}"
  },
  {
    "function_name": "kdb_set_current_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1134-1143",
    "snippet": "static void kdb_set_current_task(struct task_struct *p)\n{\n\tkdb_current_task = p;\n\n\tif (kdb_task_has_cpu(p)) {\n\t\tkdb_current_regs = KDB_TSKREGS(kdb_process_cpu(p));\n\t\treturn;\n\t}\n\tkdb_current_regs = NULL;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct task_struct *kdb_current_task;",
      "struct pt_regs *kdb_current_regs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_TSKREGS",
          "args": [
            "kdb_process_cpu(p)"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_process_cpu",
          "args": [
            "p"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_task_has_cpu",
          "args": [
            "p"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_current_task;\nstruct pt_regs *kdb_current_regs;\n\nstatic void kdb_set_current_task(struct task_struct *p)\n{\n\tkdb_current_task = p;\n\n\tif (kdb_task_has_cpu(p)) {\n\t\tkdb_current_regs = KDB_TSKREGS(kdb_process_cpu(p));\n\t\treturn;\n\t}\n\tkdb_current_regs = NULL;\n}"
  },
  {
    "function_name": "kdb_dumpregs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1123-1132",
    "snippet": "static void kdb_dumpregs(struct pt_regs *regs)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tshow_regs(regs);\n\tkdb_trap_printk--;\n\tkdb_printf(\"\\n\");\n\tconsole_loglevel = old_lvl;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_regs",
          "args": [
            "regs"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_dumpregs(struct pt_regs *regs)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tshow_regs(regs);\n\tkdb_trap_printk--;\n\tkdb_printf(\"\\n\");\n\tconsole_loglevel = old_lvl;\n}"
  },
  {
    "function_name": "kdb_reboot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1113-1121",
    "snippet": "static int kdb_reboot(int argc, const char **argv)\n{\n\temergency_restart();\n\tkdb_printf(\"Hmm, kdb_reboot did not reboot, spinning here\\n\");\n\twhile (1)\n\t\tcpu_relax();\n\t/* NOTREACHED */\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Hmm, kdb_reboot did not reboot, spinning here\\n\""
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emergency_restart",
          "args": [],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "emergency_restart",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "66-70",
          "snippet": "void emergency_restart(void)\n{\n\tkmsg_dump(KMSG_DUMP_EMERG);\n\tmachine_emergency_restart();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid emergency_restart(void)\n{\n\tkmsg_dump(KMSG_DUMP_EMERG);\n\tmachine_emergency_restart();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_reboot(int argc, const char **argv)\n{\n\temergency_restart();\n\tkdb_printf(\"Hmm, kdb_reboot did not reboot, spinning here\\n\");\n\twhile (1)\n\t\tcpu_relax();\n\t/* NOTREACHED */\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_ctrl_cmd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1085-1107",
    "snippet": "static int handle_ctrl_cmd(char *cmd)\n{\n#define CTRL_P\t16\n#define CTRL_N\t14\n\n\t/* initial situation */\n\tif (cmd_head == cmd_tail)\n\t\treturn 0;\n\tswitch (*cmd) {\n\tcase CTRL_P:\n\t\tif (cmdptr != cmd_tail)\n\t\t\tcmdptr = (cmdptr + KDB_CMD_HISTORY_COUNT - 1) %\n\t\t\t\t KDB_CMD_HISTORY_COUNT;\n\t\tstrscpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\tcase CTRL_N:\n\t\tif (cmdptr != cmd_head)\n\t\t\tcmdptr = (cmdptr+1) % KDB_CMD_HISTORY_COUNT;\n\t\tstrscpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define CTRL_N\t14",
      "#define CTRL_P\t16",
      "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */",
      "#define KDB_CMD_HISTORY_COUNT\t32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "cmd_cur",
            "cmd_hist[cmdptr]",
            "CMD_BUFLEN"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "cmd_cur",
            "cmd_hist[cmdptr]",
            "CMD_BUFLEN"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define CTRL_N\t14\n#define CTRL_P\t16\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n#define KDB_CMD_HISTORY_COUNT\t32\n\nstatic int handle_ctrl_cmd(char *cmd)\n{\n#define CTRL_P\t16\n#define CTRL_N\t14\n\n\t/* initial situation */\n\tif (cmd_head == cmd_tail)\n\t\treturn 0;\n\tswitch (*cmd) {\n\tcase CTRL_P:\n\t\tif (cmdptr != cmd_tail)\n\t\t\tcmdptr = (cmdptr + KDB_CMD_HISTORY_COUNT - 1) %\n\t\t\t\t KDB_CMD_HISTORY_COUNT;\n\t\tstrscpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\tcase CTRL_N:\n\t\tif (cmdptr != cmd_head)\n\t\t\tcmdptr = (cmdptr+1) % KDB_CMD_HISTORY_COUNT;\n\t\tstrscpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_parse",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "915-1082",
    "snippet": "int kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t/*\n\t\t * If this command is allowed to be abbreviated,\n\t\t * check to see if this is it.\n\t\t */\n\t\tif (tp->minlen && (strlen(argv[0]) <= tp->minlen) &&\n\t\t    (strncmp(argv[0], tp->name, tp->minlen) == 0))\n\t\t\tbreak;\n\n\t\tif (strcmp(argv[0], tp->name) == 0)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t\tif (strncmp(argv[0], tp->name, strlen(tp->name)) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define MAXARGC\t20",
      "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */"
    ],
    "globals_used": [
      "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;",
      "static LIST_HEAD(kdb_cmds_head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_symbol_print",
          "args": [
            "value",
            "NULL",
            "KDB_SP_DEFAULT"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_symbol_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "199-235",
          "snippet": "void kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nvoid kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetaddrarg",
          "args": [
            "0",
            "(const char **)argv",
            "&nextarg",
            "&value",
            "&offset",
            "&name"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetaddrarg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "491-623",
          "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "CMD"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "argc-1",
            "(const char **)argv"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "CMD"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_check_flags",
          "args": [
            "tp->flags",
            "kdb_cmd_enabled",
            "argc <= 1"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_check_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "172-186",
          "snippet": "static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry_is_head",
          "args": [
            "tp",
            "&kdb_cmds_head",
            "list_node"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[0]",
            "tp->name",
            "strlen(tp->name)"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tp->name"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tp",
            "&kdb_cmds_head",
            "list_node"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_is_head",
          "args": [
            "tp",
            "&kdb_cmds_head",
            "list_node"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "tp->name"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[0]",
            "tp->name",
            "tp->minlen"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tp",
            "&kdb_cmds_head",
            "list_node"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_defcmd2",
          "args": [
            "cmdstr",
            "argv[0]"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_defcmd2",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "672-697",
          "snippet": "static int kdb_defcmd2(const char *cmdstr, const char *argv0)\n{\n\tstruct kdb_macro_statement *kms;\n\n\tif (!kdb_macro)\n\t\treturn KDB_NOTIMP;\n\n\tif (strcmp(argv0, \"endefcmd\") == 0) {\n\t\tdefcmd_in_progress = false;\n\t\tif (!list_empty(&kdb_macro->statements))\n\t\t\tkdb_register(&kdb_macro->cmd);\n\t\treturn 0;\n\t}\n\n\tkms = kmalloc(sizeof(*kms), GFP_KDB);\n\tif (!kms) {\n\t\tkdb_printf(\"Could not allocate new kdb macro command: %s\\n\",\n\t\t\t   cmdstr);\n\t\treturn KDB_NOTIMP;\n\t}\n\n\tkms->statement = kdb_strdup(cmdstr, GFP_KDB);\n\tlist_add_tail(&kms->list_node, &kdb_macro->statements);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_defcmd2(const char *cmdstr, const char *argv0)\n{\n\tstruct kdb_macro_statement *kms;\n\n\tif (!kdb_macro)\n\t\treturn KDB_NOTIMP;\n\n\tif (strcmp(argv0, \"endefcmd\") == 0) {\n\t\tdefcmd_in_progress = false;\n\t\tif (!list_empty(&kdb_macro->statements))\n\t\t\tkdb_register(&kdb_macro->cmd);\n\t\treturn 0;\n\t}\n\n\tkms = kmalloc(sizeof(*kms), GFP_KDB);\n\tif (!kms) {\n\t\tkdb_printf(\"Could not allocate new kdb macro command: %s\\n\",\n\t\t\t   cmdstr);\n\t\treturn KDB_NOTIMP;\n\t}\n\n\tkms->statement = kdb_strdup(cmdstr, GFP_KDB);\n\tlist_add_tail(&kms->list_node, &kdb_macro->statements);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_grep",
          "args": [
            "cp"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "parse_grep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "826-885",
          "snippet": "static void parse_grep(const char *str)\n{\n\tint\tlen;\n\tchar\t*cp = (char *)str, *cp2;\n\n\t/* sanity check: we should have been called with the \\ first */\n\tif (*cp != '|')\n\t\treturn;\n\tcp++;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tif (!str_has_prefix(cp, \"grep \")) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\tcp += 5;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tcp2 = strchr(cp, '\\n');\n\tif (cp2)\n\t\t*cp2 = '\\0'; /* remove the trailing newline */\n\tlen = strlen(cp);\n\tif (len == 0) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\t/* now cp points to a nonzero length search string */\n\tif (*cp == '\"') {\n\t\t/* allow it be \"x y z\" by removing the \"'s - there must\n\t\t   be two of them */\n\t\tcp++;\n\t\tcp2 = strchr(cp, '\"');\n\t\tif (!cp2) {\n\t\t\tkdb_printf(\"invalid quoted string, see grephelp\\n\");\n\t\t\treturn;\n\t\t}\n\t\t*cp2 = '\\0'; /* end the string where the 2nd \" was */\n\t}\n\tkdb_grep_leading = 0;\n\tif (*cp == '^') {\n\t\tkdb_grep_leading = 1;\n\t\tcp++;\n\t}\n\tlen = strlen(cp);\n\tkdb_grep_trailing = 0;\n\tif (*(cp+len-1) == '$') {\n\t\tkdb_grep_trailing = 1;\n\t\t*(cp+len-1) = '\\0';\n\t}\n\tlen = strlen(cp);\n\tif (!len)\n\t\treturn;\n\tif (len >= KDB_GREP_STRLEN) {\n\t\tkdb_printf(\"search string too long\\n\");\n\t\treturn;\n\t}\n\tstrcpy(kdb_grep_string, cp);\n\tkdb_grepping_flag++;\n\treturn;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char kdb_grep_string[KDB_GREP_STRLEN];",
            "int kdb_grepping_flag;",
            "int kdb_grep_leading;",
            "int kdb_grep_trailing;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nchar kdb_grep_string[KDB_GREP_STRLEN];\nint kdb_grepping_flag;\nint kdb_grep_leading;\nint kdb_grep_trailing;\n\nstatic void parse_grep(const char *str)\n{\n\tint\tlen;\n\tchar\t*cp = (char *)str, *cp2;\n\n\t/* sanity check: we should have been called with the \\ first */\n\tif (*cp != '|')\n\t\treturn;\n\tcp++;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tif (!str_has_prefix(cp, \"grep \")) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\tcp += 5;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tcp2 = strchr(cp, '\\n');\n\tif (cp2)\n\t\t*cp2 = '\\0'; /* remove the trailing newline */\n\tlen = strlen(cp);\n\tif (len == 0) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\t/* now cp points to a nonzero length search string */\n\tif (*cp == '\"') {\n\t\t/* allow it be \"x y z\" by removing the \"'s - there must\n\t\t   be two of them */\n\t\tcp++;\n\t\tcp2 = strchr(cp, '\"');\n\t\tif (!cp2) {\n\t\t\tkdb_printf(\"invalid quoted string, see grephelp\\n\");\n\t\t\treturn;\n\t\t}\n\t\t*cp2 = '\\0'; /* end the string where the 2nd \" was */\n\t}\n\tkdb_grep_leading = 0;\n\tif (*cp == '^') {\n\t\tkdb_grep_leading = 1;\n\t\tcp++;\n\t}\n\tlen = strlen(cp);\n\tkdb_grep_trailing = 0;\n\tif (*(cp+len-1) == '$') {\n\t\tkdb_grep_trailing = 1;\n\t\t*(cp+len-1) = '\\0';\n\t}\n\tlen = strlen(cp);\n\tif (!len)\n\t\treturn;\n\tif (len >= KDB_GREP_STRLEN) {\n\t\tkdb_printf(\"search string too long\\n\");\n\t\treturn;\n\t}\n\tstrcpy(kdb_grep_string, cp);\n\tkdb_grepping_flag++;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*cp"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*cp"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "PAGER"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_FLAG_CLEAR",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define MAXARGC\t20\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\nstatic LIST_HEAD(kdb_cmds_head);\n\nint kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t/*\n\t\t * If this command is allowed to be abbreviated,\n\t\t * check to see if this is it.\n\t\t */\n\t\tif (tp->minlen && (strlen(argv[0]) <= tp->minlen) &&\n\t\t    (strncmp(argv[0], tp->name, tp->minlen) == 0))\n\t\t\tbreak;\n\n\t\tif (strcmp(argv[0], tp->name) == 0)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t\tif (strncmp(argv[0], tp->name, strlen(tp->name)) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "parse_grep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "826-885",
    "snippet": "static void parse_grep(const char *str)\n{\n\tint\tlen;\n\tchar\t*cp = (char *)str, *cp2;\n\n\t/* sanity check: we should have been called with the \\ first */\n\tif (*cp != '|')\n\t\treturn;\n\tcp++;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tif (!str_has_prefix(cp, \"grep \")) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\tcp += 5;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tcp2 = strchr(cp, '\\n');\n\tif (cp2)\n\t\t*cp2 = '\\0'; /* remove the trailing newline */\n\tlen = strlen(cp);\n\tif (len == 0) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\t/* now cp points to a nonzero length search string */\n\tif (*cp == '\"') {\n\t\t/* allow it be \"x y z\" by removing the \"'s - there must\n\t\t   be two of them */\n\t\tcp++;\n\t\tcp2 = strchr(cp, '\"');\n\t\tif (!cp2) {\n\t\t\tkdb_printf(\"invalid quoted string, see grephelp\\n\");\n\t\t\treturn;\n\t\t}\n\t\t*cp2 = '\\0'; /* end the string where the 2nd \" was */\n\t}\n\tkdb_grep_leading = 0;\n\tif (*cp == '^') {\n\t\tkdb_grep_leading = 1;\n\t\tcp++;\n\t}\n\tlen = strlen(cp);\n\tkdb_grep_trailing = 0;\n\tif (*(cp+len-1) == '$') {\n\t\tkdb_grep_trailing = 1;\n\t\t*(cp+len-1) = '\\0';\n\t}\n\tlen = strlen(cp);\n\tif (!len)\n\t\treturn;\n\tif (len >= KDB_GREP_STRLEN) {\n\t\tkdb_printf(\"search string too long\\n\");\n\t\treturn;\n\t}\n\tstrcpy(kdb_grep_string, cp);\n\tkdb_grepping_flag++;\n\treturn;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char kdb_grep_string[KDB_GREP_STRLEN];",
      "int kdb_grepping_flag;",
      "int kdb_grep_leading;",
      "int kdb_grep_trailing;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "kdb_grep_string",
            "cp"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"search string too long\\n\""
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp",
            "'\"'"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp",
            "'\\n'"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*cp"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "cp",
            "\"grep \""
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*cp"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nchar kdb_grep_string[KDB_GREP_STRLEN];\nint kdb_grepping_flag;\nint kdb_grep_leading;\nint kdb_grep_trailing;\n\nstatic void parse_grep(const char *str)\n{\n\tint\tlen;\n\tchar\t*cp = (char *)str, *cp2;\n\n\t/* sanity check: we should have been called with the \\ first */\n\tif (*cp != '|')\n\t\treturn;\n\tcp++;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tif (!str_has_prefix(cp, \"grep \")) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\tcp += 5;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tcp2 = strchr(cp, '\\n');\n\tif (cp2)\n\t\t*cp2 = '\\0'; /* remove the trailing newline */\n\tlen = strlen(cp);\n\tif (len == 0) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\t/* now cp points to a nonzero length search string */\n\tif (*cp == '\"') {\n\t\t/* allow it be \"x y z\" by removing the \"'s - there must\n\t\t   be two of them */\n\t\tcp++;\n\t\tcp2 = strchr(cp, '\"');\n\t\tif (!cp2) {\n\t\t\tkdb_printf(\"invalid quoted string, see grephelp\\n\");\n\t\t\treturn;\n\t\t}\n\t\t*cp2 = '\\0'; /* end the string where the 2nd \" was */\n\t}\n\tkdb_grep_leading = 0;\n\tif (*cp == '^') {\n\t\tkdb_grep_leading = 1;\n\t\tcp++;\n\t}\n\tlen = strlen(cp);\n\tkdb_grep_trailing = 0;\n\tif (*(cp+len-1) == '$') {\n\t\tkdb_grep_trailing = 1;\n\t\t*(cp+len-1) = '\\0';\n\t}\n\tlen = strlen(cp);\n\tif (!len)\n\t\treturn;\n\tif (len >= KDB_GREP_STRLEN) {\n\t\tkdb_printf(\"search string too long\\n\");\n\t\treturn;\n\t}\n\tstrcpy(kdb_grep_string, cp);\n\tkdb_grepping_flag++;\n\treturn;\n}"
  },
  {
    "function_name": "kdb_exec_defcmd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "781-812",
    "snippet": "static int kdb_exec_defcmd(int argc, const char **argv)\n{\n\tint ret;\n\tkdbtab_t *kp;\n\tstruct kdb_macro *kmp;\n\tstruct kdb_macro_statement *kms;\n\n\tif (argc != 0)\n\t\treturn KDB_ARGCOUNT;\n\n\tlist_for_each_entry(kp, &kdb_cmds_head, list_node) {\n\t\tif (strcmp(kp->name, argv[0]) == 0)\n\t\t\tbreak;\n\t}\n\tif (list_entry_is_head(kp, &kdb_cmds_head, list_node)) {\n\t\tkdb_printf(\"kdb_exec_defcmd: could not find commands for %s\\n\",\n\t\t\t   argv[0]);\n\t\treturn KDB_NOTIMP;\n\t}\n\tkmp = container_of(kp, struct kdb_macro, cmd);\n\tlist_for_each_entry(kms, &kmp->statements, list_node) {\n\t\t/*\n\t\t * Recursive use of kdb_parse, do not use argv after this point.\n\t\t */\n\t\targv = NULL;\n\t\tkdb_printf(\"[%s]kdb> %s\\n\", kmp->cmd.name, kms->statement);\n\t\tret = kdb_parse(kms->statement);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(kdb_cmds_head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_parse",
          "args": [
            "kms->statement"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_parse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "915-1082",
          "snippet": "int kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t/*\n\t\t * If this command is allowed to be abbreviated,\n\t\t * check to see if this is it.\n\t\t */\n\t\tif (tp->minlen && (strlen(argv[0]) <= tp->minlen) &&\n\t\t    (strncmp(argv[0], tp->name, tp->minlen) == 0))\n\t\t\tbreak;\n\n\t\tif (strcmp(argv[0], tp->name) == 0)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t\tif (strncmp(argv[0], tp->name, strlen(tp->name)) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define MAXARGC\t20",
            "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */"
          ],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;",
            "static LIST_HEAD(kdb_cmds_head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define MAXARGC\t20\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\nstatic LIST_HEAD(kdb_cmds_head);\n\nint kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t/*\n\t\t * If this command is allowed to be abbreviated,\n\t\t * check to see if this is it.\n\t\t */\n\t\tif (tp->minlen && (strlen(argv[0]) <= tp->minlen) &&\n\t\t    (strncmp(argv[0], tp->name, tp->minlen) == 0))\n\t\t\tbreak;\n\n\t\tif (strcmp(argv[0], tp->name) == 0)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t\tif (strncmp(argv[0], tp->name, strlen(tp->name)) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"[%s]kdb> %s\\n\"",
            "kmp->cmd.name",
            "kms->statement"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kms",
            "&kmp->statements",
            "list_node"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kp",
            "structkdb_macro",
            "cmd"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_is_head",
          "args": [
            "kp",
            "&kdb_cmds_head",
            "list_node"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "kp->name",
            "argv[0]"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kp",
            "&kdb_cmds_head",
            "list_node"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic LIST_HEAD(kdb_cmds_head);\n\nstatic int kdb_exec_defcmd(int argc, const char **argv)\n{\n\tint ret;\n\tkdbtab_t *kp;\n\tstruct kdb_macro *kmp;\n\tstruct kdb_macro_statement *kms;\n\n\tif (argc != 0)\n\t\treturn KDB_ARGCOUNT;\n\n\tlist_for_each_entry(kp, &kdb_cmds_head, list_node) {\n\t\tif (strcmp(kp->name, argv[0]) == 0)\n\t\t\tbreak;\n\t}\n\tif (list_entry_is_head(kp, &kdb_cmds_head, list_node)) {\n\t\tkdb_printf(\"kdb_exec_defcmd: could not find commands for %s\\n\",\n\t\t\t   argv[0]);\n\t\treturn KDB_NOTIMP;\n\t}\n\tkmp = container_of(kp, struct kdb_macro, cmd);\n\tlist_for_each_entry(kms, &kmp->statements, list_node) {\n\t\t/*\n\t\t * Recursive use of kdb_parse, do not use argv after this point.\n\t\t */\n\t\targv = NULL;\n\t\tkdb_printf(\"[%s]kdb> %s\\n\", kmp->cmd.name, kms->statement);\n\t\tret = kdb_parse(kms->statement);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_defcmd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "699-770",
    "snippet": "static int kdb_defcmd(int argc, const char **argv)\n{\n\tkdbtab_t *mp;\n\n\tif (defcmd_in_progress) {\n\t\tkdb_printf(\"kdb: nested defcmd detected, assuming missing \"\n\t\t\t   \"endefcmd\\n\");\n\t\tkdb_defcmd2(\"endefcmd\", \"endefcmd\");\n\t}\n\tif (argc == 0) {\n\t\tkdbtab_t *kp;\n\t\tstruct kdb_macro *kmp;\n\t\tstruct kdb_macro_statement *kms;\n\n\t\tlist_for_each_entry(kp, &kdb_cmds_head, list_node) {\n\t\t\tif (kp->func == kdb_exec_defcmd) {\n\t\t\t\tkdb_printf(\"defcmd %s \\\"%s\\\" \\\"%s\\\"\\n\",\n\t\t\t\t\t   kp->name, kp->usage, kp->help);\n\t\t\t\tkmp = container_of(kp, struct kdb_macro, cmd);\n\t\t\t\tlist_for_each_entry(kms, &kmp->statements,\n\t\t\t\t\t\t    list_node)\n\t\t\t\t\tkdb_printf(\"%s\", kms->statement);\n\t\t\t\tkdb_printf(\"endefcmd\\n\");\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tif (argc != 3)\n\t\treturn KDB_ARGCOUNT;\n\tif (in_dbg_master()) {\n\t\tkdb_printf(\"Command only available during kdb_init()\\n\");\n\t\treturn KDB_NOTIMP;\n\t}\n\tkdb_macro = kzalloc(sizeof(*kdb_macro), GFP_KDB);\n\tif (!kdb_macro)\n\t\tgoto fail_defcmd;\n\n\tmp = &kdb_macro->cmd;\n\tmp->func = kdb_exec_defcmd;\n\tmp->minlen = 0;\n\tmp->flags = KDB_ENABLE_ALWAYS_SAFE;\n\tmp->name = kdb_strdup(argv[1], GFP_KDB);\n\tif (!mp->name)\n\t\tgoto fail_name;\n\tmp->usage = kdb_strdup(argv[2], GFP_KDB);\n\tif (!mp->usage)\n\t\tgoto fail_usage;\n\tmp->help = kdb_strdup(argv[3], GFP_KDB);\n\tif (!mp->help)\n\t\tgoto fail_help;\n\tif (mp->usage[0] == '\"') {\n\t\tstrcpy(mp->usage, argv[2]+1);\n\t\tmp->usage[strlen(mp->usage)-1] = '\\0';\n\t}\n\tif (mp->help[0] == '\"') {\n\t\tstrcpy(mp->help, argv[3]+1);\n\t\tmp->help[strlen(mp->help)-1] = '\\0';\n\t}\n\n\tINIT_LIST_HEAD(&kdb_macro->statements);\n\tdefcmd_in_progress = true;\n\treturn 0;\nfail_help:\n\tkfree(mp->usage);\nfail_usage:\n\tkfree(mp->name);\nfail_name:\n\tkfree(kdb_macro);\nfail_defcmd:\n\tkdb_printf(\"Could not allocate new kdb_macro entry for %s\\n\", argv[1]);\n\treturn KDB_NOTIMP;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(kdb_cmds_head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Could not allocate new kdb_macro entry for %s\\n\"",
            "argv[1]"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kdb_macro"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&kdb_macro->statements"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mp->help"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "mp->help",
            "argv[3]+1"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "mp->usage",
            "argv[2]+1"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_strdup",
          "args": [
            "argv[3]",
            "GFP_KDB"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_strdup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "248-255",
          "snippet": "char *kdb_strdup(const char *str, gfp_t type)\n{\n\tint n = strlen(str)+1;\n\tchar *s = kmalloc(n, type);\n\tif (!s)\n\t\treturn NULL;\n\treturn strcpy(s, str);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nchar *kdb_strdup(const char *str, gfp_t type)\n{\n\tint n = strlen(str)+1;\n\tchar *s = kmalloc(n, type);\n\tif (!s)\n\t\treturn NULL;\n\treturn strcpy(s, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*kdb_macro)",
            "GFP_KDB"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_dbg_master",
          "args": [],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kms",
            "&kmp->statements",
            "list_node"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kp",
            "structkdb_macro",
            "cmd"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kp",
            "&kdb_cmds_head",
            "list_node"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_defcmd2",
          "args": [
            "\"endefcmd\"",
            "\"endefcmd\""
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_defcmd2",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "672-697",
          "snippet": "static int kdb_defcmd2(const char *cmdstr, const char *argv0)\n{\n\tstruct kdb_macro_statement *kms;\n\n\tif (!kdb_macro)\n\t\treturn KDB_NOTIMP;\n\n\tif (strcmp(argv0, \"endefcmd\") == 0) {\n\t\tdefcmd_in_progress = false;\n\t\tif (!list_empty(&kdb_macro->statements))\n\t\t\tkdb_register(&kdb_macro->cmd);\n\t\treturn 0;\n\t}\n\n\tkms = kmalloc(sizeof(*kms), GFP_KDB);\n\tif (!kms) {\n\t\tkdb_printf(\"Could not allocate new kdb macro command: %s\\n\",\n\t\t\t   cmdstr);\n\t\treturn KDB_NOTIMP;\n\t}\n\n\tkms->statement = kdb_strdup(cmdstr, GFP_KDB);\n\tlist_add_tail(&kms->list_node, &kdb_macro->statements);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_defcmd2(const char *cmdstr, const char *argv0)\n{\n\tstruct kdb_macro_statement *kms;\n\n\tif (!kdb_macro)\n\t\treturn KDB_NOTIMP;\n\n\tif (strcmp(argv0, \"endefcmd\") == 0) {\n\t\tdefcmd_in_progress = false;\n\t\tif (!list_empty(&kdb_macro->statements))\n\t\t\tkdb_register(&kdb_macro->cmd);\n\t\treturn 0;\n\t}\n\n\tkms = kmalloc(sizeof(*kms), GFP_KDB);\n\tif (!kms) {\n\t\tkdb_printf(\"Could not allocate new kdb macro command: %s\\n\",\n\t\t\t   cmdstr);\n\t\treturn KDB_NOTIMP;\n\t}\n\n\tkms->statement = kdb_strdup(cmdstr, GFP_KDB);\n\tlist_add_tail(&kms->list_node, &kdb_macro->statements);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic LIST_HEAD(kdb_cmds_head);\n\nstatic int kdb_defcmd(int argc, const char **argv)\n{\n\tkdbtab_t *mp;\n\n\tif (defcmd_in_progress) {\n\t\tkdb_printf(\"kdb: nested defcmd detected, assuming missing \"\n\t\t\t   \"endefcmd\\n\");\n\t\tkdb_defcmd2(\"endefcmd\", \"endefcmd\");\n\t}\n\tif (argc == 0) {\n\t\tkdbtab_t *kp;\n\t\tstruct kdb_macro *kmp;\n\t\tstruct kdb_macro_statement *kms;\n\n\t\tlist_for_each_entry(kp, &kdb_cmds_head, list_node) {\n\t\t\tif (kp->func == kdb_exec_defcmd) {\n\t\t\t\tkdb_printf(\"defcmd %s \\\"%s\\\" \\\"%s\\\"\\n\",\n\t\t\t\t\t   kp->name, kp->usage, kp->help);\n\t\t\t\tkmp = container_of(kp, struct kdb_macro, cmd);\n\t\t\t\tlist_for_each_entry(kms, &kmp->statements,\n\t\t\t\t\t\t    list_node)\n\t\t\t\t\tkdb_printf(\"%s\", kms->statement);\n\t\t\t\tkdb_printf(\"endefcmd\\n\");\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tif (argc != 3)\n\t\treturn KDB_ARGCOUNT;\n\tif (in_dbg_master()) {\n\t\tkdb_printf(\"Command only available during kdb_init()\\n\");\n\t\treturn KDB_NOTIMP;\n\t}\n\tkdb_macro = kzalloc(sizeof(*kdb_macro), GFP_KDB);\n\tif (!kdb_macro)\n\t\tgoto fail_defcmd;\n\n\tmp = &kdb_macro->cmd;\n\tmp->func = kdb_exec_defcmd;\n\tmp->minlen = 0;\n\tmp->flags = KDB_ENABLE_ALWAYS_SAFE;\n\tmp->name = kdb_strdup(argv[1], GFP_KDB);\n\tif (!mp->name)\n\t\tgoto fail_name;\n\tmp->usage = kdb_strdup(argv[2], GFP_KDB);\n\tif (!mp->usage)\n\t\tgoto fail_usage;\n\tmp->help = kdb_strdup(argv[3], GFP_KDB);\n\tif (!mp->help)\n\t\tgoto fail_help;\n\tif (mp->usage[0] == '\"') {\n\t\tstrcpy(mp->usage, argv[2]+1);\n\t\tmp->usage[strlen(mp->usage)-1] = '\\0';\n\t}\n\tif (mp->help[0] == '\"') {\n\t\tstrcpy(mp->help, argv[3]+1);\n\t\tmp->help[strlen(mp->help)-1] = '\\0';\n\t}\n\n\tINIT_LIST_HEAD(&kdb_macro->statements);\n\tdefcmd_in_progress = true;\n\treturn 0;\nfail_help:\n\tkfree(mp->usage);\nfail_usage:\n\tkfree(mp->name);\nfail_name:\n\tkfree(kdb_macro);\nfail_defcmd:\n\tkdb_printf(\"Could not allocate new kdb_macro entry for %s\\n\", argv[1]);\n\treturn KDB_NOTIMP;\n}"
  },
  {
    "function_name": "kdb_defcmd2",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "672-697",
    "snippet": "static int kdb_defcmd2(const char *cmdstr, const char *argv0)\n{\n\tstruct kdb_macro_statement *kms;\n\n\tif (!kdb_macro)\n\t\treturn KDB_NOTIMP;\n\n\tif (strcmp(argv0, \"endefcmd\") == 0) {\n\t\tdefcmd_in_progress = false;\n\t\tif (!list_empty(&kdb_macro->statements))\n\t\t\tkdb_register(&kdb_macro->cmd);\n\t\treturn 0;\n\t}\n\n\tkms = kmalloc(sizeof(*kms), GFP_KDB);\n\tif (!kms) {\n\t\tkdb_printf(\"Could not allocate new kdb macro command: %s\\n\",\n\t\t\t   cmdstr);\n\t\treturn KDB_NOTIMP;\n\t}\n\n\tkms->statement = kdb_strdup(cmdstr, GFP_KDB);\n\tlist_add_tail(&kms->list_node, &kdb_macro->statements);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&kms->list_node",
            "&kdb_macro->statements"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_strdup",
          "args": [
            "cmdstr",
            "GFP_KDB"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_strdup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "248-255",
          "snippet": "char *kdb_strdup(const char *str, gfp_t type)\n{\n\tint n = strlen(str)+1;\n\tchar *s = kmalloc(n, type);\n\tif (!s)\n\t\treturn NULL;\n\treturn strcpy(s, str);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nchar *kdb_strdup(const char *str, gfp_t type)\n{\n\tint n = strlen(str)+1;\n\tchar *s = kmalloc(n, type);\n\tif (!s)\n\t\treturn NULL;\n\treturn strcpy(s, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Could not allocate new kdb macro command: %s\\n\"",
            "cmdstr"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*kms)",
            "GFP_KDB"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_register",
          "args": [
            "&kdb_macro->cmd"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2630-2644",
          "snippet": "int kdb_register(kdbtab_t *cmd)\n{\n\tkdbtab_t *kp;\n\n\tlist_for_each_entry(kp, &kdb_cmds_head, list_node) {\n\t\tif (strcmp(kp->name, cmd->name) == 0) {\n\t\t\tkdb_printf(\"Duplicate kdb cmd: %s, func %p help %s\\n\",\n\t\t\t\t   cmd->name, cmd->func, cmd->help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tlist_add_tail(&cmd->list_node, &kdb_cmds_head);\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kdb_cmds_head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic LIST_HEAD(kdb_cmds_head);\n\nint kdb_register(kdbtab_t *cmd)\n{\n\tkdbtab_t *kp;\n\n\tlist_for_each_entry(kp, &kdb_cmds_head, list_node) {\n\t\tif (strcmp(kp->name, cmd->name) == 0) {\n\t\t\tkdb_printf(\"Duplicate kdb cmd: %s, func %p help %s\\n\",\n\t\t\t\t   cmd->name, cmd->func, cmd->help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tlist_add_tail(&cmd->list_node, &kdb_cmds_head);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&kdb_macro->statements"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv0",
            "\"endefcmd\""
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_defcmd2(const char *cmdstr, const char *argv0)\n{\n\tstruct kdb_macro_statement *kms;\n\n\tif (!kdb_macro)\n\t\treturn KDB_NOTIMP;\n\n\tif (strcmp(argv0, \"endefcmd\") == 0) {\n\t\tdefcmd_in_progress = false;\n\t\tif (!list_empty(&kdb_macro->statements))\n\t\t\tkdb_register(&kdb_macro->cmd);\n\t\treturn 0;\n\t}\n\n\tkms = kmalloc(sizeof(*kms), GFP_KDB);\n\tif (!kms) {\n\t\tkdb_printf(\"Could not allocate new kdb macro command: %s\\n\",\n\t\t\t   cmdstr);\n\t\treturn KDB_NOTIMP;\n\t}\n\n\tkms->statement = kdb_strdup(cmdstr, GFP_KDB);\n\tlist_add_tail(&kms->list_node, &kdb_macro->statements);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_cmderror",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "625-642",
    "snippet": "static void kdb_cmderror(int diag)\n{\n\tint i;\n\n\tif (diag >= 0) {\n\t\tkdb_printf(\"no error detected (diagnostic is %d)\\n\", diag);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < __nkdb_err; i++) {\n\t\tif (kdbmsgs[i].km_diag == diag) {\n\t\t\tkdb_printf(\"diag: %d: %s\\n\", diag, kdbmsgs[i].km_msg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tkdb_printf(\"Unknown diag %d\\n\", -diag);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static kdbmsg_t kdbmsgs[] = {\n\tKDBMSG(NOTFOUND, \"Command Not Found\"),\n\tKDBMSG(ARGCOUNT, \"Improper argument count, see usage.\"),\n\tKDBMSG(BADWIDTH, \"Illegal value for BYTESPERWORD use 1, 2, 4 or 8, \"\n\t       \"8 is only allowed on 64 bit systems\"),\n\tKDBMSG(BADRADIX, \"Illegal value for RADIX use 8, 10 or 16\"),\n\tKDBMSG(NOTENV, \"Cannot find environment variable\"),\n\tKDBMSG(NOENVVALUE, \"Environment variable should have value\"),\n\tKDBMSG(NOTIMP, \"Command not implemented\"),\n\tKDBMSG(ENVFULL, \"Environment full\"),\n\tKDBMSG(ENVBUFFULL, \"Environment buffer full\"),\n\tKDBMSG(TOOMANYBPT, \"Too many breakpoints defined\"),\n#ifdef CONFIG_CPU_XSCALE\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than ibcr registers defined\"),\n#else\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than db registers defined\"),\n#endif\n\tKDBMSG(DUPBPT, \"Duplicate breakpoint address\"),\n\tKDBMSG(BPTNOTFOUND, \"Breakpoint not found\"),\n\tKDBMSG(BADMODE, \"Invalid IDMODE\"),\n\tKDBMSG(BADINT, \"Illegal numeric value\"),\n\tKDBMSG(INVADDRFMT, \"Invalid symbolic address format\"),\n\tKDBMSG(BADREG, \"Invalid register name\"),\n\tKDBMSG(BADCPUNUM, \"Invalid cpu number\"),\n\tKDBMSG(BADLENGTH, \"Invalid length field\"),\n\tKDBMSG(NOBP, \"No Breakpoint exists\"),\n\tKDBMSG(BADADDR, \"Invalid address\"),\n\tKDBMSG(NOPERM, \"Permission denied\"),\n};",
      "static const int __nkdb_err = ARRAY_SIZE(kdbmsgs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Unknown diag %d\\n\"",
            "-diag"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic kdbmsg_t kdbmsgs[] = {\n\tKDBMSG(NOTFOUND, \"Command Not Found\"),\n\tKDBMSG(ARGCOUNT, \"Improper argument count, see usage.\"),\n\tKDBMSG(BADWIDTH, \"Illegal value for BYTESPERWORD use 1, 2, 4 or 8, \"\n\t       \"8 is only allowed on 64 bit systems\"),\n\tKDBMSG(BADRADIX, \"Illegal value for RADIX use 8, 10 or 16\"),\n\tKDBMSG(NOTENV, \"Cannot find environment variable\"),\n\tKDBMSG(NOENVVALUE, \"Environment variable should have value\"),\n\tKDBMSG(NOTIMP, \"Command not implemented\"),\n\tKDBMSG(ENVFULL, \"Environment full\"),\n\tKDBMSG(ENVBUFFULL, \"Environment buffer full\"),\n\tKDBMSG(TOOMANYBPT, \"Too many breakpoints defined\"),\n#ifdef CONFIG_CPU_XSCALE\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than ibcr registers defined\"),\n#else\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than db registers defined\"),\n#endif\n\tKDBMSG(DUPBPT, \"Duplicate breakpoint address\"),\n\tKDBMSG(BPTNOTFOUND, \"Breakpoint not found\"),\n\tKDBMSG(BADMODE, \"Invalid IDMODE\"),\n\tKDBMSG(BADINT, \"Illegal numeric value\"),\n\tKDBMSG(INVADDRFMT, \"Invalid symbolic address format\"),\n\tKDBMSG(BADREG, \"Invalid register name\"),\n\tKDBMSG(BADCPUNUM, \"Invalid cpu number\"),\n\tKDBMSG(BADLENGTH, \"Invalid length field\"),\n\tKDBMSG(NOBP, \"No Breakpoint exists\"),\n\tKDBMSG(BADADDR, \"Invalid address\"),\n\tKDBMSG(NOPERM, \"Permission denied\"),\n};\nstatic const int __nkdb_err = ARRAY_SIZE(kdbmsgs);\n\nstatic void kdb_cmderror(int diag)\n{\n\tint i;\n\n\tif (diag >= 0) {\n\t\tkdb_printf(\"no error detected (diagnostic is %d)\\n\", diag);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < __nkdb_err; i++) {\n\t\tif (kdbmsgs[i].km_diag == diag) {\n\t\t\tkdb_printf(\"diag: %d: %s\\n\", diag, kdbmsgs[i].km_msg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tkdb_printf(\"Unknown diag %d\\n\", -diag);\n}"
  },
  {
    "function_name": "kdbgetaddrarg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "491-623",
    "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdbgetularg",
          "args": [
            "cp",
            "&off"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetularg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "362-382",
          "snippet": "int kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbnearsym",
          "args": [
            "addr",
            "&symtab"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "kdbnearsym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "82-111",
          "snippet": "int kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n\tstatic char namebuf[KSYM_NAME_LEN];\n\n\tkdb_dbg_printf(AR, \"addr=0x%lx, symtab=%px\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), namebuf);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tkdb_dbg_printf(AR, \"returns %d symtab->sym_start=0x%lx, symtab->mod_name=%px, symtab->sym_name=%px (%s)\\n\",\n\t\t       ret, symtab->sym_start, symtab->mod_name, symtab->sym_name, symtab->sym_name);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n\tstatic char namebuf[KSYM_NAME_LEN];\n\n\tkdb_dbg_printf(AR, \"addr=0x%lx, symtab=%px\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), namebuf);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tkdb_dbg_printf(AR, \"returns %d symtab->sym_start=0x%lx, symtab->mod_name=%px, symtab->sym_name=%px (%s)\\n\",\n\t\t       ret, symtab->sym_start, symtab->mod_name, symtab->sym_name, symtab->sym_name);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetsymval",
          "args": [
            "symname",
            "&symtab"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetsymval",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "40-52",
          "snippet": "int kdbgetsymval(const char *symname, kdb_symtab_t *symtab)\n{\n\tkdb_dbg_printf(AR, \"symname=%s, symtab=%px\\n\", symname, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\tsymtab->sym_start = kallsyms_lookup_name(symname);\n\tif (symtab->sym_start) {\n\t\tkdb_dbg_printf(AR, \"returns 1, symtab->sym_start=0x%lx\\n\",\n\t\t\t       symtab->sym_start);\n\t\treturn 1;\n\t}\n\tkdb_dbg_printf(AR, \"returns 0\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdbgetsymval(const char *symname, kdb_symtab_t *symtab)\n{\n\tkdb_dbg_printf(AR, \"symname=%s, symtab=%px\\n\", symname, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\tsymtab->sym_start = kallsyms_lookup_name(symname);\n\tif (symtab->sym_start) {\n\t\tkdb_dbg_printf(AR, \"returns 1, symtab->sym_start=0x%lx\\n\",\n\t\t\t       symtab->sym_start);\n\t\treturn 1;\n\t}\n\tkdb_dbg_printf(AR, \"returns 0\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_check_regs",
          "args": [],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_check_regs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "456-464",
          "snippet": "static int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pt_regs *kdb_current_regs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct pt_regs *kdb_current_regs;\n\nstatic int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetulenv",
          "args": [
            "&symname[1]",
            "&addr"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetulenv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "259-272",
          "snippet": "static int kdbgetulenv(const char *match, unsigned long *value)\n{\n\tchar *ep;\n\n\tep = kdbgetenv(match);\n\tif (!ep)\n\t\treturn KDB_NOTENV;\n\tif (strlen(ep) == 0)\n\t\treturn KDB_NOENVVALUE;\n\n\t*value = simple_strtoul(ep, NULL, 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdbgetulenv(const char *match, unsigned long *value)\n{\n\tchar *ep;\n\n\tep = kdbgetenv(match);\n\tif (!ep)\n\t\treturn KDB_NOTENV;\n\tif (strlen(ep) == 0)\n\t\treturn KDB_NOENVVALUE;\n\n\t*value = simple_strtoul(ep, NULL, 0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "symname",
            "\"+-\""
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_check_flags",
          "args": [
            "KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL",
            "kdb_cmd_enabled",
            "false"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_check_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "172-186",
          "snippet": "static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_check_regs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "456-464",
    "snippet": "static int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pt_regs *kdb_current_regs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\""
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct pt_regs *kdb_current_regs;\n\nstatic int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "407-454",
    "snippet": "int kdb_set(int argc, const char **argv)\n{\n\t/*\n\t * we can be invoked two ways:\n\t *   set var=value    argv[1]=\"var\", argv[2]=\"value\"\n\t *   set var = value  argv[1]=\"var\", argv[2]=\"=\", argv[3]=\"value\"\n\t * - if the latter, shift 'em down.\n\t */\n\tif (argc == 3) {\n\t\targv[2] = argv[3];\n\t\targc--;\n\t}\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\n\t/*\n\t * Censor sensitive variables\n\t */\n\tif (strcmp(argv[1], \"PROMPT\") == 0 &&\n\t    !kdb_check_flags(KDB_ENABLE_MEM_READ, kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Check for internal variables\n\t */\n\tif (strcmp(argv[1], \"KDBDEBUG\") == 0) {\n\t\tunsigned int debugflags;\n\t\tchar *cp;\n\n\t\tdebugflags = simple_strtoul(argv[2], &cp, 0);\n\t\tif (cp == argv[2] || debugflags & ~KDB_DEBUG_FLAG_MASK) {\n\t\t\tkdb_printf(\"kdb: illegal debug flags '%s'\\n\",\n\t\t\t\t    argv[2]);\n\t\t\treturn 0;\n\t\t}\n\t\tkdb_flags = (kdb_flags & ~KDB_DEBUG(MASK))\n\t\t\t| (debugflags << KDB_DEBUG_FLAG_SHIFT);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Tokenizer squashed the '=' sign.  argv[1] is variable\n\t * name, argv[2] = value.\n\t */\n\treturn kdb_setenv(argv[1], argv[2]);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;",
      "unsigned int kdb_flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_setenv",
          "args": [
            "argv[1]",
            "argv[2]"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_setenv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "302-337",
          "snippet": "static int kdb_setenv(const char *var, const char *val)\n{\n\tint i;\n\tchar *ep;\n\tsize_t varlen, vallen;\n\n\tvarlen = strlen(var);\n\tvallen = strlen(val);\n\tep = kdballocenv(varlen + vallen + 2);\n\tif (ep == (char *)0)\n\t\treturn KDB_ENVBUFFULL;\n\n\tsprintf(ep, \"%s=%s\", var, val);\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i]\n\t\t && ((strncmp(__env[i], var, varlen) == 0)\n\t\t   && ((__env[i][varlen] == '\\0')\n\t\t    || (__env[i][varlen] == '=')))) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Wasn't existing variable.  Fit into slot.\n\t */\n\tfor (i = 0; i < __nenv-1; i++) {\n\t\tif (__env[i] == (char *)0) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn KDB_ENVFULL;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_setenv(const char *var, const char *val)\n{\n\tint i;\n\tchar *ep;\n\tsize_t varlen, vallen;\n\n\tvarlen = strlen(var);\n\tvallen = strlen(val);\n\tep = kdballocenv(varlen + vallen + 2);\n\tif (ep == (char *)0)\n\t\treturn KDB_ENVBUFFULL;\n\n\tsprintf(ep, \"%s=%s\", var, val);\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i]\n\t\t && ((strncmp(__env[i], var, varlen) == 0)\n\t\t   && ((__env[i][varlen] == '\\0')\n\t\t    || (__env[i][varlen] == '=')))) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Wasn't existing variable.  Fit into slot.\n\t */\n\tfor (i = 0; i < __nenv-1; i++) {\n\t\tif (__env[i] == (char *)0) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn KDB_ENVFULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG",
          "args": [
            "MASK"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"kdb: illegal debug flags '%s'\\n\"",
            "argv[2]"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "argv[2]",
            "&cp",
            "0"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"KDBDEBUG\""
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_check_flags",
          "args": [
            "KDB_ENABLE_MEM_READ",
            "kdb_cmd_enabled",
            "false"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_check_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "172-186",
          "snippet": "static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\nunsigned int kdb_flags;\n\nint kdb_set(int argc, const char **argv)\n{\n\t/*\n\t * we can be invoked two ways:\n\t *   set var=value    argv[1]=\"var\", argv[2]=\"value\"\n\t *   set var = value  argv[1]=\"var\", argv[2]=\"=\", argv[3]=\"value\"\n\t * - if the latter, shift 'em down.\n\t */\n\tif (argc == 3) {\n\t\targv[2] = argv[3];\n\t\targc--;\n\t}\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\n\t/*\n\t * Censor sensitive variables\n\t */\n\tif (strcmp(argv[1], \"PROMPT\") == 0 &&\n\t    !kdb_check_flags(KDB_ENABLE_MEM_READ, kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Check for internal variables\n\t */\n\tif (strcmp(argv[1], \"KDBDEBUG\") == 0) {\n\t\tunsigned int debugflags;\n\t\tchar *cp;\n\n\t\tdebugflags = simple_strtoul(argv[2], &cp, 0);\n\t\tif (cp == argv[2] || debugflags & ~KDB_DEBUG_FLAG_MASK) {\n\t\t\tkdb_printf(\"kdb: illegal debug flags '%s'\\n\",\n\t\t\t\t    argv[2]);\n\t\t\treturn 0;\n\t\t}\n\t\tkdb_flags = (kdb_flags & ~KDB_DEBUG(MASK))\n\t\t\t| (debugflags << KDB_DEBUG_FLAG_SHIFT);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Tokenizer squashed the '=' sign.  argv[1] is variable\n\t * name, argv[2] = value.\n\t */\n\treturn kdb_setenv(argv[1], argv[2]);\n}"
  },
  {
    "function_name": "kdbgetu64arg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "384-401",
    "snippet": "int kdbgetu64arg(const char *arg, u64 *value)\n{\n\tchar *endp;\n\tu64 val;\n\n\tval = simple_strtoull(arg, &endp, 0);\n\n\tif (endp == arg) {\n\n\t\tval = simple_strtoull(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoull",
          "args": [
            "arg",
            "&endp",
            "16"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoull",
          "args": [
            "arg",
            "&endp",
            "0"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetu64arg(const char *arg, u64 *value)\n{\n\tchar *endp;\n\tu64 val;\n\n\tval = simple_strtoull(arg, &endp, 0);\n\n\tif (endp == arg) {\n\n\t\tval = simple_strtoull(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdbgetularg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "362-382",
    "snippet": "int kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "arg",
            "&endp",
            "16"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "arg",
            "&endp",
            "0"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_printenv",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "342-350",
    "snippet": "static void kdb_printenv(void)\n{\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i])\n\t\t\tkdb_printf(\"%s\\n\", __env[i]);\n\t}\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%s\\n\"",
            "__env[i]"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_printenv(void)\n{\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i])\n\t\t\tkdb_printf(\"%s\\n\", __env[i]);\n\t}\n}"
  },
  {
    "function_name": "kdb_setenv",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "302-337",
    "snippet": "static int kdb_setenv(const char *var, const char *val)\n{\n\tint i;\n\tchar *ep;\n\tsize_t varlen, vallen;\n\n\tvarlen = strlen(var);\n\tvallen = strlen(val);\n\tep = kdballocenv(varlen + vallen + 2);\n\tif (ep == (char *)0)\n\t\treturn KDB_ENVBUFFULL;\n\n\tsprintf(ep, \"%s=%s\", var, val);\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i]\n\t\t && ((strncmp(__env[i], var, varlen) == 0)\n\t\t   && ((__env[i][varlen] == '\\0')\n\t\t    || (__env[i][varlen] == '=')))) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Wasn't existing variable.  Fit into slot.\n\t */\n\tfor (i = 0; i < __nenv-1; i++) {\n\t\tif (__env[i] == (char *)0) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn KDB_ENVFULL;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "__env[i]",
            "var",
            "varlen"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ep",
            "\"%s=%s\"",
            "var",
            "val"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdballocenv",
          "args": [
            "varlen + vallen + 2"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "kdballocenv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "235-247",
          "snippet": "static char *kdballocenv(size_t bytes)\n{\n#define\tKDB_ENVBUFSIZE\t512\n\tstatic char envbuffer[KDB_ENVBUFSIZE];\n\tstatic int envbufsize;\n\tchar *ep = NULL;\n\n\tif ((KDB_ENVBUFSIZE - envbufsize) >= bytes) {\n\t\tep = &envbuffer[envbufsize];\n\t\tenvbufsize += bytes;\n\t}\n\treturn ep;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define\tKDB_ENVBUFSIZE\t512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define\tKDB_ENVBUFSIZE\t512\n\nstatic char *kdballocenv(size_t bytes)\n{\n#define\tKDB_ENVBUFSIZE\t512\n\tstatic char envbuffer[KDB_ENVBUFSIZE];\n\tstatic int envbufsize;\n\tchar *ep = NULL;\n\n\tif ((KDB_ENVBUFSIZE - envbufsize) >= bytes) {\n\t\tep = &envbuffer[envbufsize];\n\t\tenvbufsize += bytes;\n\t}\n\treturn ep;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "val"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_setenv(const char *var, const char *val)\n{\n\tint i;\n\tchar *ep;\n\tsize_t varlen, vallen;\n\n\tvarlen = strlen(var);\n\tvallen = strlen(val);\n\tep = kdballocenv(varlen + vallen + 2);\n\tif (ep == (char *)0)\n\t\treturn KDB_ENVBUFFULL;\n\n\tsprintf(ep, \"%s=%s\", var, val);\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i]\n\t\t && ((strncmp(__env[i], var, varlen) == 0)\n\t\t   && ((__env[i][varlen] == '\\0')\n\t\t    || (__env[i][varlen] == '=')))) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Wasn't existing variable.  Fit into slot.\n\t */\n\tfor (i = 0; i < __nenv-1; i++) {\n\t\tif (__env[i] == (char *)0) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn KDB_ENVFULL;\n}"
  },
  {
    "function_name": "kdbgetintenv",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "284-293",
    "snippet": "int kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdbgetulenv",
          "args": [
            "match",
            "&val"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetulenv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "259-272",
          "snippet": "static int kdbgetulenv(const char *match, unsigned long *value)\n{\n\tchar *ep;\n\n\tep = kdbgetenv(match);\n\tif (!ep)\n\t\treturn KDB_NOTENV;\n\tif (strlen(ep) == 0)\n\t\treturn KDB_NOENVVALUE;\n\n\t*value = simple_strtoul(ep, NULL, 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdbgetulenv(const char *match, unsigned long *value)\n{\n\tchar *ep;\n\n\tep = kdbgetenv(match);\n\tif (!ep)\n\t\treturn KDB_NOTENV;\n\tif (strlen(ep) == 0)\n\t\treturn KDB_NOENVVALUE;\n\n\t*value = simple_strtoul(ep, NULL, 0);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}"
  },
  {
    "function_name": "kdbgetulenv",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "259-272",
    "snippet": "static int kdbgetulenv(const char *match, unsigned long *value)\n{\n\tchar *ep;\n\n\tep = kdbgetenv(match);\n\tif (!ep)\n\t\treturn KDB_NOTENV;\n\tif (strlen(ep) == 0)\n\t\treturn KDB_NOENVVALUE;\n\n\t*value = simple_strtoul(ep, NULL, 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "ep",
            "NULL",
            "0"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ep"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetenv",
          "args": [
            "match"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetenv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "197-217",
          "snippet": "char *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nchar *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdbgetulenv(const char *match, unsigned long *value)\n{\n\tchar *ep;\n\n\tep = kdbgetenv(match);\n\tif (!ep)\n\t\treturn KDB_NOTENV;\n\tif (strlen(ep) == 0)\n\t\treturn KDB_NOENVVALUE;\n\n\t*value = simple_strtoul(ep, NULL, 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdballocenv",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "235-247",
    "snippet": "static char *kdballocenv(size_t bytes)\n{\n#define\tKDB_ENVBUFSIZE\t512\n\tstatic char envbuffer[KDB_ENVBUFSIZE];\n\tstatic int envbufsize;\n\tchar *ep = NULL;\n\n\tif ((KDB_ENVBUFSIZE - envbufsize) >= bytes) {\n\t\tep = &envbuffer[envbufsize];\n\t\tenvbufsize += bytes;\n\t}\n\treturn ep;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define\tKDB_ENVBUFSIZE\t512"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define\tKDB_ENVBUFSIZE\t512\n\nstatic char *kdballocenv(size_t bytes)\n{\n#define\tKDB_ENVBUFSIZE\t512\n\tstatic char envbuffer[KDB_ENVBUFSIZE];\n\tstatic int envbufsize;\n\tchar *ep = NULL;\n\n\tif ((KDB_ENVBUFSIZE - envbufsize) >= bytes) {\n\t\tep = &envbuffer[envbufsize];\n\t\tenvbufsize += bytes;\n\t}\n\treturn ep;\n}"
  },
  {
    "function_name": "kdbgetenv",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "197-217",
    "snippet": "char *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "e",
            "'='"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "match",
            "e",
            "matchlen"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "match"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nchar *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "kdb_check_flags",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "172-186",
    "snippet": "static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}"
  },
  {
    "function_name": "kdb_curr_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "158-166",
    "snippet": "struct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_TSK",
          "args": [
            "cpu"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_thread_info",
          "args": [
            "p"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curr_task",
          "args": [
            "cpu"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_curr_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "158-166",
          "snippet": "struct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}"
  }
]