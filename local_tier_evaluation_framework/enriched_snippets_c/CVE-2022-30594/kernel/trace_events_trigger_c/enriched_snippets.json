[
  {
    "function_name": "register_trigger_cmds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "2020-2030",
    "snippet": "__init int register_trigger_cmds(void)\n{\n\tregister_trigger_traceon_traceoff_cmds();\n\tregister_trigger_snapshot_cmd();\n\tregister_trigger_stacktrace_cmd();\n\tregister_trigger_enable_disable_cmds();\n\tregister_trigger_hist_enable_disable_cmds();\n\tregister_trigger_hist_cmd();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_trigger_hist_cmd",
          "args": [],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "register_trigger_hist_cmd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "6342-6350",
          "snippet": "__init int register_trigger_hist_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_hist_cmd;",
            "static struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= event_hist_trigger_parse,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_cmd;\nstatic struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.parse\t\t\t= event_hist_trigger_parse,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\n__init int register_trigger_hist_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_trigger_hist_enable_disable_cmds",
          "args": [],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "register_trigger_hist_enable_disable_cmds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_hist.c",
          "lines": "6474-6486",
          "snippet": "__init int register_trigger_hist_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_hist_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_hist_enable_disable_cmds();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include \"tracing_map.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
            "static struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include \"tracing_map.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\n__init int register_trigger_hist_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_hist_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_hist_enable_disable_cmds();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_trigger_enable_disable_cmds",
          "args": [],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "register_trigger_enable_disable_cmds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1992-2004",
          "snippet": "static __init int register_trigger_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_enable_disable_cmds();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
            "static struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init int register_trigger_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_enable_disable_cmds();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_trigger_stacktrace_cmd",
          "args": [],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "register_trigger_stacktrace_cmd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1609-1609",
          "snippet": "static __init int register_trigger_stacktrace_cmd(void) { return 0; }",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic __init int register_trigger_stacktrace_cmd(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "register_trigger_snapshot_cmd",
          "args": [],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "register_trigger_snapshot_cmd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1517-1517",
          "snippet": "static __init int register_trigger_snapshot_cmd(void) { return 0; }",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic __init int register_trigger_snapshot_cmd(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "register_trigger_traceon_traceoff_cmds",
          "args": [],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "register_trigger_traceon_traceoff_cmds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "2006-2018",
          "snippet": "static __init int register_trigger_traceon_traceoff_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_traceon_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_traceoff_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_traceon_traceoff_cmds();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
            "static struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init int register_trigger_traceon_traceoff_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_traceon_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_traceoff_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_traceon_traceoff_cmds();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\n__init int register_trigger_cmds(void)\n{\n\tregister_trigger_traceon_traceoff_cmds();\n\tregister_trigger_snapshot_cmd();\n\tregister_trigger_stacktrace_cmd();\n\tregister_trigger_enable_disable_cmds();\n\tregister_trigger_hist_enable_disable_cmds();\n\tregister_trigger_hist_cmd();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "register_trigger_traceon_traceoff_cmds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "2006-2018",
    "snippet": "static __init int register_trigger_traceon_traceoff_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_traceon_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_traceoff_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_traceon_traceoff_cmds();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
      "static struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trigger_traceon_traceoff_cmds",
          "args": [],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trigger_traceon_traceoff_cmds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1612-1616",
          "snippet": "static __init void unregister_trigger_traceon_traceoff_cmds(void)\n{\n\tunregister_event_command(&trigger_traceon_cmd);\n\tunregister_event_command(&trigger_traceoff_cmd);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
            "static struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init void unregister_trigger_traceon_traceoff_cmds(void)\n{\n\tunregister_event_command(&trigger_traceon_cmd);\n\tunregister_event_command(&trigger_traceoff_cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_event_command",
          "args": [
            "&trigger_traceoff_cmd"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "365-382",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init int register_trigger_traceon_traceoff_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_traceon_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_traceoff_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_traceon_traceoff_cmds();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "register_trigger_enable_disable_cmds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1992-2004",
    "snippet": "static __init int register_trigger_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_enable_disable_cmds();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
      "static struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trigger_enable_disable_cmds",
          "args": [],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trigger_enable_disable_cmds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1986-1990",
          "snippet": "static __init void unregister_trigger_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_enable_cmd);\n\tunregister_event_command(&trigger_disable_cmd);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
            "static struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init void unregister_trigger_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_enable_cmd);\n\tunregister_event_command(&trigger_disable_cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_event_command",
          "args": [
            "&trigger_disable_cmd"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "365-382",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init int register_trigger_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_enable_disable_cmds();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "unregister_trigger_enable_disable_cmds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1986-1990",
    "snippet": "static __init void unregister_trigger_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_enable_cmd);\n\tunregister_event_command(&trigger_disable_cmd);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
      "static struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_event_command",
          "args": [
            "&trigger_disable_cmd"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "365-382",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic struct event_command trigger_enable_cmd = {\n\t.name\t\t\t= ENABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_disable_cmd = {\n\t.name\t\t\t= DISABLE_EVENT_STR,\n\t.trigger_type\t\t= ETT_EVENT_ENABLE,\n\t.parse\t\t\t= event_enable_trigger_parse,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.get_trigger_ops\t= event_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init void unregister_trigger_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_enable_cmd);\n\tunregister_event_command(&trigger_disable_cmd);\n}"
  },
  {
    "function_name": "event_enable_get_trigger_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1944-1964",
    "snippet": "static struct event_trigger_ops *\nevent_enable_get_trigger_ops(char *cmd, char *param)\n{\n\tstruct event_trigger_ops *ops;\n\tbool enable;\n\n#ifdef CONFIG_HIST_TRIGGERS\n\tenable = ((strcmp(cmd, ENABLE_EVENT_STR) == 0) ||\n\t\t  (strcmp(cmd, ENABLE_HIST_STR) == 0));\n#else\n\tenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\n#endif\n\tif (enable)\n\t\tops = param ? &event_enable_count_trigger_ops :\n\t\t\t&event_enable_trigger_ops;\n\telse\n\t\tops = param ? &event_disable_count_trigger_ops :\n\t\t\t&event_disable_trigger_ops;\n\n\treturn ops;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_trigger_ops event_enable_trigger_ops = {\n\t.trigger\t\t= event_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};",
      "static struct event_trigger_ops event_enable_count_trigger_ops = {\n\t.trigger\t\t= event_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};",
      "static struct event_trigger_ops event_disable_trigger_ops = {\n\t.trigger\t\t= event_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};",
      "static struct event_trigger_ops event_disable_count_trigger_ops = {\n\t.trigger\t\t= event_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "ENABLE_EVENT_STR"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic struct event_trigger_ops event_enable_trigger_ops = {\n\t.trigger\t\t= event_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\nstatic struct event_trigger_ops event_enable_count_trigger_ops = {\n\t.trigger\t\t= event_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\nstatic struct event_trigger_ops event_disable_trigger_ops = {\n\t.trigger\t\t= event_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\nstatic struct event_trigger_ops event_disable_count_trigger_ops = {\n\t.trigger\t\t= event_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\n\nstatic struct event_trigger_ops *\nevent_enable_get_trigger_ops(char *cmd, char *param)\n{\n\tstruct event_trigger_ops *ops;\n\tbool enable;\n\n#ifdef CONFIG_HIST_TRIGGERS\n\tenable = ((strcmp(cmd, ENABLE_EVENT_STR) == 0) ||\n\t\t  (strcmp(cmd, ENABLE_HIST_STR) == 0));\n#else\n\tenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\n#endif\n\tif (enable)\n\t\tops = param ? &event_enable_count_trigger_ops :\n\t\t\t&event_enable_trigger_ops;\n\telse\n\t\tops = param ? &event_disable_count_trigger_ops :\n\t\t\t&event_disable_trigger_ops;\n\n\treturn ops;\n}"
  },
  {
    "function_name": "event_enable_unregister_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1915-1942",
    "snippet": "void event_enable_unregister_trigger(char *glob,\n\t\t\t\t     struct event_trigger_data *test,\n\t\t\t\t     struct trace_event_file *file)\n{\n\tstruct enable_trigger_data *test_enable_data = test->private_data;\n\tstruct enable_trigger_data *enable_data;\n\tstruct event_trigger_data *data;\n\tbool unregistered = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tenable_data = data->private_data;\n\t\tif (enable_data &&\n\t\t    (data->cmd_ops->trigger_type ==\n\t\t     test->cmd_ops->trigger_type) &&\n\t\t    (enable_data->file == test_enable_data->file)) {\n\t\t\tunregistered = true;\n\t\t\tlist_del_rcu(&data->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unregistered && data->ops->free)\n\t\tdata->ops->free(data->ops, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->ops->free",
          "args": [
            "data->ops",
            "data"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "519-538",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "460-478",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&data->list"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "data",
            "&file->triggers",
            "list"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid event_enable_unregister_trigger(char *glob,\n\t\t\t\t     struct event_trigger_data *test,\n\t\t\t\t     struct trace_event_file *file)\n{\n\tstruct enable_trigger_data *test_enable_data = test->private_data;\n\tstruct enable_trigger_data *enable_data;\n\tstruct event_trigger_data *data;\n\tbool unregistered = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tenable_data = data->private_data;\n\t\tif (enable_data &&\n\t\t    (data->cmd_ops->trigger_type ==\n\t\t     test->cmd_ops->trigger_type) &&\n\t\t    (enable_data->file == test_enable_data->file)) {\n\t\t\tunregistered = true;\n\t\t\tlist_del_rcu(&data->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unregistered && data->ops->free)\n\t\tdata->ops->free(data->ops, data);\n}"
  },
  {
    "function_name": "event_enable_register_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1874-1913",
    "snippet": "int event_enable_register_trigger(char *glob,\n\t\t\t\t  struct event_trigger_data *data,\n\t\t\t\t  struct trace_event_file *file)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\tstruct enable_trigger_data *test_enable_data;\n\tstruct event_trigger_data *test;\n\tint ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\ttest_enable_data = test->private_data;\n\t\tif (test_enable_data &&\n\t\t    (test->cmd_ops->trigger_type ==\n\t\t     data->cmd_ops->trigger_type) &&\n\t\t    (test_enable_data->file == enable_data->file)) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (data->ops->init) {\n\t\tret = data->ops->init(data->ops, data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_add_rcu(&data->list, &file->triggers);\n\tret++;\n\n\tupdate_cond_flag(file);\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "519-538",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&data->list"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "1"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "460-478",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&data->list",
            "&file->triggers"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data->ops->init",
          "args": [
            "data->ops",
            "data"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint event_enable_register_trigger(char *glob,\n\t\t\t\t  struct event_trigger_data *data,\n\t\t\t\t  struct trace_event_file *file)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\tstruct enable_trigger_data *test_enable_data;\n\tstruct event_trigger_data *test;\n\tint ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\ttest_enable_data = test->private_data;\n\t\tif (test_enable_data &&\n\t\t    (test->cmd_ops->trigger_type ==\n\t\t     data->cmd_ops->trigger_type) &&\n\t\t    (test_enable_data->file == enable_data->file)) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (data->ops->init) {\n\t\tret = data->ops->init(data->ops, data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_add_rcu(&data->list, &file->triggers);\n\tret++;\n\n\tupdate_cond_flag(file);\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "event_enable_trigger_parse",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1723-1872",
    "snippet": "int event_enable_trigger_parse(struct event_command *cmd_ops,\n\t\t\t       struct trace_event_file *file,\n\t\t\t       char *glob, char *cmd, char *param)\n{\n\tstruct trace_event_file *event_enable_file;\n\tstruct enable_trigger_data *enable_data;\n\tstruct event_trigger_data *trigger_data;\n\tstruct event_trigger_ops *trigger_ops;\n\tstruct trace_array *tr = file->tr;\n\tconst char *system;\n\tconst char *event;\n\tbool hist = false;\n\tchar *trigger;\n\tchar *number;\n\tbool enable;\n\tint ret;\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\t/* separate the trigger from the filter (s:e:n [if filter]) */\n\ttrigger = strsep(&param, \" \\t\");\n\tif (!trigger)\n\t\treturn -EINVAL;\n\tif (param) {\n\t\tparam = skip_spaces(param);\n\t\tif (!*param)\n\t\t\tparam = NULL;\n\t}\n\n\tsystem = strsep(&trigger, \":\");\n\tif (!trigger)\n\t\treturn -EINVAL;\n\n\tevent = strsep(&trigger, \":\");\n\n\tret = -EINVAL;\n\tevent_enable_file = find_event_file(tr, system, event);\n\tif (!event_enable_file)\n\t\tgoto out;\n\n#ifdef CONFIG_HIST_TRIGGERS\n\thist = ((strcmp(cmd, ENABLE_HIST_STR) == 0) ||\n\t\t(strcmp(cmd, DISABLE_HIST_STR) == 0));\n\n\tenable = ((strcmp(cmd, ENABLE_EVENT_STR) == 0) ||\n\t\t  (strcmp(cmd, ENABLE_HIST_STR) == 0));\n#else\n\tenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\n#endif\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\tret = -ENOMEM;\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data)\n\t\tgoto out;\n\n\tenable_data = kzalloc(sizeof(*enable_data), GFP_KERNEL);\n\tif (!enable_data) {\n\t\tkfree(trigger_data);\n\t\tgoto out;\n\t}\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\tenable_data->hist = hist;\n\tenable_data->enable = enable;\n\tenable_data->file = event_enable_file;\n\ttrigger_data->private_data = enable_data;\n\n\tif (glob[0] == '!') {\n\t\tcmd_ops->unreg(glob+1, trigger_data, file);\n\t\tkfree(trigger_data);\n\t\tkfree(enable_data);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Up the trigger_data count to make sure nothing frees it on failure */\n\tevent_trigger_init(trigger_ops, trigger_data);\n\n\tif (trigger) {\n\t\tnumber = strsep(&trigger, \":\");\n\n\t\tret = -EINVAL;\n\t\tif (!strlen(number))\n\t\t\tgoto out_free;\n\n\t\t/*\n\t\t * We use the callback data field (which is a pointer)\n\t\t * as our counter.\n\t\t */\n\t\tret = kstrtoul(number, 0, &trigger_data->count);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tif (!param) /* if param is non-empty, it's supposed to be a filter */\n\t\tgoto out_reg;\n\n\tif (!cmd_ops->set_filter)\n\t\tgoto out_reg;\n\n\tret = cmd_ops->set_filter(param, trigger_data, file);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n out_reg:\n\t/* Don't let event modules unload while probe registered */\n\tret = trace_event_try_get_ref(event_enable_file->event_call);\n\tif (!ret) {\n\t\tret = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tret = trace_event_enable_disable(event_enable_file, 1, 1);\n\tif (ret < 0)\n\t\tgoto out_put;\n\tret = cmd_ops->reg(glob, trigger_data, file);\n\t/*\n\t * The above returns on success the # of functions enabled,\n\t * but if it didn't find any functions it returns zero.\n\t * Consider no functions a failure too.\n\t */\n\tif (!ret) {\n\t\tret = -ENOENT;\n\t\tgoto out_disable;\n\t} else if (ret < 0)\n\t\tgoto out_disable;\n\t/* Just return zero, not the number of enabled functions */\n\tret = 0;\n\tevent_trigger_free(trigger_ops, trigger_data);\n out:\n\treturn ret;\n\n out_disable:\n\ttrace_event_enable_disable(event_enable_file, 0, 1);\n out_put:\n\ttrace_event_put_ref(event_enable_file->event_call);\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\tevent_trigger_free(trigger_ops, trigger_data);\n\tkfree(enable_data);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "enable_data"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_trigger_free",
          "args": [
            "trigger_ops",
            "trigger_data"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "448-458",
          "snippet": "static void\nevent_trigger_free(struct event_trigger_ops *ops,\n\t\t   struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref)\n\t\ttrigger_data_free(data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic void\nevent_trigger_free(struct event_trigger_ops *ops,\n\t\t   struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref)\n\t\ttrigger_data_free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->set_filter",
          "args": [
            "NULL",
            "trigger_data",
            "NULL"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_put_ref",
          "args": [
            "event_enable_file->event_call"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_enable_disable",
          "args": [
            "event_enable_file",
            "0",
            "1"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "694-698",
          "snippet": "int trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nint trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->reg",
          "args": [
            "glob",
            "trigger_data",
            "file"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_try_get_ref",
          "args": [
            "event_enable_file->event_call"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->set_filter",
          "args": [
            "param",
            "trigger_data",
            "file"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "number",
            "0",
            "&trigger_data->count"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "number"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&trigger",
            "\":\""
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_trigger_init",
          "args": [
            "trigger_ops",
            "trigger_data"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "431-436",
          "snippet": "int event_trigger_init(struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\tdata->ref++;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint event_trigger_init(struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\tdata->ref++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->unreg",
          "args": [
            "glob+1",
            "trigger_data",
            "file"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "trigger_data->filter",
            "NULL"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&trigger_data->list"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*enable_data)",
            "GFP_KERNEL"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*trigger_data)",
            "GFP_KERNEL"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->get_trigger_ops",
          "args": [
            "cmd",
            "trigger"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "ENABLE_EVENT_STR"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_event_file",
          "args": [
            "tr",
            "system",
            "event"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_file",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "2943-2954",
          "snippet": "struct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&trigger",
            "\":\""
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&trigger",
            "\":\""
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "param"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "proc_skip_spaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "333-340",
          "snippet": "static size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\" \\t\""
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint event_enable_trigger_parse(struct event_command *cmd_ops,\n\t\t\t       struct trace_event_file *file,\n\t\t\t       char *glob, char *cmd, char *param)\n{\n\tstruct trace_event_file *event_enable_file;\n\tstruct enable_trigger_data *enable_data;\n\tstruct event_trigger_data *trigger_data;\n\tstruct event_trigger_ops *trigger_ops;\n\tstruct trace_array *tr = file->tr;\n\tconst char *system;\n\tconst char *event;\n\tbool hist = false;\n\tchar *trigger;\n\tchar *number;\n\tbool enable;\n\tint ret;\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\t/* separate the trigger from the filter (s:e:n [if filter]) */\n\ttrigger = strsep(&param, \" \\t\");\n\tif (!trigger)\n\t\treturn -EINVAL;\n\tif (param) {\n\t\tparam = skip_spaces(param);\n\t\tif (!*param)\n\t\t\tparam = NULL;\n\t}\n\n\tsystem = strsep(&trigger, \":\");\n\tif (!trigger)\n\t\treturn -EINVAL;\n\n\tevent = strsep(&trigger, \":\");\n\n\tret = -EINVAL;\n\tevent_enable_file = find_event_file(tr, system, event);\n\tif (!event_enable_file)\n\t\tgoto out;\n\n#ifdef CONFIG_HIST_TRIGGERS\n\thist = ((strcmp(cmd, ENABLE_HIST_STR) == 0) ||\n\t\t(strcmp(cmd, DISABLE_HIST_STR) == 0));\n\n\tenable = ((strcmp(cmd, ENABLE_EVENT_STR) == 0) ||\n\t\t  (strcmp(cmd, ENABLE_HIST_STR) == 0));\n#else\n\tenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\n#endif\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\tret = -ENOMEM;\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data)\n\t\tgoto out;\n\n\tenable_data = kzalloc(sizeof(*enable_data), GFP_KERNEL);\n\tif (!enable_data) {\n\t\tkfree(trigger_data);\n\t\tgoto out;\n\t}\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\tenable_data->hist = hist;\n\tenable_data->enable = enable;\n\tenable_data->file = event_enable_file;\n\ttrigger_data->private_data = enable_data;\n\n\tif (glob[0] == '!') {\n\t\tcmd_ops->unreg(glob+1, trigger_data, file);\n\t\tkfree(trigger_data);\n\t\tkfree(enable_data);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Up the trigger_data count to make sure nothing frees it on failure */\n\tevent_trigger_init(trigger_ops, trigger_data);\n\n\tif (trigger) {\n\t\tnumber = strsep(&trigger, \":\");\n\n\t\tret = -EINVAL;\n\t\tif (!strlen(number))\n\t\t\tgoto out_free;\n\n\t\t/*\n\t\t * We use the callback data field (which is a pointer)\n\t\t * as our counter.\n\t\t */\n\t\tret = kstrtoul(number, 0, &trigger_data->count);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tif (!param) /* if param is non-empty, it's supposed to be a filter */\n\t\tgoto out_reg;\n\n\tif (!cmd_ops->set_filter)\n\t\tgoto out_reg;\n\n\tret = cmd_ops->set_filter(param, trigger_data, file);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n out_reg:\n\t/* Don't let event modules unload while probe registered */\n\tret = trace_event_try_get_ref(event_enable_file->event_call);\n\tif (!ret) {\n\t\tret = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tret = trace_event_enable_disable(event_enable_file, 1, 1);\n\tif (ret < 0)\n\t\tgoto out_put;\n\tret = cmd_ops->reg(glob, trigger_data, file);\n\t/*\n\t * The above returns on success the # of functions enabled,\n\t * but if it didn't find any functions it returns zero.\n\t * Consider no functions a failure too.\n\t */\n\tif (!ret) {\n\t\tret = -ENOENT;\n\t\tgoto out_disable;\n\t} else if (ret < 0)\n\t\tgoto out_disable;\n\t/* Just return zero, not the number of enabled functions */\n\tret = 0;\n\tevent_trigger_free(trigger_ops, trigger_data);\n out:\n\treturn ret;\n\n out_disable:\n\ttrace_event_enable_disable(event_enable_file, 0, 1);\n out_put:\n\ttrace_event_put_ref(event_enable_file->event_call);\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\tevent_trigger_free(trigger_ops, trigger_data);\n\tkfree(enable_data);\n\tgoto out;\n}"
  },
  {
    "function_name": "event_enable_trigger_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1677-1693",
    "snippet": "void event_enable_trigger_free(struct event_trigger_ops *ops,\n\t\t\t       struct event_trigger_data *data)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\t/* Remove the SOFT_MODE flag */\n\t\ttrace_event_enable_disable(enable_data->file, 0, 1);\n\t\ttrace_event_put_ref(enable_data->file->event_call);\n\t\ttrigger_data_free(data);\n\t\tkfree(enable_data);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "enable_data"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trigger_data_free",
          "args": [
            "data"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_data_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "20-29",
          "snippet": "void trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_put_ref",
          "args": [
            "enable_data->file->event_call"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_enable_disable",
          "args": [
            "enable_data->file",
            "0",
            "1"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "694-698",
          "snippet": "int trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nint trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "data->ref <= 0"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid event_enable_trigger_free(struct event_trigger_ops *ops,\n\t\t\t       struct event_trigger_data *data)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\t/* Remove the SOFT_MODE flag */\n\t\ttrace_event_enable_disable(enable_data->file, 0, 1);\n\t\ttrace_event_put_ref(enable_data->file->event_call);\n\t\ttrigger_data_free(data);\n\t\tkfree(enable_data);\n\t}\n}"
  },
  {
    "function_name": "event_enable_trigger_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1651-1675",
    "snippet": "int event_enable_trigger_print(struct seq_file *m,\n\t\t\t       struct event_trigger_ops *ops,\n\t\t\t       struct event_trigger_data *data)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tseq_printf(m, \"%s:%s:%s\",\n\t\t   enable_data->hist ?\n\t\t   (enable_data->enable ? ENABLE_HIST_STR : DISABLE_HIST_STR) :\n\t\t   (enable_data->enable ? ENABLE_EVENT_STR : DISABLE_EVENT_STR),\n\t\t   enable_data->file->event_call->class->system,\n\t\t   trace_event_name(enable_data->file->event_call));\n\n\tif (data->count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", data->count);\n\n\tif (data->filter_str)\n\t\tseq_printf(m, \" if %s\\n\", data->filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" if %s\\n\"",
            "data->filter_str"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\":unlimited\""
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "enable_data->file->event_call"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint event_enable_trigger_print(struct seq_file *m,\n\t\t\t       struct event_trigger_ops *ops,\n\t\t\t       struct event_trigger_data *data)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tseq_printf(m, \"%s:%s:%s\",\n\t\t   enable_data->hist ?\n\t\t   (enable_data->enable ? ENABLE_HIST_STR : DISABLE_HIST_STR) :\n\t\t   (enable_data->enable ? ENABLE_EVENT_STR : DISABLE_EVENT_STR),\n\t\t   enable_data->file->event_call->class->system,\n\t\t   trace_event_name(enable_data->file->event_call));\n\n\tif (data->count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", data->count);\n\n\tif (data->filter_str)\n\t\tseq_printf(m, \" if %s\\n\", data->filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_enable_count_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1631-1649",
    "snippet": "static void\nevent_enable_count_trigger(struct event_trigger_data *data,\n\t\t\t   struct trace_buffer *buffer,  void *rec,\n\t\t\t   struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (!data->count)\n\t\treturn;\n\n\t/* Skip if the event is in a state we want to switch to */\n\tif (enable_data->enable == !(enable_data->file->flags & EVENT_FILE_FL_SOFT_DISABLED))\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tevent_enable_trigger(data, buffer, rec, event);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_enable_trigger",
          "args": [
            "data",
            "buffer",
            "rec",
            "event"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "event_enable_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1618-1629",
          "snippet": "static void\nevent_enable_trigger(struct event_trigger_data *data,\n\t\t     struct trace_buffer *buffer,  void *rec,\n\t\t     struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (enable_data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic void\nevent_enable_trigger(struct event_trigger_data *data,\n\t\t     struct trace_buffer *buffer,  void *rec,\n\t\t     struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (enable_data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic void\nevent_enable_count_trigger(struct event_trigger_data *data,\n\t\t\t   struct trace_buffer *buffer,  void *rec,\n\t\t\t   struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (!data->count)\n\t\treturn;\n\n\t/* Skip if the event is in a state we want to switch to */\n\tif (enable_data->enable == !(enable_data->file->flags & EVENT_FILE_FL_SOFT_DISABLED))\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tevent_enable_trigger(data, buffer, rec, event);\n}"
  },
  {
    "function_name": "event_enable_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1618-1629",
    "snippet": "static void\nevent_enable_trigger(struct event_trigger_data *data,\n\t\t     struct trace_buffer *buffer,  void *rec,\n\t\t     struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (enable_data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EVENT_FILE_FL_SOFT_DISABLED_BIT",
            "&enable_data->file->flags"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVENT_FILE_FL_SOFT_DISABLED_BIT",
            "&enable_data->file->flags"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic void\nevent_enable_trigger(struct event_trigger_data *data,\n\t\t     struct trace_buffer *buffer,  void *rec,\n\t\t     struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\n\tif (enable_data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &enable_data->file->flags);\n}"
  },
  {
    "function_name": "unregister_trigger_traceon_traceoff_cmds",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1612-1616",
    "snippet": "static __init void unregister_trigger_traceon_traceoff_cmds(void)\n{\n\tunregister_event_command(&trigger_traceon_cmd);\n\tunregister_event_command(&trigger_traceoff_cmd);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
      "static struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_event_command",
          "args": [
            "&trigger_traceoff_cmd"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "365-382",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic struct event_command trigger_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.trigger_type\t\t= ETT_TRACE_ONOFF,\n\t.flags\t\t\t= EVENT_CMD_FL_POST_TRIGGER,\n\t.parse\t\t\t= event_trigger_parse,\n\t.reg\t\t\t= register_trigger,\n\t.unreg\t\t\t= unregister_trigger,\n\t.get_trigger_ops\t= onoff_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init void unregister_trigger_traceon_traceoff_cmds(void)\n{\n\tunregister_event_command(&trigger_traceon_cmd);\n\tunregister_event_command(&trigger_traceoff_cmd);\n}"
  },
  {
    "function_name": "register_trigger_stacktrace_cmd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1609-1609",
    "snippet": "static __init int register_trigger_stacktrace_cmd(void) { return 0; }",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic __init int register_trigger_stacktrace_cmd(void) { return 0; }"
  },
  {
    "function_name": "register_trigger_stacktrace_cmd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1599-1607",
    "snippet": "static __init int register_trigger_stacktrace_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_stacktrace_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_event_command",
          "args": [
            "&trigger_stacktrace_cmd"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "365-382",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic __init int register_trigger_stacktrace_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_stacktrace_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "stacktrace_get_trigger_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1582-1586",
    "snippet": "static struct event_trigger_ops *\nstacktrace_get_trigger_ops(char *cmd, char *param)\n{\n\treturn param ? &stacktrace_count_trigger_ops : &stacktrace_trigger_ops;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic struct event_trigger_ops *\nstacktrace_get_trigger_ops(char *cmd, char *param)\n{\n\treturn param ? &stacktrace_count_trigger_ops : &stacktrace_trigger_ops;\n}"
  },
  {
    "function_name": "stacktrace_trigger_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1560-1566",
    "snippet": "static int\nstacktrace_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t\t struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"stacktrace\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_print",
          "args": [
            "\"stacktrace\"",
            "m",
            "(void *)data->count",
            "data->filter_str"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "398-417",
          "snippet": "static int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic int\nstacktrace_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t\t struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"stacktrace\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}"
  },
  {
    "function_name": "stacktrace_count_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1546-1558",
    "snippet": "static void\nstacktrace_count_trigger(struct event_trigger_data *data,\n\t\t\t struct trace_buffer *buffer, void *rec,\n\t\t\t struct ring_buffer_event *event)\n{\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tstacktrace_trigger(data, buffer, rec, event);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stacktrace_trigger",
          "args": [
            "data",
            "buffer",
            "rec",
            "event"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "stacktrace_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1538-1544",
          "snippet": "static void\nstacktrace_trigger(struct event_trigger_data *data,\n\t\t   struct trace_buffer *buffer,  void *rec,\n\t\t   struct ring_buffer_event *event)\n{\n\ttrace_dump_stack(STACK_SKIP);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [
            "#define STACK_SKIP 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\n#define STACK_SKIP 4\n\nstatic void\nstacktrace_trigger(struct event_trigger_data *data,\n\t\t   struct trace_buffer *buffer,  void *rec,\n\t\t   struct ring_buffer_event *event)\n{\n\ttrace_dump_stack(STACK_SKIP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic void\nstacktrace_count_trigger(struct event_trigger_data *data,\n\t\t\t struct trace_buffer *buffer, void *rec,\n\t\t\t struct ring_buffer_event *event)\n{\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tstacktrace_trigger(data, buffer, rec, event);\n}"
  },
  {
    "function_name": "stacktrace_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1538-1544",
    "snippet": "static void\nstacktrace_trigger(struct event_trigger_data *data,\n\t\t   struct trace_buffer *buffer,  void *rec,\n\t\t   struct ring_buffer_event *event)\n{\n\ttrace_dump_stack(STACK_SKIP);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [
      "#define STACK_SKIP 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_dump_stack",
          "args": [
            "STACK_SKIP"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "trace_dump_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "3106-3117",
          "snippet": "void trace_dump_stack(int skip)\n{\n\tif (tracing_disabled || tracing_selftest_running)\n\t\treturn;\n\n#ifndef CONFIG_UNWINDER_ORC\n\t/* Skip 1 to skip this function. */\n\tskip++;\n#endif\n\t__ftrace_trace_stack(global_trace.array_buffer.buffer,\n\t\t\t     tracing_gen_ctx(), skip, NULL);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid trace_dump_stack(int skip)\n{\n\tif (tracing_disabled || tracing_selftest_running)\n\t\treturn;\n\n#ifndef CONFIG_UNWINDER_ORC\n\t/* Skip 1 to skip this function. */\n\tskip++;\n#endif\n\t__ftrace_trace_stack(global_trace.array_buffer.buffer,\n\t\t\t     tracing_gen_ctx(), skip, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\n#define STACK_SKIP 4\n\nstatic void\nstacktrace_trigger(struct event_trigger_data *data,\n\t\t   struct trace_buffer *buffer,  void *rec,\n\t\t   struct ring_buffer_event *event)\n{\n\ttrace_dump_stack(STACK_SKIP);\n}"
  },
  {
    "function_name": "register_trigger_snapshot_cmd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1517-1517",
    "snippet": "static __init int register_trigger_snapshot_cmd(void) { return 0; }",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic __init int register_trigger_snapshot_cmd(void) { return 0; }"
  },
  {
    "function_name": "register_trigger_snapshot_cmd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1507-1515",
    "snippet": "static __init int register_trigger_snapshot_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_snapshot_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_event_command",
          "args": [
            "&trigger_snapshot_cmd"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "365-382",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic __init int register_trigger_snapshot_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_snapshot_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "snapshot_get_trigger_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1491-1495",
    "snippet": "static struct event_trigger_ops *\nsnapshot_get_trigger_ops(char *cmd, char *param)\n{\n\treturn param ? &snapshot_count_trigger_ops : &snapshot_trigger_ops;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic struct event_trigger_ops *\nsnapshot_get_trigger_ops(char *cmd, char *param)\n{\n\treturn param ? &snapshot_count_trigger_ops : &snapshot_trigger_ops;\n}"
  },
  {
    "function_name": "snapshot_trigger_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1469-1475",
    "snippet": "static int\nsnapshot_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"snapshot\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_print",
          "args": [
            "\"snapshot\"",
            "m",
            "(void *)data->count",
            "data->filter_str"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "398-417",
          "snippet": "static int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic int\nsnapshot_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"snapshot\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}"
  },
  {
    "function_name": "register_snapshot_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1458-1467",
    "snippet": "static int\nregister_snapshot_trigger(char *glob,\n\t\t\t  struct event_trigger_data *data,\n\t\t\t  struct trace_event_file *file)\n{\n\tif (tracing_alloc_snapshot_instance(file->tr) != 0)\n\t\treturn 0;\n\n\treturn register_trigger(glob, data, file);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_trigger",
          "args": [
            "glob",
            "data",
            "file"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "event_enable_unregister_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1915-1942",
          "snippet": "void event_enable_unregister_trigger(char *glob,\n\t\t\t\t     struct event_trigger_data *test,\n\t\t\t\t     struct trace_event_file *file)\n{\n\tstruct enable_trigger_data *test_enable_data = test->private_data;\n\tstruct enable_trigger_data *enable_data;\n\tstruct event_trigger_data *data;\n\tbool unregistered = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tenable_data = data->private_data;\n\t\tif (enable_data &&\n\t\t    (data->cmd_ops->trigger_type ==\n\t\t     test->cmd_ops->trigger_type) &&\n\t\t    (enable_data->file == test_enable_data->file)) {\n\t\t\tunregistered = true;\n\t\t\tlist_del_rcu(&data->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unregistered && data->ops->free)\n\t\tdata->ops->free(data->ops, data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid event_enable_unregister_trigger(char *glob,\n\t\t\t\t     struct event_trigger_data *test,\n\t\t\t\t     struct trace_event_file *file)\n{\n\tstruct enable_trigger_data *test_enable_data = test->private_data;\n\tstruct enable_trigger_data *enable_data;\n\tstruct event_trigger_data *data;\n\tbool unregistered = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tenable_data = data->private_data;\n\t\tif (enable_data &&\n\t\t    (data->cmd_ops->trigger_type ==\n\t\t     test->cmd_ops->trigger_type) &&\n\t\t    (enable_data->file == test_enable_data->file)) {\n\t\t\tunregistered = true;\n\t\t\tlist_del_rcu(&data->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unregistered && data->ops->free)\n\t\tdata->ops->free(data->ops, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_alloc_snapshot_instance",
          "args": [
            "file->tr"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_alloc_snapshot_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1195-1211",
          "snippet": "int tracing_alloc_snapshot_instance(struct trace_array *tr)\n{\n\tint ret;\n\n\tif (!tr->allocated_snapshot) {\n\n\t\t/* allocate spare buffer */\n\t\tret = resize_buffer_duplicate_size(&tr->max_buffer,\n\t\t\t\t   &tr->array_buffer, RING_BUFFER_ALL_CPUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttr->allocated_snapshot = true;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint tracing_alloc_snapshot_instance(struct trace_array *tr)\n{\n\tint ret;\n\n\tif (!tr->allocated_snapshot) {\n\n\t\t/* allocate spare buffer */\n\t\tret = resize_buffer_duplicate_size(&tr->max_buffer,\n\t\t\t\t   &tr->array_buffer, RING_BUFFER_ALL_CPUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttr->allocated_snapshot = true;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic int\nregister_snapshot_trigger(char *glob,\n\t\t\t  struct event_trigger_data *data,\n\t\t\t  struct trace_event_file *file)\n{\n\tif (tracing_alloc_snapshot_instance(file->tr) != 0)\n\t\treturn 0;\n\n\treturn register_trigger(glob, data, file);\n}"
  },
  {
    "function_name": "snapshot_count_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1444-1456",
    "snippet": "static void\nsnapshot_count_trigger(struct event_trigger_data *data,\n\t\t       struct trace_buffer *buffer, void *rec,\n\t\t       struct ring_buffer_event *event)\n{\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tsnapshot_trigger(data, buffer, rec, event);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snapshot_trigger",
          "args": [
            "data",
            "buffer",
            "rec",
            "event"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1431-1442",
          "snippet": "static void\nsnapshot_trigger(struct event_trigger_data *data,\n\t\t struct trace_buffer *buffer, void *rec,\n\t\t struct ring_buffer_event *event)\n{\n\tstruct trace_event_file *file = data->private_data;\n\n\tif (file)\n\t\ttracing_snapshot_instance(file->tr);\n\telse\n\t\ttracing_snapshot();\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic void\nsnapshot_trigger(struct event_trigger_data *data,\n\t\t struct trace_buffer *buffer, void *rec,\n\t\t struct ring_buffer_event *event)\n{\n\tstruct trace_event_file *file = data->private_data;\n\n\tif (file)\n\t\ttracing_snapshot_instance(file->tr);\n\telse\n\t\ttracing_snapshot();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic void\nsnapshot_count_trigger(struct event_trigger_data *data,\n\t\t       struct trace_buffer *buffer, void *rec,\n\t\t       struct ring_buffer_event *event)\n{\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\tsnapshot_trigger(data, buffer, rec, event);\n}"
  },
  {
    "function_name": "snapshot_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1431-1442",
    "snippet": "static void\nsnapshot_trigger(struct event_trigger_data *data,\n\t\t struct trace_buffer *buffer, void *rec,\n\t\t struct ring_buffer_event *event)\n{\n\tstruct trace_event_file *file = data->private_data;\n\n\tif (file)\n\t\ttracing_snapshot_instance(file->tr);\n\telse\n\t\ttracing_snapshot();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_snapshot",
          "args": [],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_snapshot_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1381-1385",
          "snippet": "void tracing_snapshot_alloc(void)\n{\n\t/* Give warning */\n\ttracing_snapshot();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nvoid tracing_snapshot_alloc(void)\n{\n\t/* Give warning */\n\ttracing_snapshot();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_snapshot_instance",
          "args": [
            "file->tr"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_snapshot_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1116-1119",
          "snippet": "void tracing_snapshot_instance(struct trace_array *tr)\n{\n\ttracing_snapshot_instance_cond(tr, NULL);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid tracing_snapshot_instance(struct trace_array *tr)\n{\n\ttracing_snapshot_instance_cond(tr, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic void\nsnapshot_trigger(struct event_trigger_data *data,\n\t\t struct trace_buffer *buffer, void *rec,\n\t\t struct ring_buffer_event *event)\n{\n\tstruct trace_event_file *file = data->private_data;\n\n\tif (file)\n\t\ttracing_snapshot_instance(file->tr);\n\telse\n\t\ttracing_snapshot();\n}"
  },
  {
    "function_name": "onoff_get_trigger_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1393-1407",
    "snippet": "static struct event_trigger_ops *\nonoff_get_trigger_ops(char *cmd, char *param)\n{\n\tstruct event_trigger_ops *ops;\n\n\t/* we register both traceon and traceoff to this callback */\n\tif (strcmp(cmd, \"traceon\") == 0)\n\t\tops = param ? &traceon_count_trigger_ops :\n\t\t\t&traceon_trigger_ops;\n\telse\n\t\tops = param ? &traceoff_count_trigger_ops :\n\t\t\t&traceoff_trigger_ops;\n\n\treturn ops;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_trigger_ops traceon_trigger_ops = {\n\t.trigger\t\t= traceon_trigger,\n\t.print\t\t\t= traceon_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};",
      "static struct event_trigger_ops traceon_count_trigger_ops = {\n\t.trigger\t\t= traceon_count_trigger,\n\t.print\t\t\t= traceon_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};",
      "static struct event_trigger_ops traceoff_trigger_ops = {\n\t.trigger\t\t= traceoff_trigger,\n\t.print\t\t\t= traceoff_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};",
      "static struct event_trigger_ops traceoff_count_trigger_ops = {\n\t.trigger\t\t= traceoff_count_trigger,\n\t.print\t\t\t= traceoff_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"traceon\""
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic struct event_trigger_ops traceon_trigger_ops = {\n\t.trigger\t\t= traceon_trigger,\n\t.print\t\t\t= traceon_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};\nstatic struct event_trigger_ops traceon_count_trigger_ops = {\n\t.trigger\t\t= traceon_count_trigger,\n\t.print\t\t\t= traceon_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};\nstatic struct event_trigger_ops traceoff_trigger_ops = {\n\t.trigger\t\t= traceoff_trigger,\n\t.print\t\t\t= traceoff_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};\nstatic struct event_trigger_ops traceoff_count_trigger_ops = {\n\t.trigger\t\t= traceoff_count_trigger,\n\t.print\t\t\t= traceoff_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_trigger_free,\n};\n\nstatic struct event_trigger_ops *\nonoff_get_trigger_ops(char *cmd, char *param)\n{\n\tstruct event_trigger_ops *ops;\n\n\t/* we register both traceon and traceoff to this callback */\n\tif (strcmp(cmd, \"traceon\") == 0)\n\t\tops = param ? &traceon_count_trigger_ops :\n\t\t\t&traceon_trigger_ops;\n\telse\n\t\tops = param ? &traceoff_count_trigger_ops :\n\t\t\t&traceoff_trigger_ops;\n\n\treturn ops;\n}"
  },
  {
    "function_name": "traceoff_trigger_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1357-1363",
    "snippet": "static int\ntraceoff_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"traceoff\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_print",
          "args": [
            "\"traceoff\"",
            "m",
            "(void *)data->count",
            "data->filter_str"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "398-417",
          "snippet": "static int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic int\ntraceoff_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"traceoff\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}"
  },
  {
    "function_name": "traceon_trigger_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1349-1355",
    "snippet": "static int\ntraceon_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t      struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"traceon\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_print",
          "args": [
            "\"traceon\"",
            "m",
            "(void *)data->count",
            "data->filter_str"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "398-417",
          "snippet": "static int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic int\ntraceon_trigger_print(struct seq_file *m, struct event_trigger_ops *ops,\n\t\t      struct event_trigger_data *data)\n{\n\treturn event_trigger_print(\"traceon\", m, (void *)data->count,\n\t\t\t\t   data->filter_str);\n}"
  },
  {
    "function_name": "traceoff_count_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1332-1347",
    "snippet": "static void\ntraceoff_count_trigger(struct event_trigger_data *data,\n\t\t       struct trace_buffer *buffer, void *rec,\n\t\t       struct ring_buffer_event *event)\n{\n\tif (!tracing_is_on())\n\t\treturn;\n\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\ttracing_off();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_off",
          "args": [],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1429-1432",
          "snippet": "void tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_is_on",
          "args": [],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1460-1463",
          "snippet": "int tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic void\ntraceoff_count_trigger(struct event_trigger_data *data,\n\t\t       struct trace_buffer *buffer, void *rec,\n\t\t       struct ring_buffer_event *event)\n{\n\tif (!tracing_is_on())\n\t\treturn;\n\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\ttracing_off();\n}"
  },
  {
    "function_name": "traceoff_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1321-1330",
    "snippet": "static void\ntraceoff_trigger(struct event_trigger_data *data,\n\t\t struct trace_buffer *buffer, void *rec,\n\t\t struct ring_buffer_event *event)\n{\n\tif (!tracing_is_on())\n\t\treturn;\n\n\ttracing_off();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_off",
          "args": [],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1429-1432",
          "snippet": "void tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_is_on",
          "args": [],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1460-1463",
          "snippet": "int tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic void\ntraceoff_trigger(struct event_trigger_data *data,\n\t\t struct trace_buffer *buffer, void *rec,\n\t\t struct ring_buffer_event *event)\n{\n\tif (!tracing_is_on())\n\t\treturn;\n\n\ttracing_off();\n}"
  },
  {
    "function_name": "traceon_count_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1304-1319",
    "snippet": "static void\ntraceon_count_trigger(struct event_trigger_data *data,\n\t\t      struct trace_buffer *buffer, void *rec,\n\t\t      struct ring_buffer_event *event)\n{\n\tif (tracing_is_on())\n\t\treturn;\n\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\ttracing_on();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_on",
          "args": [],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "965-968",
          "snippet": "void tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_is_on",
          "args": [],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1460-1463",
          "snippet": "int tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic void\ntraceon_count_trigger(struct event_trigger_data *data,\n\t\t      struct trace_buffer *buffer, void *rec,\n\t\t      struct ring_buffer_event *event)\n{\n\tif (tracing_is_on())\n\t\treturn;\n\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\ttracing_on();\n}"
  },
  {
    "function_name": "traceon_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1293-1302",
    "snippet": "static void\ntraceon_trigger(struct event_trigger_data *data,\n\t\tstruct trace_buffer *buffer, void *rec,\n\t\tstruct ring_buffer_event *event)\n{\n\tif (tracing_is_on())\n\t\treturn;\n\n\ttracing_on();\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_on",
          "args": [],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "965-968",
          "snippet": "void tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_is_on",
          "args": [],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1460-1463",
          "snippet": "int tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic void\ntraceon_trigger(struct event_trigger_data *data,\n\t\tstruct trace_buffer *buffer, void *rec,\n\t\tstruct ring_buffer_event *event)\n{\n\tif (tracing_is_on())\n\t\treturn;\n\n\ttracing_on();\n}"
  },
  {
    "function_name": "get_named_trigger_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1287-1291",
    "snippet": "struct event_trigger_data *\nget_named_trigger_data(struct event_trigger_data *data)\n{\n\treturn data->named_data;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstruct event_trigger_data *\nget_named_trigger_data(struct event_trigger_data *data)\n{\n\treturn data->named_data;\n}"
  },
  {
    "function_name": "set_named_trigger_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1281-1285",
    "snippet": "void set_named_trigger_data(struct event_trigger_data *data,\n\t\t\t    struct event_trigger_data *named_data)\n{\n\tdata->named_data = named_data;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid set_named_trigger_data(struct event_trigger_data *data,\n\t\t\t    struct event_trigger_data *named_data)\n{\n\tdata->named_data = named_data;\n}"
  },
  {
    "function_name": "unpause_named_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1264-1267",
    "snippet": "void unpause_named_trigger(struct event_trigger_data *data)\n{\n\t__pause_named_trigger(data, false);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pause_named_trigger",
          "args": [
            "data",
            "false"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "__pause_named_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1225-1239",
          "snippet": "static void __pause_named_trigger(struct event_trigger_data *data, bool pause)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry(test, &named_triggers, named_list) {\n\t\tif (strcmp(test->name, data->name) == 0) {\n\t\t\tif (pause) {\n\t\t\t\ttest->paused_tmp = test->paused;\n\t\t\t\ttest->paused = true;\n\t\t\t} else {\n\t\t\t\ttest->paused = test->paused_tmp;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(named_triggers);\n\nstatic void __pause_named_trigger(struct event_trigger_data *data, bool pause)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry(test, &named_triggers, named_list) {\n\t\tif (strcmp(test->name, data->name) == 0) {\n\t\t\tif (pause) {\n\t\t\t\ttest->paused_tmp = test->paused;\n\t\t\t\ttest->paused = true;\n\t\t\t} else {\n\t\t\t\ttest->paused = test->paused_tmp;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid unpause_named_trigger(struct event_trigger_data *data)\n{\n\t__pause_named_trigger(data, false);\n}"
  },
  {
    "function_name": "pause_named_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1250-1253",
    "snippet": "void pause_named_trigger(struct event_trigger_data *data)\n{\n\t__pause_named_trigger(data, true);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pause_named_trigger",
          "args": [
            "data",
            "true"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "__pause_named_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1225-1239",
          "snippet": "static void __pause_named_trigger(struct event_trigger_data *data, bool pause)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry(test, &named_triggers, named_list) {\n\t\tif (strcmp(test->name, data->name) == 0) {\n\t\t\tif (pause) {\n\t\t\t\ttest->paused_tmp = test->paused;\n\t\t\t\ttest->paused = true;\n\t\t\t} else {\n\t\t\t\ttest->paused = test->paused_tmp;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(named_triggers);\n\nstatic void __pause_named_trigger(struct event_trigger_data *data, bool pause)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry(test, &named_triggers, named_list) {\n\t\tif (strcmp(test->name, data->name) == 0) {\n\t\t\tif (pause) {\n\t\t\t\ttest->paused_tmp = test->paused;\n\t\t\t\ttest->paused = true;\n\t\t\t} else {\n\t\t\t\ttest->paused = test->paused_tmp;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid pause_named_trigger(struct event_trigger_data *data)\n{\n\t__pause_named_trigger(data, true);\n}"
  },
  {
    "function_name": "__pause_named_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1225-1239",
    "snippet": "static void __pause_named_trigger(struct event_trigger_data *data, bool pause)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry(test, &named_triggers, named_list) {\n\t\tif (strcmp(test->name, data->name) == 0) {\n\t\t\tif (pause) {\n\t\t\t\ttest->paused_tmp = test->paused;\n\t\t\t\ttest->paused = true;\n\t\t\t} else {\n\t\t\t\ttest->paused = test->paused_tmp;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(named_triggers);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "test->name",
            "data->name"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "test",
            "&named_triggers",
            "named_list"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(named_triggers);\n\nstatic void __pause_named_trigger(struct event_trigger_data *data, bool pause)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry(test, &named_triggers, named_list) {\n\t\tif (strcmp(test->name, data->name) == 0) {\n\t\t\tif (pause) {\n\t\t\t\ttest->paused_tmp = test->paused;\n\t\t\t\ttest->paused = true;\n\t\t\t} else {\n\t\t\t\ttest->paused = test->paused_tmp;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "del_named_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1217-1223",
    "snippet": "void del_named_trigger(struct event_trigger_data *data)\n{\n\tkfree(data->name);\n\tdata->name = NULL;\n\n\tlist_del(&data->named_list);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&data->named_list"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data->name"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid del_named_trigger(struct event_trigger_data *data)\n{\n\tkfree(data->name);\n\tdata->name = NULL;\n\n\tlist_del(&data->named_list);\n}"
  },
  {
    "function_name": "save_named_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1202-1211",
    "snippet": "int save_named_trigger(const char *name, struct event_trigger_data *data)\n{\n\tdata->name = kstrdup(name, GFP_KERNEL);\n\tif (!data->name)\n\t\treturn -ENOMEM;\n\n\tlist_add(&data->named_list, &named_triggers);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(named_triggers);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&data->named_list",
            "&named_triggers"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(named_triggers);\n\nint save_named_trigger(const char *name, struct event_trigger_data *data)\n{\n\tdata->name = kstrdup(name, GFP_KERNEL);\n\tif (!data->name)\n\t\treturn -ENOMEM;\n\n\tlist_add(&data->named_list, &named_triggers);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_named_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1183-1193",
    "snippet": "bool is_named_trigger(struct event_trigger_data *test)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (test == data)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(named_triggers);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "data",
            "&named_triggers",
            "named_list"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(named_triggers);\n\nbool is_named_trigger(struct event_trigger_data *test)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (test == data)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "find_named_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1160-1175",
    "snippet": "struct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(named_triggers);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "data->name",
            "name"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "data",
            "&named_triggers",
            "named_list"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(named_triggers);\n\nstruct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "set_trigger_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "1091-1142",
    "snippet": "int set_trigger_filter(char *filter_str,\n\t\t       struct event_trigger_data *trigger_data,\n\t\t       struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data = trigger_data;\n\tstruct event_filter *filter = NULL, *tmp;\n\tint ret = -EINVAL;\n\tchar *s;\n\n\tif (!filter_str) /* clear the current filter */\n\t\tgoto assign;\n\n\ts = strsep(&filter_str, \" \\t\");\n\n\tif (!strlen(s) || strcmp(s, \"if\") != 0)\n\t\tgoto out;\n\n\tif (!filter_str)\n\t\tgoto out;\n\n\t/* The filter is for the 'trigger' event, not the triggered event */\n\tret = create_event_filter(file->tr, file->event_call,\n\t\t\t\t  filter_str, false, &filter);\n\t/*\n\t * If create_event_filter() fails, filter still needs to be freed.\n\t * Which the calling code will do with data->filter.\n\t */\n assign:\n\ttmp = rcu_access_pointer(data->filter);\n\n\trcu_assign_pointer(data->filter, filter);\n\n\tif (tmp) {\n\t\t/* Make sure the call is done with the filter */\n\t\ttracepoint_synchronize_unregister();\n\t\tfree_event_filter(tmp);\n\t}\n\n\tkfree(data->filter_str);\n\tdata->filter_str = NULL;\n\n\tif (filter_str) {\n\t\tdata->filter_str = kstrdup(filter_str, GFP_KERNEL);\n\t\tif (!data->filter_str) {\n\t\t\tfree_event_filter(rcu_access_pointer(data->filter));\n\t\t\tdata->filter = NULL;\n\t\t\tret = -ENOMEM;\n\t\t}\n\t}\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_event_filter",
          "args": [
            "rcu_access_pointer(data->filter)"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "free_event_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1134-1137",
          "snippet": "void free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "data->filter"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "filter_str",
            "GFP_KERNEL"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data->filter_str"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "data->filter",
            "filter"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "data->filter"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_event_filter",
          "args": [
            "file->tr",
            "file->event_call",
            "filter_str",
            "false",
            "&filter"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "create_event_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "1857-1863",
          "snippet": "int create_event_filter(struct trace_array *tr,\n\t\t\tstruct trace_event_call *call,\n\t\t\tchar *filter_str, bool set_str,\n\t\t\tstruct event_filter **filterp)\n{\n\treturn create_filter(tr, call, filter_str, set_str, filterp);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nint create_event_filter(struct trace_array *tr,\n\t\t\tstruct trace_event_call *call,\n\t\t\tchar *filter_str, bool set_str,\n\t\t\tstruct event_filter **filterp)\n{\n\treturn create_filter(tr, call, filter_str, set_str, filterp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"if\""
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&filter_str",
            "\" \\t\""
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint set_trigger_filter(char *filter_str,\n\t\t       struct event_trigger_data *trigger_data,\n\t\t       struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data = trigger_data;\n\tstruct event_filter *filter = NULL, *tmp;\n\tint ret = -EINVAL;\n\tchar *s;\n\n\tif (!filter_str) /* clear the current filter */\n\t\tgoto assign;\n\n\ts = strsep(&filter_str, \" \\t\");\n\n\tif (!strlen(s) || strcmp(s, \"if\") != 0)\n\t\tgoto out;\n\n\tif (!filter_str)\n\t\tgoto out;\n\n\t/* The filter is for the 'trigger' event, not the triggered event */\n\tret = create_event_filter(file->tr, file->event_call,\n\t\t\t\t  filter_str, false, &filter);\n\t/*\n\t * If create_event_filter() fails, filter still needs to be freed.\n\t * Which the calling code will do with data->filter.\n\t */\n assign:\n\ttmp = rcu_access_pointer(data->filter);\n\n\trcu_assign_pointer(data->filter, filter);\n\n\tif (tmp) {\n\t\t/* Make sure the call is done with the filter */\n\t\ttracepoint_synchronize_unregister();\n\t\tfree_event_filter(tmp);\n\t}\n\n\tkfree(data->filter_str);\n\tdata->filter_str = NULL;\n\n\tif (filter_str) {\n\t\tdata->filter_str = kstrdup(filter_str, GFP_KERNEL);\n\t\tif (!data->filter_str) {\n\t\t\tfree_event_filter(rcu_access_pointer(data->filter));\n\t\t\tdata->filter = NULL;\n\t\t\tret = -ENOMEM;\n\t\t}\n\t}\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "event_trigger_parse",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "980-1073",
    "snippet": "static int\nevent_trigger_parse(struct event_command *cmd_ops,\n\t\t    struct trace_event_file *file,\n\t\t    char *glob, char *cmd, char *param)\n{\n\tstruct event_trigger_data *trigger_data;\n\tstruct event_trigger_ops *trigger_ops;\n\tchar *trigger = NULL;\n\tchar *number;\n\tint ret;\n\n\t/* separate the trigger from the filter (t:n [if filter]) */\n\tif (param && isdigit(param[0])) {\n\t\ttrigger = strsep(&param, \" \\t\");\n\t\tif (param) {\n\t\t\tparam = skip_spaces(param);\n\t\t\tif (!*param)\n\t\t\t\tparam = NULL;\n\t\t}\n\t}\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\tret = -ENOMEM;\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data)\n\t\tgoto out;\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\ttrigger_data->private_data = file;\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tINIT_LIST_HEAD(&trigger_data->named_list);\n\n\tif (glob[0] == '!') {\n\t\tcmd_ops->unreg(glob+1, trigger_data, file);\n\t\tkfree(trigger_data);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (trigger) {\n\t\tnumber = strsep(&trigger, \":\");\n\n\t\tret = -EINVAL;\n\t\tif (!strlen(number))\n\t\t\tgoto out_free;\n\n\t\t/*\n\t\t * We use the callback data field (which is a pointer)\n\t\t * as our counter.\n\t\t */\n\t\tret = kstrtoul(number, 0, &trigger_data->count);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tif (!param) /* if param is non-empty, it's supposed to be a filter */\n\t\tgoto out_reg;\n\n\tif (!cmd_ops->set_filter)\n\t\tgoto out_reg;\n\n\tret = cmd_ops->set_filter(param, trigger_data, file);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n out_reg:\n\t/* Up the trigger_data count to make sure reg doesn't free it on failure */\n\tevent_trigger_init(trigger_ops, trigger_data);\n\tret = cmd_ops->reg(glob, trigger_data, file);\n\t/*\n\t * The above returns on success the # of functions enabled,\n\t * but if it didn't find any functions it returns zero.\n\t * Consider no functions a failure too.\n\t */\n\tif (!ret) {\n\t\tcmd_ops->unreg(glob, trigger_data, file);\n\t\tret = -ENOENT;\n\t} else if (ret > 0)\n\t\tret = 0;\n\n\t/* Down the counter of trigger_data or free it if not used anymore */\n\tevent_trigger_free(trigger_ops, trigger_data);\n out:\n\treturn ret;\n\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\tkfree(trigger_data);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "trigger_data"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->set_filter",
          "args": [
            "NULL",
            "trigger_data",
            "NULL"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_trigger_free",
          "args": [
            "trigger_ops",
            "trigger_data"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "448-458",
          "snippet": "static void\nevent_trigger_free(struct event_trigger_ops *ops,\n\t\t   struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref)\n\t\ttrigger_data_free(data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic void\nevent_trigger_free(struct event_trigger_ops *ops,\n\t\t   struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref)\n\t\ttrigger_data_free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->unreg",
          "args": [
            "glob",
            "trigger_data",
            "file"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->reg",
          "args": [
            "glob",
            "trigger_data",
            "file"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_trigger_init",
          "args": [
            "trigger_ops",
            "trigger_data"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "431-436",
          "snippet": "int event_trigger_init(struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\tdata->ref++;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint event_trigger_init(struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\tdata->ref++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->set_filter",
          "args": [
            "param",
            "trigger_data",
            "file"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "number",
            "0",
            "&trigger_data->count"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "number"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&trigger",
            "\":\""
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->unreg",
          "args": [
            "glob+1",
            "trigger_data",
            "file"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&trigger_data->named_list"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&trigger_data->list"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*trigger_data)",
            "GFP_KERNEL"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->get_trigger_ops",
          "args": [
            "cmd",
            "trigger"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "param"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "proc_skip_spaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "333-340",
          "snippet": "static size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\" \\t\""
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "param[0]"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic int\nevent_trigger_parse(struct event_command *cmd_ops,\n\t\t    struct trace_event_file *file,\n\t\t    char *glob, char *cmd, char *param)\n{\n\tstruct event_trigger_data *trigger_data;\n\tstruct event_trigger_ops *trigger_ops;\n\tchar *trigger = NULL;\n\tchar *number;\n\tint ret;\n\n\t/* separate the trigger from the filter (t:n [if filter]) */\n\tif (param && isdigit(param[0])) {\n\t\ttrigger = strsep(&param, \" \\t\");\n\t\tif (param) {\n\t\t\tparam = skip_spaces(param);\n\t\t\tif (!*param)\n\t\t\t\tparam = NULL;\n\t\t}\n\t}\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\tret = -ENOMEM;\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data)\n\t\tgoto out;\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\ttrigger_data->private_data = file;\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tINIT_LIST_HEAD(&trigger_data->named_list);\n\n\tif (glob[0] == '!') {\n\t\tcmd_ops->unreg(glob+1, trigger_data, file);\n\t\tkfree(trigger_data);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (trigger) {\n\t\tnumber = strsep(&trigger, \":\");\n\n\t\tret = -EINVAL;\n\t\tif (!strlen(number))\n\t\t\tgoto out_free;\n\n\t\t/*\n\t\t * We use the callback data field (which is a pointer)\n\t\t * as our counter.\n\t\t */\n\t\tret = kstrtoul(number, 0, &trigger_data->count);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tif (!param) /* if param is non-empty, it's supposed to be a filter */\n\t\tgoto out_reg;\n\n\tif (!cmd_ops->set_filter)\n\t\tgoto out_reg;\n\n\tret = cmd_ops->set_filter(param, trigger_data, file);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n out_reg:\n\t/* Up the trigger_data count to make sure reg doesn't free it on failure */\n\tevent_trigger_init(trigger_ops, trigger_data);\n\tret = cmd_ops->reg(glob, trigger_data, file);\n\t/*\n\t * The above returns on success the # of functions enabled,\n\t * but if it didn't find any functions it returns zero.\n\t * Consider no functions a failure too.\n\t */\n\tif (!ret) {\n\t\tcmd_ops->unreg(glob, trigger_data, file);\n\t\tret = -ENOENT;\n\t} else if (ret > 0)\n\t\tret = 0;\n\n\t/* Down the counter of trigger_data or free it if not used anymore */\n\tevent_trigger_free(trigger_ops, trigger_data);\n out:\n\treturn ret;\n\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\tkfree(trigger_data);\n\tgoto out;\n}"
  },
  {
    "function_name": "event_trigger_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "928-958",
    "snippet": "int event_trigger_register(struct event_command *cmd_ops,\n\t\t\t   struct trace_event_file *file,\n\t\t\t   char *glob,\n\t\t\t   char *cmd,\n\t\t\t   char *param,\n\t\t\t   struct event_trigger_data *trigger_data,\n\t\t\t   int *n_registered)\n{\n\tint ret;\n\n\tif (n_registered)\n\t\t*n_registered = 0;\n\n\tret = cmd_ops->reg(glob, trigger_data, file);\n\t/*\n\t * The above returns on success the # of functions enabled,\n\t * but if it didn't find any functions it returns zero.\n\t * Consider no functions a failure too.\n\t */\n\tif (!ret) {\n\t\tcmd_ops->unreg(glob, trigger_data, file);\n\t\tret = -ENOENT;\n\t} else if (ret > 0) {\n\t\tif (n_registered)\n\t\t\t*n_registered = ret;\n\t\t/* Just return zero, not the number of enabled functions */\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmd_ops->unreg",
          "args": [
            "glob",
            "trigger_data",
            "file"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->reg",
          "args": [
            "glob",
            "trigger_data",
            "file"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint event_trigger_register(struct event_command *cmd_ops,\n\t\t\t   struct trace_event_file *file,\n\t\t\t   char *glob,\n\t\t\t   char *cmd,\n\t\t\t   char *param,\n\t\t\t   struct event_trigger_data *trigger_data,\n\t\t\t   int *n_registered)\n{\n\tint ret;\n\n\tif (n_registered)\n\t\t*n_registered = 0;\n\n\tret = cmd_ops->reg(glob, trigger_data, file);\n\t/*\n\t * The above returns on success the # of functions enabled,\n\t * but if it didn't find any functions it returns zero.\n\t * Consider no functions a failure too.\n\t */\n\tif (!ret) {\n\t\tcmd_ops->unreg(glob, trigger_data, file);\n\t\tret = -ENOENT;\n\t} else if (ret > 0) {\n\t\tif (n_registered)\n\t\t\t*n_registered = ret;\n\t\t/* Just return zero, not the number of enabled functions */\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_trigger_reset_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "904-909",
    "snippet": "void event_trigger_reset_filter(struct event_command *cmd_ops,\n\t\t\t\tstruct event_trigger_data *trigger_data)\n{\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmd_ops->set_filter",
          "args": [
            "NULL",
            "trigger_data",
            "NULL"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid event_trigger_reset_filter(struct event_command *cmd_ops,\n\t\t\t\tstruct event_trigger_data *trigger_data)\n{\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n}"
  },
  {
    "function_name": "event_trigger_set_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "886-895",
    "snippet": "int event_trigger_set_filter(struct event_command *cmd_ops,\n\t\t\t     struct trace_event_file *file,\n\t\t\t     char *param,\n\t\t\t     struct event_trigger_data *trigger_data)\n{\n\tif (param && cmd_ops->set_filter)\n\t\treturn cmd_ops->set_filter(param, trigger_data, file);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmd_ops->set_filter",
          "args": [
            "param",
            "trigger_data",
            "file"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint event_trigger_set_filter(struct event_command *cmd_ops,\n\t\t\t     struct trace_event_file *file,\n\t\t\t     char *param,\n\t\t\t     struct event_trigger_data *trigger_data)\n{\n\tif (param && cmd_ops->set_filter)\n\t\treturn cmd_ops->set_filter(param, trigger_data, file);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_trigger_parse_num",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "852-872",
    "snippet": "int event_trigger_parse_num(char *param,\n\t\t\t    struct event_trigger_data *trigger_data)\n{\n\tchar *number;\n\tint ret = 0;\n\n\tif (param) {\n\t\tnumber = strsep(&param, \":\");\n\n\t\tif (!strlen(number))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * We use the callback data field (which is a pointer)\n\t\t * as our counter.\n\t\t */\n\t\tret = kstrtoul(number, 0, &trigger_data->count);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "number",
            "0",
            "&trigger_data->count"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "number"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\":\""
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint event_trigger_parse_num(char *param,\n\t\t\t    struct event_trigger_data *trigger_data)\n{\n\tchar *number;\n\tint ret = 0;\n\n\tif (param) {\n\t\tnumber = strsep(&param, \":\");\n\n\t\tif (!strlen(number))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * We use the callback data field (which is a pointer)\n\t\t * as our counter.\n\t\t */\n\t\tret = kstrtoul(number, 0, &trigger_data->count);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_trigger_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "816-840",
    "snippet": "struct event_trigger_data *event_trigger_alloc(struct event_command *cmd_ops,\n\t\t\t\t\t       char *cmd,\n\t\t\t\t\t       char *param,\n\t\t\t\t\t       void *private_data)\n{\n\tstruct event_trigger_data *trigger_data;\n\tstruct event_trigger_ops *trigger_ops;\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, param);\n\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data)\n\t\treturn NULL;\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\ttrigger_data->private_data = private_data;\n\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tINIT_LIST_HEAD(&trigger_data->named_list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\treturn trigger_data;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "trigger_data->filter",
            "NULL"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&trigger_data->named_list"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&trigger_data->list"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*trigger_data)",
            "GFP_KERNEL"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->get_trigger_ops",
          "args": [
            "cmd",
            "param"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstruct event_trigger_data *event_trigger_alloc(struct event_command *cmd_ops,\n\t\t\t\t\t       char *cmd,\n\t\t\t\t\t       char *param,\n\t\t\t\t\t       void *private_data)\n{\n\tstruct event_trigger_data *trigger_data;\n\tstruct event_trigger_ops *trigger_ops;\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, param);\n\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data)\n\t\treturn NULL;\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\ttrigger_data->private_data = private_data;\n\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tINIT_LIST_HEAD(&trigger_data->named_list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\treturn trigger_data;\n}"
  },
  {
    "function_name": "event_trigger_separate_filter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "757-798",
    "snippet": "int event_trigger_separate_filter(char *param_and_filter, char **param,\n\t\t\t\t  char **filter, bool param_required)\n{\n\tint ret = 0;\n\n\t*param = *filter = NULL;\n\n\tif (!param_and_filter) {\n\t\tif (param_required)\n\t\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Here we check for an optional param. The only legal\n\t * optional param is :n, and if that's the case, continue\n\t * below. Otherwise we assume what's left is a filter and\n\t * return it as the filter string for the caller to deal with.\n\t */\n\tif (!param_required && param_and_filter && !isdigit(param_and_filter[0])) {\n\t\t*filter = param_and_filter;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Separate the param from the filter (param [if filter]).\n\t * Here we have either an optional :n param or a required\n\t * param and an optional filter.\n\t */\n\t*param = strsep(&param_and_filter, \" \\t\");\n\n\t/*\n\t * Here we have a filter, though it may be empty.\n\t */\n\tif (param_and_filter) {\n\t\t*filter = skip_spaces(param_and_filter);\n\t\tif (!**filter)\n\t\t\t*filter = NULL;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "param_and_filter"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "proc_skip_spaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "333-340",
          "snippet": "static size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param_and_filter",
            "\" \\t\""
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "param_and_filter[0]"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint event_trigger_separate_filter(char *param_and_filter, char **param,\n\t\t\t\t  char **filter, bool param_required)\n{\n\tint ret = 0;\n\n\t*param = *filter = NULL;\n\n\tif (!param_and_filter) {\n\t\tif (param_required)\n\t\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Here we check for an optional param. The only legal\n\t * optional param is :n, and if that's the case, continue\n\t * below. Otherwise we assume what's left is a filter and\n\t * return it as the filter string for the caller to deal with.\n\t */\n\tif (!param_required && param_and_filter && !isdigit(param_and_filter[0])) {\n\t\t*filter = param_and_filter;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Separate the param from the filter (param [if filter]).\n\t * Here we have either an optional :n param or a required\n\t * param and an optional filter.\n\t */\n\t*param = strsep(&param_and_filter, \" \\t\");\n\n\t/*\n\t * Here we have a filter, though it may be empty.\n\t */\n\tif (param_and_filter) {\n\t\t*filter = skip_spaces(param_and_filter);\n\t\tif (!**filter)\n\t\t\t*filter = NULL;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "event_trigger_empty_param",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "726-729",
    "snippet": "bool event_trigger_empty_param(const char *param)\n{\n\treturn !param;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nbool event_trigger_empty_param(const char *param)\n{\n\treturn !param;\n}"
  },
  {
    "function_name": "event_trigger_check_remove",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "709-712",
    "snippet": "bool event_trigger_check_remove(const char *glob)\n{\n\treturn (glob && glob[0] == '!') ? true : false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nbool event_trigger_check_remove(const char *glob)\n{\n\treturn (glob && glob[0] == '!') ? true : false;\n}"
  },
  {
    "function_name": "unregister_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "599-620",
    "snippet": "static void unregister_trigger(char *glob,\n\t\t\t       struct event_trigger_data *test,\n\t\t\t       struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool unregistered = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->cmd_ops->trigger_type == test->cmd_ops->trigger_type) {\n\t\t\tunregistered = true;\n\t\t\tlist_del_rcu(&data->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unregistered && data->ops->free)\n\t\tdata->ops->free(data->ops, data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->ops->free",
          "args": [
            "data->ops",
            "data"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "519-538",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "460-478",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&data->list"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "data",
            "&file->triggers",
            "list"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic void unregister_trigger(char *glob,\n\t\t\t       struct event_trigger_data *test,\n\t\t\t       struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool unregistered = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->cmd_ops->trigger_type == test->cmd_ops->trigger_type) {\n\t\t\tunregistered = true;\n\t\t\tlist_del_rcu(&data->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unregistered && data->ops->free)\n\t\tdata->ops->free(data->ops, data);\n}"
  },
  {
    "function_name": "register_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "553-586",
    "snippet": "static int register_trigger(char *glob,\n\t\t\t    struct event_trigger_data *data,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test;\n\tint ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == data->cmd_ops->trigger_type) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (data->ops->init) {\n\t\tret = data->ops->init(data->ops, data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_add_rcu(&data->list, &file->triggers);\n\tret++;\n\n\tupdate_cond_flag(file);\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "519-538",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&data->list"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "1"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "460-478",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&data->list",
            "&file->triggers"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data->ops->init",
          "args": [
            "data->ops",
            "data"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic int register_trigger(char *glob,\n\t\t\t    struct event_trigger_data *data,\n\t\t\t    struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test;\n\tint ret = 0;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == data->cmd_ops->trigger_type) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (data->ops->init) {\n\t\tret = data->ops->init(data->ops, data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_add_rcu(&data->list, &file->triggers);\n\tret++;\n\n\tupdate_cond_flag(file);\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "update_cond_flag",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "519-538",
    "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVENT_FILE_FL_TRIGGER_COND_BIT",
            "&file->flags"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EVENT_FILE_FL_TRIGGER_COND_BIT",
            "&file->flags"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_command_needs_rec",
          "args": [
            "data->cmd_ops"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "event_command_needs_rec",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1838-1841",
          "snippet": "static inline bool event_command_needs_rec(struct event_command *cmd_ops)\n{\n\treturn cmd_ops->flags & EVENT_CMD_FL_NEEDS_REC;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool event_command_needs_rec(struct event_command *cmd_ops)\n{\n\treturn cmd_ops->flags & EVENT_CMD_FL_NEEDS_REC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_command_post_trigger",
          "args": [
            "data->cmd_ops"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "event_command_post_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1833-1836",
          "snippet": "static inline bool event_command_post_trigger(struct event_command *cmd_ops)\n{\n\treturn cmd_ops->flags & EVENT_CMD_FL_POST_TRIGGER;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool event_command_post_trigger(struct event_command *cmd_ops)\n{\n\treturn cmd_ops->flags & EVENT_CMD_FL_POST_TRIGGER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "data",
            "&file->triggers",
            "list"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tlist_for_each_entry(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
  },
  {
    "function_name": "clear_event_triggers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "493-507",
    "snippet": "void\nclear_event_triggers(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tstruct event_trigger_data *data, *n;\n\t\tlist_for_each_entry_safe(data, n, &file->triggers, list) {\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tlist_del_rcu(&data->list);\n\t\t\tif (data->ops->free)\n\t\t\t\tdata->ops->free(data->ops, data);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->ops->free",
          "args": [
            "data->ops",
            "data"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&data->list"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "460-478",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "data",
            "n",
            "&file->triggers",
            "list"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid\nclear_event_triggers(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tstruct event_trigger_data *data, *n;\n\t\tlist_for_each_entry_safe(data, n, &file->triggers, list) {\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tlist_del_rcu(&data->list);\n\t\t\tif (data->ops->free)\n\t\t\t\tdata->ops->free(data->ops, data);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "trace_event_trigger_enable_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "460-478",
    "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_event_enable_disable",
          "args": [
            "file",
            "0",
            "1"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_enable_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "694-698",
          "snippet": "int trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_npid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_npid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nint trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVENT_FILE_FL_TRIGGER_MODE_BIT",
            "&file->flags"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&file->tm_ref"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EVENT_FILE_FL_TRIGGER_MODE_BIT",
            "&file->flags"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&file->tm_ref"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_trigger_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "448-458",
    "snippet": "static void\nevent_trigger_free(struct event_trigger_ops *ops,\n\t\t   struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref)\n\t\ttrigger_data_free(data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trigger_data_free",
          "args": [
            "data"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_data_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "20-29",
          "snippet": "void trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "data->ref <= 0"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic void\nevent_trigger_free(struct event_trigger_ops *ops,\n\t\t   struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref)\n\t\ttrigger_data_free(data);\n}"
  },
  {
    "function_name": "event_trigger_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "431-436",
    "snippet": "int event_trigger_init(struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\tdata->ref++;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nint event_trigger_init(struct event_trigger_ops *ops,\n\t\t       struct event_trigger_data *data)\n{\n\tdata->ref++;\n\treturn 0;\n}"
  },
  {
    "function_name": "event_trigger_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "398-417",
    "snippet": "static int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" if %s\\n\"",
            "filter_str"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\":unlimited\""
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic int\nevent_trigger_print(const char *name, struct seq_file *m,\n\t\t    void *data, char *filter_str)\n{\n\tlong count = (long)data;\n\n\tseq_puts(m, name);\n\n\tif (count == -1)\n\t\tseq_puts(m, \":unlimited\");\n\telse\n\t\tseq_printf(m, \":count=%ld\", count);\n\n\tif (filter_str)\n\t\tseq_printf(m, \" if %s\\n\", filter_str);\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "unregister_event_command",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "365-382",
    "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(trigger_commands);",
      "static DEFINE_MUTEX(trigger_cmd_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trigger_cmd_mutex"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->list"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd->name",
            "p->name"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "p",
            "n",
            "&trigger_commands",
            "list"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trigger_cmd_mutex"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "register_event_command",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "342-359",
    "snippet": "__init int register_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p;\n\tint ret = 0;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tlist_add(&cmd->list, &trigger_commands);\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(trigger_commands);",
      "static DEFINE_MUTEX(trigger_cmd_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trigger_cmd_mutex"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cmd->list",
            "&trigger_commands"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd->name",
            "p->name"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&trigger_commands",
            "list"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trigger_cmd_mutex"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int register_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p;\n\tint ret = 0;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tlist_add(&cmd->list, &trigger_commands);\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_trigger_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "324-328",
    "snippet": "static int\nevent_trigger_release(struct inode *inode, struct file *file)\n{\n\treturn event_trigger_regex_release(inode, file);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_regex_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_regex_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "298-308",
          "snippet": "static int event_trigger_regex_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&event_mutex);\n\n\tif (file->f_mode & FMODE_READ)\n\t\tseq_release(inode, file);\n\n\tmutex_unlock(&event_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic int event_trigger_regex_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&event_mutex);\n\n\tif (file->f_mode & FMODE_READ)\n\t\tseq_release(inode, file);\n\n\tmutex_unlock(&event_mutex);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic int\nevent_trigger_release(struct inode *inode, struct file *file)\n{\n\treturn event_trigger_regex_release(inode, file);\n}"
  },
  {
    "function_name": "event_trigger_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "317-322",
    "snippet": "static int\nevent_trigger_open(struct inode *inode, struct file *filp)\n{\n\t/* Checks for tracefs lockdown */\n\treturn event_trigger_regex_open(inode, filp);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_regex_open",
          "args": [
            "inode",
            "filp"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_regex_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "189-228",
          "snippet": "static int event_trigger_regex_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&event_mutex);\n\n\tif (unlikely(!event_file_data(file))) {\n\t\tmutex_unlock(&event_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC)) {\n\t\tstruct trace_event_file *event_file;\n\t\tstruct event_command *p;\n\n\t\tevent_file = event_file_data(file);\n\n\t\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\t\tif (p->unreg_all)\n\t\t\t\tp->unreg_all(event_file);\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &event_triggers_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = file;\n\t\t}\n\t}\n\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static const struct seq_operations event_triggers_seq_ops = {\n\t.start = trigger_start,\n\t.next = trigger_next,\n\t.stop = trigger_stop,\n\t.show = trigger_show,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic const struct seq_operations event_triggers_seq_ops = {\n\t.start = trigger_start,\n\t.next = trigger_next,\n\t.stop = trigger_stop,\n\t.show = trigger_show,\n};\n\nstatic int event_trigger_regex_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&event_mutex);\n\n\tif (unlikely(!event_file_data(file))) {\n\t\tmutex_unlock(&event_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC)) {\n\t\tstruct trace_event_file *event_file;\n\t\tstruct event_command *p;\n\n\t\tevent_file = event_file_data(file);\n\n\t\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\t\tif (p->unreg_all)\n\t\t\t\tp->unreg_all(event_file);\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &event_triggers_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = file;\n\t\t}\n\t}\n\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic int\nevent_trigger_open(struct inode *inode, struct file *filp)\n{\n\t/* Checks for tracefs lockdown */\n\treturn event_trigger_regex_open(inode, filp);\n}"
  },
  {
    "function_name": "event_trigger_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "310-315",
    "snippet": "static ssize_t\nevent_trigger_write(struct file *filp, const char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\treturn event_trigger_regex_write(filp, ubuf, cnt, ppos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trigger_regex_write",
          "args": [
            "filp",
            "ubuf",
            "cnt",
            "ppos"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_regex_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "258-296",
          "snippet": "static ssize_t event_trigger_regex_write(struct file *file,\n\t\t\t\t\t const char __user *ubuf,\n\t\t\t\t\t size_t cnt, loff_t *ppos)\n{\n\tstruct trace_event_file *event_file;\n\tssize_t ret;\n\tchar *buf;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tstrim(buf);\n\n\tmutex_lock(&event_mutex);\n\tevent_file = event_file_data(file);\n\tif (unlikely(!event_file)) {\n\t\tmutex_unlock(&event_mutex);\n\t\tkfree(buf);\n\t\treturn -ENODEV;\n\t}\n\tret = trigger_process_regex(event_file, buf);\n\tmutex_unlock(&event_mutex);\n\n\tkfree(buf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*ppos += cnt;\n\tret = cnt;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic ssize_t event_trigger_regex_write(struct file *file,\n\t\t\t\t\t const char __user *ubuf,\n\t\t\t\t\t size_t cnt, loff_t *ppos)\n{\n\tstruct trace_event_file *event_file;\n\tssize_t ret;\n\tchar *buf;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tstrim(buf);\n\n\tmutex_lock(&event_mutex);\n\tevent_file = event_file_data(file);\n\tif (unlikely(!event_file)) {\n\t\tmutex_unlock(&event_mutex);\n\t\tkfree(buf);\n\t\treturn -ENODEV;\n\t}\n\tret = trigger_process_regex(event_file, buf);\n\tmutex_unlock(&event_mutex);\n\n\tkfree(buf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*ppos += cnt;\n\tret = cnt;\n out:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic ssize_t\nevent_trigger_write(struct file *filp, const char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\treturn event_trigger_regex_write(filp, ubuf, cnt, ppos);\n}"
  },
  {
    "function_name": "event_trigger_regex_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "298-308",
    "snippet": "static int event_trigger_regex_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&event_mutex);\n\n\tif (file->f_mode & FMODE_READ)\n\t\tseq_release(inode, file);\n\n\tmutex_unlock(&event_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "328-342",
          "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic int event_trigger_regex_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&event_mutex);\n\n\tif (file->f_mode & FMODE_READ)\n\t\tseq_release(inode, file);\n\n\tmutex_unlock(&event_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_trigger_regex_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "258-296",
    "snippet": "static ssize_t event_trigger_regex_write(struct file *file,\n\t\t\t\t\t const char __user *ubuf,\n\t\t\t\t\t size_t cnt, loff_t *ppos)\n{\n\tstruct trace_event_file *event_file;\n\tssize_t ret;\n\tchar *buf;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tstrim(buf);\n\n\tmutex_lock(&event_mutex);\n\tevent_file = event_file_data(file);\n\tif (unlikely(!event_file)) {\n\t\tmutex_unlock(&event_mutex);\n\t\tkfree(buf);\n\t\treturn -ENODEV;\n\t}\n\tret = trigger_process_regex(event_file, buf);\n\tmutex_unlock(&event_mutex);\n\n\tkfree(buf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*ppos += cnt;\n\tret = cnt;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trigger_process_regex",
          "args": [
            "event_file",
            "buf"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_process_regex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "230-256",
          "snippet": "int trigger_process_regex(struct trace_event_file *file, char *buff)\n{\n\tchar *command, *next;\n\tstruct event_command *p;\n\tint ret = -EINVAL;\n\n\tnext = buff = skip_spaces(buff);\n\tcommand = strsep(&next, \": \\t\");\n\tif (next) {\n\t\tnext = skip_spaces(next);\n\t\tif (!*next)\n\t\t\tnext = NULL;\n\t}\n\tcommand = (command[0] != '!') ? command : command + 1;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->parse(p, file, buff, command, next);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\nint trigger_process_regex(struct trace_event_file *file, char *buff)\n{\n\tchar *command, *next;\n\tstruct event_command *p;\n\tint ret = -EINVAL;\n\n\tnext = buff = skip_spaces(buff);\n\tcommand = strsep(&next, \": \\t\");\n\tif (next) {\n\t\tnext = skip_spaces(next);\n\t\tif (!*next)\n\t\t\tnext = NULL;\n\t}\n\tcommand = (command[0] != '!') ? command : command + 1;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->parse(p, file, buff, command, next);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!event_file"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "file"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1519-1522",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strim",
          "args": [
            "buf"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "buf"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "buf"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "ubuf",
            "cnt"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic ssize_t event_trigger_regex_write(struct file *file,\n\t\t\t\t\t const char __user *ubuf,\n\t\t\t\t\t size_t cnt, loff_t *ppos)\n{\n\tstruct trace_event_file *event_file;\n\tssize_t ret;\n\tchar *buf;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tstrim(buf);\n\n\tmutex_lock(&event_mutex);\n\tevent_file = event_file_data(file);\n\tif (unlikely(!event_file)) {\n\t\tmutex_unlock(&event_mutex);\n\t\tkfree(buf);\n\t\treturn -ENODEV;\n\t}\n\tret = trigger_process_regex(event_file, buf);\n\tmutex_unlock(&event_mutex);\n\n\tkfree(buf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*ppos += cnt;\n\tret = cnt;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "trigger_process_regex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "230-256",
    "snippet": "int trigger_process_regex(struct trace_event_file *file, char *buff)\n{\n\tchar *command, *next;\n\tstruct event_command *p;\n\tint ret = -EINVAL;\n\n\tnext = buff = skip_spaces(buff);\n\tcommand = strsep(&next, \": \\t\");\n\tif (next) {\n\t\tnext = skip_spaces(next);\n\t\tif (!*next)\n\t\t\tnext = NULL;\n\t}\n\tcommand = (command[0] != '!') ? command : command + 1;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->parse(p, file, buff, command, next);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(trigger_commands);",
      "static DEFINE_MUTEX(trigger_cmd_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trigger_cmd_mutex"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->parse",
          "args": [
            "p",
            "file",
            "buff",
            "command",
            "next"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p->name",
            "command"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&trigger_commands",
            "list"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trigger_cmd_mutex"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "next"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "proc_skip_spaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "333-340",
          "snippet": "static size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstatic size_t proc_skip_spaces(char **buf)\n{\n\tsize_t ret;\n\tchar *tmp = skip_spaces(*buf);\n\tret = tmp - *buf;\n\t*buf = tmp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&next",
            "\": \\t\""
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\nint trigger_process_regex(struct trace_event_file *file, char *buff)\n{\n\tchar *command, *next;\n\tstruct event_command *p;\n\tint ret = -EINVAL;\n\n\tnext = buff = skip_spaces(buff);\n\tcommand = strsep(&next, \": \\t\");\n\tif (next) {\n\t\tnext = skip_spaces(next);\n\t\tif (!*next)\n\t\t\tnext = NULL;\n\t}\n\tcommand = (command[0] != '!') ? command : command + 1;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->parse(p, file, buff, command, next);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_trigger_regex_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "189-228",
    "snippet": "static int event_trigger_regex_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&event_mutex);\n\n\tif (unlikely(!event_file_data(file))) {\n\t\tmutex_unlock(&event_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC)) {\n\t\tstruct trace_event_file *event_file;\n\t\tstruct event_command *p;\n\n\t\tevent_file = event_file_data(file);\n\n\t\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\t\tif (p->unreg_all)\n\t\t\t\tp->unreg_all(event_file);\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &event_triggers_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = file;\n\t\t}\n\t}\n\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(trigger_commands);",
      "static const struct seq_operations event_triggers_seq_ops = {\n\t.start = trigger_start,\n\t.next = trigger_next,\n\t.stop = trigger_stop,\n\t.show = trigger_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&event_triggers_seq_ops"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->unreg_all",
          "args": [
            "event_file"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&trigger_commands",
            "list"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "file"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1519-1522",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!event_file_data(file)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_locked_down",
          "args": [
            "LOCKDOWN_TRACEFS"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic const struct seq_operations event_triggers_seq_ops = {\n\t.start = trigger_start,\n\t.next = trigger_next,\n\t.stop = trigger_stop,\n\t.show = trigger_show,\n};\n\nstatic int event_trigger_regex_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&event_mutex);\n\n\tif (unlikely(!event_file_data(file))) {\n\t\tmutex_unlock(&event_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC)) {\n\t\tstruct trace_event_file *event_file;\n\t\tstruct event_command *p;\n\n\t\tevent_file = event_file_data(file);\n\n\t\tlist_for_each_entry(p, &trigger_commands, list) {\n\t\t\tif (p->unreg_all)\n\t\t\t\tp->unreg_all(event_file);\n\t\t}\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &event_triggers_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = file;\n\t\t}\n\t}\n\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trigger_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "160-180",
    "snippet": "static int trigger_show(struct seq_file *m, void *v)\n{\n\tstruct event_trigger_data *data;\n\tstruct event_command *p;\n\n\tif (v == SHOW_AVAILABLE_TRIGGERS) {\n\t\tseq_puts(m, \"# Available triggers:\\n\");\n\t\tseq_putc(m, '#');\n\t\tmutex_lock(&trigger_cmd_mutex);\n\t\tlist_for_each_entry_reverse(p, &trigger_commands, list)\n\t\t\tseq_printf(m, \" %s\", p->name);\n\t\tseq_putc(m, '\\n');\n\t\tmutex_unlock(&trigger_cmd_mutex);\n\t\treturn 0;\n\t}\n\n\tdata = list_entry(v, struct event_trigger_data, list);\n\tdata->ops->print(m, data->ops, data);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [
      "#define SHOW_AVAILABLE_TRIGGERS\t(void *)(1UL)"
    ],
    "globals_used": [
      "static LIST_HEAD(trigger_commands);",
      "static DEFINE_MUTEX(trigger_cmd_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->ops->print",
          "args": [
            "m",
            "data->ops",
            "data"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "v",
            "structevent_trigger_data",
            "list"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&trigger_cmd_mutex"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" %s\"",
            "p->name"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "p",
            "&trigger_commands",
            "list"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trigger_cmd_mutex"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"# Available triggers:\\n\""
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\n#define SHOW_AVAILABLE_TRIGGERS\t(void *)(1UL)\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\nstatic int trigger_show(struct seq_file *m, void *v)\n{\n\tstruct event_trigger_data *data;\n\tstruct event_command *p;\n\n\tif (v == SHOW_AVAILABLE_TRIGGERS) {\n\t\tseq_puts(m, \"# Available triggers:\\n\");\n\t\tseq_putc(m, '#');\n\t\tmutex_lock(&trigger_cmd_mutex);\n\t\tlist_for_each_entry_reverse(p, &trigger_commands, list)\n\t\t\tseq_printf(m, \" %s\", p->name);\n\t\tseq_putc(m, '\\n');\n\t\tmutex_unlock(&trigger_cmd_mutex);\n\t\treturn 0;\n\t}\n\n\tdata = list_entry(v, struct event_trigger_data, list);\n\tdata->ops->print(m, data->ops, data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trigger_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "155-158",
    "snippet": "static void trigger_stop(struct seq_file *m, void *t)\n{\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic void trigger_stop(struct seq_file *m, void *t)\n{\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "trigger_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "139-153",
    "snippet": "static void *trigger_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_event_file *event_file;\n\n\t/* ->stop() is called even if ->start() fails */\n\tmutex_lock(&event_mutex);\n\tevent_file = event_file_data(m->private);\n\tif (unlikely(!event_file))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (list_empty(&event_file->triggers) || !check_user_trigger(event_file))\n\t\treturn *pos == 0 ? SHOW_AVAILABLE_TRIGGERS : NULL;\n\n\treturn seq_list_start(&event_file->triggers, *pos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [
      "#define SHOW_AVAILABLE_TRIGGERS\t(void *)(1UL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "&event_file->triggers",
            "*pos"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_user_trigger",
          "args": [
            "event_file"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "check_user_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
          "lines": "127-137",
          "snippet": "static bool check_user_trigger(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->flags & EVENT_TRIGGER_FL_PROBE)\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic bool check_user_trigger(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->flags & EVENT_TRIGGER_FL_PROBE)\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&event_file->triggers"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODEV"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!event_file"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "m->private"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1519-1522",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\n#define SHOW_AVAILABLE_TRIGGERS\t(void *)(1UL)\n\nstatic void *trigger_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_event_file *event_file;\n\n\t/* ->stop() is called even if ->start() fails */\n\tmutex_lock(&event_mutex);\n\tevent_file = event_file_data(m->private);\n\tif (unlikely(!event_file))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (list_empty(&event_file->triggers) || !check_user_trigger(event_file))\n\t\treturn *pos == 0 ? SHOW_AVAILABLE_TRIGGERS : NULL;\n\n\treturn seq_list_start(&event_file->triggers, *pos);\n}"
  },
  {
    "function_name": "check_user_trigger",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "127-137",
    "snippet": "static bool check_user_trigger(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->flags & EVENT_TRIGGER_FL_PROBE)\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "data",
            "&file->triggers",
            "list"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nstatic bool check_user_trigger(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->flags & EVENT_TRIGGER_FL_PROBE)\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "trigger_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "116-125",
    "snippet": "static void *trigger_next(struct seq_file *m, void *t, loff_t *pos)\n{\n\tstruct trace_event_file *event_file = event_file_data(m->private);\n\n\tif (t == SHOW_AVAILABLE_TRIGGERS) {\n\t\t(*pos)++;\n\t\treturn NULL;\n\t}\n\treturn seq_list_next(t, &event_file->triggers, pos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [
      "#define SHOW_AVAILABLE_TRIGGERS\t(void *)(1UL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "t",
            "&event_file->triggers",
            "pos"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "m->private"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1519-1522",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\n#define SHOW_AVAILABLE_TRIGGERS\t(void *)(1UL)\n\nstatic void *trigger_next(struct seq_file *m, void *t, loff_t *pos)\n{\n\tstruct trace_event_file *event_file = event_file_data(m->private);\n\n\tif (t == SHOW_AVAILABLE_TRIGGERS) {\n\t\t(*pos)++;\n\t\treturn NULL;\n\t}\n\treturn seq_list_next(t, &event_file->triggers, pos);\n}"
  },
  {
    "function_name": "event_triggers_post_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "99-111",
    "snippet": "void\nevent_triggers_post_call(struct trace_event_file *file,\n\t\t\t enum event_trigger_type tt)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->paused)\n\t\t\tcontinue;\n\t\tif (data->cmd_ops->trigger_type & tt)\n\t\t\tdata->ops->trigger(data, NULL, NULL, NULL);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->ops->trigger",
          "args": [
            "data",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "data",
            "&file->triggers",
            "list"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid\nevent_triggers_post_call(struct trace_event_file *file,\n\t\t\t enum event_trigger_type tt)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->paused)\n\t\t\tcontinue;\n\t\tif (data->cmd_ops->trigger_type & tt)\n\t\t\tdata->ops->trigger(data, NULL, NULL, NULL);\n\t}\n}"
  },
  {
    "function_name": "event_triggers_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "55-84",
    "snippet": "enum event_trigger_type\nevent_triggers_call(struct trace_event_file *file,\n\t\t    struct trace_buffer *buffer, void *rec,\n\t\t    struct ring_buffer_event *event)\n{\n\tstruct event_trigger_data *data;\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct event_filter *filter;\n\n\tif (list_empty(&file->triggers))\n\t\treturn tt;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->paused)\n\t\t\tcontinue;\n\t\tif (!rec) {\n\t\t\tdata->ops->trigger(data, buffer, rec, event);\n\t\t\tcontinue;\n\t\t}\n\t\tfilter = rcu_dereference_sched(data->filter);\n\t\tif (filter && !filter_match_preds(filter, rec))\n\t\t\tcontinue;\n\t\tif (event_command_post_trigger(data->cmd_ops)) {\n\t\t\ttt |= data->cmd_ops->trigger_type;\n\t\t\tcontinue;\n\t\t}\n\t\tdata->ops->trigger(data, buffer, rec, event);\n\t}\n\treturn tt;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->ops->trigger",
          "args": [
            "data",
            "buffer",
            "rec",
            "event"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_command_post_trigger",
          "args": [
            "data->cmd_ops"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "event_command_post_trigger",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.h",
          "lines": "1833-1836",
          "snippet": "static inline bool event_command_post_trigger(struct event_command *cmd_ops)\n{\n\treturn cmd_ops->flags & EVENT_CMD_FL_POST_TRIGGER;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include \"pid_list.h\"",
            "#include <linux/once_lite.h>",
            "#include <linux/ctype.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/glob.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include \"pid_list.h\"\n#include <linux/once_lite.h>\n#include <linux/ctype.h>\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/glob.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool event_command_post_trigger(struct event_command *cmd_ops)\n{\n\treturn cmd_ops->flags & EVENT_CMD_FL_POST_TRIGGER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_match_preds",
          "args": [
            "filter",
            "rec"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "filter_match_preds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_filter.c",
          "lines": "990-1011",
          "snippet": "int filter_match_preds(struct event_filter *filter, void *rec)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\t/* no filter is considered a match */\n\tif (!filter)\n\t\treturn 1;\n\n\t/* Protected by either SRCU(tracepoint_srcu) or preempt_disable */\n\tprog = rcu_dereference_raw(filter->prog);\n\tif (!prog)\n\t\treturn 1;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tint match = pred->fn(pred, rec);\n\t\tif (match == prog[i].when_to_branch)\n\t\t\ti = prog[i].target;\n\t}\n\treturn prog[i].target;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __percpu struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic __percpu struct;\n\nint filter_match_preds(struct event_filter *filter, void *rec)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\t/* no filter is considered a match */\n\tif (!filter)\n\t\treturn 1;\n\n\t/* Protected by either SRCU(tracepoint_srcu) or preempt_disable */\n\tprog = rcu_dereference_raw(filter->prog);\n\tif (!prog)\n\t\treturn 1;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tint match = pred->fn(pred, rec);\n\t\tif (match == prog[i].when_to_branch)\n\t\t\ti = prog[i].target;\n\t}\n\treturn prog[i].target;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "data->filter"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data->ops->trigger",
          "args": [
            "data",
            "buffer",
            "rec",
            "event"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "data",
            "&file->triggers",
            "list"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&file->triggers"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nenum event_trigger_type\nevent_triggers_call(struct trace_event_file *file,\n\t\t    struct trace_buffer *buffer, void *rec,\n\t\t    struct ring_buffer_event *event)\n{\n\tstruct event_trigger_data *data;\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct event_filter *filter;\n\n\tif (list_empty(&file->triggers))\n\t\treturn tt;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->paused)\n\t\t\tcontinue;\n\t\tif (!rec) {\n\t\t\tdata->ops->trigger(data, buffer, rec, event);\n\t\t\tcontinue;\n\t\t}\n\t\tfilter = rcu_dereference_sched(data->filter);\n\t\tif (filter && !filter_match_preds(filter, rec))\n\t\t\tcontinue;\n\t\tif (event_command_post_trigger(data->cmd_ops)) {\n\t\t\ttt |= data->cmd_ops->trigger_type;\n\t\t\tcontinue;\n\t\t}\n\t\tdata->ops->trigger(data, buffer, rec, event);\n\t}\n\treturn tt;\n}"
  },
  {
    "function_name": "trigger_data_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_trigger.c",
    "lines": "20-29",
    "snippet": "void trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data->cmd_ops->set_filter",
          "args": [
            "NULL",
            "data",
            "NULL"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/security.h>\n\nvoid trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}"
  }
]