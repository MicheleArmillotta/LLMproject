[
  {
    "function_name": "pm_restore_console",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
    "lines": "143-152",
    "snippet": "void pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/vt.h>",
      "#include <linux/kbd_kern.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/console.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int orig_fgconsole, orig_kmsg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vt_kmsg_redirect",
          "args": [
            "orig_kmsg"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vt_move_to_console",
          "args": [
            "orig_fgconsole",
            "0"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_vt_switch",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "pm_vt_switch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
          "lines": "107-128",
          "snippet": "static bool pm_vt_switch(void)\n{\n\tstruct pm_vt_switch *entry;\n\tbool ret = true;\n\n\tmutex_lock(&vt_switch_mutex);\n\tif (list_empty(&pm_vt_switch_list))\n\t\tgoto out;\n\n\tif (!console_suspend_enabled)\n\t\tgoto out;\n\n\tlist_for_each_entry(entry, &pm_vt_switch_list, head) {\n\t\tif (entry->required)\n\t\t\tgoto out;\n\t}\n\n\tret = false;\nout:\n\tmutex_unlock(&vt_switch_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(vt_switch_mutex);",
            "static LIST_HEAD(pm_vt_switch_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\nstatic DEFINE_MUTEX(vt_switch_mutex);\nstatic LIST_HEAD(pm_vt_switch_list);\n\nstatic bool pm_vt_switch(void)\n{\n\tstruct pm_vt_switch *entry;\n\tbool ret = true;\n\n\tmutex_lock(&vt_switch_mutex);\n\tif (list_empty(&pm_vt_switch_list))\n\t\tgoto out;\n\n\tif (!console_suspend_enabled)\n\t\tgoto out;\n\n\tlist_for_each_entry(entry, &pm_vt_switch_list, head) {\n\t\tif (entry->required)\n\t\t\tgoto out;\n\t}\n\n\tret = false;\nout:\n\tmutex_unlock(&vt_switch_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}"
  },
  {
    "function_name": "pm_prepare_console",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
    "lines": "130-141",
    "snippet": "void pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/vt.h>",
      "#include <linux/kbd_kern.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/console.h>"
    ],
    "macros_used": [
      "#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)"
    ],
    "globals_used": [
      "static int orig_fgconsole, orig_kmsg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vt_kmsg_redirect",
          "args": [
            "SUSPEND_CONSOLE"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vt_move_to_console",
          "args": [
            "SUSPEND_CONSOLE",
            "1"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_vt_switch",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "pm_vt_switch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
          "lines": "107-128",
          "snippet": "static bool pm_vt_switch(void)\n{\n\tstruct pm_vt_switch *entry;\n\tbool ret = true;\n\n\tmutex_lock(&vt_switch_mutex);\n\tif (list_empty(&pm_vt_switch_list))\n\t\tgoto out;\n\n\tif (!console_suspend_enabled)\n\t\tgoto out;\n\n\tlist_for_each_entry(entry, &pm_vt_switch_list, head) {\n\t\tif (entry->required)\n\t\t\tgoto out;\n\t}\n\n\tret = false;\nout:\n\tmutex_unlock(&vt_switch_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/vt.h>",
            "#include <linux/kbd_kern.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/console.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(vt_switch_mutex);",
            "static LIST_HEAD(pm_vt_switch_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\nstatic DEFINE_MUTEX(vt_switch_mutex);\nstatic LIST_HEAD(pm_vt_switch_list);\n\nstatic bool pm_vt_switch(void)\n{\n\tstruct pm_vt_switch *entry;\n\tbool ret = true;\n\n\tmutex_lock(&vt_switch_mutex);\n\tif (list_empty(&pm_vt_switch_list))\n\t\tgoto out;\n\n\tif (!console_suspend_enabled)\n\t\tgoto out;\n\n\tlist_for_each_entry(entry, &pm_vt_switch_list, head) {\n\t\tif (entry->required)\n\t\t\tgoto out;\n\t}\n\n\tret = false;\nout:\n\tmutex_unlock(&vt_switch_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\n#define SUSPEND_CONSOLE\t(MAX_NR_CONSOLES-1)\n\nstatic int orig_fgconsole, orig_kmsg;\n\nvoid pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\torig_fgconsole = vt_move_to_console(SUSPEND_CONSOLE, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn;\n\n\torig_kmsg = vt_kmsg_redirect(SUSPEND_CONSOLE);\n\treturn;\n}"
  },
  {
    "function_name": "pm_vt_switch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
    "lines": "107-128",
    "snippet": "static bool pm_vt_switch(void)\n{\n\tstruct pm_vt_switch *entry;\n\tbool ret = true;\n\n\tmutex_lock(&vt_switch_mutex);\n\tif (list_empty(&pm_vt_switch_list))\n\t\tgoto out;\n\n\tif (!console_suspend_enabled)\n\t\tgoto out;\n\n\tlist_for_each_entry(entry, &pm_vt_switch_list, head) {\n\t\tif (entry->required)\n\t\t\tgoto out;\n\t}\n\n\tret = false;\nout:\n\tmutex_unlock(&vt_switch_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/vt.h>",
      "#include <linux/kbd_kern.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/console.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(vt_switch_mutex);",
      "static LIST_HEAD(pm_vt_switch_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vt_switch_mutex"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&pm_vt_switch_list",
            "head"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pm_vt_switch_list"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vt_switch_mutex"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\nstatic DEFINE_MUTEX(vt_switch_mutex);\nstatic LIST_HEAD(pm_vt_switch_list);\n\nstatic bool pm_vt_switch(void)\n{\n\tstruct pm_vt_switch *entry;\n\tbool ret = true;\n\n\tmutex_lock(&vt_switch_mutex);\n\tif (list_empty(&pm_vt_switch_list))\n\t\tgoto out;\n\n\tif (!console_suspend_enabled)\n\t\tgoto out;\n\n\tlist_for_each_entry(entry, &pm_vt_switch_list, head) {\n\t\tif (entry->required)\n\t\t\tgoto out;\n\t}\n\n\tret = false;\nout:\n\tmutex_unlock(&vt_switch_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "pm_vt_switch_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
    "lines": "78-91",
    "snippet": "void pm_vt_switch_unregister(struct device *dev)\n{\n\tstruct pm_vt_switch *tmp;\n\n\tmutex_lock(&vt_switch_mutex);\n\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {\n\t\tif (tmp->dev == dev) {\n\t\t\tlist_del(&tmp->head);\n\t\t\tkfree(tmp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vt_switch_mutex);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/vt.h>",
      "#include <linux/kbd_kern.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/console.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(vt_switch_mutex);",
      "static LIST_HEAD(pm_vt_switch_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vt_switch_mutex"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&tmp->head"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&pm_vt_switch_list",
            "head"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vt_switch_mutex"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\nstatic DEFINE_MUTEX(vt_switch_mutex);\nstatic LIST_HEAD(pm_vt_switch_list);\n\nvoid pm_vt_switch_unregister(struct device *dev)\n{\n\tstruct pm_vt_switch *tmp;\n\n\tmutex_lock(&vt_switch_mutex);\n\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {\n\t\tif (tmp->dev == dev) {\n\t\t\tlist_del(&tmp->head);\n\t\t\tkfree(tmp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vt_switch_mutex);\n}"
  },
  {
    "function_name": "pm_vt_switch_required",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/console.c",
    "lines": "46-69",
    "snippet": "void pm_vt_switch_required(struct device *dev, bool required)\n{\n\tstruct pm_vt_switch *entry, *tmp;\n\n\tmutex_lock(&vt_switch_mutex);\n\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {\n\t\tif (tmp->dev == dev) {\n\t\t\t/* already registered, update requirement */\n\t\t\ttmp->required = required;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\tgoto out;\n\n\tentry->required = required;\n\tentry->dev = dev;\n\n\tlist_add(&entry->head, &pm_vt_switch_list);\nout:\n\tmutex_unlock(&vt_switch_mutex);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/vt.h>",
      "#include <linux/kbd_kern.h>",
      "#include <linux/vt_kern.h>",
      "#include <linux/console.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(vt_switch_mutex);",
      "static LIST_HEAD(pm_vt_switch_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vt_switch_mutex"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&entry->head",
            "&pm_vt_switch_list"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*entry)",
            "GFP_KERNEL"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&pm_vt_switch_list",
            "head"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vt_switch_mutex"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/vt.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/console.h>\n\nstatic DEFINE_MUTEX(vt_switch_mutex);\nstatic LIST_HEAD(pm_vt_switch_list);\n\nvoid pm_vt_switch_required(struct device *dev, bool required)\n{\n\tstruct pm_vt_switch *entry, *tmp;\n\n\tmutex_lock(&vt_switch_mutex);\n\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {\n\t\tif (tmp->dev == dev) {\n\t\t\t/* already registered, update requirement */\n\t\t\ttmp->required = required;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\tgoto out;\n\n\tentry->required = required;\n\tentry->dev = dev;\n\n\tlist_add(&entry->head, &pm_vt_switch_list);\nout:\n\tmutex_unlock(&vt_switch_mutex);\n}"
  }
]