[
  {
    "function_name": "rseq_syscall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
    "lines": "311-321",
    "snippet": "void rseq_syscall(struct pt_regs *regs)\n{\n\tunsigned long ip = instruction_pointer(regs);\n\tstruct task_struct *t = current;\n\tstruct rseq_cs rseq_cs;\n\n\tif (!t->rseq)\n\t\treturn;\n\tif (rseq_get_rseq_cs(t, &rseq_cs) || in_rseq_cs(ip, &rseq_cs))\n\t\tforce_sig(SIGSEGV);\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig",
          "args": [
            "SIGSEGV"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "force_sigsegv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1696-1702",
          "snippet": "void force_sigsegv(int sig)\n{\n\tif (sig == SIGSEGV)\n\t\tforce_fatal_sig(SIGSEGV);\n\telse\n\t\tforce_sig(SIGSEGV);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid force_sigsegv(int sig)\n{\n\tif (sig == SIGSEGV)\n\t\tforce_fatal_sig(SIGSEGV);\n\telse\n\t\tforce_sig(SIGSEGV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_rseq_cs",
          "args": [
            "ip",
            "&rseq_cs"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "in_rseq_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
          "lines": "232-235",
          "snippet": "static bool in_rseq_cs(unsigned long ip, struct rseq_cs *rseq_cs)\n{\n\treturn ip - rseq_cs->start_ip < rseq_cs->post_commit_offset;\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic bool in_rseq_cs(unsigned long ip, struct rseq_cs *rseq_cs)\n{\n\treturn ip - rseq_cs->start_ip < rseq_cs->post_commit_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rseq_get_rseq_cs",
          "args": [
            "t",
            "&rseq_cs"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "rseq_get_rseq_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
          "lines": "122-171",
          "snippet": "static int rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)\n{\n\tstruct rseq_cs __user *urseq_cs;\n\tu64 ptr;\n\tu32 __user *usig;\n\tu32 sig;\n\tint ret;\n\n#ifdef CONFIG_64BIT\n\tif (get_user(ptr, &t->rseq->rseq_cs.ptr64))\n\t\treturn -EFAULT;\n#else\n\tif (copy_from_user(&ptr, &t->rseq->rseq_cs.ptr64, sizeof(ptr)))\n\t\treturn -EFAULT;\n#endif\n\tif (!ptr) {\n\t\tmemset(rseq_cs, 0, sizeof(*rseq_cs));\n\t\treturn 0;\n\t}\n\tif (ptr >= TASK_SIZE)\n\t\treturn -EINVAL;\n\turseq_cs = (struct rseq_cs __user *)(unsigned long)ptr;\n\tif (copy_from_user(rseq_cs, urseq_cs, sizeof(*rseq_cs)))\n\t\treturn -EFAULT;\n\n\tif (rseq_cs->start_ip >= TASK_SIZE ||\n\t    rseq_cs->start_ip + rseq_cs->post_commit_offset >= TASK_SIZE ||\n\t    rseq_cs->abort_ip >= TASK_SIZE ||\n\t    rseq_cs->version > 0)\n\t\treturn -EINVAL;\n\t/* Check for overflow. */\n\tif (rseq_cs->start_ip + rseq_cs->post_commit_offset < rseq_cs->start_ip)\n\t\treturn -EINVAL;\n\t/* Ensure that abort_ip is not in the critical section. */\n\tif (rseq_cs->abort_ip - rseq_cs->start_ip < rseq_cs->post_commit_offset)\n\t\treturn -EINVAL;\n\n\tusig = (u32 __user *)(unsigned long)(rseq_cs->abort_ip - sizeof(u32));\n\tret = get_user(sig, usig);\n\tif (ret)\n\t\treturn ret;\n\n\tif (current->rseq_sig != sig) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\",\n\t\t\tsig, current->rseq_sig, current->pid, usig);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)\n{\n\tstruct rseq_cs __user *urseq_cs;\n\tu64 ptr;\n\tu32 __user *usig;\n\tu32 sig;\n\tint ret;\n\n#ifdef CONFIG_64BIT\n\tif (get_user(ptr, &t->rseq->rseq_cs.ptr64))\n\t\treturn -EFAULT;\n#else\n\tif (copy_from_user(&ptr, &t->rseq->rseq_cs.ptr64, sizeof(ptr)))\n\t\treturn -EFAULT;\n#endif\n\tif (!ptr) {\n\t\tmemset(rseq_cs, 0, sizeof(*rseq_cs));\n\t\treturn 0;\n\t}\n\tif (ptr >= TASK_SIZE)\n\t\treturn -EINVAL;\n\turseq_cs = (struct rseq_cs __user *)(unsigned long)ptr;\n\tif (copy_from_user(rseq_cs, urseq_cs, sizeof(*rseq_cs)))\n\t\treturn -EFAULT;\n\n\tif (rseq_cs->start_ip >= TASK_SIZE ||\n\t    rseq_cs->start_ip + rseq_cs->post_commit_offset >= TASK_SIZE ||\n\t    rseq_cs->abort_ip >= TASK_SIZE ||\n\t    rseq_cs->version > 0)\n\t\treturn -EINVAL;\n\t/* Check for overflow. */\n\tif (rseq_cs->start_ip + rseq_cs->post_commit_offset < rseq_cs->start_ip)\n\t\treturn -EINVAL;\n\t/* Ensure that abort_ip is not in the critical section. */\n\tif (rseq_cs->abort_ip - rseq_cs->start_ip < rseq_cs->post_commit_offset)\n\t\treturn -EINVAL;\n\n\tusig = (u32 __user *)(unsigned long)(rseq_cs->abort_ip - sizeof(u32));\n\tret = get_user(sig, usig);\n\tif (ret)\n\t\treturn ret;\n\n\tif (current->rseq_sig != sig) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\",\n\t\t\tsig, current->rseq_sig, current->pid, usig);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nvoid rseq_syscall(struct pt_regs *regs)\n{\n\tunsigned long ip = instruction_pointer(regs);\n\tstruct task_struct *t = current;\n\tstruct rseq_cs rseq_cs;\n\n\tif (!t->rseq)\n\t\treturn;\n\tif (rseq_get_rseq_cs(t, &rseq_cs) || in_rseq_cs(ip, &rseq_cs))\n\t\tforce_sig(SIGSEGV);\n}"
  },
  {
    "function_name": "__rseq_handle_notify_resume",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
    "lines": "278-303",
    "snippet": "void __rseq_handle_notify_resume(struct ksignal *ksig, struct pt_regs *regs)\n{\n\tstruct task_struct *t = current;\n\tint ret, sig;\n\n\tif (unlikely(t->flags & PF_EXITING))\n\t\treturn;\n\n\t/*\n\t * regs is NULL if and only if the caller is in a syscall path.  Skip\n\t * fixup and leave rseq_cs as is so that rseq_sycall() will detect and\n\t * kill a misbehaving userspace on debug kernels.\n\t */\n\tif (regs) {\n\t\tret = rseq_ip_fixup(regs);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto error;\n\t}\n\tif (unlikely(rseq_update_cpu_id(t)))\n\t\tgoto error;\n\treturn;\n\nerror:\n\tsig = ksig ? ksig->sig : 0;\n\tforce_sigsegv(sig);\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sigsegv",
          "args": [
            "sig"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "force_sigsegv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1696-1702",
          "snippet": "void force_sigsegv(int sig)\n{\n\tif (sig == SIGSEGV)\n\t\tforce_fatal_sig(SIGSEGV);\n\telse\n\t\tforce_sig(SIGSEGV);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid force_sigsegv(int sig)\n{\n\tif (sig == SIGSEGV)\n\t\tforce_fatal_sig(SIGSEGV);\n\telse\n\t\tforce_sig(SIGSEGV);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rseq_update_cpu_id(t)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rseq_update_cpu_id",
          "args": [
            "t"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "rseq_update_cpu_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
          "lines": "84-101",
          "snippet": "static int rseq_update_cpu_id(struct task_struct *t)\n{\n\tu32 cpu_id = raw_smp_processor_id();\n\tstruct rseq __user *rseq = t->rseq;\n\n\tif (!user_write_access_begin(rseq, sizeof(*rseq)))\n\t\tgoto efault;\n\tunsafe_put_user(cpu_id, &rseq->cpu_id_start, efault_end);\n\tunsafe_put_user(cpu_id, &rseq->cpu_id, efault_end);\n\tuser_write_access_end();\n\ttrace_rseq_update(t);\n\treturn 0;\n\nefault_end:\n\tuser_write_access_end();\nefault:\n\treturn -EFAULT;\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int rseq_update_cpu_id(struct task_struct *t)\n{\n\tu32 cpu_id = raw_smp_processor_id();\n\tstruct rseq __user *rseq = t->rseq;\n\n\tif (!user_write_access_begin(rseq, sizeof(*rseq)))\n\t\tgoto efault;\n\tunsafe_put_user(cpu_id, &rseq->cpu_id_start, efault_end);\n\tunsafe_put_user(cpu_id, &rseq->cpu_id, efault_end);\n\tuser_write_access_end();\n\ttrace_rseq_update(t);\n\treturn 0;\n\nefault_end:\n\tuser_write_access_end();\nefault:\n\treturn -EFAULT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rseq_ip_fixup",
          "args": [
            "regs"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "rseq_ip_fixup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
          "lines": "237-265",
          "snippet": "static int rseq_ip_fixup(struct pt_regs *regs)\n{\n\tunsigned long ip = instruction_pointer(regs);\n\tstruct task_struct *t = current;\n\tstruct rseq_cs rseq_cs;\n\tint ret;\n\n\tret = rseq_get_rseq_cs(t, &rseq_cs);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Handle potentially not being within a critical section.\n\t * If not nested over a rseq critical section, restart is useless.\n\t * Clear the rseq_cs pointer and return.\n\t */\n\tif (!in_rseq_cs(ip, &rseq_cs))\n\t\treturn clear_rseq_cs(t);\n\tret = rseq_need_restart(t, rseq_cs.flags);\n\tif (ret <= 0)\n\t\treturn ret;\n\tret = clear_rseq_cs(t);\n\tif (ret)\n\t\treturn ret;\n\ttrace_rseq_ip_fixup(ip, rseq_cs.start_ip, rseq_cs.post_commit_offset,\n\t\t\t    rseq_cs.abort_ip);\n\tinstruction_pointer_set(regs, (unsigned long)rseq_cs.abort_ip);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int rseq_ip_fixup(struct pt_regs *regs)\n{\n\tunsigned long ip = instruction_pointer(regs);\n\tstruct task_struct *t = current;\n\tstruct rseq_cs rseq_cs;\n\tint ret;\n\n\tret = rseq_get_rseq_cs(t, &rseq_cs);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Handle potentially not being within a critical section.\n\t * If not nested over a rseq critical section, restart is useless.\n\t * Clear the rseq_cs pointer and return.\n\t */\n\tif (!in_rseq_cs(ip, &rseq_cs))\n\t\treturn clear_rseq_cs(t);\n\tret = rseq_need_restart(t, rseq_cs.flags);\n\tif (ret <= 0)\n\t\treturn ret;\n\tret = clear_rseq_cs(t);\n\tif (ret)\n\t\treturn ret;\n\ttrace_rseq_ip_fixup(ip, rseq_cs.start_ip, rseq_cs.post_commit_offset,\n\t\t\t    rseq_cs.abort_ip);\n\tinstruction_pointer_set(regs, (unsigned long)rseq_cs.abort_ip);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "t->flags & PF_EXITING"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nvoid __rseq_handle_notify_resume(struct ksignal *ksig, struct pt_regs *regs)\n{\n\tstruct task_struct *t = current;\n\tint ret, sig;\n\n\tif (unlikely(t->flags & PF_EXITING))\n\t\treturn;\n\n\t/*\n\t * regs is NULL if and only if the caller is in a syscall path.  Skip\n\t * fixup and leave rseq_cs as is so that rseq_sycall() will detect and\n\t * kill a misbehaving userspace on debug kernels.\n\t */\n\tif (regs) {\n\t\tret = rseq_ip_fixup(regs);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto error;\n\t}\n\tif (unlikely(rseq_update_cpu_id(t)))\n\t\tgoto error;\n\treturn;\n\nerror:\n\tsig = ksig ? ksig->sig : 0;\n\tforce_sigsegv(sig);\n}"
  },
  {
    "function_name": "rseq_ip_fixup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
    "lines": "237-265",
    "snippet": "static int rseq_ip_fixup(struct pt_regs *regs)\n{\n\tunsigned long ip = instruction_pointer(regs);\n\tstruct task_struct *t = current;\n\tstruct rseq_cs rseq_cs;\n\tint ret;\n\n\tret = rseq_get_rseq_cs(t, &rseq_cs);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Handle potentially not being within a critical section.\n\t * If not nested over a rseq critical section, restart is useless.\n\t * Clear the rseq_cs pointer and return.\n\t */\n\tif (!in_rseq_cs(ip, &rseq_cs))\n\t\treturn clear_rseq_cs(t);\n\tret = rseq_need_restart(t, rseq_cs.flags);\n\tif (ret <= 0)\n\t\treturn ret;\n\tret = clear_rseq_cs(t);\n\tif (ret)\n\t\treturn ret;\n\ttrace_rseq_ip_fixup(ip, rseq_cs.start_ip, rseq_cs.post_commit_offset,\n\t\t\t    rseq_cs.abort_ip);\n\tinstruction_pointer_set(regs, (unsigned long)rseq_cs.abort_ip);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "instruction_pointer_set",
          "args": [
            "regs",
            "(unsigned long)rseq_cs.abort_ip"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rseq_ip_fixup",
          "args": [
            "ip",
            "rseq_cs.start_ip",
            "rseq_cs.post_commit_offset",
            "rseq_cs.abort_ip"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_rseq_cs",
          "args": [
            "t"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "clear_rseq_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
          "lines": "209-226",
          "snippet": "static int clear_rseq_cs(struct task_struct *t)\n{\n\t/*\n\t * The rseq_cs field is set to NULL on preemption or signal\n\t * delivery on top of rseq assembly block, as well as on top\n\t * of code outside of the rseq assembly block. This performs\n\t * a lazy clear of the rseq_cs field.\n\t *\n\t * Set rseq_cs to NULL.\n\t */\n#ifdef CONFIG_64BIT\n\treturn put_user(0UL, &t->rseq->rseq_cs.ptr64);\n#else\n\tif (clear_user(&t->rseq->rseq_cs.ptr64, sizeof(t->rseq->rseq_cs.ptr64)))\n\t\treturn -EFAULT;\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int clear_rseq_cs(struct task_struct *t)\n{\n\t/*\n\t * The rseq_cs field is set to NULL on preemption or signal\n\t * delivery on top of rseq assembly block, as well as on top\n\t * of code outside of the rseq assembly block. This performs\n\t * a lazy clear of the rseq_cs field.\n\t *\n\t * Set rseq_cs to NULL.\n\t */\n#ifdef CONFIG_64BIT\n\treturn put_user(0UL, &t->rseq->rseq_cs.ptr64);\n#else\n\tif (clear_user(&t->rseq->rseq_cs.ptr64, sizeof(t->rseq->rseq_cs.ptr64)))\n\t\treturn -EFAULT;\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rseq_need_restart",
          "args": [
            "t",
            "rseq_cs.flags"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "rseq_need_restart",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
          "lines": "173-207",
          "snippet": "static int rseq_need_restart(struct task_struct *t, u32 cs_flags)\n{\n\tu32 flags, event_mask;\n\tint ret;\n\n\t/* Get thread flags. */\n\tret = get_user(flags, &t->rseq->flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Take critical section flags into account. */\n\tflags |= cs_flags;\n\n\t/*\n\t * Restart on signal can only be inhibited when restart on\n\t * preempt and restart on migrate are inhibited too. Otherwise,\n\t * a preempted signal handler could fail to restart the prior\n\t * execution context on sigreturn.\n\t */\n\tif (unlikely((flags & RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL) &&\n\t\t     (flags & RSEQ_CS_PREEMPT_MIGRATE_FLAGS) !=\n\t\t     RSEQ_CS_PREEMPT_MIGRATE_FLAGS))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Load and clear event mask atomically with respect to\n\t * scheduler preemption.\n\t */\n\tpreempt_disable();\n\tevent_mask = t->rseq_event_mask;\n\tt->rseq_event_mask = 0;\n\tpreempt_enable();\n\n\treturn !!(event_mask & ~flags);\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RSEQ_CS_PREEMPT_MIGRATE_FLAGS (RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE | \\\n\t\t\t\t       RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\n#define RSEQ_CS_PREEMPT_MIGRATE_FLAGS (RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE | \\\n\t\t\t\t       RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT)\n\nstatic int rseq_need_restart(struct task_struct *t, u32 cs_flags)\n{\n\tu32 flags, event_mask;\n\tint ret;\n\n\t/* Get thread flags. */\n\tret = get_user(flags, &t->rseq->flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Take critical section flags into account. */\n\tflags |= cs_flags;\n\n\t/*\n\t * Restart on signal can only be inhibited when restart on\n\t * preempt and restart on migrate are inhibited too. Otherwise,\n\t * a preempted signal handler could fail to restart the prior\n\t * execution context on sigreturn.\n\t */\n\tif (unlikely((flags & RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL) &&\n\t\t     (flags & RSEQ_CS_PREEMPT_MIGRATE_FLAGS) !=\n\t\t     RSEQ_CS_PREEMPT_MIGRATE_FLAGS))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Load and clear event mask atomically with respect to\n\t * scheduler preemption.\n\t */\n\tpreempt_disable();\n\tevent_mask = t->rseq_event_mask;\n\tt->rseq_event_mask = 0;\n\tpreempt_enable();\n\n\treturn !!(event_mask & ~flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_rseq_cs",
          "args": [
            "ip",
            "&rseq_cs"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "in_rseq_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
          "lines": "232-235",
          "snippet": "static bool in_rseq_cs(unsigned long ip, struct rseq_cs *rseq_cs)\n{\n\treturn ip - rseq_cs->start_ip < rseq_cs->post_commit_offset;\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic bool in_rseq_cs(unsigned long ip, struct rseq_cs *rseq_cs)\n{\n\treturn ip - rseq_cs->start_ip < rseq_cs->post_commit_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rseq_get_rseq_cs",
          "args": [
            "t",
            "&rseq_cs"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "rseq_get_rseq_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
          "lines": "122-171",
          "snippet": "static int rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)\n{\n\tstruct rseq_cs __user *urseq_cs;\n\tu64 ptr;\n\tu32 __user *usig;\n\tu32 sig;\n\tint ret;\n\n#ifdef CONFIG_64BIT\n\tif (get_user(ptr, &t->rseq->rseq_cs.ptr64))\n\t\treturn -EFAULT;\n#else\n\tif (copy_from_user(&ptr, &t->rseq->rseq_cs.ptr64, sizeof(ptr)))\n\t\treturn -EFAULT;\n#endif\n\tif (!ptr) {\n\t\tmemset(rseq_cs, 0, sizeof(*rseq_cs));\n\t\treturn 0;\n\t}\n\tif (ptr >= TASK_SIZE)\n\t\treturn -EINVAL;\n\turseq_cs = (struct rseq_cs __user *)(unsigned long)ptr;\n\tif (copy_from_user(rseq_cs, urseq_cs, sizeof(*rseq_cs)))\n\t\treturn -EFAULT;\n\n\tif (rseq_cs->start_ip >= TASK_SIZE ||\n\t    rseq_cs->start_ip + rseq_cs->post_commit_offset >= TASK_SIZE ||\n\t    rseq_cs->abort_ip >= TASK_SIZE ||\n\t    rseq_cs->version > 0)\n\t\treturn -EINVAL;\n\t/* Check for overflow. */\n\tif (rseq_cs->start_ip + rseq_cs->post_commit_offset < rseq_cs->start_ip)\n\t\treturn -EINVAL;\n\t/* Ensure that abort_ip is not in the critical section. */\n\tif (rseq_cs->abort_ip - rseq_cs->start_ip < rseq_cs->post_commit_offset)\n\t\treturn -EINVAL;\n\n\tusig = (u32 __user *)(unsigned long)(rseq_cs->abort_ip - sizeof(u32));\n\tret = get_user(sig, usig);\n\tif (ret)\n\t\treturn ret;\n\n\tif (current->rseq_sig != sig) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\",\n\t\t\tsig, current->rseq_sig, current->pid, usig);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/rseq.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/types.h>",
            "#include <linux/rseq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)\n{\n\tstruct rseq_cs __user *urseq_cs;\n\tu64 ptr;\n\tu32 __user *usig;\n\tu32 sig;\n\tint ret;\n\n#ifdef CONFIG_64BIT\n\tif (get_user(ptr, &t->rseq->rseq_cs.ptr64))\n\t\treturn -EFAULT;\n#else\n\tif (copy_from_user(&ptr, &t->rseq->rseq_cs.ptr64, sizeof(ptr)))\n\t\treturn -EFAULT;\n#endif\n\tif (!ptr) {\n\t\tmemset(rseq_cs, 0, sizeof(*rseq_cs));\n\t\treturn 0;\n\t}\n\tif (ptr >= TASK_SIZE)\n\t\treturn -EINVAL;\n\turseq_cs = (struct rseq_cs __user *)(unsigned long)ptr;\n\tif (copy_from_user(rseq_cs, urseq_cs, sizeof(*rseq_cs)))\n\t\treturn -EFAULT;\n\n\tif (rseq_cs->start_ip >= TASK_SIZE ||\n\t    rseq_cs->start_ip + rseq_cs->post_commit_offset >= TASK_SIZE ||\n\t    rseq_cs->abort_ip >= TASK_SIZE ||\n\t    rseq_cs->version > 0)\n\t\treturn -EINVAL;\n\t/* Check for overflow. */\n\tif (rseq_cs->start_ip + rseq_cs->post_commit_offset < rseq_cs->start_ip)\n\t\treturn -EINVAL;\n\t/* Ensure that abort_ip is not in the critical section. */\n\tif (rseq_cs->abort_ip - rseq_cs->start_ip < rseq_cs->post_commit_offset)\n\t\treturn -EINVAL;\n\n\tusig = (u32 __user *)(unsigned long)(rseq_cs->abort_ip - sizeof(u32));\n\tret = get_user(sig, usig);\n\tif (ret)\n\t\treturn ret;\n\n\tif (current->rseq_sig != sig) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\",\n\t\t\tsig, current->rseq_sig, current->pid, usig);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int rseq_ip_fixup(struct pt_regs *regs)\n{\n\tunsigned long ip = instruction_pointer(regs);\n\tstruct task_struct *t = current;\n\tstruct rseq_cs rseq_cs;\n\tint ret;\n\n\tret = rseq_get_rseq_cs(t, &rseq_cs);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Handle potentially not being within a critical section.\n\t * If not nested over a rseq critical section, restart is useless.\n\t * Clear the rseq_cs pointer and return.\n\t */\n\tif (!in_rseq_cs(ip, &rseq_cs))\n\t\treturn clear_rseq_cs(t);\n\tret = rseq_need_restart(t, rseq_cs.flags);\n\tif (ret <= 0)\n\t\treturn ret;\n\tret = clear_rseq_cs(t);\n\tif (ret)\n\t\treturn ret;\n\ttrace_rseq_ip_fixup(ip, rseq_cs.start_ip, rseq_cs.post_commit_offset,\n\t\t\t    rseq_cs.abort_ip);\n\tinstruction_pointer_set(regs, (unsigned long)rseq_cs.abort_ip);\n\treturn 0;\n}"
  },
  {
    "function_name": "in_rseq_cs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
    "lines": "232-235",
    "snippet": "static bool in_rseq_cs(unsigned long ip, struct rseq_cs *rseq_cs)\n{\n\treturn ip - rseq_cs->start_ip < rseq_cs->post_commit_offset;\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic bool in_rseq_cs(unsigned long ip, struct rseq_cs *rseq_cs)\n{\n\treturn ip - rseq_cs->start_ip < rseq_cs->post_commit_offset;\n}"
  },
  {
    "function_name": "clear_rseq_cs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
    "lines": "209-226",
    "snippet": "static int clear_rseq_cs(struct task_struct *t)\n{\n\t/*\n\t * The rseq_cs field is set to NULL on preemption or signal\n\t * delivery on top of rseq assembly block, as well as on top\n\t * of code outside of the rseq assembly block. This performs\n\t * a lazy clear of the rseq_cs field.\n\t *\n\t * Set rseq_cs to NULL.\n\t */\n#ifdef CONFIG_64BIT\n\treturn put_user(0UL, &t->rseq->rseq_cs.ptr64);\n#else\n\tif (clear_user(&t->rseq->rseq_cs.ptr64, sizeof(t->rseq->rseq_cs.ptr64)))\n\t\treturn -EFAULT;\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_user",
          "args": [
            "&t->rseq->rseq_cs.ptr64",
            "sizeof(t->rseq->rseq_cs.ptr64)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "0UL",
            "&t->rseq->rseq_cs.ptr64"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int clear_rseq_cs(struct task_struct *t)\n{\n\t/*\n\t * The rseq_cs field is set to NULL on preemption or signal\n\t * delivery on top of rseq assembly block, as well as on top\n\t * of code outside of the rseq assembly block. This performs\n\t * a lazy clear of the rseq_cs field.\n\t *\n\t * Set rseq_cs to NULL.\n\t */\n#ifdef CONFIG_64BIT\n\treturn put_user(0UL, &t->rseq->rseq_cs.ptr64);\n#else\n\tif (clear_user(&t->rseq->rseq_cs.ptr64, sizeof(t->rseq->rseq_cs.ptr64)))\n\t\treturn -EFAULT;\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "rseq_need_restart",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
    "lines": "173-207",
    "snippet": "static int rseq_need_restart(struct task_struct *t, u32 cs_flags)\n{\n\tu32 flags, event_mask;\n\tint ret;\n\n\t/* Get thread flags. */\n\tret = get_user(flags, &t->rseq->flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Take critical section flags into account. */\n\tflags |= cs_flags;\n\n\t/*\n\t * Restart on signal can only be inhibited when restart on\n\t * preempt and restart on migrate are inhibited too. Otherwise,\n\t * a preempted signal handler could fail to restart the prior\n\t * execution context on sigreturn.\n\t */\n\tif (unlikely((flags & RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL) &&\n\t\t     (flags & RSEQ_CS_PREEMPT_MIGRATE_FLAGS) !=\n\t\t     RSEQ_CS_PREEMPT_MIGRATE_FLAGS))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Load and clear event mask atomically with respect to\n\t * scheduler preemption.\n\t */\n\tpreempt_disable();\n\tevent_mask = t->rseq_event_mask;\n\tt->rseq_event_mask = 0;\n\tpreempt_enable();\n\n\treturn !!(event_mask & ~flags);\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define RSEQ_CS_PREEMPT_MIGRATE_FLAGS (RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE | \\\n\t\t\t\t       RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(flags & RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL) &&\n\t\t     (flags & RSEQ_CS_PREEMPT_MIGRATE_FLAGS) !=\n\t\t     RSEQ_CS_PREEMPT_MIGRATE_FLAGS"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "flags",
            "&t->rseq->flags"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "530-557",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\n#define RSEQ_CS_PREEMPT_MIGRATE_FLAGS (RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE | \\\n\t\t\t\t       RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT)\n\nstatic int rseq_need_restart(struct task_struct *t, u32 cs_flags)\n{\n\tu32 flags, event_mask;\n\tint ret;\n\n\t/* Get thread flags. */\n\tret = get_user(flags, &t->rseq->flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Take critical section flags into account. */\n\tflags |= cs_flags;\n\n\t/*\n\t * Restart on signal can only be inhibited when restart on\n\t * preempt and restart on migrate are inhibited too. Otherwise,\n\t * a preempted signal handler could fail to restart the prior\n\t * execution context on sigreturn.\n\t */\n\tif (unlikely((flags & RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL) &&\n\t\t     (flags & RSEQ_CS_PREEMPT_MIGRATE_FLAGS) !=\n\t\t     RSEQ_CS_PREEMPT_MIGRATE_FLAGS))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Load and clear event mask atomically with respect to\n\t * scheduler preemption.\n\t */\n\tpreempt_disable();\n\tevent_mask = t->rseq_event_mask;\n\tt->rseq_event_mask = 0;\n\tpreempt_enable();\n\n\treturn !!(event_mask & ~flags);\n}"
  },
  {
    "function_name": "rseq_get_rseq_cs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
    "lines": "122-171",
    "snippet": "static int rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)\n{\n\tstruct rseq_cs __user *urseq_cs;\n\tu64 ptr;\n\tu32 __user *usig;\n\tu32 sig;\n\tint ret;\n\n#ifdef CONFIG_64BIT\n\tif (get_user(ptr, &t->rseq->rseq_cs.ptr64))\n\t\treturn -EFAULT;\n#else\n\tif (copy_from_user(&ptr, &t->rseq->rseq_cs.ptr64, sizeof(ptr)))\n\t\treturn -EFAULT;\n#endif\n\tif (!ptr) {\n\t\tmemset(rseq_cs, 0, sizeof(*rseq_cs));\n\t\treturn 0;\n\t}\n\tif (ptr >= TASK_SIZE)\n\t\treturn -EINVAL;\n\turseq_cs = (struct rseq_cs __user *)(unsigned long)ptr;\n\tif (copy_from_user(rseq_cs, urseq_cs, sizeof(*rseq_cs)))\n\t\treturn -EFAULT;\n\n\tif (rseq_cs->start_ip >= TASK_SIZE ||\n\t    rseq_cs->start_ip + rseq_cs->post_commit_offset >= TASK_SIZE ||\n\t    rseq_cs->abort_ip >= TASK_SIZE ||\n\t    rseq_cs->version > 0)\n\t\treturn -EINVAL;\n\t/* Check for overflow. */\n\tif (rseq_cs->start_ip + rseq_cs->post_commit_offset < rseq_cs->start_ip)\n\t\treturn -EINVAL;\n\t/* Ensure that abort_ip is not in the critical section. */\n\tif (rseq_cs->abort_ip - rseq_cs->start_ip < rseq_cs->post_commit_offset)\n\t\treturn -EINVAL;\n\n\tusig = (u32 __user *)(unsigned long)(rseq_cs->abort_ip - sizeof(u32));\n\tret = get_user(sig, usig);\n\tif (ret)\n\t\treturn ret;\n\n\tif (current->rseq_sig != sig) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\",\n\t\t\tsig, current->rseq_sig, current->pid, usig);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_WARNING\n\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\"",
            "sig",
            "current->rseq_sig",
            "current->pid",
            "usig"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "sig",
            "usig"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "530-557",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "rseq_cs",
            "urseq_cs",
            "sizeof(*rseq_cs)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rseq_cs",
            "0",
            "sizeof(*rseq_cs)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&ptr",
            "&t->rseq->rseq_cs.ptr64",
            "sizeof(ptr)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int rseq_get_rseq_cs(struct task_struct *t, struct rseq_cs *rseq_cs)\n{\n\tstruct rseq_cs __user *urseq_cs;\n\tu64 ptr;\n\tu32 __user *usig;\n\tu32 sig;\n\tint ret;\n\n#ifdef CONFIG_64BIT\n\tif (get_user(ptr, &t->rseq->rseq_cs.ptr64))\n\t\treturn -EFAULT;\n#else\n\tif (copy_from_user(&ptr, &t->rseq->rseq_cs.ptr64, sizeof(ptr)))\n\t\treturn -EFAULT;\n#endif\n\tif (!ptr) {\n\t\tmemset(rseq_cs, 0, sizeof(*rseq_cs));\n\t\treturn 0;\n\t}\n\tif (ptr >= TASK_SIZE)\n\t\treturn -EINVAL;\n\turseq_cs = (struct rseq_cs __user *)(unsigned long)ptr;\n\tif (copy_from_user(rseq_cs, urseq_cs, sizeof(*rseq_cs)))\n\t\treturn -EFAULT;\n\n\tif (rseq_cs->start_ip >= TASK_SIZE ||\n\t    rseq_cs->start_ip + rseq_cs->post_commit_offset >= TASK_SIZE ||\n\t    rseq_cs->abort_ip >= TASK_SIZE ||\n\t    rseq_cs->version > 0)\n\t\treturn -EINVAL;\n\t/* Check for overflow. */\n\tif (rseq_cs->start_ip + rseq_cs->post_commit_offset < rseq_cs->start_ip)\n\t\treturn -EINVAL;\n\t/* Ensure that abort_ip is not in the critical section. */\n\tif (rseq_cs->abort_ip - rseq_cs->start_ip < rseq_cs->post_commit_offset)\n\t\treturn -EINVAL;\n\n\tusig = (u32 __user *)(unsigned long)(rseq_cs->abort_ip - sizeof(u32));\n\tret = get_user(sig, usig);\n\tif (ret)\n\t\treturn ret;\n\n\tif (current->rseq_sig != sig) {\n\t\tprintk_ratelimited(KERN_WARNING\n\t\t\t\"Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\\n\",\n\t\t\tsig, current->rseq_sig, current->pid, usig);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "rseq_reset_rseq_cpu_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
    "lines": "103-120",
    "snippet": "static int rseq_reset_rseq_cpu_id(struct task_struct *t)\n{\n\tu32 cpu_id_start = 0, cpu_id = RSEQ_CPU_ID_UNINITIALIZED;\n\n\t/*\n\t * Reset cpu_id_start to its initial state (0).\n\t */\n\tif (put_user(cpu_id_start, &t->rseq->cpu_id_start))\n\t\treturn -EFAULT;\n\t/*\n\t * Reset cpu_id to RSEQ_CPU_ID_UNINITIALIZED, so any user coming\n\t * in after unregistration can figure out that rseq needs to be\n\t * registered again.\n\t */\n\tif (put_user(cpu_id, &t->rseq->cpu_id))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "cpu_id",
            "&t->rseq->cpu_id"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "cpu_id_start",
            "&t->rseq->cpu_id_start"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int rseq_reset_rseq_cpu_id(struct task_struct *t)\n{\n\tu32 cpu_id_start = 0, cpu_id = RSEQ_CPU_ID_UNINITIALIZED;\n\n\t/*\n\t * Reset cpu_id_start to its initial state (0).\n\t */\n\tif (put_user(cpu_id_start, &t->rseq->cpu_id_start))\n\t\treturn -EFAULT;\n\t/*\n\t * Reset cpu_id to RSEQ_CPU_ID_UNINITIALIZED, so any user coming\n\t * in after unregistration can figure out that rseq needs to be\n\t * registered again.\n\t */\n\tif (put_user(cpu_id, &t->rseq->cpu_id))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "rseq_update_cpu_id",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
    "lines": "84-101",
    "snippet": "static int rseq_update_cpu_id(struct task_struct *t)\n{\n\tu32 cpu_id = raw_smp_processor_id();\n\tstruct rseq __user *rseq = t->rseq;\n\n\tif (!user_write_access_begin(rseq, sizeof(*rseq)))\n\t\tgoto efault;\n\tunsafe_put_user(cpu_id, &rseq->cpu_id_start, efault_end);\n\tunsafe_put_user(cpu_id, &rseq->cpu_id, efault_end);\n\tuser_write_access_end();\n\ttrace_rseq_update(t);\n\treturn 0;\n\nefault_end:\n\tuser_write_access_end();\nefault:\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_write_access_end",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_rseq_update",
          "args": [
            "t"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_write_access_end",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsafe_put_user",
          "args": [
            "cpu_id",
            "&rseq->cpu_id",
            "efault_end"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsafe_put_user",
          "args": [
            "cpu_id",
            "&rseq->cpu_id_start",
            "efault_end"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_write_access_begin",
          "args": [
            "rseq",
            "sizeof(*rseq)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nstatic int rseq_update_cpu_id(struct task_struct *t)\n{\n\tu32 cpu_id = raw_smp_processor_id();\n\tstruct rseq __user *rseq = t->rseq;\n\n\tif (!user_write_access_begin(rseq, sizeof(*rseq)))\n\t\tgoto efault;\n\tunsafe_put_user(cpu_id, &rseq->cpu_id_start, efault_end);\n\tunsafe_put_user(cpu_id, &rseq->cpu_id, efault_end);\n\tuser_write_access_end();\n\ttrace_rseq_update(t);\n\treturn 0;\n\nefault_end:\n\tuser_write_access_end();\nefault:\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "rseq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rseq.c",
    "lines": "328-387",
    "snippet": "SYSCALL_DEFINE4(rseq, struct rseq __user *, rseq, u32, rseq_len,\n\t\tint, flags, u32, sig)\n{\n\tint ret;\n\n\tif (flags & RSEQ_FLAG_UNREGISTER) {\n\t\tif (flags & ~RSEQ_FLAG_UNREGISTER)\n\t\t\treturn -EINVAL;\n\t\t/* Unregister rseq for current thread. */\n\t\tif (current->rseq != rseq || !current->rseq)\n\t\t\treturn -EINVAL;\n\t\tif (rseq_len != sizeof(*rseq))\n\t\t\treturn -EINVAL;\n\t\tif (current->rseq_sig != sig)\n\t\t\treturn -EPERM;\n\t\tret = rseq_reset_rseq_cpu_id(current);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcurrent->rseq = NULL;\n\t\tcurrent->rseq_sig = 0;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(flags))\n\t\treturn -EINVAL;\n\n\tif (current->rseq) {\n\t\t/*\n\t\t * If rseq is already registered, check whether\n\t\t * the provided address differs from the prior\n\t\t * one.\n\t\t */\n\t\tif (current->rseq != rseq || rseq_len != sizeof(*rseq))\n\t\t\treturn -EINVAL;\n\t\tif (current->rseq_sig != sig)\n\t\t\treturn -EPERM;\n\t\t/* Already registered. */\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * If there was no rseq previously registered,\n\t * ensure the provided rseq is properly aligned and valid.\n\t */\n\tif (!IS_ALIGNED((unsigned long)rseq, __alignof__(*rseq)) ||\n\t    rseq_len != sizeof(*rseq))\n\t\treturn -EINVAL;\n\tif (!access_ok(rseq, rseq_len))\n\t\treturn -EFAULT;\n\tcurrent->rseq = rseq;\n\tcurrent->rseq_sig = sig;\n\t/*\n\t * If rseq was previously inactive, and has just been\n\t * registered, ensure the cpu_id_start and cpu_id fields\n\t * are updated before returning to user-space.\n\t */\n\trseq_set_notify_resume(current);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/rseq.h>",
      "#include <asm/ptrace.h>",
      "#include <linux/types.h>",
      "#include <linux/rseq.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/rseq.h>\n#include <asm/ptrace.h>\n#include <linux/types.h>\n#include <linux/rseq.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\nSYSCALL_DEFINE4(rseq, struct rseq __user *, rseq, u32, rseq_len,\n\t\tint, flags, u32, sig)\n{\n\tint ret;\n\n\tif (flags & RSEQ_FLAG_UNREGISTER) {\n\t\tif (flags & ~RSEQ_FLAG_UNREGISTER)\n\t\t\treturn -EINVAL;\n\t\t/* Unregister rseq for current thread. */\n\t\tif (current->rseq != rseq || !current->rseq)\n\t\t\treturn -EINVAL;\n\t\tif (rseq_len != sizeof(*rseq))\n\t\t\treturn -EINVAL;\n\t\tif (current->rseq_sig != sig)\n\t\t\treturn -EPERM;\n\t\tret = rseq_reset_rseq_cpu_id(current);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcurrent->rseq = NULL;\n\t\tcurrent->rseq_sig = 0;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(flags))\n\t\treturn -EINVAL;\n\n\tif (current->rseq) {\n\t\t/*\n\t\t * If rseq is already registered, check whether\n\t\t * the provided address differs from the prior\n\t\t * one.\n\t\t */\n\t\tif (current->rseq != rseq || rseq_len != sizeof(*rseq))\n\t\t\treturn -EINVAL;\n\t\tif (current->rseq_sig != sig)\n\t\t\treturn -EPERM;\n\t\t/* Already registered. */\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * If there was no rseq previously registered,\n\t * ensure the provided rseq is properly aligned and valid.\n\t */\n\tif (!IS_ALIGNED((unsigned long)rseq, __alignof__(*rseq)) ||\n\t    rseq_len != sizeof(*rseq))\n\t\treturn -EINVAL;\n\tif (!access_ok(rseq, rseq_len))\n\t\treturn -EFAULT;\n\tcurrent->rseq = rseq;\n\tcurrent->rseq_sig = sig;\n\t/*\n\t * If rseq was previously inactive, and has just been\n\t * registered, ensure the cpu_id_start and cpu_id fields\n\t * are updated before returning to user-space.\n\t */\n\trseq_set_notify_resume(current);\n\n\treturn 0;\n}"
  }
]