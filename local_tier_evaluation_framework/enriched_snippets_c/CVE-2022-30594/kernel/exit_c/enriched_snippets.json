[
  {
    "function_name": "do_wait_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "1471-1495",
    "snippet": "static int do_wait_pid(struct wait_opts *wo)\n{\n\tbool ptrace;\n\tstruct task_struct *target;\n\tint retval;\n\n\tptrace = false;\n\ttarget = pid_task(wo->wo_pid, PIDTYPE_TGID);\n\tif (target && is_effectively_child(wo, ptrace, target)) {\n\t\tretval = wait_consider_task(wo, ptrace, target);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tptrace = true;\n\ttarget = pid_task(wo->wo_pid, PIDTYPE_PID);\n\tif (target && target->ptrace &&\n\t    is_effectively_child(wo, ptrace, target)) {\n\t\tretval = wait_consider_task(wo, ptrace, target);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_consider_task",
          "args": [
            "wo",
            "ptrace",
            "target"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "wait_consider_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "1295-1396",
          "snippet": "static int wait_consider_task(struct wait_opts *wo, int ptrace,\n\t\t\t\tstruct task_struct *p)\n{\n\t/*\n\t * We can race with wait_task_zombie() from another thread.\n\t * Ensure that EXIT_ZOMBIE -> EXIT_DEAD/EXIT_TRACE transition\n\t * can't confuse the checks below.\n\t */\n\tint exit_state = READ_ONCE(p->exit_state);\n\tint ret;\n\n\tif (unlikely(exit_state == EXIT_DEAD))\n\t\treturn 0;\n\n\tret = eligible_child(wo, ptrace, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (unlikely(exit_state == EXIT_TRACE)) {\n\t\t/*\n\t\t * ptrace == 0 means we are the natural parent. In this case\n\t\t * we should clear notask_error, debugger will notify us.\n\t\t */\n\t\tif (likely(!ptrace))\n\t\t\two->notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t/*\n\t\t * If it is traced by its real parent's group, just pretend\n\t\t * the caller is ptrace_do_wait() and reap this child if it\n\t\t * is zombie.\n\t\t *\n\t\t * This also hides group stop state from real parent; otherwise\n\t\t * a single stop can be reported twice as group and ptrace stop.\n\t\t * If a ptracer wants to distinguish these two events for its\n\t\t * own children it should create a separate process which takes\n\t\t * the role of real parent.\n\t\t */\n\t\tif (!ptrace_reparented(p))\n\t\t\tptrace = 1;\n\t}\n\n\t/* slay zombie? */\n\tif (exit_state == EXIT_ZOMBIE) {\n\t\t/* we don't reap group leaders with subthreads */\n\t\tif (!delay_group_leader(p)) {\n\t\t\t/*\n\t\t\t * A zombie ptracee is only visible to its ptracer.\n\t\t\t * Notification and reaping will be cascaded to the\n\t\t\t * real parent when the ptracer detaches.\n\t\t\t */\n\t\t\tif (unlikely(ptrace) || likely(!p->ptrace))\n\t\t\t\treturn wait_task_zombie(wo, p);\n\t\t}\n\n\t\t/*\n\t\t * Allow access to stopped/continued state via zombie by\n\t\t * falling through.  Clearing of notask_error is complex.\n\t\t *\n\t\t * When !@ptrace:\n\t\t *\n\t\t * If WEXITED is set, notask_error should naturally be\n\t\t * cleared.  If not, subset of WSTOPPED|WCONTINUED is set,\n\t\t * so, if there are live subthreads, there are events to\n\t\t * wait for.  If all subthreads are dead, it's still safe\n\t\t * to clear - this function will be called again in finite\n\t\t * amount time once all the subthreads are released and\n\t\t * will then return without clearing.\n\t\t *\n\t\t * When @ptrace:\n\t\t *\n\t\t * Stopped state is per-task and thus can't change once the\n\t\t * target task dies.  Only continued and exited can happen.\n\t\t * Clear notask_error if WCONTINUED | WEXITED.\n\t\t */\n\t\tif (likely(!ptrace) || (wo->wo_flags & (WCONTINUED | WEXITED)))\n\t\t\two->notask_error = 0;\n\t} else {\n\t\t/*\n\t\t * @p is alive and it's gonna stop, continue or exit, so\n\t\t * there always is something to wait for.\n\t\t */\n\t\two->notask_error = 0;\n\t}\n\n\t/*\n\t * Wait for stopped.  Depending on @ptrace, different stopped state\n\t * is used and the two don't interact with each other.\n\t */\n\tret = wait_task_stopped(wo, ptrace, p);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Wait for continued.  There's only one continued state and the\n\t * ptracer can consume it which can confuse the real parent.  Don't\n\t * use WCONTINUED from ptracer.  You don't need or want it.\n\t */\n\treturn wait_task_continued(wo, p);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_consider_task(struct wait_opts *wo, int ptrace,\n\t\t\t\tstruct task_struct *p)\n{\n\t/*\n\t * We can race with wait_task_zombie() from another thread.\n\t * Ensure that EXIT_ZOMBIE -> EXIT_DEAD/EXIT_TRACE transition\n\t * can't confuse the checks below.\n\t */\n\tint exit_state = READ_ONCE(p->exit_state);\n\tint ret;\n\n\tif (unlikely(exit_state == EXIT_DEAD))\n\t\treturn 0;\n\n\tret = eligible_child(wo, ptrace, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (unlikely(exit_state == EXIT_TRACE)) {\n\t\t/*\n\t\t * ptrace == 0 means we are the natural parent. In this case\n\t\t * we should clear notask_error, debugger will notify us.\n\t\t */\n\t\tif (likely(!ptrace))\n\t\t\two->notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t/*\n\t\t * If it is traced by its real parent's group, just pretend\n\t\t * the caller is ptrace_do_wait() and reap this child if it\n\t\t * is zombie.\n\t\t *\n\t\t * This also hides group stop state from real parent; otherwise\n\t\t * a single stop can be reported twice as group and ptrace stop.\n\t\t * If a ptracer wants to distinguish these two events for its\n\t\t * own children it should create a separate process which takes\n\t\t * the role of real parent.\n\t\t */\n\t\tif (!ptrace_reparented(p))\n\t\t\tptrace = 1;\n\t}\n\n\t/* slay zombie? */\n\tif (exit_state == EXIT_ZOMBIE) {\n\t\t/* we don't reap group leaders with subthreads */\n\t\tif (!delay_group_leader(p)) {\n\t\t\t/*\n\t\t\t * A zombie ptracee is only visible to its ptracer.\n\t\t\t * Notification and reaping will be cascaded to the\n\t\t\t * real parent when the ptracer detaches.\n\t\t\t */\n\t\t\tif (unlikely(ptrace) || likely(!p->ptrace))\n\t\t\t\treturn wait_task_zombie(wo, p);\n\t\t}\n\n\t\t/*\n\t\t * Allow access to stopped/continued state via zombie by\n\t\t * falling through.  Clearing of notask_error is complex.\n\t\t *\n\t\t * When !@ptrace:\n\t\t *\n\t\t * If WEXITED is set, notask_error should naturally be\n\t\t * cleared.  If not, subset of WSTOPPED|WCONTINUED is set,\n\t\t * so, if there are live subthreads, there are events to\n\t\t * wait for.  If all subthreads are dead, it's still safe\n\t\t * to clear - this function will be called again in finite\n\t\t * amount time once all the subthreads are released and\n\t\t * will then return without clearing.\n\t\t *\n\t\t * When @ptrace:\n\t\t *\n\t\t * Stopped state is per-task and thus can't change once the\n\t\t * target task dies.  Only continued and exited can happen.\n\t\t * Clear notask_error if WCONTINUED | WEXITED.\n\t\t */\n\t\tif (likely(!ptrace) || (wo->wo_flags & (WCONTINUED | WEXITED)))\n\t\t\two->notask_error = 0;\n\t} else {\n\t\t/*\n\t\t * @p is alive and it's gonna stop, continue or exit, so\n\t\t * there always is something to wait for.\n\t\t */\n\t\two->notask_error = 0;\n\t}\n\n\t/*\n\t * Wait for stopped.  Depending on @ptrace, different stopped state\n\t * is used and the two don't interact with each other.\n\t */\n\tret = wait_task_stopped(wo, ptrace, p);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Wait for continued.  There's only one continued state and the\n\t * ptracer can consume it which can confuse the real parent.  Don't\n\t * use WCONTINUED from ptracer.  You don't need or want it.\n\t */\n\treturn wait_task_continued(wo, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_effectively_child",
          "args": [
            "wo",
            "ptrace",
            "target"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "is_effectively_child",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "1457-1465",
          "snippet": "static bool is_effectively_child(struct wait_opts *wo, bool ptrace,\n\t\t\t\t struct task_struct *target)\n{\n\tstruct task_struct *parent =\n\t\t!ptrace ? target->real_parent : target->parent;\n\n\treturn current == parent || (!(wo->wo_flags & __WNOTHREAD) &&\n\t\t\t\t     same_thread_group(current, parent));\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic bool is_effectively_child(struct wait_opts *wo, bool ptrace,\n\t\t\t\t struct task_struct *target)\n{\n\tstruct task_struct *parent =\n\t\t!ptrace ? target->real_parent : target->parent;\n\n\treturn current == parent || (!(wo->wo_flags & __WNOTHREAD) &&\n\t\t\t\t     same_thread_group(current, parent));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "wo->wo_pid",
            "PIDTYPE_PID"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "448-457",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int do_wait_pid(struct wait_opts *wo)\n{\n\tbool ptrace;\n\tstruct task_struct *target;\n\tint retval;\n\n\tptrace = false;\n\ttarget = pid_task(wo->wo_pid, PIDTYPE_TGID);\n\tif (target && is_effectively_child(wo, ptrace, target)) {\n\t\tretval = wait_consider_task(wo, ptrace, target);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tptrace = true;\n\ttarget = pid_task(wo->wo_pid, PIDTYPE_PID);\n\tif (target && target->ptrace &&\n\t    is_effectively_child(wo, ptrace, target)) {\n\t\tretval = wait_consider_task(wo, ptrace, target);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_effectively_child",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "1457-1465",
    "snippet": "static bool is_effectively_child(struct wait_opts *wo, bool ptrace,\n\t\t\t\t struct task_struct *target)\n{\n\tstruct task_struct *parent =\n\t\t!ptrace ? target->real_parent : target->parent;\n\n\treturn current == parent || (!(wo->wo_flags & __WNOTHREAD) &&\n\t\t\t\t     same_thread_group(current, parent));\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "current",
            "parent"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic bool is_effectively_child(struct wait_opts *wo, bool ptrace,\n\t\t\t\t struct task_struct *target)\n{\n\tstruct task_struct *parent =\n\t\t!ptrace ? target->real_parent : target->parent;\n\n\treturn current == parent || (!(wo->wo_flags & __WNOTHREAD) &&\n\t\t\t\t     same_thread_group(current, parent));\n}"
  },
  {
    "function_name": "__wake_up_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "1451-1455",
    "snippet": "void __wake_up_parent(struct task_struct *p, struct task_struct *parent)\n{\n\t__wake_up_sync_key(&parent->signal->wait_chldexit,\n\t\t\t   TASK_INTERRUPTIBLE, p);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_sync_key",
          "args": [
            "&parent->signal->wait_chldexit",
            "TASK_INTERRUPTIBLE",
            "p"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_sync_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "199-206",
          "snippet": "void __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tvoid *key)\n{\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\t__wake_up_common_lock(wq_head, mode, 1, WF_SYNC, key);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tvoid *key)\n{\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\t__wake_up_common_lock(wq_head, mode, 1, WF_SYNC, key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __wake_up_parent(struct task_struct *p, struct task_struct *parent)\n{\n\t__wake_up_sync_key(&parent->signal->wait_chldexit,\n\t\t\t   TASK_INTERRUPTIBLE, p);\n}"
  },
  {
    "function_name": "child_wait_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "1435-1449",
    "snippet": "static int child_wait_callback(wait_queue_entry_t *wait, unsigned mode,\n\t\t\t\tint sync, void *key)\n{\n\tstruct wait_opts *wo = container_of(wait, struct wait_opts,\n\t\t\t\t\t\tchild_wait);\n\tstruct task_struct *p = key;\n\n\tif (!eligible_pid(wo, p))\n\t\treturn 0;\n\n\tif ((wo->wo_flags & __WNOTHREAD) && wait->private != p->parent)\n\t\treturn 0;\n\n\treturn default_wake_function(wait, mode, sync, key);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "default_wake_function",
          "args": [
            "wait",
            "mode",
            "sync",
            "key"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "default_wake_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6719-6724",
          "snippet": "int default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags,\n\t\t\t  void *key)\n{\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_SCHED_DEBUG) && wake_flags & ~WF_SYNC);\n\treturn try_to_wake_up(curr->private, mode, wake_flags);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags,\n\t\t\t  void *key)\n{\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_SCHED_DEBUG) && wake_flags & ~WF_SYNC);\n\treturn try_to_wake_up(curr->private, mode, wake_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eligible_pid",
          "args": [
            "wo",
            "p"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "eligible_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "972-976",
          "snippet": "static int eligible_pid(struct wait_opts *wo, struct task_struct *p)\n{\n\treturn\two->wo_type == PIDTYPE_MAX ||\n\t\ttask_pid_type(p, wo->wo_type) == wo->wo_pid;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int eligible_pid(struct wait_opts *wo, struct task_struct *p)\n{\n\treturn\two->wo_type == PIDTYPE_MAX ||\n\t\ttask_pid_type(p, wo->wo_type) == wo->wo_pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wait",
            "structwait_opts",
            "child_wait"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int child_wait_callback(wait_queue_entry_t *wait, unsigned mode,\n\t\t\t\tint sync, void *key)\n{\n\tstruct wait_opts *wo = container_of(wait, struct wait_opts,\n\t\t\t\t\t\tchild_wait);\n\tstruct task_struct *p = key;\n\n\tif (!eligible_pid(wo, p))\n\t\treturn 0;\n\n\tif ((wo->wo_flags & __WNOTHREAD) && wait->private != p->parent)\n\t\treturn 0;\n\n\treturn default_wake_function(wait, mode, sync, key);\n}"
  },
  {
    "function_name": "ptrace_do_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "1421-1433",
    "snippet": "static int ptrace_do_wait(struct wait_opts *wo, struct task_struct *tsk)\n{\n\tstruct task_struct *p;\n\n\tlist_for_each_entry(p, &tsk->ptraced, ptrace_entry) {\n\t\tint ret = wait_consider_task(wo, 1, p);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_consider_task",
          "args": [
            "wo",
            "1",
            "p"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "wait_consider_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "1295-1396",
          "snippet": "static int wait_consider_task(struct wait_opts *wo, int ptrace,\n\t\t\t\tstruct task_struct *p)\n{\n\t/*\n\t * We can race with wait_task_zombie() from another thread.\n\t * Ensure that EXIT_ZOMBIE -> EXIT_DEAD/EXIT_TRACE transition\n\t * can't confuse the checks below.\n\t */\n\tint exit_state = READ_ONCE(p->exit_state);\n\tint ret;\n\n\tif (unlikely(exit_state == EXIT_DEAD))\n\t\treturn 0;\n\n\tret = eligible_child(wo, ptrace, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (unlikely(exit_state == EXIT_TRACE)) {\n\t\t/*\n\t\t * ptrace == 0 means we are the natural parent. In this case\n\t\t * we should clear notask_error, debugger will notify us.\n\t\t */\n\t\tif (likely(!ptrace))\n\t\t\two->notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t/*\n\t\t * If it is traced by its real parent's group, just pretend\n\t\t * the caller is ptrace_do_wait() and reap this child if it\n\t\t * is zombie.\n\t\t *\n\t\t * This also hides group stop state from real parent; otherwise\n\t\t * a single stop can be reported twice as group and ptrace stop.\n\t\t * If a ptracer wants to distinguish these two events for its\n\t\t * own children it should create a separate process which takes\n\t\t * the role of real parent.\n\t\t */\n\t\tif (!ptrace_reparented(p))\n\t\t\tptrace = 1;\n\t}\n\n\t/* slay zombie? */\n\tif (exit_state == EXIT_ZOMBIE) {\n\t\t/* we don't reap group leaders with subthreads */\n\t\tif (!delay_group_leader(p)) {\n\t\t\t/*\n\t\t\t * A zombie ptracee is only visible to its ptracer.\n\t\t\t * Notification and reaping will be cascaded to the\n\t\t\t * real parent when the ptracer detaches.\n\t\t\t */\n\t\t\tif (unlikely(ptrace) || likely(!p->ptrace))\n\t\t\t\treturn wait_task_zombie(wo, p);\n\t\t}\n\n\t\t/*\n\t\t * Allow access to stopped/continued state via zombie by\n\t\t * falling through.  Clearing of notask_error is complex.\n\t\t *\n\t\t * When !@ptrace:\n\t\t *\n\t\t * If WEXITED is set, notask_error should naturally be\n\t\t * cleared.  If not, subset of WSTOPPED|WCONTINUED is set,\n\t\t * so, if there are live subthreads, there are events to\n\t\t * wait for.  If all subthreads are dead, it's still safe\n\t\t * to clear - this function will be called again in finite\n\t\t * amount time once all the subthreads are released and\n\t\t * will then return without clearing.\n\t\t *\n\t\t * When @ptrace:\n\t\t *\n\t\t * Stopped state is per-task and thus can't change once the\n\t\t * target task dies.  Only continued and exited can happen.\n\t\t * Clear notask_error if WCONTINUED | WEXITED.\n\t\t */\n\t\tif (likely(!ptrace) || (wo->wo_flags & (WCONTINUED | WEXITED)))\n\t\t\two->notask_error = 0;\n\t} else {\n\t\t/*\n\t\t * @p is alive and it's gonna stop, continue or exit, so\n\t\t * there always is something to wait for.\n\t\t */\n\t\two->notask_error = 0;\n\t}\n\n\t/*\n\t * Wait for stopped.  Depending on @ptrace, different stopped state\n\t * is used and the two don't interact with each other.\n\t */\n\tret = wait_task_stopped(wo, ptrace, p);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Wait for continued.  There's only one continued state and the\n\t * ptracer can consume it which can confuse the real parent.  Don't\n\t * use WCONTINUED from ptracer.  You don't need or want it.\n\t */\n\treturn wait_task_continued(wo, p);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_consider_task(struct wait_opts *wo, int ptrace,\n\t\t\t\tstruct task_struct *p)\n{\n\t/*\n\t * We can race with wait_task_zombie() from another thread.\n\t * Ensure that EXIT_ZOMBIE -> EXIT_DEAD/EXIT_TRACE transition\n\t * can't confuse the checks below.\n\t */\n\tint exit_state = READ_ONCE(p->exit_state);\n\tint ret;\n\n\tif (unlikely(exit_state == EXIT_DEAD))\n\t\treturn 0;\n\n\tret = eligible_child(wo, ptrace, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (unlikely(exit_state == EXIT_TRACE)) {\n\t\t/*\n\t\t * ptrace == 0 means we are the natural parent. In this case\n\t\t * we should clear notask_error, debugger will notify us.\n\t\t */\n\t\tif (likely(!ptrace))\n\t\t\two->notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t/*\n\t\t * If it is traced by its real parent's group, just pretend\n\t\t * the caller is ptrace_do_wait() and reap this child if it\n\t\t * is zombie.\n\t\t *\n\t\t * This also hides group stop state from real parent; otherwise\n\t\t * a single stop can be reported twice as group and ptrace stop.\n\t\t * If a ptracer wants to distinguish these two events for its\n\t\t * own children it should create a separate process which takes\n\t\t * the role of real parent.\n\t\t */\n\t\tif (!ptrace_reparented(p))\n\t\t\tptrace = 1;\n\t}\n\n\t/* slay zombie? */\n\tif (exit_state == EXIT_ZOMBIE) {\n\t\t/* we don't reap group leaders with subthreads */\n\t\tif (!delay_group_leader(p)) {\n\t\t\t/*\n\t\t\t * A zombie ptracee is only visible to its ptracer.\n\t\t\t * Notification and reaping will be cascaded to the\n\t\t\t * real parent when the ptracer detaches.\n\t\t\t */\n\t\t\tif (unlikely(ptrace) || likely(!p->ptrace))\n\t\t\t\treturn wait_task_zombie(wo, p);\n\t\t}\n\n\t\t/*\n\t\t * Allow access to stopped/continued state via zombie by\n\t\t * falling through.  Clearing of notask_error is complex.\n\t\t *\n\t\t * When !@ptrace:\n\t\t *\n\t\t * If WEXITED is set, notask_error should naturally be\n\t\t * cleared.  If not, subset of WSTOPPED|WCONTINUED is set,\n\t\t * so, if there are live subthreads, there are events to\n\t\t * wait for.  If all subthreads are dead, it's still safe\n\t\t * to clear - this function will be called again in finite\n\t\t * amount time once all the subthreads are released and\n\t\t * will then return without clearing.\n\t\t *\n\t\t * When @ptrace:\n\t\t *\n\t\t * Stopped state is per-task and thus can't change once the\n\t\t * target task dies.  Only continued and exited can happen.\n\t\t * Clear notask_error if WCONTINUED | WEXITED.\n\t\t */\n\t\tif (likely(!ptrace) || (wo->wo_flags & (WCONTINUED | WEXITED)))\n\t\t\two->notask_error = 0;\n\t} else {\n\t\t/*\n\t\t * @p is alive and it's gonna stop, continue or exit, so\n\t\t * there always is something to wait for.\n\t\t */\n\t\two->notask_error = 0;\n\t}\n\n\t/*\n\t * Wait for stopped.  Depending on @ptrace, different stopped state\n\t * is used and the two don't interact with each other.\n\t */\n\tret = wait_task_stopped(wo, ptrace, p);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Wait for continued.  There's only one continued state and the\n\t * ptracer can consume it which can confuse the real parent.  Don't\n\t * use WCONTINUED from ptracer.  You don't need or want it.\n\t */\n\treturn wait_task_continued(wo, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&tsk->ptraced",
            "ptrace_entry"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int ptrace_do_wait(struct wait_opts *wo, struct task_struct *tsk)\n{\n\tstruct task_struct *p;\n\n\tlist_for_each_entry(p, &tsk->ptraced, ptrace_entry) {\n\t\tint ret = wait_consider_task(wo, 1, p);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_wait_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "1407-1419",
    "snippet": "static int do_wait_thread(struct wait_opts *wo, struct task_struct *tsk)\n{\n\tstruct task_struct *p;\n\n\tlist_for_each_entry(p, &tsk->children, sibling) {\n\t\tint ret = wait_consider_task(wo, 0, p);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_consider_task",
          "args": [
            "wo",
            "0",
            "p"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "wait_consider_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "1295-1396",
          "snippet": "static int wait_consider_task(struct wait_opts *wo, int ptrace,\n\t\t\t\tstruct task_struct *p)\n{\n\t/*\n\t * We can race with wait_task_zombie() from another thread.\n\t * Ensure that EXIT_ZOMBIE -> EXIT_DEAD/EXIT_TRACE transition\n\t * can't confuse the checks below.\n\t */\n\tint exit_state = READ_ONCE(p->exit_state);\n\tint ret;\n\n\tif (unlikely(exit_state == EXIT_DEAD))\n\t\treturn 0;\n\n\tret = eligible_child(wo, ptrace, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (unlikely(exit_state == EXIT_TRACE)) {\n\t\t/*\n\t\t * ptrace == 0 means we are the natural parent. In this case\n\t\t * we should clear notask_error, debugger will notify us.\n\t\t */\n\t\tif (likely(!ptrace))\n\t\t\two->notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t/*\n\t\t * If it is traced by its real parent's group, just pretend\n\t\t * the caller is ptrace_do_wait() and reap this child if it\n\t\t * is zombie.\n\t\t *\n\t\t * This also hides group stop state from real parent; otherwise\n\t\t * a single stop can be reported twice as group and ptrace stop.\n\t\t * If a ptracer wants to distinguish these two events for its\n\t\t * own children it should create a separate process which takes\n\t\t * the role of real parent.\n\t\t */\n\t\tif (!ptrace_reparented(p))\n\t\t\tptrace = 1;\n\t}\n\n\t/* slay zombie? */\n\tif (exit_state == EXIT_ZOMBIE) {\n\t\t/* we don't reap group leaders with subthreads */\n\t\tif (!delay_group_leader(p)) {\n\t\t\t/*\n\t\t\t * A zombie ptracee is only visible to its ptracer.\n\t\t\t * Notification and reaping will be cascaded to the\n\t\t\t * real parent when the ptracer detaches.\n\t\t\t */\n\t\t\tif (unlikely(ptrace) || likely(!p->ptrace))\n\t\t\t\treturn wait_task_zombie(wo, p);\n\t\t}\n\n\t\t/*\n\t\t * Allow access to stopped/continued state via zombie by\n\t\t * falling through.  Clearing of notask_error is complex.\n\t\t *\n\t\t * When !@ptrace:\n\t\t *\n\t\t * If WEXITED is set, notask_error should naturally be\n\t\t * cleared.  If not, subset of WSTOPPED|WCONTINUED is set,\n\t\t * so, if there are live subthreads, there are events to\n\t\t * wait for.  If all subthreads are dead, it's still safe\n\t\t * to clear - this function will be called again in finite\n\t\t * amount time once all the subthreads are released and\n\t\t * will then return without clearing.\n\t\t *\n\t\t * When @ptrace:\n\t\t *\n\t\t * Stopped state is per-task and thus can't change once the\n\t\t * target task dies.  Only continued and exited can happen.\n\t\t * Clear notask_error if WCONTINUED | WEXITED.\n\t\t */\n\t\tif (likely(!ptrace) || (wo->wo_flags & (WCONTINUED | WEXITED)))\n\t\t\two->notask_error = 0;\n\t} else {\n\t\t/*\n\t\t * @p is alive and it's gonna stop, continue or exit, so\n\t\t * there always is something to wait for.\n\t\t */\n\t\two->notask_error = 0;\n\t}\n\n\t/*\n\t * Wait for stopped.  Depending on @ptrace, different stopped state\n\t * is used and the two don't interact with each other.\n\t */\n\tret = wait_task_stopped(wo, ptrace, p);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Wait for continued.  There's only one continued state and the\n\t * ptracer can consume it which can confuse the real parent.  Don't\n\t * use WCONTINUED from ptracer.  You don't need or want it.\n\t */\n\treturn wait_task_continued(wo, p);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_consider_task(struct wait_opts *wo, int ptrace,\n\t\t\t\tstruct task_struct *p)\n{\n\t/*\n\t * We can race with wait_task_zombie() from another thread.\n\t * Ensure that EXIT_ZOMBIE -> EXIT_DEAD/EXIT_TRACE transition\n\t * can't confuse the checks below.\n\t */\n\tint exit_state = READ_ONCE(p->exit_state);\n\tint ret;\n\n\tif (unlikely(exit_state == EXIT_DEAD))\n\t\treturn 0;\n\n\tret = eligible_child(wo, ptrace, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (unlikely(exit_state == EXIT_TRACE)) {\n\t\t/*\n\t\t * ptrace == 0 means we are the natural parent. In this case\n\t\t * we should clear notask_error, debugger will notify us.\n\t\t */\n\t\tif (likely(!ptrace))\n\t\t\two->notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t/*\n\t\t * If it is traced by its real parent's group, just pretend\n\t\t * the caller is ptrace_do_wait() and reap this child if it\n\t\t * is zombie.\n\t\t *\n\t\t * This also hides group stop state from real parent; otherwise\n\t\t * a single stop can be reported twice as group and ptrace stop.\n\t\t * If a ptracer wants to distinguish these two events for its\n\t\t * own children it should create a separate process which takes\n\t\t * the role of real parent.\n\t\t */\n\t\tif (!ptrace_reparented(p))\n\t\t\tptrace = 1;\n\t}\n\n\t/* slay zombie? */\n\tif (exit_state == EXIT_ZOMBIE) {\n\t\t/* we don't reap group leaders with subthreads */\n\t\tif (!delay_group_leader(p)) {\n\t\t\t/*\n\t\t\t * A zombie ptracee is only visible to its ptracer.\n\t\t\t * Notification and reaping will be cascaded to the\n\t\t\t * real parent when the ptracer detaches.\n\t\t\t */\n\t\t\tif (unlikely(ptrace) || likely(!p->ptrace))\n\t\t\t\treturn wait_task_zombie(wo, p);\n\t\t}\n\n\t\t/*\n\t\t * Allow access to stopped/continued state via zombie by\n\t\t * falling through.  Clearing of notask_error is complex.\n\t\t *\n\t\t * When !@ptrace:\n\t\t *\n\t\t * If WEXITED is set, notask_error should naturally be\n\t\t * cleared.  If not, subset of WSTOPPED|WCONTINUED is set,\n\t\t * so, if there are live subthreads, there are events to\n\t\t * wait for.  If all subthreads are dead, it's still safe\n\t\t * to clear - this function will be called again in finite\n\t\t * amount time once all the subthreads are released and\n\t\t * will then return without clearing.\n\t\t *\n\t\t * When @ptrace:\n\t\t *\n\t\t * Stopped state is per-task and thus can't change once the\n\t\t * target task dies.  Only continued and exited can happen.\n\t\t * Clear notask_error if WCONTINUED | WEXITED.\n\t\t */\n\t\tif (likely(!ptrace) || (wo->wo_flags & (WCONTINUED | WEXITED)))\n\t\t\two->notask_error = 0;\n\t} else {\n\t\t/*\n\t\t * @p is alive and it's gonna stop, continue or exit, so\n\t\t * there always is something to wait for.\n\t\t */\n\t\two->notask_error = 0;\n\t}\n\n\t/*\n\t * Wait for stopped.  Depending on @ptrace, different stopped state\n\t * is used and the two don't interact with each other.\n\t */\n\tret = wait_task_stopped(wo, ptrace, p);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Wait for continued.  There's only one continued state and the\n\t * ptracer can consume it which can confuse the real parent.  Don't\n\t * use WCONTINUED from ptracer.  You don't need or want it.\n\t */\n\treturn wait_task_continued(wo, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&tsk->children",
            "sibling"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int do_wait_thread(struct wait_opts *wo, struct task_struct *tsk)\n{\n\tstruct task_struct *p;\n\n\tlist_for_each_entry(p, &tsk->children, sibling) {\n\t\tint ret = wait_consider_task(wo, 0, p);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wait_consider_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "1295-1396",
    "snippet": "static int wait_consider_task(struct wait_opts *wo, int ptrace,\n\t\t\t\tstruct task_struct *p)\n{\n\t/*\n\t * We can race with wait_task_zombie() from another thread.\n\t * Ensure that EXIT_ZOMBIE -> EXIT_DEAD/EXIT_TRACE transition\n\t * can't confuse the checks below.\n\t */\n\tint exit_state = READ_ONCE(p->exit_state);\n\tint ret;\n\n\tif (unlikely(exit_state == EXIT_DEAD))\n\t\treturn 0;\n\n\tret = eligible_child(wo, ptrace, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (unlikely(exit_state == EXIT_TRACE)) {\n\t\t/*\n\t\t * ptrace == 0 means we are the natural parent. In this case\n\t\t * we should clear notask_error, debugger will notify us.\n\t\t */\n\t\tif (likely(!ptrace))\n\t\t\two->notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t/*\n\t\t * If it is traced by its real parent's group, just pretend\n\t\t * the caller is ptrace_do_wait() and reap this child if it\n\t\t * is zombie.\n\t\t *\n\t\t * This also hides group stop state from real parent; otherwise\n\t\t * a single stop can be reported twice as group and ptrace stop.\n\t\t * If a ptracer wants to distinguish these two events for its\n\t\t * own children it should create a separate process which takes\n\t\t * the role of real parent.\n\t\t */\n\t\tif (!ptrace_reparented(p))\n\t\t\tptrace = 1;\n\t}\n\n\t/* slay zombie? */\n\tif (exit_state == EXIT_ZOMBIE) {\n\t\t/* we don't reap group leaders with subthreads */\n\t\tif (!delay_group_leader(p)) {\n\t\t\t/*\n\t\t\t * A zombie ptracee is only visible to its ptracer.\n\t\t\t * Notification and reaping will be cascaded to the\n\t\t\t * real parent when the ptracer detaches.\n\t\t\t */\n\t\t\tif (unlikely(ptrace) || likely(!p->ptrace))\n\t\t\t\treturn wait_task_zombie(wo, p);\n\t\t}\n\n\t\t/*\n\t\t * Allow access to stopped/continued state via zombie by\n\t\t * falling through.  Clearing of notask_error is complex.\n\t\t *\n\t\t * When !@ptrace:\n\t\t *\n\t\t * If WEXITED is set, notask_error should naturally be\n\t\t * cleared.  If not, subset of WSTOPPED|WCONTINUED is set,\n\t\t * so, if there are live subthreads, there are events to\n\t\t * wait for.  If all subthreads are dead, it's still safe\n\t\t * to clear - this function will be called again in finite\n\t\t * amount time once all the subthreads are released and\n\t\t * will then return without clearing.\n\t\t *\n\t\t * When @ptrace:\n\t\t *\n\t\t * Stopped state is per-task and thus can't change once the\n\t\t * target task dies.  Only continued and exited can happen.\n\t\t * Clear notask_error if WCONTINUED | WEXITED.\n\t\t */\n\t\tif (likely(!ptrace) || (wo->wo_flags & (WCONTINUED | WEXITED)))\n\t\t\two->notask_error = 0;\n\t} else {\n\t\t/*\n\t\t * @p is alive and it's gonna stop, continue or exit, so\n\t\t * there always is something to wait for.\n\t\t */\n\t\two->notask_error = 0;\n\t}\n\n\t/*\n\t * Wait for stopped.  Depending on @ptrace, different stopped state\n\t * is used and the two don't interact with each other.\n\t */\n\tret = wait_task_stopped(wo, ptrace, p);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Wait for continued.  There's only one continued state and the\n\t * ptracer can consume it which can confuse the real parent.  Don't\n\t * use WCONTINUED from ptracer.  You don't need or want it.\n\t */\n\treturn wait_task_continued(wo, p);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_task_continued",
          "args": [
            "wo",
            "p"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "wait_task_continued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "1243-1284",
          "snippet": "static int wait_task_continued(struct wait_opts *wo, struct task_struct *p)\n{\n\tstruct waitid_info *infop;\n\tpid_t pid;\n\tuid_t uid;\n\n\tif (!unlikely(wo->wo_flags & WCONTINUED))\n\t\treturn 0;\n\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED))\n\t\treturn 0;\n\n\tspin_lock_irq(&p->sighand->siglock);\n\t/* Re-check with the lock held.  */\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED)) {\n\t\tspin_unlock_irq(&p->sighand->siglock);\n\t\treturn 0;\n\t}\n\tif (!unlikely(wo->wo_flags & WNOWAIT))\n\t\tp->signal->flags &= ~SIGNAL_STOP_CONTINUED;\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tspin_unlock_irq(&p->sighand->siglock);\n\n\tpid = task_pid_vnr(p);\n\tget_task_struct(p);\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tput_task_struct(p);\n\n\tinfop = wo->wo_info;\n\tif (!infop) {\n\t\two->wo_stat = 0xffff;\n\t} else {\n\t\tinfop->cause = CLD_CONTINUED;\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t\tinfop->status = SIGCONT;\n\t}\n\treturn pid;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_task_continued(struct wait_opts *wo, struct task_struct *p)\n{\n\tstruct waitid_info *infop;\n\tpid_t pid;\n\tuid_t uid;\n\n\tif (!unlikely(wo->wo_flags & WCONTINUED))\n\t\treturn 0;\n\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED))\n\t\treturn 0;\n\n\tspin_lock_irq(&p->sighand->siglock);\n\t/* Re-check with the lock held.  */\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED)) {\n\t\tspin_unlock_irq(&p->sighand->siglock);\n\t\treturn 0;\n\t}\n\tif (!unlikely(wo->wo_flags & WNOWAIT))\n\t\tp->signal->flags &= ~SIGNAL_STOP_CONTINUED;\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tspin_unlock_irq(&p->sighand->siglock);\n\n\tpid = task_pid_vnr(p);\n\tget_task_struct(p);\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tput_task_struct(p);\n\n\tinfop = wo->wo_info;\n\tif (!infop) {\n\t\two->wo_stat = 0xffff;\n\t} else {\n\t\tinfop->cause = CLD_CONTINUED;\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t\tinfop->status = SIGCONT;\n\t}\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_task_stopped",
          "args": [
            "wo",
            "ptrace",
            "p"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "wait_task_stopped",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "1171-1235",
          "snippet": "static int wait_task_stopped(struct wait_opts *wo,\n\t\t\t\tint ptrace, struct task_struct *p)\n{\n\tstruct waitid_info *infop;\n\tint exit_code, *p_code, why;\n\tuid_t uid = 0; /* unneeded, required by compiler */\n\tpid_t pid;\n\n\t/*\n\t * Traditionally we see ptrace'd stopped tasks regardless of options.\n\t */\n\tif (!ptrace && !(wo->wo_flags & WUNTRACED))\n\t\treturn 0;\n\n\tif (!task_stopped_code(p, ptrace))\n\t\treturn 0;\n\n\texit_code = 0;\n\tspin_lock_irq(&p->sighand->siglock);\n\n\tp_code = task_stopped_code(p, ptrace);\n\tif (unlikely(!p_code))\n\t\tgoto unlock_sig;\n\n\texit_code = *p_code;\n\tif (!exit_code)\n\t\tgoto unlock_sig;\n\n\tif (!unlikely(wo->wo_flags & WNOWAIT))\n\t\t*p_code = 0;\n\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\nunlock_sig:\n\tspin_unlock_irq(&p->sighand->siglock);\n\tif (!exit_code)\n\t\treturn 0;\n\n\t/*\n\t * Now we are pretty sure this task is interesting.\n\t * Make sure it doesn't get reaped out from under us while we\n\t * give up the lock and then examine it below.  We don't want to\n\t * keep holding onto the tasklist_lock while we call getrusage and\n\t * possibly take page faults for user memory.\n\t */\n\tget_task_struct(p);\n\tpid = task_pid_vnr(p);\n\twhy = ptrace ? CLD_TRAPPED : CLD_STOPPED;\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tput_task_struct(p);\n\n\tif (likely(!(wo->wo_flags & WNOWAIT)))\n\t\two->wo_stat = (exit_code << 8) | 0x7f;\n\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tinfop->cause = why;\n\t\tinfop->status = exit_code;\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t}\n\treturn pid;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_task_stopped(struct wait_opts *wo,\n\t\t\t\tint ptrace, struct task_struct *p)\n{\n\tstruct waitid_info *infop;\n\tint exit_code, *p_code, why;\n\tuid_t uid = 0; /* unneeded, required by compiler */\n\tpid_t pid;\n\n\t/*\n\t * Traditionally we see ptrace'd stopped tasks regardless of options.\n\t */\n\tif (!ptrace && !(wo->wo_flags & WUNTRACED))\n\t\treturn 0;\n\n\tif (!task_stopped_code(p, ptrace))\n\t\treturn 0;\n\n\texit_code = 0;\n\tspin_lock_irq(&p->sighand->siglock);\n\n\tp_code = task_stopped_code(p, ptrace);\n\tif (unlikely(!p_code))\n\t\tgoto unlock_sig;\n\n\texit_code = *p_code;\n\tif (!exit_code)\n\t\tgoto unlock_sig;\n\n\tif (!unlikely(wo->wo_flags & WNOWAIT))\n\t\t*p_code = 0;\n\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\nunlock_sig:\n\tspin_unlock_irq(&p->sighand->siglock);\n\tif (!exit_code)\n\t\treturn 0;\n\n\t/*\n\t * Now we are pretty sure this task is interesting.\n\t * Make sure it doesn't get reaped out from under us while we\n\t * give up the lock and then examine it below.  We don't want to\n\t * keep holding onto the tasklist_lock while we call getrusage and\n\t * possibly take page faults for user memory.\n\t */\n\tget_task_struct(p);\n\tpid = task_pid_vnr(p);\n\twhy = ptrace ? CLD_TRAPPED : CLD_STOPPED;\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tput_task_struct(p);\n\n\tif (likely(!(wo->wo_flags & WNOWAIT)))\n\t\two->wo_stat = (exit_code << 8) | 0x7f;\n\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tinfop->cause = why;\n\t\tinfop->status = exit_code;\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t}\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ptrace"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_task_zombie",
          "args": [
            "wo",
            "p"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "wait_task_zombie",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "1011-1139",
          "snippet": "static int wait_task_zombie(struct wait_opts *wo, struct task_struct *p)\n{\n\tint state, status;\n\tpid_t pid = task_pid_vnr(p);\n\tuid_t uid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tstruct waitid_info *infop;\n\n\tif (!likely(wo->wo_flags & WEXITED))\n\t\treturn 0;\n\n\tif (unlikely(wo->wo_flags & WNOWAIT)) {\n\t\tstatus = (p->signal->flags & SIGNAL_GROUP_EXIT)\n\t\t\t? p->signal->group_exit_code : p->exit_code;\n\t\tget_task_struct(p);\n\t\tread_unlock(&tasklist_lock);\n\t\tsched_annotate_sleep();\n\t\tif (wo->wo_rusage)\n\t\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\t\tput_task_struct(p);\n\t\tgoto out_info;\n\t}\n\t/*\n\t * Move the task's state to DEAD/TRACE, only one thread can do this.\n\t */\n\tstate = (ptrace_reparented(p) && thread_group_leader(p)) ?\n\t\tEXIT_TRACE : EXIT_DEAD;\n\tif (cmpxchg(&p->exit_state, EXIT_ZOMBIE, state) != EXIT_ZOMBIE)\n\t\treturn 0;\n\t/*\n\t * We own this thread, nobody else can reap it.\n\t */\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\n\t/*\n\t * Check thread_group_leader() to exclude the traced sub-threads.\n\t */\n\tif (state == EXIT_DEAD && thread_group_leader(p)) {\n\t\tstruct signal_struct *sig = p->signal;\n\t\tstruct signal_struct *psig = current->signal;\n\t\tunsigned long maxrss;\n\t\tu64 tgutime, tgstime;\n\n\t\t/*\n\t\t * The resource counters for the group leader are in its\n\t\t * own task_struct.  Those for dead threads in the group\n\t\t * are in its signal_struct, as are those for the child\n\t\t * processes it has previously reaped.  All these\n\t\t * accumulate in the parent's signal_struct c* fields.\n\t\t *\n\t\t * We don't bother to take a lock here to protect these\n\t\t * p->signal fields because the whole thread group is dead\n\t\t * and nobody can change them.\n\t\t *\n\t\t * psig->stats_lock also protects us from our sub-theads\n\t\t * which can reap other children at the same time. Until\n\t\t * we change k_getrusage()-like users to rely on this lock\n\t\t * we have to take ->siglock as well.\n\t\t *\n\t\t * We use thread_group_cputime_adjusted() to get times for\n\t\t * the thread group, which consolidates times for all threads\n\t\t * in the group including the group leader.\n\t\t */\n\t\tthread_group_cputime_adjusted(p, &tgutime, &tgstime);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\twrite_seqlock(&psig->stats_lock);\n\t\tpsig->cutime += tgutime + sig->cutime;\n\t\tpsig->cstime += tgstime + sig->cstime;\n\t\tpsig->cgtime += task_gtime(p) + sig->gtime + sig->cgtime;\n\t\tpsig->cmin_flt +=\n\t\t\tp->min_flt + sig->min_flt + sig->cmin_flt;\n\t\tpsig->cmaj_flt +=\n\t\t\tp->maj_flt + sig->maj_flt + sig->cmaj_flt;\n\t\tpsig->cnvcsw +=\n\t\t\tp->nvcsw + sig->nvcsw + sig->cnvcsw;\n\t\tpsig->cnivcsw +=\n\t\t\tp->nivcsw + sig->nivcsw + sig->cnivcsw;\n\t\tpsig->cinblock +=\n\t\t\ttask_io_get_inblock(p) +\n\t\t\tsig->inblock + sig->cinblock;\n\t\tpsig->coublock +=\n\t\t\ttask_io_get_oublock(p) +\n\t\t\tsig->oublock + sig->coublock;\n\t\tmaxrss = max(sig->maxrss, sig->cmaxrss);\n\t\tif (psig->cmaxrss < maxrss)\n\t\t\tpsig->cmaxrss = maxrss;\n\t\ttask_io_accounting_add(&psig->ioac, &p->ioac);\n\t\ttask_io_accounting_add(&psig->ioac, &sig->ioac);\n\t\twrite_sequnlock(&psig->stats_lock);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t}\n\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tstatus = (p->signal->flags & SIGNAL_GROUP_EXIT)\n\t\t? p->signal->group_exit_code : p->exit_code;\n\two->wo_stat = status;\n\n\tif (state == EXIT_TRACE) {\n\t\twrite_lock_irq(&tasklist_lock);\n\t\t/* We dropped tasklist, ptracer could die and untrace */\n\t\tptrace_unlink(p);\n\n\t\t/* If parent wants a zombie, don't release it now */\n\t\tstate = EXIT_ZOMBIE;\n\t\tif (do_notify_parent(p, p->exit_signal))\n\t\t\tstate = EXIT_DEAD;\n\t\tp->exit_state = state;\n\t\twrite_unlock_irq(&tasklist_lock);\n\t}\n\tif (state == EXIT_DEAD)\n\t\trelease_task(p);\n\nout_info:\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tif ((status & 0x7f) == 0) {\n\t\t\tinfop->cause = CLD_EXITED;\n\t\t\tinfop->status = status >> 8;\n\t\t} else {\n\t\t\tinfop->cause = (status & 0x80) ? CLD_DUMPED : CLD_KILLED;\n\t\t\tinfop->status = status & 0x7f;\n\t\t}\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t}\n\n\treturn pid;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_task_zombie(struct wait_opts *wo, struct task_struct *p)\n{\n\tint state, status;\n\tpid_t pid = task_pid_vnr(p);\n\tuid_t uid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tstruct waitid_info *infop;\n\n\tif (!likely(wo->wo_flags & WEXITED))\n\t\treturn 0;\n\n\tif (unlikely(wo->wo_flags & WNOWAIT)) {\n\t\tstatus = (p->signal->flags & SIGNAL_GROUP_EXIT)\n\t\t\t? p->signal->group_exit_code : p->exit_code;\n\t\tget_task_struct(p);\n\t\tread_unlock(&tasklist_lock);\n\t\tsched_annotate_sleep();\n\t\tif (wo->wo_rusage)\n\t\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\t\tput_task_struct(p);\n\t\tgoto out_info;\n\t}\n\t/*\n\t * Move the task's state to DEAD/TRACE, only one thread can do this.\n\t */\n\tstate = (ptrace_reparented(p) && thread_group_leader(p)) ?\n\t\tEXIT_TRACE : EXIT_DEAD;\n\tif (cmpxchg(&p->exit_state, EXIT_ZOMBIE, state) != EXIT_ZOMBIE)\n\t\treturn 0;\n\t/*\n\t * We own this thread, nobody else can reap it.\n\t */\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\n\t/*\n\t * Check thread_group_leader() to exclude the traced sub-threads.\n\t */\n\tif (state == EXIT_DEAD && thread_group_leader(p)) {\n\t\tstruct signal_struct *sig = p->signal;\n\t\tstruct signal_struct *psig = current->signal;\n\t\tunsigned long maxrss;\n\t\tu64 tgutime, tgstime;\n\n\t\t/*\n\t\t * The resource counters for the group leader are in its\n\t\t * own task_struct.  Those for dead threads in the group\n\t\t * are in its signal_struct, as are those for the child\n\t\t * processes it has previously reaped.  All these\n\t\t * accumulate in the parent's signal_struct c* fields.\n\t\t *\n\t\t * We don't bother to take a lock here to protect these\n\t\t * p->signal fields because the whole thread group is dead\n\t\t * and nobody can change them.\n\t\t *\n\t\t * psig->stats_lock also protects us from our sub-theads\n\t\t * which can reap other children at the same time. Until\n\t\t * we change k_getrusage()-like users to rely on this lock\n\t\t * we have to take ->siglock as well.\n\t\t *\n\t\t * We use thread_group_cputime_adjusted() to get times for\n\t\t * the thread group, which consolidates times for all threads\n\t\t * in the group including the group leader.\n\t\t */\n\t\tthread_group_cputime_adjusted(p, &tgutime, &tgstime);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\twrite_seqlock(&psig->stats_lock);\n\t\tpsig->cutime += tgutime + sig->cutime;\n\t\tpsig->cstime += tgstime + sig->cstime;\n\t\tpsig->cgtime += task_gtime(p) + sig->gtime + sig->cgtime;\n\t\tpsig->cmin_flt +=\n\t\t\tp->min_flt + sig->min_flt + sig->cmin_flt;\n\t\tpsig->cmaj_flt +=\n\t\t\tp->maj_flt + sig->maj_flt + sig->cmaj_flt;\n\t\tpsig->cnvcsw +=\n\t\t\tp->nvcsw + sig->nvcsw + sig->cnvcsw;\n\t\tpsig->cnivcsw +=\n\t\t\tp->nivcsw + sig->nivcsw + sig->cnivcsw;\n\t\tpsig->cinblock +=\n\t\t\ttask_io_get_inblock(p) +\n\t\t\tsig->inblock + sig->cinblock;\n\t\tpsig->coublock +=\n\t\t\ttask_io_get_oublock(p) +\n\t\t\tsig->oublock + sig->coublock;\n\t\tmaxrss = max(sig->maxrss, sig->cmaxrss);\n\t\tif (psig->cmaxrss < maxrss)\n\t\t\tpsig->cmaxrss = maxrss;\n\t\ttask_io_accounting_add(&psig->ioac, &p->ioac);\n\t\ttask_io_accounting_add(&psig->ioac, &sig->ioac);\n\t\twrite_sequnlock(&psig->stats_lock);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t}\n\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tstatus = (p->signal->flags & SIGNAL_GROUP_EXIT)\n\t\t? p->signal->group_exit_code : p->exit_code;\n\two->wo_stat = status;\n\n\tif (state == EXIT_TRACE) {\n\t\twrite_lock_irq(&tasklist_lock);\n\t\t/* We dropped tasklist, ptracer could die and untrace */\n\t\tptrace_unlink(p);\n\n\t\t/* If parent wants a zombie, don't release it now */\n\t\tstate = EXIT_ZOMBIE;\n\t\tif (do_notify_parent(p, p->exit_signal))\n\t\t\tstate = EXIT_DEAD;\n\t\tp->exit_state = state;\n\t\twrite_unlock_irq(&tasklist_lock);\n\t}\n\tif (state == EXIT_DEAD)\n\t\trelease_task(p);\n\nout_info:\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tif ((status & 0x7f) == 0) {\n\t\t\tinfop->cause = CLD_EXITED;\n\t\t\tinfop->status = status >> 8;\n\t\t} else {\n\t\t\tinfop->cause = (status & 0x80) ? CLD_DUMPED : CLD_KILLED;\n\t\t\tinfop->status = status & 0x7f;\n\t\t}\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t}\n\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!p->ptrace"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ptrace"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay_group_leader",
          "args": [
            "p"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_reparented",
          "args": [
            "p"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->ptrace"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ptrace"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ptrace"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "exit_state == EXIT_TRACE"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eligible_child",
          "args": [
            "wo",
            "ptrace",
            "p"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "eligible_child",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "978-1003",
          "snippet": "static int\neligible_child(struct wait_opts *wo, bool ptrace, struct task_struct *p)\n{\n\tif (!eligible_pid(wo, p))\n\t\treturn 0;\n\n\t/*\n\t * Wait for all children (clone and not) if __WALL is set or\n\t * if it is traced by us.\n\t */\n\tif (ptrace || (wo->wo_flags & __WALL))\n\t\treturn 1;\n\n\t/*\n\t * Otherwise, wait for clone children *only* if __WCLONE is set;\n\t * otherwise, wait for non-clone children *only*.\n\t *\n\t * Note: a \"clone\" child here is one that reports to its parent\n\t * using a signal other than SIGCHLD, or a non-leader thread which\n\t * we can only see if it is traced by us.\n\t */\n\tif ((p->exit_signal != SIGCHLD) ^ !!(wo->wo_flags & __WCLONE))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int\neligible_child(struct wait_opts *wo, bool ptrace, struct task_struct *p)\n{\n\tif (!eligible_pid(wo, p))\n\t\treturn 0;\n\n\t/*\n\t * Wait for all children (clone and not) if __WALL is set or\n\t * if it is traced by us.\n\t */\n\tif (ptrace || (wo->wo_flags & __WALL))\n\t\treturn 1;\n\n\t/*\n\t * Otherwise, wait for clone children *only* if __WCLONE is set;\n\t * otherwise, wait for non-clone children *only*.\n\t *\n\t * Note: a \"clone\" child here is one that reports to its parent\n\t * using a signal other than SIGCHLD, or a non-leader thread which\n\t * we can only see if it is traced by us.\n\t */\n\tif ((p->exit_signal != SIGCHLD) ^ !!(wo->wo_flags & __WCLONE))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "exit_state == EXIT_DEAD"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "p->exit_state"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_consider_task(struct wait_opts *wo, int ptrace,\n\t\t\t\tstruct task_struct *p)\n{\n\t/*\n\t * We can race with wait_task_zombie() from another thread.\n\t * Ensure that EXIT_ZOMBIE -> EXIT_DEAD/EXIT_TRACE transition\n\t * can't confuse the checks below.\n\t */\n\tint exit_state = READ_ONCE(p->exit_state);\n\tint ret;\n\n\tif (unlikely(exit_state == EXIT_DEAD))\n\t\treturn 0;\n\n\tret = eligible_child(wo, ptrace, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tif (unlikely(exit_state == EXIT_TRACE)) {\n\t\t/*\n\t\t * ptrace == 0 means we are the natural parent. In this case\n\t\t * we should clear notask_error, debugger will notify us.\n\t\t */\n\t\tif (likely(!ptrace))\n\t\t\two->notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t/*\n\t\t * If it is traced by its real parent's group, just pretend\n\t\t * the caller is ptrace_do_wait() and reap this child if it\n\t\t * is zombie.\n\t\t *\n\t\t * This also hides group stop state from real parent; otherwise\n\t\t * a single stop can be reported twice as group and ptrace stop.\n\t\t * If a ptracer wants to distinguish these two events for its\n\t\t * own children it should create a separate process which takes\n\t\t * the role of real parent.\n\t\t */\n\t\tif (!ptrace_reparented(p))\n\t\t\tptrace = 1;\n\t}\n\n\t/* slay zombie? */\n\tif (exit_state == EXIT_ZOMBIE) {\n\t\t/* we don't reap group leaders with subthreads */\n\t\tif (!delay_group_leader(p)) {\n\t\t\t/*\n\t\t\t * A zombie ptracee is only visible to its ptracer.\n\t\t\t * Notification and reaping will be cascaded to the\n\t\t\t * real parent when the ptracer detaches.\n\t\t\t */\n\t\t\tif (unlikely(ptrace) || likely(!p->ptrace))\n\t\t\t\treturn wait_task_zombie(wo, p);\n\t\t}\n\n\t\t/*\n\t\t * Allow access to stopped/continued state via zombie by\n\t\t * falling through.  Clearing of notask_error is complex.\n\t\t *\n\t\t * When !@ptrace:\n\t\t *\n\t\t * If WEXITED is set, notask_error should naturally be\n\t\t * cleared.  If not, subset of WSTOPPED|WCONTINUED is set,\n\t\t * so, if there are live subthreads, there are events to\n\t\t * wait for.  If all subthreads are dead, it's still safe\n\t\t * to clear - this function will be called again in finite\n\t\t * amount time once all the subthreads are released and\n\t\t * will then return without clearing.\n\t\t *\n\t\t * When @ptrace:\n\t\t *\n\t\t * Stopped state is per-task and thus can't change once the\n\t\t * target task dies.  Only continued and exited can happen.\n\t\t * Clear notask_error if WCONTINUED | WEXITED.\n\t\t */\n\t\tif (likely(!ptrace) || (wo->wo_flags & (WCONTINUED | WEXITED)))\n\t\t\two->notask_error = 0;\n\t} else {\n\t\t/*\n\t\t * @p is alive and it's gonna stop, continue or exit, so\n\t\t * there always is something to wait for.\n\t\t */\n\t\two->notask_error = 0;\n\t}\n\n\t/*\n\t * Wait for stopped.  Depending on @ptrace, different stopped state\n\t * is used and the two don't interact with each other.\n\t */\n\tret = wait_task_stopped(wo, ptrace, p);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Wait for continued.  There's only one continued state and the\n\t * ptracer can consume it which can confuse the real parent.  Don't\n\t * use WCONTINUED from ptracer.  You don't need or want it.\n\t */\n\treturn wait_task_continued(wo, p);\n}"
  },
  {
    "function_name": "wait_task_continued",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "1243-1284",
    "snippet": "static int wait_task_continued(struct wait_opts *wo, struct task_struct *p)\n{\n\tstruct waitid_info *infop;\n\tpid_t pid;\n\tuid_t uid;\n\n\tif (!unlikely(wo->wo_flags & WCONTINUED))\n\t\treturn 0;\n\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED))\n\t\treturn 0;\n\n\tspin_lock_irq(&p->sighand->siglock);\n\t/* Re-check with the lock held.  */\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED)) {\n\t\tspin_unlock_irq(&p->sighand->siglock);\n\t\treturn 0;\n\t}\n\tif (!unlikely(wo->wo_flags & WNOWAIT))\n\t\tp->signal->flags &= ~SIGNAL_STOP_CONTINUED;\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tspin_unlock_irq(&p->sighand->siglock);\n\n\tpid = task_pid_vnr(p);\n\tget_task_struct(p);\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tput_task_struct(p);\n\n\tinfop = wo->wo_info;\n\tif (!infop) {\n\t\two->wo_stat = 0xffff;\n\t} else {\n\t\tinfop->cause = CLD_CONTINUED;\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t\tinfop->status = SIGCONT;\n\t}\n\treturn pid;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "put_task_struct_rcu_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "178-182",
          "snippet": "void put_task_struct_rcu_user(struct task_struct *task)\n{\n\tif (refcount_dec_and_test(&task->rcu_users))\n\t\tcall_rcu(&task->rcu, delayed_put_task_struct);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid put_task_struct_rcu_user(struct task_struct *task)\n{\n\tif (refcount_dec_and_test(&task->rcu_users))\n\t\tcall_rcu(&task->rcu, delayed_put_task_struct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrusage",
          "args": [
            "p",
            "RUSAGE_BOTH",
            "wo->wo_rusage"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_annotate_sleep",
          "args": [],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "p"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "p"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&p->sighand->siglock"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "task_uid(p)"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "p"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "wo->wo_flags & WNOWAIT"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&p->sighand->siglock"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "wo->wo_flags & WCONTINUED"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_task_continued(struct wait_opts *wo, struct task_struct *p)\n{\n\tstruct waitid_info *infop;\n\tpid_t pid;\n\tuid_t uid;\n\n\tif (!unlikely(wo->wo_flags & WCONTINUED))\n\t\treturn 0;\n\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED))\n\t\treturn 0;\n\n\tspin_lock_irq(&p->sighand->siglock);\n\t/* Re-check with the lock held.  */\n\tif (!(p->signal->flags & SIGNAL_STOP_CONTINUED)) {\n\t\tspin_unlock_irq(&p->sighand->siglock);\n\t\treturn 0;\n\t}\n\tif (!unlikely(wo->wo_flags & WNOWAIT))\n\t\tp->signal->flags &= ~SIGNAL_STOP_CONTINUED;\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tspin_unlock_irq(&p->sighand->siglock);\n\n\tpid = task_pid_vnr(p);\n\tget_task_struct(p);\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tput_task_struct(p);\n\n\tinfop = wo->wo_info;\n\tif (!infop) {\n\t\two->wo_stat = 0xffff;\n\t} else {\n\t\tinfop->cause = CLD_CONTINUED;\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t\tinfop->status = SIGCONT;\n\t}\n\treturn pid;\n}"
  },
  {
    "function_name": "wait_task_stopped",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "1171-1235",
    "snippet": "static int wait_task_stopped(struct wait_opts *wo,\n\t\t\t\tint ptrace, struct task_struct *p)\n{\n\tstruct waitid_info *infop;\n\tint exit_code, *p_code, why;\n\tuid_t uid = 0; /* unneeded, required by compiler */\n\tpid_t pid;\n\n\t/*\n\t * Traditionally we see ptrace'd stopped tasks regardless of options.\n\t */\n\tif (!ptrace && !(wo->wo_flags & WUNTRACED))\n\t\treturn 0;\n\n\tif (!task_stopped_code(p, ptrace))\n\t\treturn 0;\n\n\texit_code = 0;\n\tspin_lock_irq(&p->sighand->siglock);\n\n\tp_code = task_stopped_code(p, ptrace);\n\tif (unlikely(!p_code))\n\t\tgoto unlock_sig;\n\n\texit_code = *p_code;\n\tif (!exit_code)\n\t\tgoto unlock_sig;\n\n\tif (!unlikely(wo->wo_flags & WNOWAIT))\n\t\t*p_code = 0;\n\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\nunlock_sig:\n\tspin_unlock_irq(&p->sighand->siglock);\n\tif (!exit_code)\n\t\treturn 0;\n\n\t/*\n\t * Now we are pretty sure this task is interesting.\n\t * Make sure it doesn't get reaped out from under us while we\n\t * give up the lock and then examine it below.  We don't want to\n\t * keep holding onto the tasklist_lock while we call getrusage and\n\t * possibly take page faults for user memory.\n\t */\n\tget_task_struct(p);\n\tpid = task_pid_vnr(p);\n\twhy = ptrace ? CLD_TRAPPED : CLD_STOPPED;\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tput_task_struct(p);\n\n\tif (likely(!(wo->wo_flags & WNOWAIT)))\n\t\two->wo_stat = (exit_code << 8) | 0x7f;\n\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tinfop->cause = why;\n\t\tinfop->status = exit_code;\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t}\n\treturn pid;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(wo->wo_flags & WNOWAIT)"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "put_task_struct_rcu_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "178-182",
          "snippet": "void put_task_struct_rcu_user(struct task_struct *task)\n{\n\tif (refcount_dec_and_test(&task->rcu_users))\n\t\tcall_rcu(&task->rcu, delayed_put_task_struct);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid put_task_struct_rcu_user(struct task_struct *task)\n{\n\tif (refcount_dec_and_test(&task->rcu_users))\n\t\tcall_rcu(&task->rcu, delayed_put_task_struct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrusage",
          "args": [
            "p",
            "RUSAGE_BOTH",
            "wo->wo_rusage"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_annotate_sleep",
          "args": [],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "p"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "p"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&p->sighand->siglock"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "task_uid(p)"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "p"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "wo->wo_flags & WNOWAIT"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p_code"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_stopped_code",
          "args": [
            "p",
            "ptrace"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "task_stopped_code",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "1141-1151",
          "snippet": "static int *task_stopped_code(struct task_struct *p, bool ptrace)\n{\n\tif (ptrace) {\n\t\tif (task_is_traced(p) && !(p->jobctl & JOBCTL_LISTENING))\n\t\t\treturn &p->exit_code;\n\t} else {\n\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\treturn &p->signal->group_exit_code;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int *task_stopped_code(struct task_struct *p, bool ptrace)\n{\n\tif (ptrace) {\n\t\tif (task_is_traced(p) && !(p->jobctl & JOBCTL_LISTENING))\n\t\t\treturn &p->exit_code;\n\t} else {\n\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\treturn &p->signal->group_exit_code;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&p->sighand->siglock"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_task_stopped(struct wait_opts *wo,\n\t\t\t\tint ptrace, struct task_struct *p)\n{\n\tstruct waitid_info *infop;\n\tint exit_code, *p_code, why;\n\tuid_t uid = 0; /* unneeded, required by compiler */\n\tpid_t pid;\n\n\t/*\n\t * Traditionally we see ptrace'd stopped tasks regardless of options.\n\t */\n\tif (!ptrace && !(wo->wo_flags & WUNTRACED))\n\t\treturn 0;\n\n\tif (!task_stopped_code(p, ptrace))\n\t\treturn 0;\n\n\texit_code = 0;\n\tspin_lock_irq(&p->sighand->siglock);\n\n\tp_code = task_stopped_code(p, ptrace);\n\tif (unlikely(!p_code))\n\t\tgoto unlock_sig;\n\n\texit_code = *p_code;\n\tif (!exit_code)\n\t\tgoto unlock_sig;\n\n\tif (!unlikely(wo->wo_flags & WNOWAIT))\n\t\t*p_code = 0;\n\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\nunlock_sig:\n\tspin_unlock_irq(&p->sighand->siglock);\n\tif (!exit_code)\n\t\treturn 0;\n\n\t/*\n\t * Now we are pretty sure this task is interesting.\n\t * Make sure it doesn't get reaped out from under us while we\n\t * give up the lock and then examine it below.  We don't want to\n\t * keep holding onto the tasklist_lock while we call getrusage and\n\t * possibly take page faults for user memory.\n\t */\n\tget_task_struct(p);\n\tpid = task_pid_vnr(p);\n\twhy = ptrace ? CLD_TRAPPED : CLD_STOPPED;\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tput_task_struct(p);\n\n\tif (likely(!(wo->wo_flags & WNOWAIT)))\n\t\two->wo_stat = (exit_code << 8) | 0x7f;\n\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tinfop->cause = why;\n\t\tinfop->status = exit_code;\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t}\n\treturn pid;\n}"
  },
  {
    "function_name": "task_stopped_code",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "1141-1151",
    "snippet": "static int *task_stopped_code(struct task_struct *p, bool ptrace)\n{\n\tif (ptrace) {\n\t\tif (task_is_traced(p) && !(p->jobctl & JOBCTL_LISTENING))\n\t\t\treturn &p->exit_code;\n\t} else {\n\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\treturn &p->signal->group_exit_code;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_is_traced",
          "args": [
            "p"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int *task_stopped_code(struct task_struct *p, bool ptrace)\n{\n\tif (ptrace) {\n\t\tif (task_is_traced(p) && !(p->jobctl & JOBCTL_LISTENING))\n\t\t\treturn &p->exit_code;\n\t} else {\n\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\treturn &p->signal->group_exit_code;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "wait_task_zombie",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "1011-1139",
    "snippet": "static int wait_task_zombie(struct wait_opts *wo, struct task_struct *p)\n{\n\tint state, status;\n\tpid_t pid = task_pid_vnr(p);\n\tuid_t uid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tstruct waitid_info *infop;\n\n\tif (!likely(wo->wo_flags & WEXITED))\n\t\treturn 0;\n\n\tif (unlikely(wo->wo_flags & WNOWAIT)) {\n\t\tstatus = (p->signal->flags & SIGNAL_GROUP_EXIT)\n\t\t\t? p->signal->group_exit_code : p->exit_code;\n\t\tget_task_struct(p);\n\t\tread_unlock(&tasklist_lock);\n\t\tsched_annotate_sleep();\n\t\tif (wo->wo_rusage)\n\t\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\t\tput_task_struct(p);\n\t\tgoto out_info;\n\t}\n\t/*\n\t * Move the task's state to DEAD/TRACE, only one thread can do this.\n\t */\n\tstate = (ptrace_reparented(p) && thread_group_leader(p)) ?\n\t\tEXIT_TRACE : EXIT_DEAD;\n\tif (cmpxchg(&p->exit_state, EXIT_ZOMBIE, state) != EXIT_ZOMBIE)\n\t\treturn 0;\n\t/*\n\t * We own this thread, nobody else can reap it.\n\t */\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\n\t/*\n\t * Check thread_group_leader() to exclude the traced sub-threads.\n\t */\n\tif (state == EXIT_DEAD && thread_group_leader(p)) {\n\t\tstruct signal_struct *sig = p->signal;\n\t\tstruct signal_struct *psig = current->signal;\n\t\tunsigned long maxrss;\n\t\tu64 tgutime, tgstime;\n\n\t\t/*\n\t\t * The resource counters for the group leader are in its\n\t\t * own task_struct.  Those for dead threads in the group\n\t\t * are in its signal_struct, as are those for the child\n\t\t * processes it has previously reaped.  All these\n\t\t * accumulate in the parent's signal_struct c* fields.\n\t\t *\n\t\t * We don't bother to take a lock here to protect these\n\t\t * p->signal fields because the whole thread group is dead\n\t\t * and nobody can change them.\n\t\t *\n\t\t * psig->stats_lock also protects us from our sub-theads\n\t\t * which can reap other children at the same time. Until\n\t\t * we change k_getrusage()-like users to rely on this lock\n\t\t * we have to take ->siglock as well.\n\t\t *\n\t\t * We use thread_group_cputime_adjusted() to get times for\n\t\t * the thread group, which consolidates times for all threads\n\t\t * in the group including the group leader.\n\t\t */\n\t\tthread_group_cputime_adjusted(p, &tgutime, &tgstime);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\twrite_seqlock(&psig->stats_lock);\n\t\tpsig->cutime += tgutime + sig->cutime;\n\t\tpsig->cstime += tgstime + sig->cstime;\n\t\tpsig->cgtime += task_gtime(p) + sig->gtime + sig->cgtime;\n\t\tpsig->cmin_flt +=\n\t\t\tp->min_flt + sig->min_flt + sig->cmin_flt;\n\t\tpsig->cmaj_flt +=\n\t\t\tp->maj_flt + sig->maj_flt + sig->cmaj_flt;\n\t\tpsig->cnvcsw +=\n\t\t\tp->nvcsw + sig->nvcsw + sig->cnvcsw;\n\t\tpsig->cnivcsw +=\n\t\t\tp->nivcsw + sig->nivcsw + sig->cnivcsw;\n\t\tpsig->cinblock +=\n\t\t\ttask_io_get_inblock(p) +\n\t\t\tsig->inblock + sig->cinblock;\n\t\tpsig->coublock +=\n\t\t\ttask_io_get_oublock(p) +\n\t\t\tsig->oublock + sig->coublock;\n\t\tmaxrss = max(sig->maxrss, sig->cmaxrss);\n\t\tif (psig->cmaxrss < maxrss)\n\t\t\tpsig->cmaxrss = maxrss;\n\t\ttask_io_accounting_add(&psig->ioac, &p->ioac);\n\t\ttask_io_accounting_add(&psig->ioac, &sig->ioac);\n\t\twrite_sequnlock(&psig->stats_lock);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t}\n\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tstatus = (p->signal->flags & SIGNAL_GROUP_EXIT)\n\t\t? p->signal->group_exit_code : p->exit_code;\n\two->wo_stat = status;\n\n\tif (state == EXIT_TRACE) {\n\t\twrite_lock_irq(&tasklist_lock);\n\t\t/* We dropped tasklist, ptracer could die and untrace */\n\t\tptrace_unlink(p);\n\n\t\t/* If parent wants a zombie, don't release it now */\n\t\tstate = EXIT_ZOMBIE;\n\t\tif (do_notify_parent(p, p->exit_signal))\n\t\t\tstate = EXIT_DEAD;\n\t\tp->exit_state = state;\n\t\twrite_unlock_irq(&tasklist_lock);\n\t}\n\tif (state == EXIT_DEAD)\n\t\trelease_task(p);\n\nout_info:\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tif ((status & 0x7f) == 0) {\n\t\t\tinfop->cause = CLD_EXITED;\n\t\t\tinfop->status = status >> 8;\n\t\t} else {\n\t\t\tinfop->cause = (status & 0x80) ? CLD_DUMPED : CLD_KILLED;\n\t\t\tinfop->status = status & 0x7f;\n\t\t}\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t}\n\n\treturn pid;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_task",
          "args": [
            "p"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "release_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "184-232",
          "snippet": "void release_task(struct task_struct *p)\n{\n\tstruct task_struct *leader;\n\tstruct pid *thread_pid;\n\tint zap_leader;\nrepeat:\n\t/* don't need to get the RCU readlock here - the process is dead and\n\t * can't be modifying its own credentials. But shut RCU-lockdep up */\n\trcu_read_lock();\n\tdec_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1);\n\trcu_read_unlock();\n\n\tcgroup_release(p);\n\n\twrite_lock_irq(&tasklist_lock);\n\tptrace_release_task(p);\n\tthread_pid = get_pid(p->thread_pid);\n\t__exit_signal(p);\n\n\t/*\n\t * If we are the last non-leader member of the thread\n\t * group, and the leader is zombie, then notify the\n\t * group leader's parent process. (if it wants notification.)\n\t */\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader)\n\t\t\t&& leader->exit_state == EXIT_ZOMBIE) {\n\t\t/*\n\t\t * If we were the last child thread and the leader has\n\t\t * exited already, and the leader's parent ignores SIGCHLD,\n\t\t * then we are the one who should release the leader.\n\t\t */\n\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = EXIT_DEAD;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\tseccomp_filter_release(p);\n\tproc_flush_pid(thread_pid);\n\tput_pid(thread_pid);\n\trelease_thread(p);\n\tput_task_struct_rcu_user(p);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid release_task(struct task_struct *p)\n{\n\tstruct task_struct *leader;\n\tstruct pid *thread_pid;\n\tint zap_leader;\nrepeat:\n\t/* don't need to get the RCU readlock here - the process is dead and\n\t * can't be modifying its own credentials. But shut RCU-lockdep up */\n\trcu_read_lock();\n\tdec_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1);\n\trcu_read_unlock();\n\n\tcgroup_release(p);\n\n\twrite_lock_irq(&tasklist_lock);\n\tptrace_release_task(p);\n\tthread_pid = get_pid(p->thread_pid);\n\t__exit_signal(p);\n\n\t/*\n\t * If we are the last non-leader member of the thread\n\t * group, and the leader is zombie, then notify the\n\t * group leader's parent process. (if it wants notification.)\n\t */\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader)\n\t\t\t&& leader->exit_state == EXIT_ZOMBIE) {\n\t\t/*\n\t\t * If we were the last child thread and the leader has\n\t\t * exited already, and the leader's parent ignores SIGCHLD,\n\t\t * then we are the one who should release the leader.\n\t\t */\n\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = EXIT_DEAD;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\tseccomp_filter_release(p);\n\tproc_flush_pid(thread_pid);\n\tput_pid(thread_pid);\n\trelease_thread(p);\n\tput_task_struct_rcu_user(p);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "356-359",
          "snippet": "void __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_notify_parent",
          "args": [
            "p",
            "p->exit_signal"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2014-2110",
          "snippet": "bool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\t/* Wake up all pidfd waiters */\n\tdo_notify_pidfd(tsk);\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != READ_ONCE(tsk->parent->self_exec_id))\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\t/*\n\t * Send with __send_signal as si_pid and si_uid are in the\n\t * parent's namespaces.\n\t */\n\tif (valid_signal(sig) && sig)\n\t\t__send_signal(sig, &info, tsk->parent, PIDTYPE_TGID, false);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\t/* Wake up all pidfd waiters */\n\tdo_notify_pidfd(tsk);\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != READ_ONCE(tsk->parent->self_exec_id))\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\t/*\n\t * Send with __send_signal as si_pid and si_uid are in the\n\t * parent's namespaces.\n\t */\n\tif (valid_signal(sig) && sig)\n\t\t__send_signal(sig, &info, tsk->parent, PIDTYPE_TGID, false);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_unlink",
          "args": [
            "p"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "__ptrace_unlink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ptrace.c",
          "lines": "116-171",
          "snippet": "void __ptrace_unlink(struct task_struct *child)\n{\n\tconst struct cred *old_cred;\n\tBUG_ON(!child->ptrace);\n\n\tclear_task_syscall_work(child, SYSCALL_TRACE);\n#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)\n\tclear_task_syscall_work(child, SYSCALL_EMU);\n#endif\n\n\tchild->parent = child->real_parent;\n\tlist_del_init(&child->ptrace_entry);\n\told_cred = child->ptracer_cred;\n\tchild->ptracer_cred = NULL;\n\tput_cred(old_cred);\n\n\tspin_lock(&child->sighand->siglock);\n\tchild->ptrace = 0;\n\t/*\n\t * Clear all pending traps and TRAPPING.  TRAPPING should be\n\t * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.\n\t */\n\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);\n\ttask_clear_jobctl_trapping(child);\n\n\t/*\n\t * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and\n\t * @child isn't dead.\n\t */\n\tif (!(child->flags & PF_EXITING) &&\n\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||\n\t     child->signal->group_stop_count)) {\n\t\tchild->jobctl |= JOBCTL_STOP_PENDING;\n\n\t\t/*\n\t\t * This is only possible if this thread was cloned by the\n\t\t * traced task running in the stopped group, set the signal\n\t\t * for the future reports.\n\t\t * FIXME: we should change ptrace_init_task() to handle this\n\t\t * case.\n\t\t */\n\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))\n\t\t\tchild->jobctl |= SIGSTOP;\n\t}\n\n\t/*\n\t * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick\n\t * @child in the butt.  Note that @resume should be used iff @child\n\t * is in TASK_TRACED; otherwise, we might unduly disrupt\n\t * TASK_KILLABLE sleeps.\n\t */\n\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))\n\t\tptrace_signal_wake_up(child, true);\n\n\tspin_unlock(&child->sighand->siglock);\n}",
          "includes": [
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <linux/minmax.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <linux/minmax.h>\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nvoid __ptrace_unlink(struct task_struct *child)\n{\n\tconst struct cred *old_cred;\n\tBUG_ON(!child->ptrace);\n\n\tclear_task_syscall_work(child, SYSCALL_TRACE);\n#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)\n\tclear_task_syscall_work(child, SYSCALL_EMU);\n#endif\n\n\tchild->parent = child->real_parent;\n\tlist_del_init(&child->ptrace_entry);\n\told_cred = child->ptracer_cred;\n\tchild->ptracer_cred = NULL;\n\tput_cred(old_cred);\n\n\tspin_lock(&child->sighand->siglock);\n\tchild->ptrace = 0;\n\t/*\n\t * Clear all pending traps and TRAPPING.  TRAPPING should be\n\t * cleared regardless of JOBCTL_STOP_PENDING.  Do it explicitly.\n\t */\n\ttask_clear_jobctl_pending(child, JOBCTL_TRAP_MASK);\n\ttask_clear_jobctl_trapping(child);\n\n\t/*\n\t * Reinstate JOBCTL_STOP_PENDING if group stop is in effect and\n\t * @child isn't dead.\n\t */\n\tif (!(child->flags & PF_EXITING) &&\n\t    (child->signal->flags & SIGNAL_STOP_STOPPED ||\n\t     child->signal->group_stop_count)) {\n\t\tchild->jobctl |= JOBCTL_STOP_PENDING;\n\n\t\t/*\n\t\t * This is only possible if this thread was cloned by the\n\t\t * traced task running in the stopped group, set the signal\n\t\t * for the future reports.\n\t\t * FIXME: we should change ptrace_init_task() to handle this\n\t\t * case.\n\t\t */\n\t\tif (!(child->jobctl & JOBCTL_STOP_SIGMASK))\n\t\t\tchild->jobctl |= SIGSTOP;\n\t}\n\n\t/*\n\t * If transition to TASK_STOPPED is pending or in TASK_TRACED, kick\n\t * @child in the butt.  Note that @resume should be used iff @child\n\t * is in TASK_TRACED; otherwise, we might unduly disrupt\n\t * TASK_KILLABLE sleeps.\n\t */\n\tif (child->jobctl & JOBCTL_STOP_PENDING || task_is_traced(child))\n\t\tptrace_signal_wake_up(child, true);\n\n\tspin_unlock(&child->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "324-327",
          "snippet": "void __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrusage",
          "args": [
            "p",
            "RUSAGE_BOTH",
            "wo->wo_rusage"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_sequnlock",
          "args": [
            "&psig->stats_lock"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_accounting_add",
          "args": [
            "&psig->ioac",
            "&sig->ioac"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_accounting_add",
          "args": [
            "&psig->ioac",
            "&p->ioac"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "sig->maxrss",
            "sig->cmaxrss"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_io_get_oublock",
          "args": [
            "p"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_get_inblock",
          "args": [
            "p"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_gtime",
          "args": [
            "p"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "task_gtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "806-825",
          "snippet": "u64 task_gtime(struct task_struct *t)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 gtime;\n\n\tif (!vtime_accounting_enabled())\n\t\treturn t->gtime;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tgtime = t->gtime;\n\t\tif (vtime->state == VTIME_GUEST)\n\t\t\tgtime += vtime->gtime + vtime_delta(vtime);\n\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn gtime;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nu64 task_gtime(struct task_struct *t)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 gtime;\n\n\tif (!vtime_accounting_enabled())\n\t\treturn t->gtime;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tgtime = t->gtime;\n\t\tif (vtime->state == VTIME_GUEST)\n\t\t\tgtime += vtime->gtime + vtime_delta(vtime);\n\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn gtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqlock",
          "args": [
            "&psig->stats_lock"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_cputime_adjusted",
          "args": [
            "p",
            "&tgutime",
            "&tgstime"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "thread_group_cputime_adjusted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "624-630",
          "snippet": "void thread_group_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputime(p, &cputime);\n\tcputime_adjust(&cputime, &p->signal->prev_cputime, ut, st);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid thread_group_cputime_adjusted(struct task_struct *p, u64 *ut, u64 *st)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputime(p, &cputime);\n\tcputime_adjust(&cputime, &p->signal->prev_cputime, ut, st);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "p"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_annotate_sleep",
          "args": [],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&p->exit_state",
            "EXIT_ZOMBIE",
            "state"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "rb_time_cmpxchg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "737-742",
          "snippet": "static bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "p"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_reparented",
          "args": [
            "p"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "put_task_struct_rcu_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "178-182",
          "snippet": "void put_task_struct_rcu_user(struct task_struct *task)\n{\n\tif (refcount_dec_and_test(&task->rcu_users))\n\t\tcall_rcu(&task->rcu, delayed_put_task_struct);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid put_task_struct_rcu_user(struct task_struct *task)\n{\n\tif (refcount_dec_and_test(&task->rcu_users))\n\t\tcall_rcu(&task->rcu, delayed_put_task_struct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrusage",
          "args": [
            "p",
            "RUSAGE_BOTH",
            "wo->wo_rusage"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_annotate_sleep",
          "args": [],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "p"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "wo->wo_flags & WNOWAIT"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "wo->wo_flags & WEXITED"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "task_uid(p)"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "p"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "p"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int wait_task_zombie(struct wait_opts *wo, struct task_struct *p)\n{\n\tint state, status;\n\tpid_t pid = task_pid_vnr(p);\n\tuid_t uid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tstruct waitid_info *infop;\n\n\tif (!likely(wo->wo_flags & WEXITED))\n\t\treturn 0;\n\n\tif (unlikely(wo->wo_flags & WNOWAIT)) {\n\t\tstatus = (p->signal->flags & SIGNAL_GROUP_EXIT)\n\t\t\t? p->signal->group_exit_code : p->exit_code;\n\t\tget_task_struct(p);\n\t\tread_unlock(&tasklist_lock);\n\t\tsched_annotate_sleep();\n\t\tif (wo->wo_rusage)\n\t\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\t\tput_task_struct(p);\n\t\tgoto out_info;\n\t}\n\t/*\n\t * Move the task's state to DEAD/TRACE, only one thread can do this.\n\t */\n\tstate = (ptrace_reparented(p) && thread_group_leader(p)) ?\n\t\tEXIT_TRACE : EXIT_DEAD;\n\tif (cmpxchg(&p->exit_state, EXIT_ZOMBIE, state) != EXIT_ZOMBIE)\n\t\treturn 0;\n\t/*\n\t * We own this thread, nobody else can reap it.\n\t */\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\n\t/*\n\t * Check thread_group_leader() to exclude the traced sub-threads.\n\t */\n\tif (state == EXIT_DEAD && thread_group_leader(p)) {\n\t\tstruct signal_struct *sig = p->signal;\n\t\tstruct signal_struct *psig = current->signal;\n\t\tunsigned long maxrss;\n\t\tu64 tgutime, tgstime;\n\n\t\t/*\n\t\t * The resource counters for the group leader are in its\n\t\t * own task_struct.  Those for dead threads in the group\n\t\t * are in its signal_struct, as are those for the child\n\t\t * processes it has previously reaped.  All these\n\t\t * accumulate in the parent's signal_struct c* fields.\n\t\t *\n\t\t * We don't bother to take a lock here to protect these\n\t\t * p->signal fields because the whole thread group is dead\n\t\t * and nobody can change them.\n\t\t *\n\t\t * psig->stats_lock also protects us from our sub-theads\n\t\t * which can reap other children at the same time. Until\n\t\t * we change k_getrusage()-like users to rely on this lock\n\t\t * we have to take ->siglock as well.\n\t\t *\n\t\t * We use thread_group_cputime_adjusted() to get times for\n\t\t * the thread group, which consolidates times for all threads\n\t\t * in the group including the group leader.\n\t\t */\n\t\tthread_group_cputime_adjusted(p, &tgutime, &tgstime);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\twrite_seqlock(&psig->stats_lock);\n\t\tpsig->cutime += tgutime + sig->cutime;\n\t\tpsig->cstime += tgstime + sig->cstime;\n\t\tpsig->cgtime += task_gtime(p) + sig->gtime + sig->cgtime;\n\t\tpsig->cmin_flt +=\n\t\t\tp->min_flt + sig->min_flt + sig->cmin_flt;\n\t\tpsig->cmaj_flt +=\n\t\t\tp->maj_flt + sig->maj_flt + sig->cmaj_flt;\n\t\tpsig->cnvcsw +=\n\t\t\tp->nvcsw + sig->nvcsw + sig->cnvcsw;\n\t\tpsig->cnivcsw +=\n\t\t\tp->nivcsw + sig->nivcsw + sig->cnivcsw;\n\t\tpsig->cinblock +=\n\t\t\ttask_io_get_inblock(p) +\n\t\t\tsig->inblock + sig->cinblock;\n\t\tpsig->coublock +=\n\t\t\ttask_io_get_oublock(p) +\n\t\t\tsig->oublock + sig->coublock;\n\t\tmaxrss = max(sig->maxrss, sig->cmaxrss);\n\t\tif (psig->cmaxrss < maxrss)\n\t\t\tpsig->cmaxrss = maxrss;\n\t\ttask_io_accounting_add(&psig->ioac, &p->ioac);\n\t\ttask_io_accounting_add(&psig->ioac, &sig->ioac);\n\t\twrite_sequnlock(&psig->stats_lock);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t}\n\n\tif (wo->wo_rusage)\n\t\tgetrusage(p, RUSAGE_BOTH, wo->wo_rusage);\n\tstatus = (p->signal->flags & SIGNAL_GROUP_EXIT)\n\t\t? p->signal->group_exit_code : p->exit_code;\n\two->wo_stat = status;\n\n\tif (state == EXIT_TRACE) {\n\t\twrite_lock_irq(&tasklist_lock);\n\t\t/* We dropped tasklist, ptracer could die and untrace */\n\t\tptrace_unlink(p);\n\n\t\t/* If parent wants a zombie, don't release it now */\n\t\tstate = EXIT_ZOMBIE;\n\t\tif (do_notify_parent(p, p->exit_signal))\n\t\t\tstate = EXIT_DEAD;\n\t\tp->exit_state = state;\n\t\twrite_unlock_irq(&tasklist_lock);\n\t}\n\tif (state == EXIT_DEAD)\n\t\trelease_task(p);\n\nout_info:\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tif ((status & 0x7f) == 0) {\n\t\t\tinfop->cause = CLD_EXITED;\n\t\t\tinfop->status = status >> 8;\n\t\t} else {\n\t\t\tinfop->cause = (status & 0x80) ? CLD_DUMPED : CLD_KILLED;\n\t\t\tinfop->status = status & 0x7f;\n\t\t}\n\t\tinfop->pid = pid;\n\t\tinfop->uid = uid;\n\t}\n\n\treturn pid;\n}"
  },
  {
    "function_name": "eligible_child",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "978-1003",
    "snippet": "static int\neligible_child(struct wait_opts *wo, bool ptrace, struct task_struct *p)\n{\n\tif (!eligible_pid(wo, p))\n\t\treturn 0;\n\n\t/*\n\t * Wait for all children (clone and not) if __WALL is set or\n\t * if it is traced by us.\n\t */\n\tif (ptrace || (wo->wo_flags & __WALL))\n\t\treturn 1;\n\n\t/*\n\t * Otherwise, wait for clone children *only* if __WCLONE is set;\n\t * otherwise, wait for non-clone children *only*.\n\t *\n\t * Note: a \"clone\" child here is one that reports to its parent\n\t * using a signal other than SIGCHLD, or a non-leader thread which\n\t * we can only see if it is traced by us.\n\t */\n\tif ((p->exit_signal != SIGCHLD) ^ !!(wo->wo_flags & __WCLONE))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eligible_pid",
          "args": [
            "wo",
            "p"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "eligible_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "972-976",
          "snippet": "static int eligible_pid(struct wait_opts *wo, struct task_struct *p)\n{\n\treturn\two->wo_type == PIDTYPE_MAX ||\n\t\ttask_pid_type(p, wo->wo_type) == wo->wo_pid;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int eligible_pid(struct wait_opts *wo, struct task_struct *p)\n{\n\treturn\two->wo_type == PIDTYPE_MAX ||\n\t\ttask_pid_type(p, wo->wo_type) == wo->wo_pid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int\neligible_child(struct wait_opts *wo, bool ptrace, struct task_struct *p)\n{\n\tif (!eligible_pid(wo, p))\n\t\treturn 0;\n\n\t/*\n\t * Wait for all children (clone and not) if __WALL is set or\n\t * if it is traced by us.\n\t */\n\tif (ptrace || (wo->wo_flags & __WALL))\n\t\treturn 1;\n\n\t/*\n\t * Otherwise, wait for clone children *only* if __WCLONE is set;\n\t * otherwise, wait for non-clone children *only*.\n\t *\n\t * Note: a \"clone\" child here is one that reports to its parent\n\t * using a signal other than SIGCHLD, or a non-leader thread which\n\t * we can only see if it is traced by us.\n\t */\n\tif ((p->exit_signal != SIGCHLD) ^ !!(wo->wo_flags & __WCLONE))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "eligible_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "972-976",
    "snippet": "static int eligible_pid(struct wait_opts *wo, struct task_struct *p)\n{\n\treturn\two->wo_type == PIDTYPE_MAX ||\n\t\ttask_pid_type(p, wo->wo_type) == wo->wo_pid;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_pid_type",
          "args": [
            "p",
            "wo->wo_type"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int eligible_pid(struct wait_opts *wo, struct task_struct *p)\n{\n\treturn\two->wo_type == PIDTYPE_MAX ||\n\t\ttask_pid_type(p, wo->wo_type) == wo->wo_pid;\n}"
  },
  {
    "function_name": "do_group_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "910-938",
    "snippet": "void\ndo_group_exit(int exit_code)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tif (sig->flags & SIGNAL_GROUP_EXIT)\n\t\texit_code = sig->group_exit_code;\n\telse if (sig->group_exec_task)\n\t\texit_code = 0;\n\telse if (!thread_group_empty(current)) {\n\t\tstruct sighand_struct *const sighand = current->sighand;\n\n\t\tspin_lock_irq(&sighand->siglock);\n\t\tif (sig->flags & SIGNAL_GROUP_EXIT)\n\t\t\t/* Another thread got here before we took the lock.  */\n\t\t\texit_code = sig->group_exit_code;\n\t\telse if (sig->group_exec_task)\n\t\t\texit_code = 0;\n\t\telse {\n\t\t\tsig->group_exit_code = exit_code;\n\t\t\tsig->flags = SIGNAL_GROUP_EXIT;\n\t\t\tzap_other_threads(current);\n\t\t}\n\t\tspin_unlock_irq(&sighand->siglock);\n\t}\n\n\tdo_exit(exit_code);\n\t/* NOTREACHED */\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "exit_code"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "do_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "734-859",
          "snippet": "void __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\t/*\n\t * If do_dead is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t *\n\t * On uptodate architectures force_uaccess_begin is a noop.  On\n\t * architectures that still have set_fs/get_fs in addition to handling\n\t * oopses handles kernel threads that run as set_fs(KERNEL_DS) by\n\t * default.\n\t */\n\tforce_uaccess_begin();\n\n\tkcov_task_exit(tsk);\n\n\tcoredump_task_exit(tsk);\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tio_uring_files_cancel();\n\texit_signals(tsk);  /* sets PF_EXITING */\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\t/*\n\t\t * If the last thread of global init has exited, panic\n\t\t * immediately to get a useable coredump.\n\t\t */\n\t\tif (unlikely(is_global_init(tsk)))\n\t\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\t\ttsk->signal->group_exit_code ?: (int)code);\n\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\t/*\n\t * If do_dead is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t *\n\t * On uptodate architectures force_uaccess_begin is a noop.  On\n\t * architectures that still have set_fs/get_fs in addition to handling\n\t * oopses handles kernel threads that run as set_fs(KERNEL_DS) by\n\t * default.\n\t */\n\tforce_uaccess_begin();\n\n\tkcov_task_exit(tsk);\n\n\tcoredump_task_exit(tsk);\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tio_uring_files_cancel();\n\texit_signals(tsk);  /* sets PF_EXITING */\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\t/*\n\t\t * If the last thread of global init has exited, panic\n\t\t * immediately to get a useable coredump.\n\t\t */\n\t\tif (unlikely(is_global_init(tsk)))\n\t\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\t\ttsk->signal->group_exit_code ?: (int)code);\n\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&sighand->siglock"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zap_other_threads",
          "args": [
            "current"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "zap_other_threads",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1363-1382",
          "snippet": "int zap_other_threads(struct task_struct *p)\n{\n\tstruct task_struct *t = p;\n\tint count = 0;\n\n\tp->signal->group_stop_count = 0;\n\n\twhile_each_thread(p, t) {\n\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\tcount++;\n\n\t\t/* Don't bother with already dead threads */\n\t\tif (t->exit_state)\n\t\t\tcontinue;\n\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\tsignal_wake_up(t, 1);\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint zap_other_threads(struct task_struct *p)\n{\n\tstruct task_struct *t = p;\n\tint count = 0;\n\n\tp->signal->group_stop_count = 0;\n\n\twhile_each_thread(p, t) {\n\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\tcount++;\n\n\t\t/* Don't bother with already dead threads */\n\t\tif (t->exit_state)\n\t\t\tcontinue;\n\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\tsignal_wake_up(t, 1);\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&sighand->siglock"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "current"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid\ndo_group_exit(int exit_code)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tif (sig->flags & SIGNAL_GROUP_EXIT)\n\t\texit_code = sig->group_exit_code;\n\telse if (sig->group_exec_task)\n\t\texit_code = 0;\n\telse if (!thread_group_empty(current)) {\n\t\tstruct sighand_struct *const sighand = current->sighand;\n\n\t\tspin_lock_irq(&sighand->siglock);\n\t\tif (sig->flags & SIGNAL_GROUP_EXIT)\n\t\t\t/* Another thread got here before we took the lock.  */\n\t\t\texit_code = sig->group_exit_code;\n\t\telse if (sig->group_exec_task)\n\t\t\texit_code = 0;\n\t\telse {\n\t\t\tsig->group_exit_code = exit_code;\n\t\t\tsig->flags = SIGNAL_GROUP_EXIT;\n\t\t\tzap_other_threads(current);\n\t\t}\n\t\tspin_unlock_irq(&sighand->siglock);\n\t}\n\n\tdo_exit(exit_code);\n\t/* NOTREACHED */\n}"
  },
  {
    "function_name": "make_task_dead",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "861-899",
    "snippet": "void __noreturn make_task_dead(int signr)\n{\n\t/*\n\t * Take the task off the cpu after something catastrophic has\n\t * happened.\n\t *\n\t * We can get here from a kernel oops, sometimes with preemption off.\n\t * Start by checking for critical errors.\n\t * Then fix up important state like USER_DS and preemption.\n\t * Then do everything else.\n\t */\n\tstruct task_struct *tsk = current;\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/*\n\t * We're taking recursive faults here in make_task_dead. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\tfutex_exit_recursive(tsk);\n\t\ttsk->exit_state = EXIT_DEAD;\n\t\trefcount_inc(&tsk->rcu_users);\n\t\tdo_task_dead();\n\t}\n\n\tdo_exit(signr);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "signr"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "do_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "734-859",
          "snippet": "void __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\t/*\n\t * If do_dead is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t *\n\t * On uptodate architectures force_uaccess_begin is a noop.  On\n\t * architectures that still have set_fs/get_fs in addition to handling\n\t * oopses handles kernel threads that run as set_fs(KERNEL_DS) by\n\t * default.\n\t */\n\tforce_uaccess_begin();\n\n\tkcov_task_exit(tsk);\n\n\tcoredump_task_exit(tsk);\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tio_uring_files_cancel();\n\texit_signals(tsk);  /* sets PF_EXITING */\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\t/*\n\t\t * If the last thread of global init has exited, panic\n\t\t * immediately to get a useable coredump.\n\t\t */\n\t\tif (unlikely(is_global_init(tsk)))\n\t\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\t\ttsk->signal->group_exit_code ?: (int)code);\n\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\t/*\n\t * If do_dead is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t *\n\t * On uptodate architectures force_uaccess_begin is a noop.  On\n\t * architectures that still have set_fs/get_fs in addition to handling\n\t * oopses handles kernel threads that run as set_fs(KERNEL_DS) by\n\t * default.\n\t */\n\tforce_uaccess_begin();\n\n\tkcov_task_exit(tsk);\n\n\tcoredump_task_exit(tsk);\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tio_uring_files_cancel();\n\texit_signals(tsk);  /* sets PF_EXITING */\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\t/*\n\t\t * If the last thread of global init has exited, panic\n\t\t * immediately to get a useable coredump.\n\t\t */\n\t\tif (unlikely(is_global_init(tsk)))\n\t\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\t\ttsk->signal->group_exit_code ?: (int)code);\n\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_task_dead",
          "args": [],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "do_task_dead",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6306-6320",
          "snippet": "void __noreturn do_task_dead(void)\n{\n\t/* Causes final put_task_struct in finish_task_switch(): */\n\tset_special_state(TASK_DEAD);\n\n\t/* Tell freezer to ignore us: */\n\tcurrent->flags |= PF_NOFREEZE;\n\n\t__schedule(SM_NONE);\n\tBUG();\n\n\t/* Avoid \"noreturn function does return\" - but don't continue if BUG() is a NOP: */\n\tfor (;;)\n\t\tcpu_relax();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [
            "#define SM_NONE\t\t\t0x0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\n#define SM_NONE\t\t\t0x0\n\nvoid __noreturn do_task_dead(void)\n{\n\t/* Causes final put_task_struct in finish_task_switch(): */\n\tset_special_state(TASK_DEAD);\n\n\t/* Tell freezer to ignore us: */\n\tcurrent->flags |= PF_NOFREEZE;\n\n\t__schedule(SM_NONE);\n\tBUG();\n\n\t/* Avoid \"noreturn function does return\" - but don't continue if BUG() is a NOP: */\n\tfor (;;)\n\t\tcpu_relax();\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_inc",
          "args": [
            "&tsk->rcu_users"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "53-56",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "futex_exit_recursive",
          "args": [
            "tsk"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "futex_exit_recursive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/futex/core.c",
          "lines": "1042-1048",
          "snippet": "void futex_exit_recursive(struct task_struct *tsk)\n{\n\t/* If the state is FUTEX_STATE_EXITING then futex_exit_mutex is held */\n\tif (tsk->futex_state == FUTEX_STATE_EXITING)\n\t\tmutex_unlock(&tsk->futex_exit_mutex);\n\ttsk->futex_state = FUTEX_STATE_DEAD;\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"futex.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memblock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/jhash.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"futex.h\"\n#include <linux/slab.h>\n#include <linux/fault-inject.h>\n#include <linux/memblock.h>\n#include <linux/pagemap.h>\n#include <linux/jhash.h>\n#include <linux/compat.h>\n\nvoid futex_exit_recursive(struct task_struct *tsk)\n{\n\t/* If the state is FUTEX_STATE_EXITING then futex_exit_mutex is held */\n\tif (tsk->futex_state == FUTEX_STATE_EXITING)\n\t\tmutex_unlock(&tsk->futex_exit_mutex);\n\ttsk->futex_state = FUTEX_STATE_DEAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"Fixing recursive fault but reboot is needed!\\n\""
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tsk->flags & PF_EXITING"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count_set",
          "args": [
            "PREEMPT_ENABLED"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"note: %s[%d] exited with preempt_count %d\\n\"",
            "current->comm",
            "task_pid_nr(current)",
            "preempt_count()"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "in_atomic()"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_atomic",
          "args": [],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Attempted to kill the idle task!\""
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_panic_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "74-85",
          "snippet": "static int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tsk->pid"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "in_interrupt()"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn make_task_dead(int signr)\n{\n\t/*\n\t * Take the task off the cpu after something catastrophic has\n\t * happened.\n\t *\n\t * We can get here from a kernel oops, sometimes with preemption off.\n\t * Start by checking for critical errors.\n\t * Then fix up important state like USER_DS and preemption.\n\t * Then do everything else.\n\t */\n\tstruct task_struct *tsk = current;\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/*\n\t * We're taking recursive faults here in make_task_dead. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\tfutex_exit_recursive(tsk);\n\t\ttsk->exit_state = EXIT_DEAD;\n\t\trefcount_inc(&tsk->rcu_users);\n\t\tdo_task_dead();\n\t}\n\n\tdo_exit(signr);\n}"
  },
  {
    "function_name": "do_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "734-859",
    "snippet": "void __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\t/*\n\t * If do_dead is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t *\n\t * On uptodate architectures force_uaccess_begin is a noop.  On\n\t * architectures that still have set_fs/get_fs in addition to handling\n\t * oopses handles kernel threads that run as set_fs(KERNEL_DS) by\n\t * default.\n\t */\n\tforce_uaccess_begin();\n\n\tkcov_task_exit(tsk);\n\n\tcoredump_task_exit(tsk);\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tio_uring_files_cancel();\n\texit_signals(tsk);  /* sets PF_EXITING */\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\t/*\n\t\t * If the last thread of global init has exited, panic\n\t\t * immediately to get a useable coredump.\n\t\t */\n\t\tif (unlikely(is_global_init(tsk)))\n\t\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\t\ttsk->signal->group_exit_code ?: (int)code);\n\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_task_dead",
          "args": [],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "do_task_dead",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6306-6320",
          "snippet": "void __noreturn do_task_dead(void)\n{\n\t/* Causes final put_task_struct in finish_task_switch(): */\n\tset_special_state(TASK_DEAD);\n\n\t/* Tell freezer to ignore us: */\n\tcurrent->flags |= PF_NOFREEZE;\n\n\t__schedule(SM_NONE);\n\tBUG();\n\n\t/* Avoid \"noreturn function does return\" - but don't continue if BUG() is a NOP: */\n\tfor (;;)\n\t\tcpu_relax();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [
            "#define SM_NONE\t\t\t0x0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\n#define SM_NONE\t\t\t0x0\n\nvoid __noreturn do_task_dead(void)\n{\n\t/* Causes final put_task_struct in finish_task_switch(): */\n\tset_special_state(TASK_DEAD);\n\n\t/* Tell freezer to ignore us: */\n\tcurrent->flags |= PF_NOFREEZE;\n\n\t__schedule(SM_NONE);\n\tBUG();\n\n\t/* Avoid \"noreturn function does return\" - but don't continue if BUG() is a NOP: */\n\tfor (;;)\n\t\tcpu_relax();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_free_task",
          "args": [
            "tsk"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_tasks_rcu_finish",
          "args": [],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "exit_tasks_rcu_finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "922-922",
          "snippet": "void exit_tasks_rcu_finish(void) { exit_tasks_rcu_finish_trace(current); }",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid exit_tasks_rcu_finish(void) { exit_tasks_rcu_finish_trace(current); }"
        }
      },
      {
        "call_info": {
          "callee": "exit_rcu",
          "args": [],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "irq_exit_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "647-652",
          "snippet": "void irq_exit_rcu(void)\n{\n\t__irq_exit_rcu();\n\t /* must be last! */\n\tlockdep_hardirq_exit();\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid irq_exit_rcu(void)\n{\n\t__irq_exit_rcu();\n\t /* must be last! */\n\tlockdep_hardirq_exit();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_add",
          "args": [
            "dirty_throttle_leaks",
            "tsk->nr_dirtied"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_usage",
          "args": [],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "check_stack_usage",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "731-731",
          "snippet": "static inline void check_stack_usage(void) {}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void check_stack_usage(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "validate_creds_for_do_exit",
          "args": [
            "tsk"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "validate_creds_for_do_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cred.c",
          "lines": "922-930",
          "snippet": "void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}",
          "includes": [
            "#include <linux/uidgid.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uidgid.h>\n#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "tsk->task_frag.page"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pipe_info",
          "args": [
            "tsk->splice_pipe"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_io_context",
          "args": [
            "tsk"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_held",
          "args": [],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "debug_check_no_locks_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6448-6452",
          "snippet": "void debug_check_no_locks_held(void)\n{\n\tif (unlikely(current->lockdep_depth > 0))\n\t\tprint_held_locks_bug();\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_check_no_locks_held(void)\n{\n\tif (unlikely(current->lockdep_depth > 0))\n\t\tprint_held_locks_bug();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "current->pi_state_cache"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->pi_state_cache"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_put_task_policy",
          "args": [
            "tsk"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_exit_connector",
          "args": [
            "tsk"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_notify",
          "args": [
            "tsk",
            "group_dead"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "exit_notify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "668-708",
          "snippet": "static void exit_notify(struct task_struct *tsk, int group_dead)\n{\n\tbool autoreap;\n\tstruct task_struct *p, *n;\n\tLIST_HEAD(dead);\n\n\twrite_lock_irq(&tasklist_lock);\n\tforget_original_parent(tsk, &dead);\n\n\tif (group_dead)\n\t\tkill_orphaned_pgrp(tsk->group_leader, NULL);\n\n\ttsk->exit_state = EXIT_ZOMBIE;\n\tif (unlikely(tsk->ptrace)) {\n\t\tint sig = thread_group_leader(tsk) &&\n\t\t\t\tthread_group_empty(tsk) &&\n\t\t\t\t!ptrace_reparented(tsk) ?\n\t\t\ttsk->exit_signal : SIGCHLD;\n\t\tautoreap = do_notify_parent(tsk, sig);\n\t} else if (thread_group_leader(tsk)) {\n\t\tautoreap = thread_group_empty(tsk) &&\n\t\t\tdo_notify_parent(tsk, tsk->exit_signal);\n\t} else {\n\t\tautoreap = true;\n\t}\n\n\tif (autoreap) {\n\t\ttsk->exit_state = EXIT_DEAD;\n\t\tlist_add(&tsk->ptrace_entry, &dead);\n\t}\n\n\t/* mt-exec, de_thread() is waiting for group leader */\n\tif (unlikely(tsk->signal->notify_count < 0))\n\t\twake_up_process(tsk->signal->group_exec_task);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tlist_for_each_entry_safe(p, n, &dead, ptrace_entry) {\n\t\tlist_del_init(&p->ptrace_entry);\n\t\trelease_task(p);\n\t}\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void exit_notify(struct task_struct *tsk, int group_dead)\n{\n\tbool autoreap;\n\tstruct task_struct *p, *n;\n\tLIST_HEAD(dead);\n\n\twrite_lock_irq(&tasklist_lock);\n\tforget_original_parent(tsk, &dead);\n\n\tif (group_dead)\n\t\tkill_orphaned_pgrp(tsk->group_leader, NULL);\n\n\ttsk->exit_state = EXIT_ZOMBIE;\n\tif (unlikely(tsk->ptrace)) {\n\t\tint sig = thread_group_leader(tsk) &&\n\t\t\t\tthread_group_empty(tsk) &&\n\t\t\t\t!ptrace_reparented(tsk) ?\n\t\t\ttsk->exit_signal : SIGCHLD;\n\t\tautoreap = do_notify_parent(tsk, sig);\n\t} else if (thread_group_leader(tsk)) {\n\t\tautoreap = thread_group_empty(tsk) &&\n\t\t\tdo_notify_parent(tsk, tsk->exit_signal);\n\t} else {\n\t\tautoreap = true;\n\t}\n\n\tif (autoreap) {\n\t\ttsk->exit_state = EXIT_DEAD;\n\t\tlist_add(&tsk->ptrace_entry, &dead);\n\t}\n\n\t/* mt-exec, de_thread() is waiting for group leader */\n\tif (unlikely(tsk->signal->notify_count < 0))\n\t\twake_up_process(tsk->signal->group_exec_task);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tlist_for_each_entry_safe(p, n, &dead, ptrace_entry) {\n\t\tlist_del_init(&p->ptrace_entry);\n\t\trelease_task(p);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit_tasks_rcu_start",
          "args": [],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "exit_tasks_rcu_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "921-921",
          "snippet": "void exit_tasks_rcu_start(void) { }",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid exit_tasks_rcu_start(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "flush_ptrace_hw_breakpoint",
          "args": [
            "tsk"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_exit",
          "args": [
            "tsk"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "6385-6410",
          "snippet": "void cgroup_exit(struct task_struct *tsk)\n{\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tint i;\n\n\tspin_lock_irq(&css_set_lock);\n\n\tWARN_ON_ONCE(list_empty(&tsk->cg_list));\n\tcset = task_css_set(tsk);\n\tcss_set_move_task(tsk, cset, NULL, false);\n\tlist_add_tail(&tsk->cg_list, &cset->dying_tasks);\n\tcset->nr_tasks--;\n\n\tWARN_ON_ONCE(cgroup_task_frozen(tsk));\n\tif (unlikely(!(tsk->flags & PF_KTHREAD) &&\n\t\t     test_bit(CGRP_FREEZE, &task_dfl_cgroup(tsk)->flags)))\n\t\tcgroup_update_frozen(task_dfl_cgroup(tsk));\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* see cgroup_post_fork() for details */\n\tdo_each_subsys_mask(ss, i, have_exit_callback) {\n\t\tss->exit(tsk);\n\t} while_each_subsys_mask();\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 have_exit_callback",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 have_exit_callback;\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nvoid cgroup_exit(struct task_struct *tsk)\n{\n\tstruct cgroup_subsys *ss;\n\tstruct css_set *cset;\n\tint i;\n\n\tspin_lock_irq(&css_set_lock);\n\n\tWARN_ON_ONCE(list_empty(&tsk->cg_list));\n\tcset = task_css_set(tsk);\n\tcss_set_move_task(tsk, cset, NULL, false);\n\tlist_add_tail(&tsk->cg_list, &cset->dying_tasks);\n\tcset->nr_tasks--;\n\n\tWARN_ON_ONCE(cgroup_task_frozen(tsk));\n\tif (unlikely(!(tsk->flags & PF_KTHREAD) &&\n\t\t     test_bit(CGRP_FREEZE, &task_dfl_cgroup(tsk)->flags)))\n\t\tcgroup_update_frozen(task_dfl_cgroup(tsk));\n\n\tspin_unlock_irq(&css_set_lock);\n\n\t/* see cgroup_post_fork() for details */\n\tdo_each_subsys_mask(ss, i, have_exit_callback) {\n\t\tss->exit(tsk);\n\t} while_each_subsys_mask();\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_autogroup_exit_task",
          "args": [
            "tsk"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "sched_autogroup_exit_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "125-133",
          "snippet": "void sched_autogroup_exit_task(struct task_struct *p)\n{\n\t/*\n\t * We are going to call exit_notify() and autogroup_move_group() can't\n\t * see this thread after that: we can no longer use signal->autogroup.\n\t * See the PF_EXITING check in task_wants_autogroup().\n\t */\n\tsched_move_task(p);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nvoid sched_autogroup_exit_task(struct task_struct *p)\n{\n\t/*\n\t * We are going to call exit_notify() and autogroup_move_group() can't\n\t * see this thread after that: we can no longer use signal->autogroup.\n\t * See the PF_EXITING check in task_wants_autogroup().\n\t */\n\tsched_move_task(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_exit_task",
          "args": [
            "tsk"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_exit_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "12783-12812",
          "snippet": "void perf_event_exit_task(struct task_struct *child)\n{\n\tstruct perf_event *event, *tmp;\n\tint ctxn;\n\n\tmutex_lock(&child->perf_event_mutex);\n\tlist_for_each_entry_safe(event, tmp, &child->perf_event_list,\n\t\t\t\t owner_entry) {\n\t\tlist_del_init(&event->owner_entry);\n\n\t\t/*\n\t\t * Ensure the list deletion is visible before we clear\n\t\t * the owner, closes a race against perf_release() where\n\t\t * we need to serialize on the owner->perf_event_mutex.\n\t\t */\n\t\tsmp_store_release(&event->owner, NULL);\n\t}\n\tmutex_unlock(&child->perf_event_mutex);\n\n\tfor_each_task_context_nr(ctxn)\n\t\tperf_event_exit_task_context(child, ctxn);\n\n\t/*\n\t * The perf_event_exit_task_context calls perf_event_task\n\t * with child's task_ctx, which generates EXIT events for\n\t * child contexts and sets child->perf_event_ctxp[] to NULL.\n\t * At this point we need to send EXIT events to cpu contexts.\n\t */\n\tperf_event_task(child, NULL, 0);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nvoid perf_event_exit_task(struct task_struct *child)\n{\n\tstruct perf_event *event, *tmp;\n\tint ctxn;\n\n\tmutex_lock(&child->perf_event_mutex);\n\tlist_for_each_entry_safe(event, tmp, &child->perf_event_list,\n\t\t\t\t owner_entry) {\n\t\tlist_del_init(&event->owner_entry);\n\n\t\t/*\n\t\t * Ensure the list deletion is visible before we clear\n\t\t * the owner, closes a race against perf_release() where\n\t\t * we need to serialize on the owner->perf_event_mutex.\n\t\t */\n\t\tsmp_store_release(&event->owner, NULL);\n\t}\n\tmutex_unlock(&child->perf_event_mutex);\n\n\tfor_each_task_context_nr(ctxn)\n\t\tperf_event_exit_task_context(child, ctxn);\n\n\t/*\n\t * The perf_event_exit_task_context calls perf_event_task\n\t * with child's task_ctx, which generates EXIT events for\n\t * child contexts and sets child->perf_event_ctxp[] to NULL.\n\t * At this point we need to send EXIT events to cpu contexts.\n\t */\n\tperf_event_task(child, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit_thread",
          "args": [
            "tsk"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_task_work",
          "args": [
            "tsk"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_task_namespaces",
          "args": [
            "tsk"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "exit_task_namespaces",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/nsproxy.c",
          "lines": "252-255",
          "snippet": "void exit_task_namespaces(struct task_struct *p)\n{\n\tswitch_task_namespaces(p, NULL);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/file.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/time_namespace.h>",
            "#include <linux/ipc_namespace.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/init_task.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_struct.h>\n#include <linux/time_namespace.h>\n#include <linux/ipc_namespace.h>\n#include <net/net_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/mnt_namespace.h>\n#include <linux/init_task.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid exit_task_namespaces(struct task_struct *p)\n{\n\tswitch_task_namespaces(p, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disassociate_ctty",
          "args": [
            "1"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_fs",
          "args": [
            "tsk"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_files",
          "args": [
            "tsk"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_shm",
          "args": [
            "tsk"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_sem",
          "args": [
            "tsk"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sched_process_exit",
          "args": [
            "tsk"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_process",
          "args": [],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "acct_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/acct.c",
          "lines": "587-602",
          "snippet": "void acct_process(void)\n{\n\tstruct pid_namespace *ns;\n\n\t/*\n\t * This loop is safe lockless, since current is still\n\t * alive and holds its namespace, which in turn holds\n\t * its parent.\n\t */\n\tfor (ns = task_active_pid_ns(current); ns != NULL; ns = ns->parent) {\n\t\tif (ns->bacct)\n\t\t\tbreak;\n\t}\n\tif (unlikely(ns))\n\t\tslow_acct_process(ns);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid acct_process(void)\n{\n\tstruct pid_namespace *ns;\n\n\t/*\n\t * This loop is safe lockless, since current is still\n\t * alive and holds its namespace, which in turn holds\n\t * its parent.\n\t */\n\tfor (ns = task_active_pid_ns(current); ns != NULL; ns = ns->parent) {\n\t\tif (ns->bacct)\n\t\t\tbreak;\n\t}\n\tif (unlikely(ns))\n\t\tslow_acct_process(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit_mm",
          "args": [],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "exit_mm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "476-511",
          "snippet": "static void exit_mm(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\texit_mm_release(current, mm);\n\tif (!mm)\n\t\treturn;\n\tsync_mm_rss(mm);\n\tmmap_read_lock(mm);\n\tmmgrab(mm);\n\tBUG_ON(mm != current->active_mm);\n\t/* more a memory barrier than a real lock */\n\ttask_lock(current);\n\t/*\n\t * When a thread stops operating on an address space, the loop\n\t * in membarrier_private_expedited() may not observe that\n\t * tsk->mm, and the loop in membarrier_global_expedited() may\n\t * not observe a MEMBARRIER_STATE_GLOBAL_EXPEDITED\n\t * rq->membarrier_state, so those would not issue an IPI.\n\t * Membarrier requires a memory barrier after accessing\n\t * user-space memory, before clearing tsk->mm or the\n\t * rq->membarrier_state.\n\t */\n\tsmp_mb__after_spinlock();\n\tlocal_irq_disable();\n\tcurrent->mm = NULL;\n\tmembarrier_update_current_mm(NULL);\n\tenter_lazy_tlb(mm, current);\n\tlocal_irq_enable();\n\ttask_unlock(current);\n\tmmap_read_unlock(mm);\n\tmm_update_next_owner(mm);\n\tmmput(mm);\n\tif (test_thread_flag(TIF_MEMDIE))\n\t\texit_oom_victim();\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void exit_mm(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\texit_mm_release(current, mm);\n\tif (!mm)\n\t\treturn;\n\tsync_mm_rss(mm);\n\tmmap_read_lock(mm);\n\tmmgrab(mm);\n\tBUG_ON(mm != current->active_mm);\n\t/* more a memory barrier than a real lock */\n\ttask_lock(current);\n\t/*\n\t * When a thread stops operating on an address space, the loop\n\t * in membarrier_private_expedited() may not observe that\n\t * tsk->mm, and the loop in membarrier_global_expedited() may\n\t * not observe a MEMBARRIER_STATE_GLOBAL_EXPEDITED\n\t * rq->membarrier_state, so those would not issue an IPI.\n\t * Membarrier requires a memory barrier after accessing\n\t * user-space memory, before clearing tsk->mm or the\n\t * rq->membarrier_state.\n\t */\n\tsmp_mb__after_spinlock();\n\tlocal_irq_disable();\n\tcurrent->mm = NULL;\n\tmembarrier_update_current_mm(NULL);\n\tenter_lazy_tlb(mm, current);\n\tlocal_irq_enable();\n\ttask_unlock(current);\n\tmmap_read_unlock(mm);\n\tmm_update_next_owner(mm);\n\tmmput(mm);\n\tif (test_thread_flag(TIF_MEMDIE))\n\t\texit_oom_victim();\n}"
        }
      },
      {
        "call_info": {
          "callee": "taskstats_exit",
          "args": [
            "tsk",
            "group_dead"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "taskstats_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/taskstats.c",
          "lines": "583-641",
          "snippet": "void taskstats_exit(struct task_struct *tsk, int group_dead)\n{\n\tint rc;\n\tstruct listener_list *listeners;\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tint is_thread_group;\n\n\tif (!family_registered)\n\t\treturn;\n\n\t/*\n\t * Size includes space for nested attributes\n\t */\n\tsize = taskstats_packet_size();\n\n\tis_thread_group = !!taskstats_tgid_alloc(tsk);\n\tif (is_thread_group) {\n\t\t/* PID + STATS + TGID + STATS */\n\t\tsize = 2 * size;\n\t\t/* fill the tsk->signal->stats structure */\n\t\tfill_tgid_exit(tsk);\n\t}\n\n\tlisteners = raw_cpu_ptr(&listener_array);\n\tif (list_empty(&listeners->list))\n\t\treturn;\n\n\trc = prepare_reply(NULL, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID,\n\t\t\t task_pid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tfill_stats(&init_user_ns, &init_pid_ns, tsk, stats);\n\n\t/*\n\t * Doesn't matter if tsk is the leader or the last group member leaving\n\t */\n\tif (!is_thread_group || !group_dead)\n\t\tgoto send;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID,\n\t\t\t task_tgid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tmemcpy(stats, tsk->signal->stats, sizeof(*stats));\n\nsend:\n\tsend_cpu_listeners(rep_skb, listeners);\n\treturn;\nerr:\n\tnlmsg_free(rep_skb);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int family_registered;",
            "static DEFINE_PER_CPU(struct listener_list, listener_array);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int family_registered;\nstatic DEFINE_PER_CPU(struct listener_list, listener_array);\n\nvoid taskstats_exit(struct task_struct *tsk, int group_dead)\n{\n\tint rc;\n\tstruct listener_list *listeners;\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tint is_thread_group;\n\n\tif (!family_registered)\n\t\treturn;\n\n\t/*\n\t * Size includes space for nested attributes\n\t */\n\tsize = taskstats_packet_size();\n\n\tis_thread_group = !!taskstats_tgid_alloc(tsk);\n\tif (is_thread_group) {\n\t\t/* PID + STATS + TGID + STATS */\n\t\tsize = 2 * size;\n\t\t/* fill the tsk->signal->stats structure */\n\t\tfill_tgid_exit(tsk);\n\t}\n\n\tlisteners = raw_cpu_ptr(&listener_array);\n\tif (list_empty(&listeners->list))\n\t\treturn;\n\n\trc = prepare_reply(NULL, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID,\n\t\t\t task_pid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tfill_stats(&init_user_ns, &init_pid_ns, tsk, stats);\n\n\t/*\n\t * Doesn't matter if tsk is the leader or the last group member leaving\n\t */\n\tif (!is_thread_group || !group_dead)\n\t\tgoto send;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID,\n\t\t\t task_tgid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tmemcpy(stats, tsk->signal->stats, sizeof(*stats));\n\nsend:\n\tsend_cpu_listeners(rep_skb, listeners);\n\treturn;\nerr:\n\tnlmsg_free(rep_skb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_free",
          "args": [
            "tsk"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_rule_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/auditfilter.c",
          "lines": "99-103",
          "snippet": "void audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nvoid audit_free_rule_rcu(struct rcu_head *head)\n{\n\tstruct audit_entry *e = container_of(head, struct audit_entry, rcu);\n\taudit_free_rule(e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tty_audit_exit",
          "args": [],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_collect",
          "args": [
            "code",
            "group_dead"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "acct_collect",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/acct.c",
          "lines": "531-570",
          "snippet": "void acct_collect(long exitcode, int group_dead)\n{\n\tstruct pacct_struct *pacct = &current->signal->pacct;\n\tu64 utime, stime;\n\tunsigned long vsize = 0;\n\n\tif (group_dead && current->mm) {\n\t\tstruct vm_area_struct *vma;\n\n\t\tmmap_read_lock(current->mm);\n\t\tvma = current->mm->mmap;\n\t\twhile (vma) {\n\t\t\tvsize += vma->vm_end - vma->vm_start;\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t\tmmap_read_unlock(current->mm);\n\t}\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (group_dead)\n\t\tpacct->ac_mem = vsize / 1024;\n\tif (thread_group_leader(current)) {\n\t\tpacct->ac_exitcode = exitcode;\n\t\tif (current->flags & PF_FORKNOEXEC)\n\t\t\tpacct->ac_flag |= AFORK;\n\t}\n\tif (current->flags & PF_SUPERPRIV)\n\t\tpacct->ac_flag |= ASU;\n\tif (current->flags & PF_DUMPCORE)\n\t\tpacct->ac_flag |= ACORE;\n\tif (current->flags & PF_SIGNALED)\n\t\tpacct->ac_flag |= AXSIG;\n\n\ttask_cputime(current, &utime, &stime);\n\tpacct->ac_utime += utime;\n\tpacct->ac_stime += stime;\n\tpacct->ac_minflt += current->min_flt;\n\tpacct->ac_majflt += current->maj_flt;\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid acct_collect(long exitcode, int group_dead)\n{\n\tstruct pacct_struct *pacct = &current->signal->pacct;\n\tu64 utime, stime;\n\tunsigned long vsize = 0;\n\n\tif (group_dead && current->mm) {\n\t\tstruct vm_area_struct *vma;\n\n\t\tmmap_read_lock(current->mm);\n\t\tvma = current->mm->mmap;\n\t\twhile (vma) {\n\t\t\tvsize += vma->vm_end - vma->vm_start;\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t\tmmap_read_unlock(current->mm);\n\t}\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (group_dead)\n\t\tpacct->ac_mem = vsize / 1024;\n\tif (thread_group_leader(current)) {\n\t\tpacct->ac_exitcode = exitcode;\n\t\tif (current->flags & PF_FORKNOEXEC)\n\t\t\tpacct->ac_flag |= AFORK;\n\t}\n\tif (current->flags & PF_SUPERPRIV)\n\t\tpacct->ac_flag |= ASU;\n\tif (current->flags & PF_DUMPCORE)\n\t\tpacct->ac_flag |= ACORE;\n\tif (current->flags & PF_SIGNALED)\n\t\tpacct->ac_flag |= AXSIG;\n\n\ttask_cputime(current, &utime, &stime);\n\tpacct->ac_utime += utime;\n\tpacct->ac_stime += stime;\n\tpacct->ac_minflt += current->min_flt;\n\tpacct->ac_majflt += current->maj_flt;\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setmax_mm_hiwater_rss",
          "args": [
            "&tsk->signal->maxrss",
            "tsk->mm"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_itimers",
          "args": [
            "tsk->signal"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "exit_itimers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "1057-1065",
          "snippet": "void exit_itimers(struct signal_struct *sig)\n{\n\tstruct k_itimer *tmr;\n\n\twhile (!list_empty(&sig->posix_timers)) {\n\t\ttmr = list_entry(sig->posix_timers.next, struct k_itimer, list);\n\t\titimer_delete(tmr);\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nvoid exit_itimers(struct signal_struct *sig)\n{\n\tstruct k_itimer *tmr;\n\n\twhile (!list_empty(&sig->posix_timers)) {\n\t\ttmr = list_entry(sig->posix_timers.next, struct k_itimer, list);\n\t\titimer_delete(tmr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&tsk->signal->real_timer"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1438-1449",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Attempted to kill init! exitcode=0x%08x\\n\"",
            "tsk->signal->group_exit_code ?: (int)code"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "panic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "179-361",
          "snippet": "void panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define PANIC_BLINK_SPD 18",
            "#define PANIC_TIMER_STEP 100"
          ],
          "globals_used": [
            "bool crash_kexec_post_notifiers;",
            "int panic_timeout = CONFIG_PANIC_TIMEOUT;",
            "long (*panic_blink)(int state);",
            "atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\n#define PANIC_BLINK_SPD 18\n#define PANIC_TIMER_STEP 100\n\nbool crash_kexec_post_notifiers;\nint panic_timeout = CONFIG_PANIC_TIMEOUT;\nlong (*panic_blink)(int state);\natomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);\n\nvoid panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\tpreempt_disable_notrace();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If kgdb is enabled, give it a chance to run before we stop all\n\t * the other CPUs or else we won't be able to debug processes left\n\t * running on them.\n\t */\n\tkgdb_panic(buf);\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n#ifdef CONFIG_VT\n\tunblank_screen();\n#endif\n\tconsole_unblank();\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic(CONSOLE_FLUSH_PENDING);\n\n\tpanic_print_sys_info();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\tif (panic_reboot_mode != REBOOT_UNDEFINED)\n\t\t\treboot_mode = panic_reboot_mode;\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\tdisabled_wait();\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\n\t/* Do not scroll important messages printed above */\n\tsuppress_printk = 1;\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_global_init(tsk)"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_global_init",
          "args": [
            "tsk"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&tsk->signal->live"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_update_integrals",
          "args": [
            "tsk"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "acct_update_integrals",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tsacct.c",
          "lines": "146-155",
          "snippet": "void acct_update_integrals(struct task_struct *tsk)\n{\n\tu64 utime, stime;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\ttask_cputime(tsk, &utime, &stime);\n\t__acct_update_integrals(tsk, utime, stime);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/acct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid acct_update_integrals(struct task_struct *tsk)\n{\n\tu64 utime, stime;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\ttask_cputime(tsk, &utime, &stime);\n\t__acct_update_integrals(tsk, utime, stime);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_mm_rss",
          "args": [
            "tsk->mm"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_signals",
          "args": [
            "tsk"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "exit_signals",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2946-2994",
          "snippet": "void exit_signals(struct task_struct *tsk)\n{\n\tint group_stop = 0;\n\tsigset_t unblocked;\n\n\t/*\n\t * @tsk is about to have PF_EXITING set - lock out users which\n\t * expect stable threadgroup.\n\t */\n\tcgroup_threadgroup_change_begin(tsk);\n\n\tif (thread_group_empty(tsk) || (tsk->signal->flags & SIGNAL_GROUP_EXIT)) {\n\t\ttsk->flags |= PF_EXITING;\n\t\tcgroup_threadgroup_change_end(tsk);\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t/*\n\t * From now this task is not visible for group-wide signals,\n\t * see wants_signal(), do_signal_stop().\n\t */\n\ttsk->flags |= PF_EXITING;\n\n\tcgroup_threadgroup_change_end(tsk);\n\n\tif (!task_sigpending(tsk))\n\t\tgoto out;\n\n\tunblocked = tsk->blocked;\n\tsignotset(&unblocked);\n\tretarget_shared_pending(tsk, &unblocked);\n\n\tif (unlikely(tsk->jobctl & JOBCTL_STOP_PENDING) &&\n\t    task_participate_group_stop(tsk))\n\t\tgroup_stop = CLD_STOPPED;\nout:\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\t/*\n\t * If group stop has completed, deliver the notification.  This\n\t * should always go to the real parent of the group leader.\n\t */\n\tif (unlikely(group_stop)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(tsk, false, group_stop);\n\t\tread_unlock(&tasklist_lock);\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid exit_signals(struct task_struct *tsk)\n{\n\tint group_stop = 0;\n\tsigset_t unblocked;\n\n\t/*\n\t * @tsk is about to have PF_EXITING set - lock out users which\n\t * expect stable threadgroup.\n\t */\n\tcgroup_threadgroup_change_begin(tsk);\n\n\tif (thread_group_empty(tsk) || (tsk->signal->flags & SIGNAL_GROUP_EXIT)) {\n\t\ttsk->flags |= PF_EXITING;\n\t\tcgroup_threadgroup_change_end(tsk);\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t/*\n\t * From now this task is not visible for group-wide signals,\n\t * see wants_signal(), do_signal_stop().\n\t */\n\ttsk->flags |= PF_EXITING;\n\n\tcgroup_threadgroup_change_end(tsk);\n\n\tif (!task_sigpending(tsk))\n\t\tgoto out;\n\n\tunblocked = tsk->blocked;\n\tsignotset(&unblocked);\n\tretarget_shared_pending(tsk, &unblocked);\n\n\tif (unlikely(tsk->jobctl & JOBCTL_STOP_PENDING) &&\n\t    task_participate_group_stop(tsk))\n\t\tgroup_stop = CLD_STOPPED;\nout:\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\t/*\n\t * If group stop has completed, deliver the notification.  This\n\t * should always go to the real parent of the group leader.\n\t */\n\tif (unlikely(group_stop)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(tsk, false, group_stop);\n\t\tread_unlock(&tasklist_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_uring_files_cancel",
          "args": [],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_event",
          "args": [
            "PTRACE_EVENT_EXIT",
            "code"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coredump_task_exit",
          "args": [
            "tsk"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "coredump_task_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "344-382",
          "snippet": "static void coredump_task_exit(struct task_struct *tsk)\n{\n\tstruct core_state *core_state;\n\n\t/*\n\t * Serialize with any possible pending coredump.\n\t * We must hold siglock around checking core_state\n\t * and setting PF_POSTCOREDUMP.  The core-inducing thread\n\t * will increment ->nr_threads for each thread in the\n\t * group without PF_POSTCOREDUMP set.\n\t */\n\tspin_lock_irq(&tsk->sighand->siglock);\n\ttsk->flags |= PF_POSTCOREDUMP;\n\tcore_state = tsk->signal->core_state;\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\tif (core_state) {\n\t\tstruct core_thread self;\n\n\t\tself.task = current;\n\t\tif (self.task->flags & PF_SIGNALED)\n\t\t\tself.next = xchg(&core_state->dumper.next, &self);\n\t\telse\n\t\t\tself.task = NULL;\n\t\t/*\n\t\t * Implies mb(), the result of xchg() must be visible\n\t\t * to core_state->dumper.\n\t\t */\n\t\tif (atomic_dec_and_test(&core_state->nr_threads))\n\t\t\tcomplete(&core_state->startup);\n\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tif (!self.task) /* see coredump_finish() */\n\t\t\t\tbreak;\n\t\t\tfreezable_schedule();\n\t\t}\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void coredump_task_exit(struct task_struct *tsk)\n{\n\tstruct core_state *core_state;\n\n\t/*\n\t * Serialize with any possible pending coredump.\n\t * We must hold siglock around checking core_state\n\t * and setting PF_POSTCOREDUMP.  The core-inducing thread\n\t * will increment ->nr_threads for each thread in the\n\t * group without PF_POSTCOREDUMP set.\n\t */\n\tspin_lock_irq(&tsk->sighand->siglock);\n\ttsk->flags |= PF_POSTCOREDUMP;\n\tcore_state = tsk->signal->core_state;\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\tif (core_state) {\n\t\tstruct core_thread self;\n\n\t\tself.task = current;\n\t\tif (self.task->flags & PF_SIGNALED)\n\t\t\tself.next = xchg(&core_state->dumper.next, &self);\n\t\telse\n\t\t\tself.task = NULL;\n\t\t/*\n\t\t * Implies mb(), the result of xchg() must be visible\n\t\t * to core_state->dumper.\n\t\t */\n\t\tif (atomic_dec_and_test(&core_state->nr_threads))\n\t\t\tcomplete(&core_state->startup);\n\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tif (!self.task) /* see coredump_finish() */\n\t\t\t\tbreak;\n\t\t\tfreezable_schedule();\n\t\t}\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcov_task_exit",
          "args": [
            "tsk"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "kcov_task_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcov.c",
          "lines": "416-457",
          "snippet": "void kcov_task_exit(struct task_struct *t)\n{\n\tstruct kcov *kcov;\n\tunsigned long flags;\n\n\tkcov = t->kcov;\n\tif (kcov == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&kcov->lock, flags);\n\tkcov_debug(\"t = %px, kcov->t = %px\\n\", t, kcov->t);\n\t/*\n\t * For KCOV_ENABLE devices we want to make sure that t->kcov->t == t,\n\t * which comes down to:\n\t *        WARN_ON(!kcov->remote && kcov->t != t);\n\t *\n\t * For KCOV_REMOTE_ENABLE devices, the exiting task is either:\n\t *\n\t * 1. A remote task between kcov_remote_start() and kcov_remote_stop().\n\t *    In this case we should print a warning right away, since a task\n\t *    shouldn't be exiting when it's in a kcov coverage collection\n\t *    section. Here t points to the task that is collecting remote\n\t *    coverage, and t->kcov->t points to the thread that created the\n\t *    kcov device. Which means that to detect this case we need to\n\t *    check that t != t->kcov->t, and this gives us the following:\n\t *        WARN_ON(kcov->remote && kcov->t != t);\n\t *\n\t * 2. The task that created kcov exiting without calling KCOV_DISABLE,\n\t *    and then again we make sure that t->kcov->t == t:\n\t *        WARN_ON(kcov->remote && kcov->t != t);\n\t *\n\t * By combining all three checks into one we get:\n\t */\n\tif (WARN_ON(kcov->t != t)) {\n\t\tspin_unlock_irqrestore(&kcov->lock, flags);\n\t\treturn;\n\t}\n\t/* Just to not leave dangling references behind. */\n\tkcov_disable(t, kcov);\n\tspin_unlock_irqrestore(&kcov->lock, flags);\n\tkcov_put(kcov);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/log2.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kcov.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/types.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/kcov.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/hashtable.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n\nvoid kcov_task_exit(struct task_struct *t)\n{\n\tstruct kcov *kcov;\n\tunsigned long flags;\n\n\tkcov = t->kcov;\n\tif (kcov == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&kcov->lock, flags);\n\tkcov_debug(\"t = %px, kcov->t = %px\\n\", t, kcov->t);\n\t/*\n\t * For KCOV_ENABLE devices we want to make sure that t->kcov->t == t,\n\t * which comes down to:\n\t *        WARN_ON(!kcov->remote && kcov->t != t);\n\t *\n\t * For KCOV_REMOTE_ENABLE devices, the exiting task is either:\n\t *\n\t * 1. A remote task between kcov_remote_start() and kcov_remote_stop().\n\t *    In this case we should print a warning right away, since a task\n\t *    shouldn't be exiting when it's in a kcov coverage collection\n\t *    section. Here t points to the task that is collecting remote\n\t *    coverage, and t->kcov->t points to the thread that created the\n\t *    kcov device. Which means that to detect this case we need to\n\t *    check that t != t->kcov->t, and this gives us the following:\n\t *        WARN_ON(kcov->remote && kcov->t != t);\n\t *\n\t * 2. The task that created kcov exiting without calling KCOV_DISABLE,\n\t *    and then again we make sure that t->kcov->t == t:\n\t *        WARN_ON(kcov->remote && kcov->t != t);\n\t *\n\t * By combining all three checks into one we get:\n\t */\n\tif (WARN_ON(kcov->t != t)) {\n\t\tspin_unlock_irqrestore(&kcov->lock, flags);\n\t\treturn;\n\t}\n\t/* Just to not leave dangling references behind. */\n\tkcov_disable(t, kcov);\n\tspin_unlock_irqrestore(&kcov->lock, flags);\n\tkcov_put(kcov);\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_uaccess_begin",
          "args": [],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "blk_needs_flush_plug(tsk)"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_needs_flush_plug",
          "args": [
            "tsk"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\t/*\n\t * If do_dead is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t *\n\t * On uptodate architectures force_uaccess_begin is a noop.  On\n\t * architectures that still have set_fs/get_fs in addition to handling\n\t * oopses handles kernel threads that run as set_fs(KERNEL_DS) by\n\t * default.\n\t */\n\tforce_uaccess_begin();\n\n\tkcov_task_exit(tsk);\n\n\tcoredump_task_exit(tsk);\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tio_uring_files_cancel();\n\texit_signals(tsk);  /* sets PF_EXITING */\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\t/*\n\t\t * If the last thread of global init has exited, panic\n\t\t * immediately to get a useable coredump.\n\t\t */\n\t\tif (unlikely(is_global_init(tsk)))\n\t\t\tpanic(\"Attempted to kill init! exitcode=0x%08x\\n\",\n\t\t\t\ttsk->signal->group_exit_code ?: (int)code);\n\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}"
  },
  {
    "function_name": "check_stack_usage",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "731-731",
    "snippet": "static inline void check_stack_usage(void) {}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline void check_stack_usage(void) {}"
  },
  {
    "function_name": "check_stack_usage",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "711-729",
    "snippet": "static void check_stack_usage(void)\n{\n\tstatic DEFINE_SPINLOCK(low_water_lock);\n\tstatic int lowest_to_date = THREAD_SIZE;\n\tunsigned long free;\n\n\tfree = stack_not_used(current);\n\n\tif (free >= lowest_to_date)\n\t\treturn;\n\n\tspin_lock(&low_water_lock);\n\tif (free < lowest_to_date) {\n\t\tpr_info(\"%s (%d) used greatest stack depth: %lu bytes left\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current), free);\n\t\tlowest_to_date = free;\n\t}\n\tspin_unlock(&low_water_lock);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&low_water_lock"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s (%d) used greatest stack depth: %lu bytes left\\n\"",
            "current->comm",
            "task_pid_nr(current)",
            "free"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&low_water_lock"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack_not_used",
          "args": [
            "current"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void check_stack_usage(void)\n{\n\tstatic DEFINE_SPINLOCK(low_water_lock);\n\tstatic int lowest_to_date = THREAD_SIZE;\n\tunsigned long free;\n\n\tfree = stack_not_used(current);\n\n\tif (free >= lowest_to_date)\n\t\treturn;\n\n\tspin_lock(&low_water_lock);\n\tif (free < lowest_to_date) {\n\t\tpr_info(\"%s (%d) used greatest stack depth: %lu bytes left\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current), free);\n\t\tlowest_to_date = free;\n\t}\n\tspin_unlock(&low_water_lock);\n}"
  },
  {
    "function_name": "exit_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "668-708",
    "snippet": "static void exit_notify(struct task_struct *tsk, int group_dead)\n{\n\tbool autoreap;\n\tstruct task_struct *p, *n;\n\tLIST_HEAD(dead);\n\n\twrite_lock_irq(&tasklist_lock);\n\tforget_original_parent(tsk, &dead);\n\n\tif (group_dead)\n\t\tkill_orphaned_pgrp(tsk->group_leader, NULL);\n\n\ttsk->exit_state = EXIT_ZOMBIE;\n\tif (unlikely(tsk->ptrace)) {\n\t\tint sig = thread_group_leader(tsk) &&\n\t\t\t\tthread_group_empty(tsk) &&\n\t\t\t\t!ptrace_reparented(tsk) ?\n\t\t\ttsk->exit_signal : SIGCHLD;\n\t\tautoreap = do_notify_parent(tsk, sig);\n\t} else if (thread_group_leader(tsk)) {\n\t\tautoreap = thread_group_empty(tsk) &&\n\t\t\tdo_notify_parent(tsk, tsk->exit_signal);\n\t} else {\n\t\tautoreap = true;\n\t}\n\n\tif (autoreap) {\n\t\ttsk->exit_state = EXIT_DEAD;\n\t\tlist_add(&tsk->ptrace_entry, &dead);\n\t}\n\n\t/* mt-exec, de_thread() is waiting for group leader */\n\tif (unlikely(tsk->signal->notify_count < 0))\n\t\twake_up_process(tsk->signal->group_exec_task);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tlist_for_each_entry_safe(p, n, &dead, ptrace_entry) {\n\t\tlist_del_init(&p->ptrace_entry);\n\t\trelease_task(p);\n\t}\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_task",
          "args": [
            "p"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "release_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "184-232",
          "snippet": "void release_task(struct task_struct *p)\n{\n\tstruct task_struct *leader;\n\tstruct pid *thread_pid;\n\tint zap_leader;\nrepeat:\n\t/* don't need to get the RCU readlock here - the process is dead and\n\t * can't be modifying its own credentials. But shut RCU-lockdep up */\n\trcu_read_lock();\n\tdec_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1);\n\trcu_read_unlock();\n\n\tcgroup_release(p);\n\n\twrite_lock_irq(&tasklist_lock);\n\tptrace_release_task(p);\n\tthread_pid = get_pid(p->thread_pid);\n\t__exit_signal(p);\n\n\t/*\n\t * If we are the last non-leader member of the thread\n\t * group, and the leader is zombie, then notify the\n\t * group leader's parent process. (if it wants notification.)\n\t */\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader)\n\t\t\t&& leader->exit_state == EXIT_ZOMBIE) {\n\t\t/*\n\t\t * If we were the last child thread and the leader has\n\t\t * exited already, and the leader's parent ignores SIGCHLD,\n\t\t * then we are the one who should release the leader.\n\t\t */\n\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = EXIT_DEAD;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\tseccomp_filter_release(p);\n\tproc_flush_pid(thread_pid);\n\tput_pid(thread_pid);\n\trelease_thread(p);\n\tput_task_struct_rcu_user(p);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid release_task(struct task_struct *p)\n{\n\tstruct task_struct *leader;\n\tstruct pid *thread_pid;\n\tint zap_leader;\nrepeat:\n\t/* don't need to get the RCU readlock here - the process is dead and\n\t * can't be modifying its own credentials. But shut RCU-lockdep up */\n\trcu_read_lock();\n\tdec_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1);\n\trcu_read_unlock();\n\n\tcgroup_release(p);\n\n\twrite_lock_irq(&tasklist_lock);\n\tptrace_release_task(p);\n\tthread_pid = get_pid(p->thread_pid);\n\t__exit_signal(p);\n\n\t/*\n\t * If we are the last non-leader member of the thread\n\t * group, and the leader is zombie, then notify the\n\t * group leader's parent process. (if it wants notification.)\n\t */\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader)\n\t\t\t&& leader->exit_state == EXIT_ZOMBIE) {\n\t\t/*\n\t\t * If we were the last child thread and the leader has\n\t\t * exited already, and the leader's parent ignores SIGCHLD,\n\t\t * then we are the one who should release the leader.\n\t\t */\n\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = EXIT_DEAD;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\tseccomp_filter_release(p);\n\tproc_flush_pid(thread_pid);\n\tput_pid(thread_pid);\n\trelease_thread(p);\n\tput_task_struct_rcu_user(p);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->ptrace_entry"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "p",
            "n",
            "&dead",
            "ptrace_entry"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "356-359",
          "snippet": "void __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "tsk->signal->group_exec_task"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tsk->signal->notify_count < 0"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tsk->ptrace_entry",
            "&dead"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_notify_parent",
          "args": [
            "tsk",
            "tsk->exit_signal"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2014-2110",
          "snippet": "bool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\t/* Wake up all pidfd waiters */\n\tdo_notify_pidfd(tsk);\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != READ_ONCE(tsk->parent->self_exec_id))\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\t/*\n\t * Send with __send_signal as si_pid and si_uid are in the\n\t * parent's namespaces.\n\t */\n\tif (valid_signal(sig) && sig)\n\t\t__send_signal(sig, &info, tsk->parent, PIDTYPE_TGID, false);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\t/* Wake up all pidfd waiters */\n\tdo_notify_pidfd(tsk);\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != READ_ONCE(tsk->parent->self_exec_id))\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\t/*\n\t * Send with __send_signal as si_pid and si_uid are in the\n\t * parent's namespaces.\n\t */\n\tif (valid_signal(sig) && sig)\n\t\t__send_signal(sig, &info, tsk->parent, PIDTYPE_TGID, false);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "tsk"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "tsk"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_reparented",
          "args": [
            "tsk"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "tsk"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "tsk"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tsk->ptrace"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_orphaned_pgrp",
          "args": [
            "tsk->group_leader",
            "NULL"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "kill_orphaned_pgrp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "318-342",
          "snippet": "static void\nkill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)\n{\n\tstruct pid *pgrp = task_pgrp(tsk);\n\tstruct task_struct *ignored_task = tsk;\n\n\tif (!parent)\n\t\t/* exit: our father is in a different pgrp than\n\t\t * we are and we were the only connection outside.\n\t\t */\n\t\tparent = tsk->real_parent;\n\telse\n\t\t/* reparent: our child is in a different pgrp than\n\t\t * we are, and it was the only connection outside.\n\t\t */\n\t\tignored_task = NULL;\n\n\tif (task_pgrp(parent) != pgrp &&\n\t    task_session(parent) == task_session(tsk) &&\n\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&\n\t    has_stopped_jobs(pgrp)) {\n\t\t__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);\n\t\t__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);\n\t}\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void\nkill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)\n{\n\tstruct pid *pgrp = task_pgrp(tsk);\n\tstruct task_struct *ignored_task = tsk;\n\n\tif (!parent)\n\t\t/* exit: our father is in a different pgrp than\n\t\t * we are and we were the only connection outside.\n\t\t */\n\t\tparent = tsk->real_parent;\n\telse\n\t\t/* reparent: our child is in a different pgrp than\n\t\t * we are, and it was the only connection outside.\n\t\t */\n\t\tignored_task = NULL;\n\n\tif (task_pgrp(parent) != pgrp &&\n\t    task_session(parent) == task_session(tsk) &&\n\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&\n\t    has_stopped_jobs(pgrp)) {\n\t\t__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);\n\t\t__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "forget_original_parent",
          "args": [
            "tsk",
            "&dead"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "forget_original_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "629-662",
          "snippet": "static void forget_original_parent(struct task_struct *father,\n\t\t\t\t\tstruct list_head *dead)\n{\n\tstruct task_struct *p, *t, *reaper;\n\n\tif (unlikely(!list_empty(&father->ptraced)))\n\t\texit_ptrace(father, dead);\n\n\t/* Can drop and reacquire tasklist_lock */\n\treaper = find_child_reaper(father, dead);\n\tif (list_empty(&father->children))\n\t\treturn;\n\n\treaper = find_new_reaper(father, reaper);\n\tlist_for_each_entry(p, &father->children, sibling) {\n\t\tfor_each_thread(p, t) {\n\t\t\tRCU_INIT_POINTER(t->real_parent, reaper);\n\t\t\tBUG_ON((!t->ptrace) != (rcu_access_pointer(t->parent) == father));\n\t\t\tif (likely(!t->ptrace))\n\t\t\t\tt->parent = t->real_parent;\n\t\t\tif (t->pdeath_signal)\n\t\t\t\tgroup_send_sig_info(t->pdeath_signal,\n\t\t\t\t\t\t    SEND_SIG_NOINFO, t,\n\t\t\t\t\t\t    PIDTYPE_TGID);\n\t\t}\n\t\t/*\n\t\t * If this is a threaded reparent there is no need to\n\t\t * notify anyone anything has happened.\n\t\t */\n\t\tif (!same_thread_group(reaper, father))\n\t\t\treparent_leader(father, p, dead);\n\t}\n\tlist_splice_tail_init(&father->children, &reaper->children);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void forget_original_parent(struct task_struct *father,\n\t\t\t\t\tstruct list_head *dead)\n{\n\tstruct task_struct *p, *t, *reaper;\n\n\tif (unlikely(!list_empty(&father->ptraced)))\n\t\texit_ptrace(father, dead);\n\n\t/* Can drop and reacquire tasklist_lock */\n\treaper = find_child_reaper(father, dead);\n\tif (list_empty(&father->children))\n\t\treturn;\n\n\treaper = find_new_reaper(father, reaper);\n\tlist_for_each_entry(p, &father->children, sibling) {\n\t\tfor_each_thread(p, t) {\n\t\t\tRCU_INIT_POINTER(t->real_parent, reaper);\n\t\t\tBUG_ON((!t->ptrace) != (rcu_access_pointer(t->parent) == father));\n\t\t\tif (likely(!t->ptrace))\n\t\t\t\tt->parent = t->real_parent;\n\t\t\tif (t->pdeath_signal)\n\t\t\t\tgroup_send_sig_info(t->pdeath_signal,\n\t\t\t\t\t\t    SEND_SIG_NOINFO, t,\n\t\t\t\t\t\t    PIDTYPE_TGID);\n\t\t}\n\t\t/*\n\t\t * If this is a threaded reparent there is no need to\n\t\t * notify anyone anything has happened.\n\t\t */\n\t\tif (!same_thread_group(reaper, father))\n\t\t\treparent_leader(father, p, dead);\n\t}\n\tlist_splice_tail_init(&father->children, &reaper->children);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "324-327",
          "snippet": "void __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dead"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void exit_notify(struct task_struct *tsk, int group_dead)\n{\n\tbool autoreap;\n\tstruct task_struct *p, *n;\n\tLIST_HEAD(dead);\n\n\twrite_lock_irq(&tasklist_lock);\n\tforget_original_parent(tsk, &dead);\n\n\tif (group_dead)\n\t\tkill_orphaned_pgrp(tsk->group_leader, NULL);\n\n\ttsk->exit_state = EXIT_ZOMBIE;\n\tif (unlikely(tsk->ptrace)) {\n\t\tint sig = thread_group_leader(tsk) &&\n\t\t\t\tthread_group_empty(tsk) &&\n\t\t\t\t!ptrace_reparented(tsk) ?\n\t\t\ttsk->exit_signal : SIGCHLD;\n\t\tautoreap = do_notify_parent(tsk, sig);\n\t} else if (thread_group_leader(tsk)) {\n\t\tautoreap = thread_group_empty(tsk) &&\n\t\t\tdo_notify_parent(tsk, tsk->exit_signal);\n\t} else {\n\t\tautoreap = true;\n\t}\n\n\tif (autoreap) {\n\t\ttsk->exit_state = EXIT_DEAD;\n\t\tlist_add(&tsk->ptrace_entry, &dead);\n\t}\n\n\t/* mt-exec, de_thread() is waiting for group leader */\n\tif (unlikely(tsk->signal->notify_count < 0))\n\t\twake_up_process(tsk->signal->group_exec_task);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tlist_for_each_entry_safe(p, n, &dead, ptrace_entry) {\n\t\tlist_del_init(&p->ptrace_entry);\n\t\trelease_task(p);\n\t}\n}"
  },
  {
    "function_name": "forget_original_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "629-662",
    "snippet": "static void forget_original_parent(struct task_struct *father,\n\t\t\t\t\tstruct list_head *dead)\n{\n\tstruct task_struct *p, *t, *reaper;\n\n\tif (unlikely(!list_empty(&father->ptraced)))\n\t\texit_ptrace(father, dead);\n\n\t/* Can drop and reacquire tasklist_lock */\n\treaper = find_child_reaper(father, dead);\n\tif (list_empty(&father->children))\n\t\treturn;\n\n\treaper = find_new_reaper(father, reaper);\n\tlist_for_each_entry(p, &father->children, sibling) {\n\t\tfor_each_thread(p, t) {\n\t\t\tRCU_INIT_POINTER(t->real_parent, reaper);\n\t\t\tBUG_ON((!t->ptrace) != (rcu_access_pointer(t->parent) == father));\n\t\t\tif (likely(!t->ptrace))\n\t\t\t\tt->parent = t->real_parent;\n\t\t\tif (t->pdeath_signal)\n\t\t\t\tgroup_send_sig_info(t->pdeath_signal,\n\t\t\t\t\t\t    SEND_SIG_NOINFO, t,\n\t\t\t\t\t\t    PIDTYPE_TGID);\n\t\t}\n\t\t/*\n\t\t * If this is a threaded reparent there is no need to\n\t\t * notify anyone anything has happened.\n\t\t */\n\t\tif (!same_thread_group(reaper, father))\n\t\t\treparent_leader(father, p, dead);\n\t}\n\tlist_splice_tail_init(&father->children, &reaper->children);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&father->children",
            "&reaper->children"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reparent_leader",
          "args": [
            "father",
            "p",
            "dead"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "reparent_leader",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "600-619",
          "snippet": "static void reparent_leader(struct task_struct *father, struct task_struct *p,\n\t\t\t\tstruct list_head *dead)\n{\n\tif (unlikely(p->exit_state == EXIT_DEAD))\n\t\treturn;\n\n\t/* We don't want people slaying init. */\n\tp->exit_signal = SIGCHLD;\n\n\t/* If it has exited notify the new parent about this child's death. */\n\tif (!p->ptrace &&\n\t    p->exit_state == EXIT_ZOMBIE && thread_group_empty(p)) {\n\t\tif (do_notify_parent(p, p->exit_signal)) {\n\t\t\tp->exit_state = EXIT_DEAD;\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t\t}\n\t}\n\n\tkill_orphaned_pgrp(p, father);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void reparent_leader(struct task_struct *father, struct task_struct *p,\n\t\t\t\tstruct list_head *dead)\n{\n\tif (unlikely(p->exit_state == EXIT_DEAD))\n\t\treturn;\n\n\t/* We don't want people slaying init. */\n\tp->exit_signal = SIGCHLD;\n\n\t/* If it has exited notify the new parent about this child's death. */\n\tif (!p->ptrace &&\n\t    p->exit_state == EXIT_ZOMBIE && thread_group_empty(p)) {\n\t\tif (do_notify_parent(p, p->exit_signal)) {\n\t\t\tp->exit_state = EXIT_DEAD;\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t\t}\n\t}\n\n\tkill_orphaned_pgrp(p, father);\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "reaper",
            "father"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group_send_sig_info",
          "args": [
            "t->pdeath_signal",
            "SEND_SIG_NOINFO",
            "t",
            "PIDTYPE_TGID"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "group_send_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1434-1447",
          "snippet": "int group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!t->ptrace"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(!t->ptrace) != (rcu_access_pointer(t->parent) == father)"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "t->parent"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "t->real_parent",
            "reaper"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&father->children",
            "sibling"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_new_reaper",
          "args": [
            "father",
            "reaper"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "find_new_reaper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "562-595",
          "snippet": "static struct task_struct *find_new_reaper(struct task_struct *father,\n\t\t\t\t\t   struct task_struct *child_reaper)\n{\n\tstruct task_struct *thread, *reaper;\n\n\tthread = find_alive_thread(father);\n\tif (thread)\n\t\treturn thread;\n\n\tif (father->signal->has_child_subreaper) {\n\t\tunsigned int ns_level = task_pid(father)->level;\n\t\t/*\n\t\t * Find the first ->is_child_subreaper ancestor in our pid_ns.\n\t\t * We can't check reaper != child_reaper to ensure we do not\n\t\t * cross the namespaces, the exiting parent could be injected\n\t\t * by setns() + fork().\n\t\t * We check pid->level, this is slightly more efficient than\n\t\t * task_active_pid_ns(reaper) != task_active_pid_ns(father).\n\t\t */\n\t\tfor (reaper = father->real_parent;\n\t\t     task_pid(reaper)->level == ns_level;\n\t\t     reaper = reaper->real_parent) {\n\t\t\tif (reaper == &init_task)\n\t\t\t\tbreak;\n\t\t\tif (!reaper->signal->is_child_subreaper)\n\t\t\t\tcontinue;\n\t\t\tthread = find_alive_thread(reaper);\n\t\t\tif (thread)\n\t\t\t\treturn thread;\n\t\t}\n\t}\n\n\treturn child_reaper;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *find_new_reaper(struct task_struct *father,\n\t\t\t\t\t   struct task_struct *child_reaper)\n{\n\tstruct task_struct *thread, *reaper;\n\n\tthread = find_alive_thread(father);\n\tif (thread)\n\t\treturn thread;\n\n\tif (father->signal->has_child_subreaper) {\n\t\tunsigned int ns_level = task_pid(father)->level;\n\t\t/*\n\t\t * Find the first ->is_child_subreaper ancestor in our pid_ns.\n\t\t * We can't check reaper != child_reaper to ensure we do not\n\t\t * cross the namespaces, the exiting parent could be injected\n\t\t * by setns() + fork().\n\t\t * We check pid->level, this is slightly more efficient than\n\t\t * task_active_pid_ns(reaper) != task_active_pid_ns(father).\n\t\t */\n\t\tfor (reaper = father->real_parent;\n\t\t     task_pid(reaper)->level == ns_level;\n\t\t     reaper = reaper->real_parent) {\n\t\t\tif (reaper == &init_task)\n\t\t\t\tbreak;\n\t\t\tif (!reaper->signal->is_child_subreaper)\n\t\t\t\tcontinue;\n\t\t\tthread = find_alive_thread(reaper);\n\t\t\tif (thread)\n\t\t\t\treturn thread;\n\t\t}\n\t}\n\n\treturn child_reaper;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&father->children"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_child_reaper",
          "args": [
            "father",
            "dead"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "find_child_reaper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "524-553",
          "snippet": "static struct task_struct *find_child_reaper(struct task_struct *father,\n\t\t\t\t\t\tstruct list_head *dead)\n\t__releases(&tasklist_lock)\n\t__acquires(&tasklist_lock)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(father);\n\tstruct task_struct *reaper = pid_ns->child_reaper;\n\tstruct task_struct *p, *n;\n\n\tif (likely(reaper != father))\n\t\treturn reaper;\n\n\treaper = find_alive_thread(father);\n\tif (reaper) {\n\t\tpid_ns->child_reaper = reaper;\n\t\treturn reaper;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\n\tlist_for_each_entry_safe(p, n, dead, ptrace_entry) {\n\t\tlist_del_init(&p->ptrace_entry);\n\t\trelease_task(p);\n\t}\n\n\tzap_pid_ns_processes(pid_ns);\n\twrite_lock_irq(&tasklist_lock);\n\n\treturn father;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *find_child_reaper(struct task_struct *father,\n\t\t\t\t\t\tstruct list_head *dead)\n\t__releases(&tasklist_lock)\n\t__acquires(&tasklist_lock)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(father);\n\tstruct task_struct *reaper = pid_ns->child_reaper;\n\tstruct task_struct *p, *n;\n\n\tif (likely(reaper != father))\n\t\treturn reaper;\n\n\treaper = find_alive_thread(father);\n\tif (reaper) {\n\t\tpid_ns->child_reaper = reaper;\n\t\treturn reaper;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\n\tlist_for_each_entry_safe(p, n, dead, ptrace_entry) {\n\t\tlist_del_init(&p->ptrace_entry);\n\t\trelease_task(p);\n\t}\n\n\tzap_pid_ns_processes(pid_ns);\n\twrite_lock_irq(&tasklist_lock);\n\n\treturn father;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit_ptrace",
          "args": [
            "father",
            "dead"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "exit_ptrace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ptrace.c",
          "lines": "589-600",
          "snippet": "void exit_ptrace(struct task_struct *tracer, struct list_head *dead)\n{\n\tstruct task_struct *p, *n;\n\n\tlist_for_each_entry_safe(p, n, &tracer->ptraced, ptrace_entry) {\n\t\tif (unlikely(p->ptrace & PT_EXITKILL))\n\t\t\tsend_sig_info(SIGKILL, SEND_SIG_PRIV, p);\n\n\t\tif (__ptrace_detach(tracer, p))\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t}\n}",
          "includes": [
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <linux/minmax.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/regset.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/uio.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <linux/minmax.h>\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nvoid exit_ptrace(struct task_struct *tracer, struct list_head *dead)\n{\n\tstruct task_struct *p, *n;\n\n\tlist_for_each_entry_safe(p, n, &tracer->ptraced, ptrace_entry) {\n\t\tif (unlikely(p->ptrace & PT_EXITKILL))\n\t\t\tsend_sig_info(SIGKILL, SEND_SIG_PRIV, p);\n\n\t\tif (__ptrace_detach(tracer, p))\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!list_empty(&father->ptraced)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void forget_original_parent(struct task_struct *father,\n\t\t\t\t\tstruct list_head *dead)\n{\n\tstruct task_struct *p, *t, *reaper;\n\n\tif (unlikely(!list_empty(&father->ptraced)))\n\t\texit_ptrace(father, dead);\n\n\t/* Can drop and reacquire tasklist_lock */\n\treaper = find_child_reaper(father, dead);\n\tif (list_empty(&father->children))\n\t\treturn;\n\n\treaper = find_new_reaper(father, reaper);\n\tlist_for_each_entry(p, &father->children, sibling) {\n\t\tfor_each_thread(p, t) {\n\t\t\tRCU_INIT_POINTER(t->real_parent, reaper);\n\t\t\tBUG_ON((!t->ptrace) != (rcu_access_pointer(t->parent) == father));\n\t\t\tif (likely(!t->ptrace))\n\t\t\t\tt->parent = t->real_parent;\n\t\t\tif (t->pdeath_signal)\n\t\t\t\tgroup_send_sig_info(t->pdeath_signal,\n\t\t\t\t\t\t    SEND_SIG_NOINFO, t,\n\t\t\t\t\t\t    PIDTYPE_TGID);\n\t\t}\n\t\t/*\n\t\t * If this is a threaded reparent there is no need to\n\t\t * notify anyone anything has happened.\n\t\t */\n\t\tif (!same_thread_group(reaper, father))\n\t\t\treparent_leader(father, p, dead);\n\t}\n\tlist_splice_tail_init(&father->children, &reaper->children);\n}"
  },
  {
    "function_name": "reparent_leader",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "600-619",
    "snippet": "static void reparent_leader(struct task_struct *father, struct task_struct *p,\n\t\t\t\tstruct list_head *dead)\n{\n\tif (unlikely(p->exit_state == EXIT_DEAD))\n\t\treturn;\n\n\t/* We don't want people slaying init. */\n\tp->exit_signal = SIGCHLD;\n\n\t/* If it has exited notify the new parent about this child's death. */\n\tif (!p->ptrace &&\n\t    p->exit_state == EXIT_ZOMBIE && thread_group_empty(p)) {\n\t\tif (do_notify_parent(p, p->exit_signal)) {\n\t\t\tp->exit_state = EXIT_DEAD;\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t\t}\n\t}\n\n\tkill_orphaned_pgrp(p, father);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_orphaned_pgrp",
          "args": [
            "p",
            "father"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "kill_orphaned_pgrp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "318-342",
          "snippet": "static void\nkill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)\n{\n\tstruct pid *pgrp = task_pgrp(tsk);\n\tstruct task_struct *ignored_task = tsk;\n\n\tif (!parent)\n\t\t/* exit: our father is in a different pgrp than\n\t\t * we are and we were the only connection outside.\n\t\t */\n\t\tparent = tsk->real_parent;\n\telse\n\t\t/* reparent: our child is in a different pgrp than\n\t\t * we are, and it was the only connection outside.\n\t\t */\n\t\tignored_task = NULL;\n\n\tif (task_pgrp(parent) != pgrp &&\n\t    task_session(parent) == task_session(tsk) &&\n\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&\n\t    has_stopped_jobs(pgrp)) {\n\t\t__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);\n\t\t__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);\n\t}\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void\nkill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)\n{\n\tstruct pid *pgrp = task_pgrp(tsk);\n\tstruct task_struct *ignored_task = tsk;\n\n\tif (!parent)\n\t\t/* exit: our father is in a different pgrp than\n\t\t * we are and we were the only connection outside.\n\t\t */\n\t\tparent = tsk->real_parent;\n\telse\n\t\t/* reparent: our child is in a different pgrp than\n\t\t * we are, and it was the only connection outside.\n\t\t */\n\t\tignored_task = NULL;\n\n\tif (task_pgrp(parent) != pgrp &&\n\t    task_session(parent) == task_session(tsk) &&\n\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&\n\t    has_stopped_jobs(pgrp)) {\n\t\t__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);\n\t\t__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&p->ptrace_entry",
            "dead"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_notify_parent",
          "args": [
            "p",
            "p->exit_signal"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2014-2110",
          "snippet": "bool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\t/* Wake up all pidfd waiters */\n\tdo_notify_pidfd(tsk);\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != READ_ONCE(tsk->parent->self_exec_id))\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\t/*\n\t * Send with __send_signal as si_pid and si_uid are in the\n\t * parent's namespaces.\n\t */\n\tif (valid_signal(sig) && sig)\n\t\t__send_signal(sig, &info, tsk->parent, PIDTYPE_TGID, false);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\t/* Wake up all pidfd waiters */\n\tdo_notify_pidfd(tsk);\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != READ_ONCE(tsk->parent->self_exec_id))\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\t/*\n\t * Send with __send_signal as si_pid and si_uid are in the\n\t * parent's namespaces.\n\t */\n\tif (valid_signal(sig) && sig)\n\t\t__send_signal(sig, &info, tsk->parent, PIDTYPE_TGID, false);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "p"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->exit_state == EXIT_DEAD"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void reparent_leader(struct task_struct *father, struct task_struct *p,\n\t\t\t\tstruct list_head *dead)\n{\n\tif (unlikely(p->exit_state == EXIT_DEAD))\n\t\treturn;\n\n\t/* We don't want people slaying init. */\n\tp->exit_signal = SIGCHLD;\n\n\t/* If it has exited notify the new parent about this child's death. */\n\tif (!p->ptrace &&\n\t    p->exit_state == EXIT_ZOMBIE && thread_group_empty(p)) {\n\t\tif (do_notify_parent(p, p->exit_signal)) {\n\t\t\tp->exit_state = EXIT_DEAD;\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t\t}\n\t}\n\n\tkill_orphaned_pgrp(p, father);\n}"
  },
  {
    "function_name": "find_new_reaper",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "562-595",
    "snippet": "static struct task_struct *find_new_reaper(struct task_struct *father,\n\t\t\t\t\t   struct task_struct *child_reaper)\n{\n\tstruct task_struct *thread, *reaper;\n\n\tthread = find_alive_thread(father);\n\tif (thread)\n\t\treturn thread;\n\n\tif (father->signal->has_child_subreaper) {\n\t\tunsigned int ns_level = task_pid(father)->level;\n\t\t/*\n\t\t * Find the first ->is_child_subreaper ancestor in our pid_ns.\n\t\t * We can't check reaper != child_reaper to ensure we do not\n\t\t * cross the namespaces, the exiting parent could be injected\n\t\t * by setns() + fork().\n\t\t * We check pid->level, this is slightly more efficient than\n\t\t * task_active_pid_ns(reaper) != task_active_pid_ns(father).\n\t\t */\n\t\tfor (reaper = father->real_parent;\n\t\t     task_pid(reaper)->level == ns_level;\n\t\t     reaper = reaper->real_parent) {\n\t\t\tif (reaper == &init_task)\n\t\t\t\tbreak;\n\t\t\tif (!reaper->signal->is_child_subreaper)\n\t\t\t\tcontinue;\n\t\t\tthread = find_alive_thread(reaper);\n\t\t\tif (thread)\n\t\t\t\treturn thread;\n\t\t}\n\t}\n\n\treturn child_reaper;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_alive_thread",
          "args": [
            "reaper"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "find_alive_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "513-522",
          "snippet": "static struct task_struct *find_alive_thread(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tif (!(t->flags & PF_EXITING))\n\t\t\treturn t;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *find_alive_thread(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tif (!(t->flags & PF_EXITING))\n\t\t\treturn t;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid",
          "args": [
            "reaper"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "init_task_pid_links",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1710-1716",
          "snippet": "static inline void init_task_pid_links(struct task_struct *task)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type)\n\t\tINIT_HLIST_NODE(&task->pid_links[type]);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic inline void init_task_pid_links(struct task_struct *task)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type)\n\t\tINIT_HLIST_NODE(&task->pid_links[type]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *find_new_reaper(struct task_struct *father,\n\t\t\t\t\t   struct task_struct *child_reaper)\n{\n\tstruct task_struct *thread, *reaper;\n\n\tthread = find_alive_thread(father);\n\tif (thread)\n\t\treturn thread;\n\n\tif (father->signal->has_child_subreaper) {\n\t\tunsigned int ns_level = task_pid(father)->level;\n\t\t/*\n\t\t * Find the first ->is_child_subreaper ancestor in our pid_ns.\n\t\t * We can't check reaper != child_reaper to ensure we do not\n\t\t * cross the namespaces, the exiting parent could be injected\n\t\t * by setns() + fork().\n\t\t * We check pid->level, this is slightly more efficient than\n\t\t * task_active_pid_ns(reaper) != task_active_pid_ns(father).\n\t\t */\n\t\tfor (reaper = father->real_parent;\n\t\t     task_pid(reaper)->level == ns_level;\n\t\t     reaper = reaper->real_parent) {\n\t\t\tif (reaper == &init_task)\n\t\t\t\tbreak;\n\t\t\tif (!reaper->signal->is_child_subreaper)\n\t\t\t\tcontinue;\n\t\t\tthread = find_alive_thread(reaper);\n\t\t\tif (thread)\n\t\t\t\treturn thread;\n\t\t}\n\t}\n\n\treturn child_reaper;\n}"
  },
  {
    "function_name": "find_child_reaper",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "524-553",
    "snippet": "static struct task_struct *find_child_reaper(struct task_struct *father,\n\t\t\t\t\t\tstruct list_head *dead)\n\t__releases(&tasklist_lock)\n\t__acquires(&tasklist_lock)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(father);\n\tstruct task_struct *reaper = pid_ns->child_reaper;\n\tstruct task_struct *p, *n;\n\n\tif (likely(reaper != father))\n\t\treturn reaper;\n\n\treaper = find_alive_thread(father);\n\tif (reaper) {\n\t\tpid_ns->child_reaper = reaper;\n\t\treturn reaper;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\n\tlist_for_each_entry_safe(p, n, dead, ptrace_entry) {\n\t\tlist_del_init(&p->ptrace_entry);\n\t\trelease_task(p);\n\t}\n\n\tzap_pid_ns_processes(pid_ns);\n\twrite_lock_irq(&tasklist_lock);\n\n\treturn father;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "324-327",
          "snippet": "void __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zap_pid_ns_processes",
          "args": [
            "pid_ns"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "zap_pid_ns_processes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid_namespace.c",
          "lines": "166-256",
          "snippet": "void zap_pid_ns_processes(struct pid_namespace *pid_ns)\n{\n\tint nr;\n\tint rc;\n\tstruct task_struct *task, *me = current;\n\tint init_pids = thread_group_leader(me) ? 1 : 2;\n\tstruct pid *pid;\n\n\t/* Don't allow any more processes into the pid namespace */\n\tdisable_pid_allocation(pid_ns);\n\n\t/*\n\t * Ignore SIGCHLD causing any terminated children to autoreap.\n\t * This speeds up the namespace shutdown, plus see the comment\n\t * below.\n\t */\n\tspin_lock_irq(&me->sighand->siglock);\n\tme->sighand->action[SIGCHLD - 1].sa.sa_handler = SIG_IGN;\n\tspin_unlock_irq(&me->sighand->siglock);\n\n\t/*\n\t * The last thread in the cgroup-init thread group is terminating.\n\t * Find remaining pid_ts in the namespace, signal and wait for them\n\t * to exit.\n\t *\n\t * Note:  This signals each threads in the namespace - even those that\n\t * \t  belong to the same thread group, To avoid this, we would have\n\t * \t  to walk the entire tasklist looking a processes in this\n\t * \t  namespace, but that could be unnecessarily expensive if the\n\t * \t  pid namespace has just a few processes. Or we need to\n\t * \t  maintain a tasklist for each pid namespace.\n\t *\n\t */\n\trcu_read_lock();\n\tread_lock(&tasklist_lock);\n\tnr = 2;\n\tidr_for_each_entry_continue(&pid_ns->idr, pid, nr) {\n\t\ttask = pid_task(pid, PIDTYPE_PID);\n\t\tif (task && !__fatal_signal_pending(task))\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, task, PIDTYPE_MAX);\n\t}\n\tread_unlock(&tasklist_lock);\n\trcu_read_unlock();\n\n\t/*\n\t * Reap the EXIT_ZOMBIE children we had before we ignored SIGCHLD.\n\t * kernel_wait4() will also block until our children traced from the\n\t * parent namespace are detached and become EXIT_DEAD.\n\t */\n\tdo {\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\t\trc = kernel_wait4(-1, NULL, __WALL, NULL);\n\t} while (rc != -ECHILD);\n\n\t/*\n\t * kernel_wait4() misses EXIT_DEAD children, and EXIT_ZOMBIE\n\t * process whose parents processes are outside of the pid\n\t * namespace.  Such processes are created with setns()+fork().\n\t *\n\t * If those EXIT_ZOMBIE processes are not reaped by their\n\t * parents before their parents exit, they will be reparented\n\t * to pid_ns->child_reaper.  Thus pidns->child_reaper needs to\n\t * stay valid until they all go away.\n\t *\n\t * The code relies on the pid_ns->child_reaper ignoring\n\t * SIGCHILD to cause those EXIT_ZOMBIE processes to be\n\t * autoreaped if reparented.\n\t *\n\t * Semantically it is also desirable to wait for EXIT_ZOMBIE\n\t * processes before allowing the child_reaper to be reaped, as\n\t * that gives the invariant that when the init process of a\n\t * pid namespace is reaped all of the processes in the pid\n\t * namespace are gone.\n\t *\n\t * Once all of the other tasks are gone from the pid_namespace\n\t * free_pid() will awaken this task.\n\t */\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (pid_ns->pid_allocated == init_pids)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tif (pid_ns->reboot)\n\t\tcurrent->signal->group_exit_code = pid_ns->reboot;\n\n\tacct_exit_ns(pid_ns);\n\treturn;\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nvoid zap_pid_ns_processes(struct pid_namespace *pid_ns)\n{\n\tint nr;\n\tint rc;\n\tstruct task_struct *task, *me = current;\n\tint init_pids = thread_group_leader(me) ? 1 : 2;\n\tstruct pid *pid;\n\n\t/* Don't allow any more processes into the pid namespace */\n\tdisable_pid_allocation(pid_ns);\n\n\t/*\n\t * Ignore SIGCHLD causing any terminated children to autoreap.\n\t * This speeds up the namespace shutdown, plus see the comment\n\t * below.\n\t */\n\tspin_lock_irq(&me->sighand->siglock);\n\tme->sighand->action[SIGCHLD - 1].sa.sa_handler = SIG_IGN;\n\tspin_unlock_irq(&me->sighand->siglock);\n\n\t/*\n\t * The last thread in the cgroup-init thread group is terminating.\n\t * Find remaining pid_ts in the namespace, signal and wait for them\n\t * to exit.\n\t *\n\t * Note:  This signals each threads in the namespace - even those that\n\t * \t  belong to the same thread group, To avoid this, we would have\n\t * \t  to walk the entire tasklist looking a processes in this\n\t * \t  namespace, but that could be unnecessarily expensive if the\n\t * \t  pid namespace has just a few processes. Or we need to\n\t * \t  maintain a tasklist for each pid namespace.\n\t *\n\t */\n\trcu_read_lock();\n\tread_lock(&tasklist_lock);\n\tnr = 2;\n\tidr_for_each_entry_continue(&pid_ns->idr, pid, nr) {\n\t\ttask = pid_task(pid, PIDTYPE_PID);\n\t\tif (task && !__fatal_signal_pending(task))\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, task, PIDTYPE_MAX);\n\t}\n\tread_unlock(&tasklist_lock);\n\trcu_read_unlock();\n\n\t/*\n\t * Reap the EXIT_ZOMBIE children we had before we ignored SIGCHLD.\n\t * kernel_wait4() will also block until our children traced from the\n\t * parent namespace are detached and become EXIT_DEAD.\n\t */\n\tdo {\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\t\trc = kernel_wait4(-1, NULL, __WALL, NULL);\n\t} while (rc != -ECHILD);\n\n\t/*\n\t * kernel_wait4() misses EXIT_DEAD children, and EXIT_ZOMBIE\n\t * process whose parents processes are outside of the pid\n\t * namespace.  Such processes are created with setns()+fork().\n\t *\n\t * If those EXIT_ZOMBIE processes are not reaped by their\n\t * parents before their parents exit, they will be reparented\n\t * to pid_ns->child_reaper.  Thus pidns->child_reaper needs to\n\t * stay valid until they all go away.\n\t *\n\t * The code relies on the pid_ns->child_reaper ignoring\n\t * SIGCHILD to cause those EXIT_ZOMBIE processes to be\n\t * autoreaped if reparented.\n\t *\n\t * Semantically it is also desirable to wait for EXIT_ZOMBIE\n\t * processes before allowing the child_reaper to be reaped, as\n\t * that gives the invariant that when the init process of a\n\t * pid namespace is reaped all of the processes in the pid\n\t * namespace are gone.\n\t *\n\t * Once all of the other tasks are gone from the pid_namespace\n\t * free_pid() will awaken this task.\n\t */\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (pid_ns->pid_allocated == init_pids)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tif (pid_ns->reboot)\n\t\tcurrent->signal->group_exit_code = pid_ns->reboot;\n\n\tacct_exit_ns(pid_ns);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_task",
          "args": [
            "p"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "release_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "184-232",
          "snippet": "void release_task(struct task_struct *p)\n{\n\tstruct task_struct *leader;\n\tstruct pid *thread_pid;\n\tint zap_leader;\nrepeat:\n\t/* don't need to get the RCU readlock here - the process is dead and\n\t * can't be modifying its own credentials. But shut RCU-lockdep up */\n\trcu_read_lock();\n\tdec_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1);\n\trcu_read_unlock();\n\n\tcgroup_release(p);\n\n\twrite_lock_irq(&tasklist_lock);\n\tptrace_release_task(p);\n\tthread_pid = get_pid(p->thread_pid);\n\t__exit_signal(p);\n\n\t/*\n\t * If we are the last non-leader member of the thread\n\t * group, and the leader is zombie, then notify the\n\t * group leader's parent process. (if it wants notification.)\n\t */\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader)\n\t\t\t&& leader->exit_state == EXIT_ZOMBIE) {\n\t\t/*\n\t\t * If we were the last child thread and the leader has\n\t\t * exited already, and the leader's parent ignores SIGCHLD,\n\t\t * then we are the one who should release the leader.\n\t\t */\n\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = EXIT_DEAD;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\tseccomp_filter_release(p);\n\tproc_flush_pid(thread_pid);\n\tput_pid(thread_pid);\n\trelease_thread(p);\n\tput_task_struct_rcu_user(p);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid release_task(struct task_struct *p)\n{\n\tstruct task_struct *leader;\n\tstruct pid *thread_pid;\n\tint zap_leader;\nrepeat:\n\t/* don't need to get the RCU readlock here - the process is dead and\n\t * can't be modifying its own credentials. But shut RCU-lockdep up */\n\trcu_read_lock();\n\tdec_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1);\n\trcu_read_unlock();\n\n\tcgroup_release(p);\n\n\twrite_lock_irq(&tasklist_lock);\n\tptrace_release_task(p);\n\tthread_pid = get_pid(p->thread_pid);\n\t__exit_signal(p);\n\n\t/*\n\t * If we are the last non-leader member of the thread\n\t * group, and the leader is zombie, then notify the\n\t * group leader's parent process. (if it wants notification.)\n\t */\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader)\n\t\t\t&& leader->exit_state == EXIT_ZOMBIE) {\n\t\t/*\n\t\t * If we were the last child thread and the leader has\n\t\t * exited already, and the leader's parent ignores SIGCHLD,\n\t\t * then we are the one who should release the leader.\n\t\t */\n\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = EXIT_DEAD;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\tseccomp_filter_release(p);\n\tproc_flush_pid(thread_pid);\n\tput_pid(thread_pid);\n\trelease_thread(p);\n\tput_task_struct_rcu_user(p);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->ptrace_entry"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "p",
            "n",
            "dead",
            "ptrace_entry"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "356-359",
          "snippet": "void __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_alive_thread",
          "args": [
            "father"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "find_alive_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "513-522",
          "snippet": "static struct task_struct *find_alive_thread(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tif (!(t->flags & PF_EXITING))\n\t\t\treturn t;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *find_alive_thread(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tif (!(t->flags & PF_EXITING))\n\t\t\treturn t;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "reaper != father"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "father"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "507-510",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&tasklist_lock"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&tasklist_lock"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *find_child_reaper(struct task_struct *father,\n\t\t\t\t\t\tstruct list_head *dead)\n\t__releases(&tasklist_lock)\n\t__acquires(&tasklist_lock)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(father);\n\tstruct task_struct *reaper = pid_ns->child_reaper;\n\tstruct task_struct *p, *n;\n\n\tif (likely(reaper != father))\n\t\treturn reaper;\n\n\treaper = find_alive_thread(father);\n\tif (reaper) {\n\t\tpid_ns->child_reaper = reaper;\n\t\treturn reaper;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\n\tlist_for_each_entry_safe(p, n, dead, ptrace_entry) {\n\t\tlist_del_init(&p->ptrace_entry);\n\t\trelease_task(p);\n\t}\n\n\tzap_pid_ns_processes(pid_ns);\n\twrite_lock_irq(&tasklist_lock);\n\n\treturn father;\n}"
  },
  {
    "function_name": "find_alive_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "513-522",
    "snippet": "static struct task_struct *find_alive_thread(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tif (!(t->flags & PF_EXITING))\n\t\t\treturn t;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct task_struct *find_alive_thread(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tif (!(t->flags & PF_EXITING))\n\t\t\treturn t;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "exit_mm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "476-511",
    "snippet": "static void exit_mm(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\texit_mm_release(current, mm);\n\tif (!mm)\n\t\treturn;\n\tsync_mm_rss(mm);\n\tmmap_read_lock(mm);\n\tmmgrab(mm);\n\tBUG_ON(mm != current->active_mm);\n\t/* more a memory barrier than a real lock */\n\ttask_lock(current);\n\t/*\n\t * When a thread stops operating on an address space, the loop\n\t * in membarrier_private_expedited() may not observe that\n\t * tsk->mm, and the loop in membarrier_global_expedited() may\n\t * not observe a MEMBARRIER_STATE_GLOBAL_EXPEDITED\n\t * rq->membarrier_state, so those would not issue an IPI.\n\t * Membarrier requires a memory barrier after accessing\n\t * user-space memory, before clearing tsk->mm or the\n\t * rq->membarrier_state.\n\t */\n\tsmp_mb__after_spinlock();\n\tlocal_irq_disable();\n\tcurrent->mm = NULL;\n\tmembarrier_update_current_mm(NULL);\n\tenter_lazy_tlb(mm, current);\n\tlocal_irq_enable();\n\ttask_unlock(current);\n\tmmap_read_unlock(mm);\n\tmm_update_next_owner(mm);\n\tmmput(mm);\n\tif (test_thread_flag(TIF_MEMDIE))\n\t\texit_oom_victim();\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit_oom_victim",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_MEMDIE"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "mmput_async",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1148-1154",
          "snippet": "void mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_update_next_owner",
          "args": [
            "mm"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "mm_update_next_owner",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "388-469",
          "snippet": "void mm_update_next_owner(struct mm_struct *mm)\n{\n\tstruct task_struct *c, *g, *p = current;\n\nretry:\n\t/*\n\t * If the exiting or execing task is not the owner, it's\n\t * someone else's problem.\n\t */\n\tif (mm->owner != p)\n\t\treturn;\n\t/*\n\t * The current owner is exiting/execing and there are no other\n\t * candidates.  Do not leave the mm pointing to a possibly\n\t * freed task structure.\n\t */\n\tif (atomic_read(&mm->mm_users) <= 1) {\n\t\tWRITE_ONCE(mm->owner, NULL);\n\t\treturn;\n\t}\n\n\tread_lock(&tasklist_lock);\n\t/*\n\t * Search in the children\n\t */\n\tlist_for_each_entry(c, &p->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search in the siblings\n\t */\n\tlist_for_each_entry(c, &p->real_parent->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search through everything else, we should not get here often.\n\t */\n\tfor_each_process(g) {\n\t\tif (g->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tfor_each_thread(g, c) {\n\t\t\tif (c->mm == mm)\n\t\t\t\tgoto assign_new_owner;\n\t\t\tif (c->mm)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\t/*\n\t * We found no owner yet mm_users > 1: this implies that we are\n\t * most likely racing with swapoff (try_to_unuse()) or /proc or\n\t * ptrace or page migration (get_task_mm()).  Mark owner as NULL.\n\t */\n\tWRITE_ONCE(mm->owner, NULL);\n\treturn;\n\nassign_new_owner:\n\tBUG_ON(c == p);\n\tget_task_struct(c);\n\t/*\n\t * The task_lock protects c->mm from changing.\n\t * We always want mm->owner->mm == mm\n\t */\n\ttask_lock(c);\n\t/*\n\t * Delay read_unlock() till we have the task_lock()\n\t * to ensure that c does not slip away underneath us\n\t */\n\tread_unlock(&tasklist_lock);\n\tif (c->mm != mm) {\n\t\ttask_unlock(c);\n\t\tput_task_struct(c);\n\t\tgoto retry;\n\t}\n\tWRITE_ONCE(mm->owner, c);\n\ttask_unlock(c);\n\tput_task_struct(c);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid mm_update_next_owner(struct mm_struct *mm)\n{\n\tstruct task_struct *c, *g, *p = current;\n\nretry:\n\t/*\n\t * If the exiting or execing task is not the owner, it's\n\t * someone else's problem.\n\t */\n\tif (mm->owner != p)\n\t\treturn;\n\t/*\n\t * The current owner is exiting/execing and there are no other\n\t * candidates.  Do not leave the mm pointing to a possibly\n\t * freed task structure.\n\t */\n\tif (atomic_read(&mm->mm_users) <= 1) {\n\t\tWRITE_ONCE(mm->owner, NULL);\n\t\treturn;\n\t}\n\n\tread_lock(&tasklist_lock);\n\t/*\n\t * Search in the children\n\t */\n\tlist_for_each_entry(c, &p->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search in the siblings\n\t */\n\tlist_for_each_entry(c, &p->real_parent->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search through everything else, we should not get here often.\n\t */\n\tfor_each_process(g) {\n\t\tif (g->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tfor_each_thread(g, c) {\n\t\t\tif (c->mm == mm)\n\t\t\t\tgoto assign_new_owner;\n\t\t\tif (c->mm)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\t/*\n\t * We found no owner yet mm_users > 1: this implies that we are\n\t * most likely racing with swapoff (try_to_unuse()) or /proc or\n\t * ptrace or page migration (get_task_mm()).  Mark owner as NULL.\n\t */\n\tWRITE_ONCE(mm->owner, NULL);\n\treturn;\n\nassign_new_owner:\n\tBUG_ON(c == p);\n\tget_task_struct(c);\n\t/*\n\t * The task_lock protects c->mm from changing.\n\t * We always want mm->owner->mm == mm\n\t */\n\ttask_lock(c);\n\t/*\n\t * Delay read_unlock() till we have the task_lock()\n\t * to ensure that c does not slip away underneath us\n\t */\n\tread_unlock(&tasklist_lock);\n\tif (c->mm != mm) {\n\t\ttask_unlock(c);\n\t\tput_task_struct(c);\n\t\tgoto retry;\n\t}\n\tWRITE_ONCE(mm->owner, c);\n\ttask_unlock(c);\n\tput_task_struct(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmap_read_unlock",
          "args": [
            "mm"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "current"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_lazy_tlb",
          "args": [
            "mm",
            "current"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "membarrier_update_current_mm",
          "args": [
            "NULL"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_update_current_mm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "232-242",
          "snippet": "void membarrier_update_current_mm(struct mm_struct *next_mm)\n{\n\tstruct rq *rq = this_rq();\n\tint membarrier_state = 0;\n\n\tif (next_mm)\n\t\tmembarrier_state = atomic_read(&next_mm->membarrier_state);\n\tif (READ_ONCE(rq->membarrier_state) == membarrier_state)\n\t\treturn;\n\tWRITE_ONCE(rq->membarrier_state, membarrier_state);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid membarrier_update_current_mm(struct mm_struct *next_mm)\n{\n\tstruct rq *rq = this_rq();\n\tint membarrier_state = 0;\n\n\tif (next_mm)\n\t\tmembarrier_state = atomic_read(&next_mm->membarrier_state);\n\tif (READ_ONCE(rq->membarrier_state) == membarrier_state)\n\t\treturn;\n\tWRITE_ONCE(rq->membarrier_state, membarrier_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_spinlock",
          "args": [],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "current"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mm != current->active_mm"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmgrab",
          "args": [
            "mm"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap_read_lock",
          "args": [
            "mm"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_mm_rss",
          "args": [
            "mm"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_mm_release",
          "args": [
            "current",
            "mm"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "exit_mm_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1414-1418",
          "snippet": "void exit_mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tfutex_exit_release(tsk);\n\tmm_release(tsk, mm);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid exit_mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tfutex_exit_release(tsk);\n\tmm_release(tsk, mm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void exit_mm(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\texit_mm_release(current, mm);\n\tif (!mm)\n\t\treturn;\n\tsync_mm_rss(mm);\n\tmmap_read_lock(mm);\n\tmmgrab(mm);\n\tBUG_ON(mm != current->active_mm);\n\t/* more a memory barrier than a real lock */\n\ttask_lock(current);\n\t/*\n\t * When a thread stops operating on an address space, the loop\n\t * in membarrier_private_expedited() may not observe that\n\t * tsk->mm, and the loop in membarrier_global_expedited() may\n\t * not observe a MEMBARRIER_STATE_GLOBAL_EXPEDITED\n\t * rq->membarrier_state, so those would not issue an IPI.\n\t * Membarrier requires a memory barrier after accessing\n\t * user-space memory, before clearing tsk->mm or the\n\t * rq->membarrier_state.\n\t */\n\tsmp_mb__after_spinlock();\n\tlocal_irq_disable();\n\tcurrent->mm = NULL;\n\tmembarrier_update_current_mm(NULL);\n\tenter_lazy_tlb(mm, current);\n\tlocal_irq_enable();\n\ttask_unlock(current);\n\tmmap_read_unlock(mm);\n\tmm_update_next_owner(mm);\n\tmmput(mm);\n\tif (test_thread_flag(TIF_MEMDIE))\n\t\texit_oom_victim();\n}"
  },
  {
    "function_name": "mm_update_next_owner",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "388-469",
    "snippet": "void mm_update_next_owner(struct mm_struct *mm)\n{\n\tstruct task_struct *c, *g, *p = current;\n\nretry:\n\t/*\n\t * If the exiting or execing task is not the owner, it's\n\t * someone else's problem.\n\t */\n\tif (mm->owner != p)\n\t\treturn;\n\t/*\n\t * The current owner is exiting/execing and there are no other\n\t * candidates.  Do not leave the mm pointing to a possibly\n\t * freed task structure.\n\t */\n\tif (atomic_read(&mm->mm_users) <= 1) {\n\t\tWRITE_ONCE(mm->owner, NULL);\n\t\treturn;\n\t}\n\n\tread_lock(&tasklist_lock);\n\t/*\n\t * Search in the children\n\t */\n\tlist_for_each_entry(c, &p->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search in the siblings\n\t */\n\tlist_for_each_entry(c, &p->real_parent->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search through everything else, we should not get here often.\n\t */\n\tfor_each_process(g) {\n\t\tif (g->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tfor_each_thread(g, c) {\n\t\t\tif (c->mm == mm)\n\t\t\t\tgoto assign_new_owner;\n\t\t\tif (c->mm)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\t/*\n\t * We found no owner yet mm_users > 1: this implies that we are\n\t * most likely racing with swapoff (try_to_unuse()) or /proc or\n\t * ptrace or page migration (get_task_mm()).  Mark owner as NULL.\n\t */\n\tWRITE_ONCE(mm->owner, NULL);\n\treturn;\n\nassign_new_owner:\n\tBUG_ON(c == p);\n\tget_task_struct(c);\n\t/*\n\t * The task_lock protects c->mm from changing.\n\t * We always want mm->owner->mm == mm\n\t */\n\ttask_lock(c);\n\t/*\n\t * Delay read_unlock() till we have the task_lock()\n\t * to ensure that c does not slip away underneath us\n\t */\n\tread_unlock(&tasklist_lock);\n\tif (c->mm != mm) {\n\t\ttask_unlock(c);\n\t\tput_task_struct(c);\n\t\tgoto retry;\n\t}\n\tWRITE_ONCE(mm->owner, c);\n\ttask_unlock(c);\n\tput_task_struct(c);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "c"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "put_task_struct_rcu_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "178-182",
          "snippet": "void put_task_struct_rcu_user(struct task_struct *task)\n{\n\tif (refcount_dec_and_test(&task->rcu_users))\n\t\tcall_rcu(&task->rcu, delayed_put_task_struct);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid put_task_struct_rcu_user(struct task_struct *task)\n{\n\tif (refcount_dec_and_test(&task->rcu_users))\n\t\tcall_rcu(&task->rcu, delayed_put_task_struct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "c"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "mm->owner",
            "c"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "c"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "c"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "c"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "c == p"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "mm->owner",
            "NULL"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "g",
            "c"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "c",
            "&p->real_parent->children",
            "sibling"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "c",
            "&p->children",
            "sibling"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "mm->owner",
            "NULL"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mm->mm_users"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid mm_update_next_owner(struct mm_struct *mm)\n{\n\tstruct task_struct *c, *g, *p = current;\n\nretry:\n\t/*\n\t * If the exiting or execing task is not the owner, it's\n\t * someone else's problem.\n\t */\n\tif (mm->owner != p)\n\t\treturn;\n\t/*\n\t * The current owner is exiting/execing and there are no other\n\t * candidates.  Do not leave the mm pointing to a possibly\n\t * freed task structure.\n\t */\n\tif (atomic_read(&mm->mm_users) <= 1) {\n\t\tWRITE_ONCE(mm->owner, NULL);\n\t\treturn;\n\t}\n\n\tread_lock(&tasklist_lock);\n\t/*\n\t * Search in the children\n\t */\n\tlist_for_each_entry(c, &p->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search in the siblings\n\t */\n\tlist_for_each_entry(c, &p->real_parent->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t/*\n\t * Search through everything else, we should not get here often.\n\t */\n\tfor_each_process(g) {\n\t\tif (g->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\t\tfor_each_thread(g, c) {\n\t\t\tif (c->mm == mm)\n\t\t\t\tgoto assign_new_owner;\n\t\t\tif (c->mm)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\t/*\n\t * We found no owner yet mm_users > 1: this implies that we are\n\t * most likely racing with swapoff (try_to_unuse()) or /proc or\n\t * ptrace or page migration (get_task_mm()).  Mark owner as NULL.\n\t */\n\tWRITE_ONCE(mm->owner, NULL);\n\treturn;\n\nassign_new_owner:\n\tBUG_ON(c == p);\n\tget_task_struct(c);\n\t/*\n\t * The task_lock protects c->mm from changing.\n\t * We always want mm->owner->mm == mm\n\t */\n\ttask_lock(c);\n\t/*\n\t * Delay read_unlock() till we have the task_lock()\n\t * to ensure that c does not slip away underneath us\n\t */\n\tread_unlock(&tasklist_lock);\n\tif (c->mm != mm) {\n\t\ttask_unlock(c);\n\t\tput_task_struct(c);\n\t\tgoto retry;\n\t}\n\tWRITE_ONCE(mm->owner, c);\n\ttask_unlock(c);\n\tput_task_struct(c);\n}"
  },
  {
    "function_name": "coredump_task_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "344-382",
    "snippet": "static void coredump_task_exit(struct task_struct *tsk)\n{\n\tstruct core_state *core_state;\n\n\t/*\n\t * Serialize with any possible pending coredump.\n\t * We must hold siglock around checking core_state\n\t * and setting PF_POSTCOREDUMP.  The core-inducing thread\n\t * will increment ->nr_threads for each thread in the\n\t * group without PF_POSTCOREDUMP set.\n\t */\n\tspin_lock_irq(&tsk->sighand->siglock);\n\ttsk->flags |= PF_POSTCOREDUMP;\n\tcore_state = tsk->signal->core_state;\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\tif (core_state) {\n\t\tstruct core_thread self;\n\n\t\tself.task = current;\n\t\tif (self.task->flags & PF_SIGNALED)\n\t\t\tself.next = xchg(&core_state->dumper.next, &self);\n\t\telse\n\t\t\tself.task = NULL;\n\t\t/*\n\t\t * Implies mb(), the result of xchg() must be visible\n\t\t * to core_state->dumper.\n\t\t */\n\t\tif (atomic_dec_and_test(&core_state->nr_threads))\n\t\t\tcomplete(&core_state->startup);\n\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tif (!self.task) /* see coredump_finish() */\n\t\t\t\tbreak;\n\t\t\tfreezable_schedule();\n\t\t}\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezable_schedule",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&core_state->startup"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&core_state->nr_threads"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&core_state->dumper.next",
            "&self"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void coredump_task_exit(struct task_struct *tsk)\n{\n\tstruct core_state *core_state;\n\n\t/*\n\t * Serialize with any possible pending coredump.\n\t * We must hold siglock around checking core_state\n\t * and setting PF_POSTCOREDUMP.  The core-inducing thread\n\t * will increment ->nr_threads for each thread in the\n\t * group without PF_POSTCOREDUMP set.\n\t */\n\tspin_lock_irq(&tsk->sighand->siglock);\n\ttsk->flags |= PF_POSTCOREDUMP;\n\tcore_state = tsk->signal->core_state;\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\tif (core_state) {\n\t\tstruct core_thread self;\n\n\t\tself.task = current;\n\t\tif (self.task->flags & PF_SIGNALED)\n\t\t\tself.next = xchg(&core_state->dumper.next, &self);\n\t\telse\n\t\t\tself.task = NULL;\n\t\t/*\n\t\t * Implies mb(), the result of xchg() must be visible\n\t\t * to core_state->dumper.\n\t\t */\n\t\tif (atomic_dec_and_test(&core_state->nr_threads))\n\t\t\tcomplete(&core_state->startup);\n\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tif (!self.task) /* see coredump_finish() */\n\t\t\t\tbreak;\n\t\t\tfreezable_schedule();\n\t\t}\n\t\t__set_current_state(TASK_RUNNING);\n\t}\n}"
  },
  {
    "function_name": "kill_orphaned_pgrp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "318-342",
    "snippet": "static void\nkill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)\n{\n\tstruct pid *pgrp = task_pgrp(tsk);\n\tstruct task_struct *ignored_task = tsk;\n\n\tif (!parent)\n\t\t/* exit: our father is in a different pgrp than\n\t\t * we are and we were the only connection outside.\n\t\t */\n\t\tparent = tsk->real_parent;\n\telse\n\t\t/* reparent: our child is in a different pgrp than\n\t\t * we are, and it was the only connection outside.\n\t\t */\n\t\tignored_task = NULL;\n\n\tif (task_pgrp(parent) != pgrp &&\n\t    task_session(parent) == task_session(tsk) &&\n\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&\n\t    has_stopped_jobs(pgrp)) {\n\t\t__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);\n\t\t__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);\n\t}\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kill_pgrp_info",
          "args": [
            "SIGCONT",
            "SEND_SIG_PRIV",
            "pgrp"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "__kill_pgrp_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1454-1467",
          "snippet": "int __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_stopped_jobs",
          "args": [
            "pgrp"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "has_stopped_jobs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "301-311",
          "snippet": "static bool has_stopped_jobs(struct pid *pgrp)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\treturn true;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic bool has_stopped_jobs(struct pid *pgrp)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\treturn true;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "will_become_orphaned_pgrp",
          "args": [
            "pgrp",
            "ignored_task"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "will_become_orphaned_pgrp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "271-288",
          "snippet": "static int will_become_orphaned_pgrp(struct pid *pgrp,\n\t\t\t\t\tstruct task_struct *ignored_task)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif ((p == ignored_task) ||\n\t\t    (p->exit_state && thread_group_empty(p)) ||\n\t\t    is_global_init(p->real_parent))\n\t\t\tcontinue;\n\n\t\tif (task_pgrp(p->real_parent) != pgrp &&\n\t\t    task_session(p->real_parent) == task_session(p))\n\t\t\treturn 0;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn 1;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int will_become_orphaned_pgrp(struct pid *pgrp,\n\t\t\t\t\tstruct task_struct *ignored_task)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif ((p == ignored_task) ||\n\t\t    (p->exit_state && thread_group_empty(p)) ||\n\t\t    is_global_init(p->real_parent))\n\t\t\tcontinue;\n\n\t\tif (task_pgrp(p->real_parent) != pgrp &&\n\t\t    task_session(p->real_parent) == task_session(p))\n\t\t\treturn 0;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_session",
          "args": [
            "tsk"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_session",
          "args": [
            "parent"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pgrp",
          "args": [
            "parent"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pgrp",
          "args": [
            "tsk"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void\nkill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)\n{\n\tstruct pid *pgrp = task_pgrp(tsk);\n\tstruct task_struct *ignored_task = tsk;\n\n\tif (!parent)\n\t\t/* exit: our father is in a different pgrp than\n\t\t * we are and we were the only connection outside.\n\t\t */\n\t\tparent = tsk->real_parent;\n\telse\n\t\t/* reparent: our child is in a different pgrp than\n\t\t * we are, and it was the only connection outside.\n\t\t */\n\t\tignored_task = NULL;\n\n\tif (task_pgrp(parent) != pgrp &&\n\t    task_session(parent) == task_session(tsk) &&\n\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&\n\t    has_stopped_jobs(pgrp)) {\n\t\t__kill_pgrp_info(SIGHUP, SEND_SIG_PRIV, pgrp);\n\t\t__kill_pgrp_info(SIGCONT, SEND_SIG_PRIV, pgrp);\n\t}\n}"
  },
  {
    "function_name": "has_stopped_jobs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "301-311",
    "snippet": "static bool has_stopped_jobs(struct pid *pgrp)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\treturn true;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn false;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_each_pid_task",
          "args": [
            "pgrp",
            "PIDTYPE_PGID",
            "p"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_pid_task",
          "args": [
            "pgrp",
            "PIDTYPE_PGID",
            "p"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic bool has_stopped_jobs(struct pid *pgrp)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif (p->signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\treturn true;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn false;\n}"
  },
  {
    "function_name": "is_current_pgrp_orphaned",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "290-299",
    "snippet": "int is_current_pgrp_orphaned(void)\n{\n\tint retval;\n\n\tread_lock(&tasklist_lock);\n\tretval = will_become_orphaned_pgrp(task_pgrp(current), NULL);\n\tread_unlock(&tasklist_lock);\n\n\treturn retval;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "will_become_orphaned_pgrp",
          "args": [
            "task_pgrp(current)",
            "NULL"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "will_become_orphaned_pgrp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "271-288",
          "snippet": "static int will_become_orphaned_pgrp(struct pid *pgrp,\n\t\t\t\t\tstruct task_struct *ignored_task)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif ((p == ignored_task) ||\n\t\t    (p->exit_state && thread_group_empty(p)) ||\n\t\t    is_global_init(p->real_parent))\n\t\t\tcontinue;\n\n\t\tif (task_pgrp(p->real_parent) != pgrp &&\n\t\t    task_session(p->real_parent) == task_session(p))\n\t\t\treturn 0;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn 1;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int will_become_orphaned_pgrp(struct pid *pgrp,\n\t\t\t\t\tstruct task_struct *ignored_task)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif ((p == ignored_task) ||\n\t\t    (p->exit_state && thread_group_empty(p)) ||\n\t\t    is_global_init(p->real_parent))\n\t\t\tcontinue;\n\n\t\tif (task_pgrp(p->real_parent) != pgrp &&\n\t\t    task_session(p->real_parent) == task_session(p))\n\t\t\treturn 0;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pgrp",
          "args": [
            "current"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint is_current_pgrp_orphaned(void)\n{\n\tint retval;\n\n\tread_lock(&tasklist_lock);\n\tretval = will_become_orphaned_pgrp(task_pgrp(current), NULL);\n\tread_unlock(&tasklist_lock);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "will_become_orphaned_pgrp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "271-288",
    "snippet": "static int will_become_orphaned_pgrp(struct pid *pgrp,\n\t\t\t\t\tstruct task_struct *ignored_task)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif ((p == ignored_task) ||\n\t\t    (p->exit_state && thread_group_empty(p)) ||\n\t\t    is_global_init(p->real_parent))\n\t\t\tcontinue;\n\n\t\tif (task_pgrp(p->real_parent) != pgrp &&\n\t\t    task_session(p->real_parent) == task_session(p))\n\t\t\treturn 0;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_each_pid_task",
          "args": [
            "pgrp",
            "PIDTYPE_PGID",
            "p"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_session",
          "args": [
            "p"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_session",
          "args": [
            "p->real_parent"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pgrp",
          "args": [
            "p->real_parent"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_global_init",
          "args": [
            "p->real_parent"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "p"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_each_pid_task",
          "args": [
            "pgrp",
            "PIDTYPE_PGID",
            "p"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int will_become_orphaned_pgrp(struct pid *pgrp,\n\t\t\t\t\tstruct task_struct *ignored_task)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tif ((p == ignored_task) ||\n\t\t    (p->exit_state && thread_group_empty(p)) ||\n\t\t    is_global_init(p->real_parent))\n\t\t\tcontinue;\n\n\t\tif (task_pgrp(p->real_parent) != pgrp &&\n\t\t    task_session(p->real_parent) == task_session(p))\n\t\t\treturn 0;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "rcuwait_wake_up",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "234-260",
    "snippet": "int rcuwait_wake_up(struct rcuwait *w)\n{\n\tint ret = 0;\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\n\t/*\n\t * Order condition vs @task, such that everything prior to the load\n\t * of @task is visible. This is the condition as to why the user called\n\t * rcuwait_wake() in the first place. Pairs with set_current_state()\n\t * barrier (A) in rcuwait_wait_event().\n\t *\n\t *    WAIT                WAKE\n\t *    [S] tsk = current\t  [S] cond = true\n\t *        MB (A)\t      MB (B)\n\t *    [L] cond\t\t  [L] tsk\n\t */\n\tsmp_mb(); /* (B) */\n\n\ttask = rcu_dereference(w->task);\n\tif (task)\n\t\tret = wake_up_process(task);\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "task"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "w->task"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint rcuwait_wake_up(struct rcuwait *w)\n{\n\tint ret = 0;\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\n\t/*\n\t * Order condition vs @task, such that everything prior to the load\n\t * of @task is visible. This is the condition as to why the user called\n\t * rcuwait_wake() in the first place. Pairs with set_current_state()\n\t * barrier (A) in rcuwait_wait_event().\n\t *\n\t *    WAIT                WAKE\n\t *    [S] tsk = current\t  [S] cond = true\n\t *        MB (A)\t      MB (B)\n\t *    [L] cond\t\t  [L] tsk\n\t */\n\tsmp_mb(); /* (B) */\n\n\ttask = rcu_dereference(w->task);\n\tif (task)\n\t\tret = wake_up_process(task);\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "release_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "184-232",
    "snippet": "void release_task(struct task_struct *p)\n{\n\tstruct task_struct *leader;\n\tstruct pid *thread_pid;\n\tint zap_leader;\nrepeat:\n\t/* don't need to get the RCU readlock here - the process is dead and\n\t * can't be modifying its own credentials. But shut RCU-lockdep up */\n\trcu_read_lock();\n\tdec_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1);\n\trcu_read_unlock();\n\n\tcgroup_release(p);\n\n\twrite_lock_irq(&tasklist_lock);\n\tptrace_release_task(p);\n\tthread_pid = get_pid(p->thread_pid);\n\t__exit_signal(p);\n\n\t/*\n\t * If we are the last non-leader member of the thread\n\t * group, and the leader is zombie, then notify the\n\t * group leader's parent process. (if it wants notification.)\n\t */\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader)\n\t\t\t&& leader->exit_state == EXIT_ZOMBIE) {\n\t\t/*\n\t\t * If we were the last child thread and the leader has\n\t\t * exited already, and the leader's parent ignores SIGCHLD,\n\t\t * then we are the one who should release the leader.\n\t\t */\n\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = EXIT_DEAD;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\tseccomp_filter_release(p);\n\tproc_flush_pid(thread_pid);\n\tput_pid(thread_pid);\n\trelease_thread(p);\n\tput_task_struct_rcu_user(p);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "zap_leader"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct_rcu_user",
          "args": [
            "p"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "put_task_struct_rcu_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "178-182",
          "snippet": "void put_task_struct_rcu_user(struct task_struct *task)\n{\n\tif (refcount_dec_and_test(&task->rcu_users))\n\t\tcall_rcu(&task->rcu, delayed_put_task_struct);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid put_task_struct_rcu_user(struct task_struct *task)\n{\n\tif (refcount_dec_and_test(&task->rcu_users))\n\t\tcall_rcu(&task->rcu, delayed_put_task_struct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_thread",
          "args": [
            "p"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "thread_pid"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "delayed_put_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "120-124",
          "snippet": "static void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_pid(struct rcu_head *rhp)\n{\n\tstruct pid *pid = container_of(rhp, struct pid, rcu);\n\tput_pid(pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_flush_pid",
          "args": [
            "thread_pid"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_filter_release",
          "args": [
            "p"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_filter_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "556-566",
          "snippet": "void seccomp_filter_release(struct task_struct *tsk)\n{\n\tstruct seccomp_filter *orig = tsk->seccomp.filter;\n\n\t/* We are effectively holding the siglock by not having any sighand. */\n\tWARN_ON(tsk->sighand != NULL);\n\n\t/* Detach task from its filter tree. */\n\ttsk->seccomp.filter = NULL;\n\t__seccomp_filter_release(orig);\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nvoid seccomp_filter_release(struct task_struct *tsk)\n{\n\tstruct seccomp_filter *orig = tsk->seccomp.filter;\n\n\t/* We are effectively holding the siglock by not having any sighand. */\n\tWARN_ON(tsk->sighand != NULL);\n\n\t/* Detach task from its filter tree. */\n\ttsk->seccomp.filter = NULL;\n\t__seccomp_filter_release(orig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "356-359",
          "snippet": "void __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_notify_parent",
          "args": [
            "leader",
            "leader->exit_signal"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2014-2110",
          "snippet": "bool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\t/* Wake up all pidfd waiters */\n\tdo_notify_pidfd(tsk);\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != READ_ONCE(tsk->parent->self_exec_id))\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\t/*\n\t * Send with __send_signal as si_pid and si_uid are in the\n\t * parent's namespaces.\n\t */\n\tif (valid_signal(sig) && sig)\n\t\t__send_signal(sig, &info, tsk->parent, PIDTYPE_TGID, false);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\t/* Wake up all pidfd waiters */\n\tdo_notify_pidfd(tsk);\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != READ_ONCE(tsk->parent->self_exec_id))\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\t/*\n\t * Send with __send_signal as si_pid and si_uid are in the\n\t * parent's namespaces.\n\t */\n\tif (valid_signal(sig) && sig)\n\t\t__send_signal(sig, &info, tsk->parent, PIDTYPE_TGID, false);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "leader"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__exit_signal",
          "args": [
            "p"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "__exit_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "93-166",
          "snippet": "static void __exit_signal(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tbool group_dead = thread_group_leader(tsk);\n\tstruct sighand_struct *sighand;\n\tstruct tty_struct *tty;\n\tu64 utime, stime;\n\n\tsighand = rcu_dereference_check(tsk->sighand,\n\t\t\t\t\tlockdep_tasklist_lock_is_held());\n\tspin_lock(&sighand->siglock);\n\n#ifdef CONFIG_POSIX_TIMERS\n\tposix_cpu_timers_exit(tsk);\n\tif (group_dead)\n\t\tposix_cpu_timers_exit_group(tsk);\n#endif\n\n\tif (group_dead) {\n\t\ttty = sig->tty;\n\t\tsig->tty = NULL;\n\t} else {\n\t\t/*\n\t\t * If there is any task waiting for the group exit\n\t\t * then notify it:\n\t\t */\n\t\tif (sig->notify_count > 0 && !--sig->notify_count)\n\t\t\twake_up_process(sig->group_exec_task);\n\n\t\tif (tsk == sig->curr_target)\n\t\t\tsig->curr_target = next_thread(tsk);\n\t}\n\n\tadd_device_randomness((const void*) &tsk->se.sum_exec_runtime,\n\t\t\t      sizeof(unsigned long long));\n\n\t/*\n\t * Accumulate here the counters for all threads as they die. We could\n\t * skip the group leader because it is the last user of signal_struct,\n\t * but we want to avoid the race with thread_group_cputime() which can\n\t * see the empty ->thread_head list.\n\t */\n\ttask_cputime(tsk, &utime, &stime);\n\twrite_seqlock(&sig->stats_lock);\n\tsig->utime += utime;\n\tsig->stime += stime;\n\tsig->gtime += task_gtime(tsk);\n\tsig->min_flt += tsk->min_flt;\n\tsig->maj_flt += tsk->maj_flt;\n\tsig->nvcsw += tsk->nvcsw;\n\tsig->nivcsw += tsk->nivcsw;\n\tsig->inblock += task_io_get_inblock(tsk);\n\tsig->oublock += task_io_get_oublock(tsk);\n\ttask_io_accounting_add(&sig->ioac, &tsk->ioac);\n\tsig->sum_sched_runtime += tsk->se.sum_exec_runtime;\n\tsig->nr_threads--;\n\t__unhash_process(tsk, group_dead);\n\twrite_sequnlock(&sig->stats_lock);\n\n\t/*\n\t * Do this under ->siglock, we can race with another thread\n\t * doing sigqueue_free() if we have SIGQUEUE_PREALLOC signals.\n\t */\n\tflush_sigqueue(&tsk->pending);\n\ttsk->sighand = NULL;\n\tspin_unlock(&sighand->siglock);\n\n\t__cleanup_sighand(sighand);\n\tclear_tsk_thread_flag(tsk, TIF_SIGPENDING);\n\tif (group_dead) {\n\t\tflush_sigqueue(&sig->shared_pending);\n\t\ttty_kref_put(tty);\n\t}\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __exit_signal(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tbool group_dead = thread_group_leader(tsk);\n\tstruct sighand_struct *sighand;\n\tstruct tty_struct *tty;\n\tu64 utime, stime;\n\n\tsighand = rcu_dereference_check(tsk->sighand,\n\t\t\t\t\tlockdep_tasklist_lock_is_held());\n\tspin_lock(&sighand->siglock);\n\n#ifdef CONFIG_POSIX_TIMERS\n\tposix_cpu_timers_exit(tsk);\n\tif (group_dead)\n\t\tposix_cpu_timers_exit_group(tsk);\n#endif\n\n\tif (group_dead) {\n\t\ttty = sig->tty;\n\t\tsig->tty = NULL;\n\t} else {\n\t\t/*\n\t\t * If there is any task waiting for the group exit\n\t\t * then notify it:\n\t\t */\n\t\tif (sig->notify_count > 0 && !--sig->notify_count)\n\t\t\twake_up_process(sig->group_exec_task);\n\n\t\tif (tsk == sig->curr_target)\n\t\t\tsig->curr_target = next_thread(tsk);\n\t}\n\n\tadd_device_randomness((const void*) &tsk->se.sum_exec_runtime,\n\t\t\t      sizeof(unsigned long long));\n\n\t/*\n\t * Accumulate here the counters for all threads as they die. We could\n\t * skip the group leader because it is the last user of signal_struct,\n\t * but we want to avoid the race with thread_group_cputime() which can\n\t * see the empty ->thread_head list.\n\t */\n\ttask_cputime(tsk, &utime, &stime);\n\twrite_seqlock(&sig->stats_lock);\n\tsig->utime += utime;\n\tsig->stime += stime;\n\tsig->gtime += task_gtime(tsk);\n\tsig->min_flt += tsk->min_flt;\n\tsig->maj_flt += tsk->maj_flt;\n\tsig->nvcsw += tsk->nvcsw;\n\tsig->nivcsw += tsk->nivcsw;\n\tsig->inblock += task_io_get_inblock(tsk);\n\tsig->oublock += task_io_get_oublock(tsk);\n\ttask_io_accounting_add(&sig->ioac, &tsk->ioac);\n\tsig->sum_sched_runtime += tsk->se.sum_exec_runtime;\n\tsig->nr_threads--;\n\t__unhash_process(tsk, group_dead);\n\twrite_sequnlock(&sig->stats_lock);\n\n\t/*\n\t * Do this under ->siglock, we can race with another thread\n\t * doing sigqueue_free() if we have SIGQUEUE_PREALLOC signals.\n\t */\n\tflush_sigqueue(&tsk->pending);\n\ttsk->sighand = NULL;\n\tspin_unlock(&sighand->siglock);\n\n\t__cleanup_sighand(sighand);\n\tclear_tsk_thread_flag(tsk, TIF_SIGPENDING);\n\tif (group_dead) {\n\t\tflush_sigqueue(&sig->shared_pending);\n\t\ttty_kref_put(tty);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pid",
          "args": [
            "p->thread_pid"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "460-469",
          "snippet": "struct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_get_pid(pid_t nr)\n{\n\tstruct pid *pid;\n\n\trcu_read_lock();\n\tpid = get_pid(find_vpid(nr));\n\trcu_read_unlock();\n\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_release_task",
          "args": [
            "p"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "324-327",
          "snippet": "void __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_release",
          "args": [
            "p"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "6412-6425",
          "snippet": "void cgroup_release(struct task_struct *task)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tdo_each_subsys_mask(ss, ssid, have_release_callback) {\n\t\tss->release(task);\n\t} while_each_subsys_mask();\n\n\tspin_lock_irq(&css_set_lock);\n\tcss_set_skip_task_iters(task_css_set(task), task);\n\tlist_del_init(&task->cg_list);\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u16 have_release_callback",
            "static void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic u16 have_release_callback;\nstatic void css_task_iter_skip(struct css_task_iter *it,\n\t\t\t       struct task_struct *task);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\n\nvoid cgroup_release(struct task_struct *task)\n{\n\tstruct cgroup_subsys *ss;\n\tint ssid;\n\n\tdo_each_subsys_mask(ss, ssid, have_release_callback) {\n\t\tss->release(task);\n\t} while_each_subsys_mask();\n\n\tspin_lock_irq(&css_set_lock);\n\tcss_set_skip_task_iters(task_css_set(task), task);\n\tlist_del_init(&task->cg_list);\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_rlimit_ucounts",
          "args": [
            "task_ucounts(p)",
            "UCOUNT_RLIMIT_NPROC",
            "1"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "dec_rlimit_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "281-292",
          "snippet": "bool dec_rlimit_ucounts(struct ucounts *ucounts, enum ucount_type type, long v)\n{\n\tstruct ucounts *iter;\n\tlong new = -1; /* Silence compiler warning */\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong dec = atomic_long_sub_return(v, &iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t\tif (iter == ucounts)\n\t\t\tnew = dec;\n\t}\n\treturn (new == 0);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nbool dec_rlimit_ucounts(struct ucounts *ucounts, enum ucount_type type, long v)\n{\n\tstruct ucounts *iter;\n\tlong new = -1; /* Silence compiler warning */\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong dec = atomic_long_sub_return(v, &iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t\tif (iter == ucounts)\n\t\t\tnew = dec;\n\t}\n\treturn (new == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_ucounts",
          "args": [
            "p"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid release_task(struct task_struct *p)\n{\n\tstruct task_struct *leader;\n\tstruct pid *thread_pid;\n\tint zap_leader;\nrepeat:\n\t/* don't need to get the RCU readlock here - the process is dead and\n\t * can't be modifying its own credentials. But shut RCU-lockdep up */\n\trcu_read_lock();\n\tdec_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1);\n\trcu_read_unlock();\n\n\tcgroup_release(p);\n\n\twrite_lock_irq(&tasklist_lock);\n\tptrace_release_task(p);\n\tthread_pid = get_pid(p->thread_pid);\n\t__exit_signal(p);\n\n\t/*\n\t * If we are the last non-leader member of the thread\n\t * group, and the leader is zombie, then notify the\n\t * group leader's parent process. (if it wants notification.)\n\t */\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader)\n\t\t\t&& leader->exit_state == EXIT_ZOMBIE) {\n\t\t/*\n\t\t * If we were the last child thread and the leader has\n\t\t * exited already, and the leader's parent ignores SIGCHLD,\n\t\t * then we are the one who should release the leader.\n\t\t */\n\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = EXIT_DEAD;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\tseccomp_filter_release(p);\n\tproc_flush_pid(thread_pid);\n\tput_pid(thread_pid);\n\trelease_thread(p);\n\tput_task_struct_rcu_user(p);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}"
  },
  {
    "function_name": "put_task_struct_rcu_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "178-182",
    "snippet": "void put_task_struct_rcu_user(struct task_struct *task)\n{\n\tif (refcount_dec_and_test(&task->rcu_users))\n\t\tcall_rcu(&task->rcu, delayed_put_task_struct);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&task->rcu",
            "delayed_put_task_struct"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&task->rcu_users"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid put_task_struct_rcu_user(struct task_struct *task)\n{\n\tif (refcount_dec_and_test(&task->rcu_users))\n\t\tcall_rcu(&task->rcu, delayed_put_task_struct);\n}"
  },
  {
    "function_name": "delayed_put_task_struct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "168-176",
    "snippet": "static void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tkprobe_flush_task(tsk);\n\tperf_event_delayed_put(tsk);\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "tsk"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "put_task_struct_rcu_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "178-182",
          "snippet": "void put_task_struct_rcu_user(struct task_struct *task)\n{\n\tif (refcount_dec_and_test(&task->rcu_users))\n\t\tcall_rcu(&task->rcu, delayed_put_task_struct);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid put_task_struct_rcu_user(struct task_struct *task)\n{\n\tif (refcount_dec_and_test(&task->rcu_users))\n\t\tcall_rcu(&task->rcu, delayed_put_task_struct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_sched_process_free",
          "args": [
            "tsk"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_delayed_put",
          "args": [
            "tsk"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_delayed_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "12890-12896",
          "snippet": "void perf_event_delayed_put(struct task_struct *task)\n{\n\tint ctxn;\n\n\tfor_each_task_context_nr(ctxn)\n\t\tWARN_ON_ONCE(task->perf_event_ctxp[ctxn]);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);",
            "static __must_check struct",
            "static void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);\nstatic __must_check struct;\nstatic void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);\n\nvoid perf_event_delayed_put(struct task_struct *task)\n{\n\tint ctxn;\n\n\tfor_each_task_context_nr(ctxn)\n\t\tWARN_ON_ONCE(task->perf_event_ctxp[ctxn]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_flush_task",
          "args": [
            "tsk"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_flush_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1287-1307",
          "snippet": "void kprobe_flush_task(struct task_struct *tk)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct llist_node *node;\n\n\t/* Early boot, not yet initialized. */\n\tif (unlikely(!kprobes_initialized))\n\t\treturn;\n\n\tkprobe_busy_begin();\n\n\tnode = __llist_del_all(&tk->kretprobe_instances);\n\twhile (node) {\n\t\tri = container_of(node, struct kretprobe_instance, llist);\n\t\tnode = node->next;\n\n\t\trecycle_rp_inst(ri);\n\t}\n\n\tkprobe_busy_end();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kprobes_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int kprobes_initialized;\n\nvoid kprobe_flush_task(struct task_struct *tk)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct llist_node *node;\n\n\t/* Early boot, not yet initialized. */\n\tif (unlikely(!kprobes_initialized))\n\t\treturn;\n\n\tkprobe_busy_begin();\n\n\tnode = __llist_del_all(&tk->kretprobe_instances);\n\twhile (node) {\n\t\tri = container_of(node, struct kretprobe_instance, llist);\n\t\tnode = node->next;\n\n\t\trecycle_rp_inst(ri);\n\t}\n\n\tkprobe_busy_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rhp",
            "structtask_struct",
            "rcu"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tkprobe_flush_task(tsk);\n\tperf_event_delayed_put(tsk);\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}"
  },
  {
    "function_name": "__exit_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "93-166",
    "snippet": "static void __exit_signal(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tbool group_dead = thread_group_leader(tsk);\n\tstruct sighand_struct *sighand;\n\tstruct tty_struct *tty;\n\tu64 utime, stime;\n\n\tsighand = rcu_dereference_check(tsk->sighand,\n\t\t\t\t\tlockdep_tasklist_lock_is_held());\n\tspin_lock(&sighand->siglock);\n\n#ifdef CONFIG_POSIX_TIMERS\n\tposix_cpu_timers_exit(tsk);\n\tif (group_dead)\n\t\tposix_cpu_timers_exit_group(tsk);\n#endif\n\n\tif (group_dead) {\n\t\ttty = sig->tty;\n\t\tsig->tty = NULL;\n\t} else {\n\t\t/*\n\t\t * If there is any task waiting for the group exit\n\t\t * then notify it:\n\t\t */\n\t\tif (sig->notify_count > 0 && !--sig->notify_count)\n\t\t\twake_up_process(sig->group_exec_task);\n\n\t\tif (tsk == sig->curr_target)\n\t\t\tsig->curr_target = next_thread(tsk);\n\t}\n\n\tadd_device_randomness((const void*) &tsk->se.sum_exec_runtime,\n\t\t\t      sizeof(unsigned long long));\n\n\t/*\n\t * Accumulate here the counters for all threads as they die. We could\n\t * skip the group leader because it is the last user of signal_struct,\n\t * but we want to avoid the race with thread_group_cputime() which can\n\t * see the empty ->thread_head list.\n\t */\n\ttask_cputime(tsk, &utime, &stime);\n\twrite_seqlock(&sig->stats_lock);\n\tsig->utime += utime;\n\tsig->stime += stime;\n\tsig->gtime += task_gtime(tsk);\n\tsig->min_flt += tsk->min_flt;\n\tsig->maj_flt += tsk->maj_flt;\n\tsig->nvcsw += tsk->nvcsw;\n\tsig->nivcsw += tsk->nivcsw;\n\tsig->inblock += task_io_get_inblock(tsk);\n\tsig->oublock += task_io_get_oublock(tsk);\n\ttask_io_accounting_add(&sig->ioac, &tsk->ioac);\n\tsig->sum_sched_runtime += tsk->se.sum_exec_runtime;\n\tsig->nr_threads--;\n\t__unhash_process(tsk, group_dead);\n\twrite_sequnlock(&sig->stats_lock);\n\n\t/*\n\t * Do this under ->siglock, we can race with another thread\n\t * doing sigqueue_free() if we have SIGQUEUE_PREALLOC signals.\n\t */\n\tflush_sigqueue(&tsk->pending);\n\ttsk->sighand = NULL;\n\tspin_unlock(&sighand->siglock);\n\n\t__cleanup_sighand(sighand);\n\tclear_tsk_thread_flag(tsk, TIF_SIGPENDING);\n\tif (group_dead) {\n\t\tflush_sigqueue(&sig->shared_pending);\n\t\ttty_kref_put(tty);\n\t}\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tty_kref_put",
          "args": [
            "tty"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_sigqueue",
          "args": [
            "&sig->shared_pending"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "flush_sigqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "461-471",
          "snippet": "void flush_sigqueue(struct sigpending *queue)\n{\n\tstruct sigqueue *q;\n\n\tsigemptyset(&queue->signal);\n\twhile (!list_empty(&queue->list)) {\n\t\tq = list_entry(queue->list.next, struct sigqueue , list);\n\t\tlist_del_init(&q->list);\n\t\t__sigqueue_free(q);\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid flush_sigqueue(struct sigpending *queue)\n{\n\tstruct sigqueue *q;\n\n\tsigemptyset(&queue->signal);\n\twhile (!list_empty(&queue->list)) {\n\t\tq = list_entry(queue->list.next, struct sigqueue , list);\n\t\tlist_del_init(&q->list);\n\t\t__sigqueue_free(q);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "tsk",
            "TIF_SIGPENDING"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cleanup_sighand",
          "args": [
            "sighand"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "__cleanup_sighand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1585-1595",
          "snippet": "void __cleanup_sighand(struct sighand_struct *sighand)\n{\n\tif (refcount_dec_and_test(&sighand->count)) {\n\t\tsignalfd_cleanup(sighand);\n\t\t/*\n\t\t * sighand_cachep is SLAB_TYPESAFE_BY_RCU so we can free it\n\t\t * without an RCU grace period, see __lock_task_sighand().\n\t\t */\n\t\tkmem_cache_free(sighand_cachep, sighand);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *sighand_cachep;",
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstruct kmem_cache *sighand_cachep;\nstatic __latent_entropy struct;\n\nvoid __cleanup_sighand(struct sighand_struct *sighand)\n{\n\tif (refcount_dec_and_test(&sighand->count)) {\n\t\tsignalfd_cleanup(sighand);\n\t\t/*\n\t\t * sighand_cachep is SLAB_TYPESAFE_BY_RCU so we can free it\n\t\t * without an RCU grace period, see __lock_task_sighand().\n\t\t */\n\t\tkmem_cache_free(sighand_cachep, sighand);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sighand->siglock"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_sequnlock",
          "args": [
            "&sig->stats_lock"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unhash_process",
          "args": [
            "tsk",
            "group_dead"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "__unhash_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "73-88",
          "snippet": "static void __unhash_process(struct task_struct *p, bool group_dead)\n{\n\tnr_threads--;\n\tdetach_pid(p, PIDTYPE_PID);\n\tif (group_dead) {\n\t\tdetach_pid(p, PIDTYPE_TGID);\n\t\tdetach_pid(p, PIDTYPE_PGID);\n\t\tdetach_pid(p, PIDTYPE_SID);\n\n\t\tlist_del_rcu(&p->tasks);\n\t\tlist_del_init(&p->sibling);\n\t\t__this_cpu_dec(process_counts);\n\t}\n\tlist_del_rcu(&p->thread_group);\n\tlist_del_rcu(&p->thread_node);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __unhash_process(struct task_struct *p, bool group_dead)\n{\n\tnr_threads--;\n\tdetach_pid(p, PIDTYPE_PID);\n\tif (group_dead) {\n\t\tdetach_pid(p, PIDTYPE_TGID);\n\t\tdetach_pid(p, PIDTYPE_PGID);\n\t\tdetach_pid(p, PIDTYPE_SID);\n\n\t\tlist_del_rcu(&p->tasks);\n\t\tlist_del_init(&p->sibling);\n\t\t__this_cpu_dec(process_counts);\n\t}\n\tlist_del_rcu(&p->thread_group);\n\tlist_del_rcu(&p->thread_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_io_accounting_add",
          "args": [
            "&sig->ioac",
            "&tsk->ioac"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_get_oublock",
          "args": [
            "tsk"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_get_inblock",
          "args": [
            "tsk"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_gtime",
          "args": [
            "tsk"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "task_gtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "806-825",
          "snippet": "u64 task_gtime(struct task_struct *t)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 gtime;\n\n\tif (!vtime_accounting_enabled())\n\t\treturn t->gtime;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tgtime = t->gtime;\n\t\tif (vtime->state == VTIME_GUEST)\n\t\t\tgtime += vtime->gtime + vtime_delta(vtime);\n\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn gtime;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nu64 task_gtime(struct task_struct *t)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 gtime;\n\n\tif (!vtime_accounting_enabled())\n\t\treturn t->gtime;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\tgtime = t->gtime;\n\t\tif (vtime->state == VTIME_GUEST)\n\t\t\tgtime += vtime->gtime + vtime_delta(vtime);\n\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn gtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqlock",
          "args": [
            "&sig->stats_lock"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "tsk",
            "&utime",
            "&stime"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "832-870",
          "snippet": "bool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_device_randomness",
          "args": [
            "(const void*) &tsk->se.sum_exec_runtime",
            "sizeof(unsigned long long)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_thread",
          "args": [
            "tsk"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "sig->group_exec_task"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_cpu_timers_exit_group",
          "args": [
            "tsk"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "posix_cpu_timers_exit_group",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-cpu-timers.c",
          "lines": "542-545",
          "snippet": "void posix_cpu_timers_exit_group(struct task_struct *tsk)\n{\n\tcleanup_timers(&tsk->signal->posix_cputimers);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void handle_posix_cpu_timers(struct task_struct *tsk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/task_work.h>\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void handle_posix_cpu_timers(struct task_struct *tsk);\n\nvoid posix_cpu_timers_exit_group(struct task_struct *tsk)\n{\n\tcleanup_timers(&tsk->signal->posix_cputimers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sighand->siglock"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "tsk->sighand",
            "lockdep_tasklist_lock_is_held()"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_tasklist_lock_is_held",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_tasklist_lock_is_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "144-147",
          "snippet": "int lockdep_tasklist_lock_is_held(void)\n{\n\treturn lockdep_is_held(&tasklist_lock);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\n__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);\n\nint lockdep_tasklist_lock_is_held(void)\n{\n\treturn lockdep_is_held(&tasklist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "tsk"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __exit_signal(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tbool group_dead = thread_group_leader(tsk);\n\tstruct sighand_struct *sighand;\n\tstruct tty_struct *tty;\n\tu64 utime, stime;\n\n\tsighand = rcu_dereference_check(tsk->sighand,\n\t\t\t\t\tlockdep_tasklist_lock_is_held());\n\tspin_lock(&sighand->siglock);\n\n#ifdef CONFIG_POSIX_TIMERS\n\tposix_cpu_timers_exit(tsk);\n\tif (group_dead)\n\t\tposix_cpu_timers_exit_group(tsk);\n#endif\n\n\tif (group_dead) {\n\t\ttty = sig->tty;\n\t\tsig->tty = NULL;\n\t} else {\n\t\t/*\n\t\t * If there is any task waiting for the group exit\n\t\t * then notify it:\n\t\t */\n\t\tif (sig->notify_count > 0 && !--sig->notify_count)\n\t\t\twake_up_process(sig->group_exec_task);\n\n\t\tif (tsk == sig->curr_target)\n\t\t\tsig->curr_target = next_thread(tsk);\n\t}\n\n\tadd_device_randomness((const void*) &tsk->se.sum_exec_runtime,\n\t\t\t      sizeof(unsigned long long));\n\n\t/*\n\t * Accumulate here the counters for all threads as they die. We could\n\t * skip the group leader because it is the last user of signal_struct,\n\t * but we want to avoid the race with thread_group_cputime() which can\n\t * see the empty ->thread_head list.\n\t */\n\ttask_cputime(tsk, &utime, &stime);\n\twrite_seqlock(&sig->stats_lock);\n\tsig->utime += utime;\n\tsig->stime += stime;\n\tsig->gtime += task_gtime(tsk);\n\tsig->min_flt += tsk->min_flt;\n\tsig->maj_flt += tsk->maj_flt;\n\tsig->nvcsw += tsk->nvcsw;\n\tsig->nivcsw += tsk->nivcsw;\n\tsig->inblock += task_io_get_inblock(tsk);\n\tsig->oublock += task_io_get_oublock(tsk);\n\ttask_io_accounting_add(&sig->ioac, &tsk->ioac);\n\tsig->sum_sched_runtime += tsk->se.sum_exec_runtime;\n\tsig->nr_threads--;\n\t__unhash_process(tsk, group_dead);\n\twrite_sequnlock(&sig->stats_lock);\n\n\t/*\n\t * Do this under ->siglock, we can race with another thread\n\t * doing sigqueue_free() if we have SIGQUEUE_PREALLOC signals.\n\t */\n\tflush_sigqueue(&tsk->pending);\n\ttsk->sighand = NULL;\n\tspin_unlock(&sighand->siglock);\n\n\t__cleanup_sighand(sighand);\n\tclear_tsk_thread_flag(tsk, TIF_SIGPENDING);\n\tif (group_dead) {\n\t\tflush_sigqueue(&sig->shared_pending);\n\t\ttty_kref_put(tty);\n\t}\n}"
  },
  {
    "function_name": "__unhash_process",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "73-88",
    "snippet": "static void __unhash_process(struct task_struct *p, bool group_dead)\n{\n\tnr_threads--;\n\tdetach_pid(p, PIDTYPE_PID);\n\tif (group_dead) {\n\t\tdetach_pid(p, PIDTYPE_TGID);\n\t\tdetach_pid(p, PIDTYPE_PGID);\n\t\tdetach_pid(p, PIDTYPE_SID);\n\n\t\tlist_del_rcu(&p->tasks);\n\t\tlist_del_init(&p->sibling);\n\t\t__this_cpu_dec(process_counts);\n\t}\n\tlist_del_rcu(&p->thread_group);\n\tlist_del_rcu(&p->thread_node);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&p->thread_node"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&p->thread_group"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "process_counts"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&p->sibling"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&p->tasks"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "detach_pid",
          "args": [
            "p",
            "PIDTYPE_SID"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "detach_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "356-359",
          "snippet": "void detach_pid(struct task_struct *task, enum pid_type type)\n{\n\t__change_pid(task, type, NULL);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid detach_pid(struct task_struct *task, enum pid_type type)\n{\n\t__change_pid(task, type, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void __unhash_process(struct task_struct *p, bool group_dead)\n{\n\tnr_threads--;\n\tdetach_pid(p, PIDTYPE_PID);\n\tif (group_dead) {\n\t\tdetach_pid(p, PIDTYPE_TGID);\n\t\tdetach_pid(p, PIDTYPE_PGID);\n\t\tdetach_pid(p, PIDTYPE_SID);\n\n\t\tlist_del_rcu(&p->tasks);\n\t\tlist_del_init(&p->sibling);\n\t\t__this_cpu_dec(process_counts);\n\t}\n\tlist_del_rcu(&p->thread_group);\n\tlist_del_rcu(&p->thread_node);\n}"
  },
  {
    "function_name": "exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "901-904",
    "snippet": "SYSCALL_DEFINE1(exit, int, error_code)\n{\n\tdo_exit((error_code&0xff)<<8);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE1(exit, int, error_code)\n{\n\tdo_exit((error_code&0xff)<<8);\n}"
  },
  {
    "function_name": "exit_group",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "945-950",
    "snippet": "SYSCALL_DEFINE1(exit_group, int, error_code)\n{\n\tdo_group_exit((error_code & 0xff) << 8);\n\t/* NOTREACHED */\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE1(exit_group, int, error_code)\n{\n\tdo_group_exit((error_code & 0xff) << 8);\n\t/* NOTREACHED */\n\treturn 0;\n}"
  },
  {
    "function_name": "waitid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "1624-1655",
    "snippet": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\n\tif (!user_write_access_begin(infop, sizeof(*infop)))\n\t\treturn -EFAULT;\n\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_write_access_end();\n\treturn err;\nEfault:\n\tuser_write_access_end();\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\n\tif (!user_write_access_begin(infop, sizeof(*infop)))\n\t\treturn -EFAULT;\n\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_write_access_end();\n\treturn err;\nEfault:\n\tuser_write_access_end();\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "wait4",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "1716-1727",
    "snippet": "SYSCALL_DEFINE4(wait4, pid_t, upid, int __user *, stat_addr,\n\t\tint, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tlong err = kernel_wait4(upid, stat_addr, options, ru ? &r : NULL);\n\n\tif (err > 0) {\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE4(wait4, pid_t, upid, int __user *, stat_addr,\n\t\tint, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tlong err = kernel_wait4(upid, stat_addr, options, ru ? &r : NULL);\n\n\tif (err > 0) {\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "waitpid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "1735-1738",
    "snippet": "SYSCALL_DEFINE3(waitpid, pid_t, pid, int __user *, stat_addr, int, options)\n{\n\treturn kernel_wait4(pid, stat_addr, options, NULL);\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE3(waitpid, pid_t, pid, int __user *, stat_addr, int, options)\n{\n\treturn kernel_wait4(pid, stat_addr, options, NULL);\n}"
  },
  {
    "function_name": "wait4",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "1743-1756",
    "snippet": "SYSCALL_DEFINE4(wait4,\n\tcompat_pid_t, pid,\n\tcompat_uint_t __user *, stat_addr,\n\tint, options,\n\tstruct compat_rusage __user *, ru)\n{\n\tstruct rusage r;\n\tlong err = kernel_wait4(pid, stat_addr, options, ru ? &r : NULL);\n\tif (err > 0) {\n\t\tif (ru && put_compat_rusage(&r, ru))\n\t\t\treturn -EFAULT;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE4(wait4,\n\tcompat_pid_t, pid,\n\tcompat_uint_t __user *, stat_addr,\n\tint, options,\n\tstruct compat_rusage __user *, ru)\n{\n\tstruct rusage r;\n\tlong err = kernel_wait4(pid, stat_addr, options, ru ? &r : NULL);\n\tif (err > 0) {\n\t\tif (ru && put_compat_rusage(&r, ru))\n\t\t\treturn -EFAULT;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "waitid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
    "lines": "1758-1798",
    "snippet": "SYSCALL_DEFINE5(waitid,\n\t\tint, which, compat_pid_t, pid,\n\t\tstruct compat_siginfo __user *, infop, int, options,\n\t\tstruct compat_rusage __user *, uru)\n{\n\tstruct rusage ru;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, pid, &info, options, uru ? &ru : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t\tif (uru) {\n\t\t\t/* kernel_waitid() overwrites everything in ru */\n\t\t\tif (COMPAT_USE_64BIT_TIME)\n\t\t\t\terr = copy_to_user(uru, &ru, sizeof(ru));\n\t\t\telse\n\t\t\t\terr = put_compat_rusage(&ru, uru);\n\t\t\tif (err)\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (!infop)\n\t\treturn err;\n\n\tif (!user_write_access_begin(infop, sizeof(*infop)))\n\t\treturn -EFAULT;\n\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_write_access_end();\n\treturn err;\nEfault:\n\tuser_write_access_end();\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <asm/mmu_context.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/io_uring.h>",
      "#include <linux/compat.h>",
      "#include <linux/rcuwait.h>",
      "#include <linux/random.h>",
      "#include <linux/kcov.h>",
      "#include <linux/shm.h>",
      "#include <linux/writeback.h>",
      "#include <linux/oom.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/init_task.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/task_work.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/resource.h>",
      "#include <linux/audit.h> /* for audit_free() */",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/futex.h>",
      "#include <linux/mutex.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/signal.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/kthread.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/profile.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/acct.h>",
      "#include <linux/cpu.h>",
      "#include <linux/key.h>",
      "#include <linux/iocontext.h>",
      "#include <linux/tty.h>",
      "#include <linux/personality.h>",
      "#include <linux/completion.h>",
      "#include <linux/capability.h>",
      "#include <linux/module.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/autogroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE5(waitid,\n\t\tint, which, compat_pid_t, pid,\n\t\tstruct compat_siginfo __user *, infop, int, options,\n\t\tstruct compat_rusage __user *, uru)\n{\n\tstruct rusage ru;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, pid, &info, options, uru ? &ru : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t\tif (uru) {\n\t\t\t/* kernel_waitid() overwrites everything in ru */\n\t\t\tif (COMPAT_USE_64BIT_TIME)\n\t\t\t\terr = copy_to_user(uru, &ru, sizeof(ru));\n\t\t\telse\n\t\t\t\terr = put_compat_rusage(&ru, uru);\n\t\t\tif (err)\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (!infop)\n\t\treturn err;\n\n\tif (!user_write_access_begin(infop, sizeof(*infop)))\n\t\treturn -EFAULT;\n\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_write_access_end();\n\treturn err;\nEfault:\n\tuser_write_access_end();\n\treturn -EFAULT;\n}"
  }
]