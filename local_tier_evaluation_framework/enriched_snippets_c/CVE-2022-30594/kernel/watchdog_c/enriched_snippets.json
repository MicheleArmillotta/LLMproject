[
  {
    "function_name": "lockup_detector_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "845-857",
    "snippet": "void __init lockup_detector_init(void)\n{\n\tif (tick_nohz_full_enabled())\n\t\tpr_info(\"Disabling watchdog on nohz_full cores by default\\n\");\n\n\tcpumask_copy(&watchdog_cpumask,\n\t\t     housekeeping_cpumask(HK_FLAG_TIMER));\n\n\tif (!watchdog_nmi_probe())\n\t\tnmi_watchdog_available = true;\n\tlockup_detector_setup();\n\twatchdog_sysctl_init();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cpumask watchdog_cpumask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "watchdog_sysctl_init",
          "args": [],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_sysctl_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "837-840",
          "snippet": "static void __init watchdog_sysctl_init(void)\n{\n\tregister_sysctl_init(\"kernel\", watchdog_sysctls);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void __init watchdog_sysctl_init(void)\n{\n\tregister_sysctl_init(\"kernel\", watchdog_sysctls);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockup_detector_setup",
          "args": [],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "lockup_detector_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "590-593",
          "snippet": "static inline void lockup_detector_setup(void)\n{\n\tlockup_detector_reconfigure();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic inline void lockup_detector_setup(void)\n{\n\tlockup_detector_reconfigure();\n}"
        }
      },
      {
        "call_info": {
          "callee": "watchdog_nmi_probe",
          "args": [],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_nmi_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "110-113",
          "snippet": "__init watchdog_nmi_probe(void)\n{\n\treturn hardlockup_detector_perf_init();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n__init watchdog_nmi_probe(void)\n{\n\treturn hardlockup_detector_perf_init();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "&watchdog_cpumask",
            "housekeeping_cpumask(HK_FLAG_TIMER)"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "housekeeping_cpumask",
          "args": [
            "HK_FLAG_TIMER"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/isolation.c",
          "lines": "40-46",
          "snippet": "const struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nconst struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Disabling watchdog on nohz_full cores by default\\n\""
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_enabled",
          "args": [],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstruct cpumask watchdog_cpumask;\n\nvoid __init lockup_detector_init(void)\n{\n\tif (tick_nohz_full_enabled())\n\t\tpr_info(\"Disabling watchdog on nohz_full cores by default\\n\");\n\n\tcpumask_copy(&watchdog_cpumask,\n\t\t     housekeeping_cpumask(HK_FLAG_TIMER));\n\n\tif (!watchdog_nmi_probe())\n\t\tnmi_watchdog_available = true;\n\tlockup_detector_setup();\n\twatchdog_sysctl_init();\n}"
  },
  {
    "function_name": "watchdog_sysctl_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "837-840",
    "snippet": "static void __init watchdog_sysctl_init(void)\n{\n\tregister_sysctl_init(\"kernel\", watchdog_sysctls);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_sysctl_init",
          "args": [
            "\"kernel\"",
            "watchdog_sysctls"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void __init watchdog_sysctl_init(void)\n{\n\tregister_sysctl_init(\"kernel\", watchdog_sysctls);\n}"
  },
  {
    "function_name": "proc_watchdog_cpumask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "729-742",
    "snippet": "int proc_watchdog_cpumask(struct ctl_table *table, int write,\n\t\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err;\n\n\tmutex_lock(&watchdog_mutex);\n\n\terr = proc_do_large_bitmap(table, write, buffer, lenp, ppos);\n\tif (!err && write)\n\t\tproc_watchdog_update();\n\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(watchdog_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_watchdog_update",
          "args": [],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "proc_watchdog_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "628-633",
          "snippet": "static void proc_watchdog_update(void)\n{\n\t/* Remove impossible cpus to keep sysctl output clean. */\n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\tlockup_detector_reconfigure();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask watchdog_cpumask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstruct cpumask watchdog_cpumask;\n\nstatic void proc_watchdog_update(void)\n{\n\t/* Remove impossible cpus to keep sysctl output clean. */\n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\tlockup_detector_reconfigure();\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_do_large_bitmap",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "proc_do_large_bitmap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "1615-1619",
          "snippet": "int proc_do_large_bitmap(struct ctl_table *table, int write,\n\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nint proc_do_large_bitmap(struct ctl_table *table, int write,\n\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\nint proc_watchdog_cpumask(struct ctl_table *table, int write,\n\t\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err;\n\n\tmutex_lock(&watchdog_mutex);\n\n\terr = proc_do_large_bitmap(table, write, buffer, lenp, ppos);\n\tif (!err && write)\n\t\tproc_watchdog_update();\n\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "proc_watchdog_thresh",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "706-721",
    "snippet": "int proc_watchdog_thresh(struct ctl_table *table, int write,\n\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old;\n\n\tmutex_lock(&watchdog_mutex);\n\n\told = READ_ONCE(watchdog_thresh);\n\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (!err && write && old != READ_ONCE(watchdog_thresh))\n\t\tproc_watchdog_update();\n\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(watchdog_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_watchdog_update",
          "args": [],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "proc_watchdog_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "628-633",
          "snippet": "static void proc_watchdog_update(void)\n{\n\t/* Remove impossible cpus to keep sysctl output clean. */\n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\tlockup_detector_reconfigure();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask watchdog_cpumask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstruct cpumask watchdog_cpumask;\n\nstatic void proc_watchdog_update(void)\n{\n\t/* Remove impossible cpus to keep sysctl output clean. */\n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\tlockup_detector_reconfigure();\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "watchdog_thresh"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_minmax",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "1567-1571",
          "snippet": "int proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "watchdog_thresh"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\nint proc_watchdog_thresh(struct ctl_table *table, int write,\n\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old;\n\n\tmutex_lock(&watchdog_mutex);\n\n\told = READ_ONCE(watchdog_thresh);\n\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (!err && write && old != READ_ONCE(watchdog_thresh))\n\t\tproc_watchdog_update();\n\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "proc_soft_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "696-701",
    "snippet": "int proc_soft_watchdog(struct ctl_table *table, int write,\n\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn proc_watchdog_common(SOFT_WATCHDOG_ENABLED,\n\t\t\t\t    table, write, buffer, lenp, ppos);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_watchdog_common",
          "args": [
            "SOFT_WATCHDOG_ENABLED",
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "proc_watchdog_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "647-669",
          "snippet": "static int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t/*\n\t\t * On read synchronize the userspace interface. This is a\n\t\t * racy snapshot.\n\t\t */\n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(watchdog_mutex);",
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\nunsigned long __read_mostly watchdog_enabled;\n\nstatic int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t/*\n\t\t * On read synchronize the userspace interface. This is a\n\t\t * racy snapshot.\n\t\t */\n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint proc_soft_watchdog(struct ctl_table *table, int write,\n\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn proc_watchdog_common(SOFT_WATCHDOG_ENABLED,\n\t\t\t\t    table, write, buffer, lenp, ppos);\n}"
  },
  {
    "function_name": "proc_nmi_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "684-691",
    "snippet": "int proc_nmi_watchdog(struct ctl_table *table, int write,\n\t\t      void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (!nmi_watchdog_available && write)\n\t\treturn -ENOTSUPP;\n\treturn proc_watchdog_common(NMI_WATCHDOG_ENABLED,\n\t\t\t\t    table, write, buffer, lenp, ppos);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_watchdog_common",
          "args": [
            "NMI_WATCHDOG_ENABLED",
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "proc_watchdog_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "647-669",
          "snippet": "static int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t/*\n\t\t * On read synchronize the userspace interface. This is a\n\t\t * racy snapshot.\n\t\t */\n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(watchdog_mutex);",
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\nunsigned long __read_mostly watchdog_enabled;\n\nstatic int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t/*\n\t\t * On read synchronize the userspace interface. This is a\n\t\t * racy snapshot.\n\t\t */\n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint proc_nmi_watchdog(struct ctl_table *table, int write,\n\t\t      void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (!nmi_watchdog_available && write)\n\t\treturn -ENOTSUPP;\n\treturn proc_watchdog_common(NMI_WATCHDOG_ENABLED,\n\t\t\t\t    table, write, buffer, lenp, ppos);\n}"
  },
  {
    "function_name": "proc_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "674-679",
    "snippet": "int proc_watchdog(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn proc_watchdog_common(NMI_WATCHDOG_ENABLED|SOFT_WATCHDOG_ENABLED,\n\t\t\t\t    table, write, buffer, lenp, ppos);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_watchdog_common",
          "args": [
            "NMI_WATCHDOG_ENABLED|SOFT_WATCHDOG_ENABLED",
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "proc_watchdog_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "647-669",
          "snippet": "static int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t/*\n\t\t * On read synchronize the userspace interface. This is a\n\t\t * racy snapshot.\n\t\t */\n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(watchdog_mutex);",
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\nunsigned long __read_mostly watchdog_enabled;\n\nstatic int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t/*\n\t\t * On read synchronize the userspace interface. This is a\n\t\t * racy snapshot.\n\t\t */\n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint proc_watchdog(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn proc_watchdog_common(NMI_WATCHDOG_ENABLED|SOFT_WATCHDOG_ENABLED,\n\t\t\t\t    table, write, buffer, lenp, ppos);\n}"
  },
  {
    "function_name": "proc_watchdog_common",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "647-669",
    "snippet": "static int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t/*\n\t\t * On read synchronize the userspace interface. This is a\n\t\t * racy snapshot.\n\t\t */\n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(watchdog_mutex);",
      "unsigned long __read_mostly watchdog_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_watchdog_update",
          "args": [],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "proc_watchdog_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "628-633",
          "snippet": "static void proc_watchdog_update(void)\n{\n\t/* Remove impossible cpus to keep sysctl output clean. */\n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\tlockup_detector_reconfigure();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask watchdog_cpumask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstruct cpumask watchdog_cpumask;\n\nstatic void proc_watchdog_update(void)\n{\n\t/* Remove impossible cpus to keep sysctl output clean. */\n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\tlockup_detector_reconfigure();\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*param"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_minmax",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "1567-1571",
          "snippet": "int proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*param"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\nunsigned long __read_mostly watchdog_enabled;\n\nstatic int proc_watchdog_common(int which, struct ctl_table *table, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err, old, *param = table->data;\n\n\tmutex_lock(&watchdog_mutex);\n\n\tif (!write) {\n\t\t/*\n\t\t * On read synchronize the userspace interface. This is a\n\t\t * racy snapshot.\n\t\t */\n\t\t*param = (watchdog_enabled & which) != 0;\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t} else {\n\t\told = READ_ONCE(*param);\n\t\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\t\tif (!err && old != READ_ONCE(*param))\n\t\t\tproc_watchdog_update();\n\t}\n\tmutex_unlock(&watchdog_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "proc_watchdog_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "628-633",
    "snippet": "static void proc_watchdog_update(void)\n{\n\t/* Remove impossible cpus to keep sysctl output clean. */\n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\tlockup_detector_reconfigure();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cpumask watchdog_cpumask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockup_detector_reconfigure",
          "args": [],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "lockup_detector_reconfigure",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "582-589",
          "snippet": "static void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\tlockup_detector_update_enable();\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\tlockup_detector_update_enable();\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "&watchdog_cpumask",
            "&watchdog_cpumask",
            "cpu_possible_mask"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstruct cpumask watchdog_cpumask;\n\nstatic void proc_watchdog_update(void)\n{\n\t/* Remove impossible cpus to keep sysctl output clean. */\n\tcpumask_and(&watchdog_cpumask, &watchdog_cpumask, cpu_possible_mask);\n\tlockup_detector_reconfigure();\n}"
  },
  {
    "function_name": "lockup_detector_soft_poweroff",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "620-623",
    "snippet": "void lockup_detector_soft_poweroff(void)\n{\n\twatchdog_enabled = 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long __read_mostly watchdog_enabled;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nvoid lockup_detector_soft_poweroff(void)\n{\n\twatchdog_enabled = 0;\n}"
  },
  {
    "function_name": "lockup_detector_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "607-612",
    "snippet": "void lockup_detector_cleanup(void)\n{\n\tmutex_lock(&watchdog_mutex);\n\t__lockup_detector_cleanup();\n\tmutex_unlock(&watchdog_mutex);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(watchdog_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lockup_detector_cleanup",
          "args": [],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "__lockup_detector_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "596-600",
          "snippet": "static void __lockup_detector_cleanup(void)\n{\n\tlockdep_assert_held(&watchdog_mutex);\n\thardlockup_detector_perf_cleanup();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(watchdog_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\nstatic void __lockup_detector_cleanup(void)\n{\n\tlockdep_assert_held(&watchdog_mutex);\n\thardlockup_detector_perf_cleanup();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\nvoid lockup_detector_cleanup(void)\n{\n\tmutex_lock(&watchdog_mutex);\n\t__lockup_detector_cleanup();\n\tmutex_unlock(&watchdog_mutex);\n}"
  },
  {
    "function_name": "__lockup_detector_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "596-600",
    "snippet": "static void __lockup_detector_cleanup(void)\n{\n\tlockdep_assert_held(&watchdog_mutex);\n\thardlockup_detector_perf_cleanup();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(watchdog_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hardlockup_detector_perf_cleanup",
          "args": [],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_detector_perf_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "223-239",
          "snippet": "void hardlockup_detector_perf_cleanup(void)\n{\n\tint cpu;\n\n\tfor_each_cpu(cpu, &dead_events_mask) {\n\t\tstruct perf_event *event = per_cpu(dead_event, cpu);\n\n\t\t/*\n\t\t * Required because for_each_cpu() reports  unconditionally\n\t\t * CPU0 as set on UP kernels. Sigh.\n\t\t */\n\t\tif (event)\n\t\t\tperf_event_release_kernel(event);\n\t\tper_cpu(dead_event, cpu) = NULL;\n\t}\n\tcpumask_clear(&dead_events_mask);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct perf_event *, dead_event);",
            "static struct cpumask dead_events_mask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, dead_event);\nstatic struct cpumask dead_events_mask;\n\nvoid hardlockup_detector_perf_cleanup(void)\n{\n\tint cpu;\n\n\tfor_each_cpu(cpu, &dead_events_mask) {\n\t\tstruct perf_event *event = per_cpu(dead_event, cpu);\n\n\t\t/*\n\t\t * Required because for_each_cpu() reports  unconditionally\n\t\t * CPU0 as set on UP kernels. Sigh.\n\t\t */\n\t\tif (event)\n\t\t\tperf_event_release_kernel(event);\n\t\tper_cpu(dead_event, cpu) = NULL;\n\t}\n\tcpumask_clear(&dead_events_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\nstatic void __lockup_detector_cleanup(void)\n{\n\tlockdep_assert_held(&watchdog_mutex);\n\thardlockup_detector_perf_cleanup();\n}"
  },
  {
    "function_name": "lockup_detector_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "590-593",
    "snippet": "static inline void lockup_detector_setup(void)\n{\n\tlockup_detector_reconfigure();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockup_detector_reconfigure",
          "args": [],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "lockup_detector_reconfigure",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "582-589",
          "snippet": "static void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\tlockup_detector_update_enable();\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\tlockup_detector_update_enable();\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic inline void lockup_detector_setup(void)\n{\n\tlockup_detector_reconfigure();\n}"
  },
  {
    "function_name": "lockup_detector_reconfigure",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "582-589",
    "snippet": "static void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\tlockup_detector_update_enable();\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "watchdog_nmi_start",
          "args": [],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_nmi_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "136-136",
          "snippet": "void __weak watchdog_nmi_start(void) { }",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nvoid __weak watchdog_nmi_start(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "lockup_detector_update_enable",
          "args": [],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "lockup_detector_update_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "144-153",
          "snippet": "static void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (nmi_watchdog_available && nmi_watchdog_user_enabled)\n\t\twatchdog_enabled |= NMI_WATCHDOG_ENABLED;\n\tif (soft_watchdog_user_enabled)\n\t\twatchdog_enabled |= SOFT_WATCHDOG_ENABLED;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (nmi_watchdog_available && nmi_watchdog_user_enabled)\n\t\twatchdog_enabled |= NMI_WATCHDOG_ENABLED;\n\tif (soft_watchdog_user_enabled)\n\t\twatchdog_enabled |= SOFT_WATCHDOG_ENABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "watchdog_nmi_stop",
          "args": [],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_nmi_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "123-123",
          "snippet": "void __weak watchdog_nmi_stop(void) { }",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nvoid __weak watchdog_nmi_stop(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\tlockup_detector_update_enable();\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "lockup_detector_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "563-579",
    "snippet": "static __init void lockup_detector_setup(void)\n{\n\t/*\n\t * If sysctl is off and watchdog got disabled on the command line,\n\t * nothing to do here.\n\t */\n\tlockup_detector_update_enable();\n\n\tif (!IS_ENABLED(CONFIG_SYSCTL) &&\n\t    !(watchdog_enabled && watchdog_thresh))\n\t\treturn;\n\n\tmutex_lock(&watchdog_mutex);\n\tlockup_detector_reconfigure();\n\tsoftlockup_initialized = true;\n\tmutex_unlock(&watchdog_mutex);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(watchdog_mutex);",
      "unsigned long __read_mostly watchdog_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockup_detector_reconfigure",
          "args": [],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "lockup_detector_reconfigure",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "582-589",
          "snippet": "static void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\tlockup_detector_update_enable();\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\tlockup_detector_update_enable();\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&watchdog_mutex"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SYSCTL"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockup_detector_update_enable",
          "args": [],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "lockup_detector_update_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "144-153",
          "snippet": "static void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (nmi_watchdog_available && nmi_watchdog_user_enabled)\n\t\twatchdog_enabled |= NMI_WATCHDOG_ENABLED;\n\tif (soft_watchdog_user_enabled)\n\t\twatchdog_enabled |= SOFT_WATCHDOG_ENABLED;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (nmi_watchdog_available && nmi_watchdog_user_enabled)\n\t\twatchdog_enabled |= NMI_WATCHDOG_ENABLED;\n\tif (soft_watchdog_user_enabled)\n\t\twatchdog_enabled |= SOFT_WATCHDOG_ENABLED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\nunsigned long __read_mostly watchdog_enabled;\n\nstatic __init void lockup_detector_setup(void)\n{\n\t/*\n\t * If sysctl is off and watchdog got disabled on the command line,\n\t * nothing to do here.\n\t */\n\tlockup_detector_update_enable();\n\n\tif (!IS_ENABLED(CONFIG_SYSCTL) &&\n\t    !(watchdog_enabled && watchdog_thresh))\n\t\treturn;\n\n\tmutex_lock(&watchdog_mutex);\n\tlockup_detector_reconfigure();\n\tsoftlockup_initialized = true;\n\tmutex_unlock(&watchdog_mutex);\n}"
  },
  {
    "function_name": "lockup_detector_reconfigure",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "540-558",
    "snippet": "static void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\n\tsoftlockup_stop_all();\n\tset_sample_period();\n\tlockup_detector_update_enable();\n\tif (watchdog_enabled && watchdog_thresh)\n\t\tsoftlockup_start_all();\n\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n\t/*\n\t * Must be called outside the cpus locked section to prevent\n\t * recursive locking in the perf code.\n\t */\n\t__lockup_detector_cleanup();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long __read_mostly watchdog_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__lockup_detector_cleanup",
          "args": [],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "__lockup_detector_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "596-600",
          "snippet": "static void __lockup_detector_cleanup(void)\n{\n\tlockdep_assert_held(&watchdog_mutex);\n\thardlockup_detector_perf_cleanup();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(watchdog_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\nstatic void __lockup_detector_cleanup(void)\n{\n\tlockdep_assert_held(&watchdog_mutex);\n\thardlockup_detector_perf_cleanup();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "watchdog_nmi_start",
          "args": [],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_nmi_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "136-136",
          "snippet": "void __weak watchdog_nmi_start(void) { }",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nvoid __weak watchdog_nmi_start(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "softlockup_start_all",
          "args": [],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "softlockup_start_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "517-524",
          "snippet": "static void softlockup_start_all(void)\n{\n\tint cpu;\n\n\tcpumask_copy(&watchdog_allowed_mask, &watchdog_cpumask);\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_start_fn, NULL, false);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask watchdog_cpumask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstruct cpumask watchdog_cpumask;\n\nstatic void softlockup_start_all(void)\n{\n\tint cpu;\n\n\tcpumask_copy(&watchdog_allowed_mask, &watchdog_cpumask);\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_start_fn, NULL, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockup_detector_update_enable",
          "args": [],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "lockup_detector_update_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "144-153",
          "snippet": "static void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (nmi_watchdog_available && nmi_watchdog_user_enabled)\n\t\twatchdog_enabled |= NMI_WATCHDOG_ENABLED;\n\tif (soft_watchdog_user_enabled)\n\t\twatchdog_enabled |= SOFT_WATCHDOG_ENABLED;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (nmi_watchdog_available && nmi_watchdog_user_enabled)\n\t\twatchdog_enabled |= NMI_WATCHDOG_ENABLED;\n\tif (soft_watchdog_user_enabled)\n\t\twatchdog_enabled |= SOFT_WATCHDOG_ENABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_sample_period",
          "args": [],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "set_sample_period",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "231-242",
          "snippet": "static void set_sample_period(void)\n{\n\t/*\n\t * convert watchdog_thresh from seconds to ns\n\t * the divide by 5 is to give hrtimer several chances (two\n\t * or three with the current relation between the soft\n\t * and hard thresholds) to increment before the\n\t * hardlockup detector generates a warning\n\t */\n\tsample_period = get_softlockup_thresh() * ((u64)NSEC_PER_SEC / 5);\n\twatchdog_update_hrtimer_threshold(sample_period);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void set_sample_period(void)\n{\n\t/*\n\t * convert watchdog_thresh from seconds to ns\n\t * the divide by 5 is to give hrtimer several chances (two\n\t * or three with the current relation between the soft\n\t * and hard thresholds) to increment before the\n\t * hardlockup detector generates a warning\n\t */\n\tsample_period = get_softlockup_thresh() * ((u64)NSEC_PER_SEC / 5);\n\twatchdog_update_hrtimer_threshold(sample_period);\n}"
        }
      },
      {
        "call_info": {
          "callee": "softlockup_stop_all",
          "args": [],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "softlockup_stop_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "498-509",
          "snippet": "static void softlockup_stop_all(void)\n{\n\tint cpu;\n\n\tif (!softlockup_initialized)\n\t\treturn;\n\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_stop_fn, NULL, false);\n\n\tcpumask_clear(&watchdog_allowed_mask);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void softlockup_stop_all(void)\n{\n\tint cpu;\n\n\tif (!softlockup_initialized)\n\t\treturn;\n\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_stop_fn, NULL, false);\n\n\tcpumask_clear(&watchdog_allowed_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "watchdog_nmi_stop",
          "args": [],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_nmi_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "123-123",
          "snippet": "void __weak watchdog_nmi_stop(void) { }",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nvoid __weak watchdog_nmi_stop(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic void lockup_detector_reconfigure(void)\n{\n\tcpus_read_lock();\n\twatchdog_nmi_stop();\n\n\tsoftlockup_stop_all();\n\tset_sample_period();\n\tlockup_detector_update_enable();\n\tif (watchdog_enabled && watchdog_thresh)\n\t\tsoftlockup_start_all();\n\n\twatchdog_nmi_start();\n\tcpus_read_unlock();\n\t/*\n\t * Must be called outside the cpus locked section to prevent\n\t * recursive locking in the perf code.\n\t */\n\t__lockup_detector_cleanup();\n}"
  },
  {
    "function_name": "lockup_detector_offline_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "533-538",
    "snippet": "int lockup_detector_offline_cpu(unsigned int cpu)\n{\n\tif (cpumask_test_cpu(cpu, &watchdog_allowed_mask))\n\t\twatchdog_disable(cpu);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "watchdog_disable",
          "args": [
            "cpu"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "476-490",
          "snippet": "static void watchdog_disable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\t/*\n\t * Disable the perf event first. That prevents that a large delay\n\t * between disabling the timer and disabling the perf event causes\n\t * the perf NMI to detect a false positive.\n\t */\n\twatchdog_nmi_disable(cpu);\n\thrtimer_cancel(hrtimer);\n\twait_for_completion(this_cpu_ptr(&softlockup_completion));\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void watchdog_disable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\t/*\n\t * Disable the perf event first. That prevents that a large delay\n\t * between disabling the timer and disabling the perf event causes\n\t * the perf NMI to detect a false positive.\n\t */\n\twatchdog_nmi_disable(cpu);\n\thrtimer_cancel(hrtimer);\n\twait_for_completion(this_cpu_ptr(&softlockup_completion));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&watchdog_allowed_mask"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint lockup_detector_offline_cpu(unsigned int cpu)\n{\n\tif (cpumask_test_cpu(cpu, &watchdog_allowed_mask))\n\t\twatchdog_disable(cpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "lockup_detector_online_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "526-531",
    "snippet": "int lockup_detector_online_cpu(unsigned int cpu)\n{\n\tif (cpumask_test_cpu(cpu, &watchdog_allowed_mask))\n\t\twatchdog_enable(cpu);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "watchdog_enable",
          "args": [
            "cpu"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "450-474",
          "snippet": "static void watchdog_enable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\tstruct completion *done = this_cpu_ptr(&softlockup_completion);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\tinit_completion(done);\n\tcomplete(done);\n\n\t/*\n\t * Start the timer first to prevent the NMI watchdog triggering\n\t * before the timer has a chance to fire.\n\t */\n\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\thrtimer->function = watchdog_timer_fn;\n\thrtimer_start(hrtimer, ns_to_ktime(sample_period),\n\t\t      HRTIMER_MODE_REL_PINNED_HARD);\n\n\t/* Initialize timestamp */\n\tupdate_touch_ts();\n\t/* Enable the perf event */\n\tif (watchdog_enabled & NMI_WATCHDOG_ENABLED)\n\t\twatchdog_nmi_enable(cpu);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic void watchdog_enable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\tstruct completion *done = this_cpu_ptr(&softlockup_completion);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\tinit_completion(done);\n\tcomplete(done);\n\n\t/*\n\t * Start the timer first to prevent the NMI watchdog triggering\n\t * before the timer has a chance to fire.\n\t */\n\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\thrtimer->function = watchdog_timer_fn;\n\thrtimer_start(hrtimer, ns_to_ktime(sample_period),\n\t\t      HRTIMER_MODE_REL_PINNED_HARD);\n\n\t/* Initialize timestamp */\n\tupdate_touch_ts();\n\t/* Enable the perf event */\n\tif (watchdog_enabled & NMI_WATCHDOG_ENABLED)\n\t\twatchdog_nmi_enable(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&watchdog_allowed_mask"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint lockup_detector_online_cpu(unsigned int cpu)\n{\n\tif (cpumask_test_cpu(cpu, &watchdog_allowed_mask))\n\t\twatchdog_enable(cpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "softlockup_start_all",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "517-524",
    "snippet": "static void softlockup_start_all(void)\n{\n\tint cpu;\n\n\tcpumask_copy(&watchdog_allowed_mask, &watchdog_cpumask);\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_start_fn, NULL, false);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cpumask watchdog_cpumask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_on_cpu",
          "args": [
            "cpu",
            "softlockup_start_fn",
            "NULL",
            "false"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_on_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/up.c",
          "lines": "58-72",
          "snippet": "int smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par, bool phys)\n{\n\tint ret;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tif (phys)\n\t\thypervisor_pin_vcpu(0);\n\tret = func(par);\n\tif (phys)\n\t\thypervisor_pin_vcpu(-1);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par, bool phys)\n{\n\tint ret;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tif (phys)\n\t\thypervisor_pin_vcpu(0);\n\tret = func(par);\n\tif (phys)\n\t\thypervisor_pin_vcpu(-1);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "&watchdog_allowed_mask"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "&watchdog_allowed_mask",
            "&watchdog_cpumask"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstruct cpumask watchdog_cpumask;\n\nstatic void softlockup_start_all(void)\n{\n\tint cpu;\n\n\tcpumask_copy(&watchdog_allowed_mask, &watchdog_cpumask);\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_start_fn, NULL, false);\n}"
  },
  {
    "function_name": "softlockup_start_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "511-515",
    "snippet": "static int softlockup_start_fn(void *data)\n{\n\twatchdog_enable(smp_processor_id());\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "watchdog_enable",
          "args": [
            "smp_processor_id()"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "450-474",
          "snippet": "static void watchdog_enable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\tstruct completion *done = this_cpu_ptr(&softlockup_completion);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\tinit_completion(done);\n\tcomplete(done);\n\n\t/*\n\t * Start the timer first to prevent the NMI watchdog triggering\n\t * before the timer has a chance to fire.\n\t */\n\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\thrtimer->function = watchdog_timer_fn;\n\thrtimer_start(hrtimer, ns_to_ktime(sample_period),\n\t\t      HRTIMER_MODE_REL_PINNED_HARD);\n\n\t/* Initialize timestamp */\n\tupdate_touch_ts();\n\t/* Enable the perf event */\n\tif (watchdog_enabled & NMI_WATCHDOG_ENABLED)\n\t\twatchdog_nmi_enable(cpu);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic void watchdog_enable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\tstruct completion *done = this_cpu_ptr(&softlockup_completion);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\tinit_completion(done);\n\tcomplete(done);\n\n\t/*\n\t * Start the timer first to prevent the NMI watchdog triggering\n\t * before the timer has a chance to fire.\n\t */\n\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\thrtimer->function = watchdog_timer_fn;\n\thrtimer_start(hrtimer, ns_to_ktime(sample_period),\n\t\t      HRTIMER_MODE_REL_PINNED_HARD);\n\n\t/* Initialize timestamp */\n\tupdate_touch_ts();\n\t/* Enable the perf event */\n\tif (watchdog_enabled & NMI_WATCHDOG_ENABLED)\n\t\twatchdog_nmi_enable(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int softlockup_start_fn(void *data)\n{\n\twatchdog_enable(smp_processor_id());\n\treturn 0;\n}"
  },
  {
    "function_name": "softlockup_stop_all",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "498-509",
    "snippet": "static void softlockup_stop_all(void)\n{\n\tint cpu;\n\n\tif (!softlockup_initialized)\n\t\treturn;\n\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_stop_fn, NULL, false);\n\n\tcpumask_clear(&watchdog_allowed_mask);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "&watchdog_allowed_mask"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_on_cpu",
          "args": [
            "cpu",
            "softlockup_stop_fn",
            "NULL",
            "false"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_on_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/up.c",
          "lines": "58-72",
          "snippet": "int smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par, bool phys)\n{\n\tint ret;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tif (phys)\n\t\thypervisor_pin_vcpu(0);\n\tret = func(par);\n\tif (phys)\n\t\thypervisor_pin_vcpu(-1);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par, bool phys)\n{\n\tint ret;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tif (phys)\n\t\thypervisor_pin_vcpu(0);\n\tret = func(par);\n\tif (phys)\n\t\thypervisor_pin_vcpu(-1);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "&watchdog_allowed_mask"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void softlockup_stop_all(void)\n{\n\tint cpu;\n\n\tif (!softlockup_initialized)\n\t\treturn;\n\n\tfor_each_cpu(cpu, &watchdog_allowed_mask)\n\t\tsmp_call_on_cpu(cpu, softlockup_stop_fn, NULL, false);\n\n\tcpumask_clear(&watchdog_allowed_mask);\n}"
  },
  {
    "function_name": "softlockup_stop_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "492-496",
    "snippet": "static int softlockup_stop_fn(void *data)\n{\n\twatchdog_disable(smp_processor_id());\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "watchdog_disable",
          "args": [
            "smp_processor_id()"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "476-490",
          "snippet": "static void watchdog_disable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\t/*\n\t * Disable the perf event first. That prevents that a large delay\n\t * between disabling the timer and disabling the perf event causes\n\t * the perf NMI to detect a false positive.\n\t */\n\twatchdog_nmi_disable(cpu);\n\thrtimer_cancel(hrtimer);\n\twait_for_completion(this_cpu_ptr(&softlockup_completion));\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void watchdog_disable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\t/*\n\t * Disable the perf event first. That prevents that a large delay\n\t * between disabling the timer and disabling the perf event causes\n\t * the perf NMI to detect a false positive.\n\t */\n\twatchdog_nmi_disable(cpu);\n\thrtimer_cancel(hrtimer);\n\twait_for_completion(this_cpu_ptr(&softlockup_completion));\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int softlockup_stop_fn(void *data)\n{\n\twatchdog_disable(smp_processor_id());\n\treturn 0;\n}"
  },
  {
    "function_name": "watchdog_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "476-490",
    "snippet": "static void watchdog_disable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\t/*\n\t * Disable the perf event first. That prevents that a large delay\n\t * between disabling the timer and disabling the perf event causes\n\t * the perf NMI to detect a false positive.\n\t */\n\twatchdog_nmi_disable(cpu);\n\thrtimer_cancel(hrtimer);\n\twait_for_completion(this_cpu_ptr(&softlockup_completion));\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "this_cpu_ptr(&softlockup_completion)"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&softlockup_completion"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "hrtimer"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1438-1449",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tint ret;\n\n\tdo {\n\t\tret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret < 0)\n\t\t\thrtimer_cancel_wait_running(timer);\n\t} while (ret < 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "watchdog_nmi_disable",
          "args": [
            "cpu"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_nmi_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "104-107",
          "snippet": "void __weak watchdog_nmi_disable(unsigned int cpu)\n{\n\thardlockup_detector_perf_disable();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nvoid __weak watchdog_nmi_disable(unsigned int cpu)\n{\n\thardlockup_detector_perf_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu != smp_processor_id()"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&watchdog_hrtimer"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void watchdog_disable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\t/*\n\t * Disable the perf event first. That prevents that a large delay\n\t * between disabling the timer and disabling the perf event causes\n\t * the perf NMI to detect a false positive.\n\t */\n\twatchdog_nmi_disable(cpu);\n\thrtimer_cancel(hrtimer);\n\twait_for_completion(this_cpu_ptr(&softlockup_completion));\n}"
  },
  {
    "function_name": "watchdog_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "450-474",
    "snippet": "static void watchdog_enable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\tstruct completion *done = this_cpu_ptr(&softlockup_completion);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\tinit_completion(done);\n\tcomplete(done);\n\n\t/*\n\t * Start the timer first to prevent the NMI watchdog triggering\n\t * before the timer has a chance to fire.\n\t */\n\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\thrtimer->function = watchdog_timer_fn;\n\thrtimer_start(hrtimer, ns_to_ktime(sample_period),\n\t\t      HRTIMER_MODE_REL_PINNED_HARD);\n\n\t/* Initialize timestamp */\n\tupdate_touch_ts();\n\t/* Enable the perf event */\n\tif (watchdog_enabled & NMI_WATCHDOG_ENABLED)\n\t\twatchdog_nmi_enable(cpu);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long __read_mostly watchdog_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "watchdog_nmi_enable",
          "args": [
            "cpu"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_nmi_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "98-102",
          "snippet": "int __weak watchdog_nmi_enable(unsigned int cpu)\n{\n\thardlockup_detector_perf_enable();\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nint __weak watchdog_nmi_enable(unsigned int cpu)\n{\n\thardlockup_detector_perf_enable();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_touch_ts",
          "args": [],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "update_touch_ts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "250-254",
          "snippet": "static void update_touch_ts(void)\n{\n\t__this_cpu_write(watchdog_touch_ts, get_timestamp());\n\tupdate_report_ts();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void update_touch_ts(void)\n{\n\t__this_cpu_write(watchdog_touch_ts, get_timestamp());\n\tupdate_report_ts();\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "hrtimer",
            "ns_to_ktime(sample_period)",
            "HRTIMER_MODE_REL_PINNED_HARD"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "sample_period"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "hrtimer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_REL_HARD"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2007-2013",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "done"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "done"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu != smp_processor_id()"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&softlockup_completion"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&watchdog_hrtimer"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic void watchdog_enable(unsigned int cpu)\n{\n\tstruct hrtimer *hrtimer = this_cpu_ptr(&watchdog_hrtimer);\n\tstruct completion *done = this_cpu_ptr(&softlockup_completion);\n\n\tWARN_ON_ONCE(cpu != smp_processor_id());\n\n\tinit_completion(done);\n\tcomplete(done);\n\n\t/*\n\t * Start the timer first to prevent the NMI watchdog triggering\n\t * before the timer has a chance to fire.\n\t */\n\thrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\thrtimer->function = watchdog_timer_fn;\n\thrtimer_start(hrtimer, ns_to_ktime(sample_period),\n\t\t      HRTIMER_MODE_REL_PINNED_HARD);\n\n\t/* Initialize timestamp */\n\tupdate_touch_ts();\n\t/* Enable the perf event */\n\tif (watchdog_enabled & NMI_WATCHDOG_ENABLED)\n\t\twatchdog_nmi_enable(cpu);\n}"
  },
  {
    "function_name": "watchdog_timer_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "354-448",
    "snippet": "static enum hrtimer_restart watchdog_timer_fn(struct hrtimer *hrtimer)\n{\n\tunsigned long touch_ts, period_ts, now;\n\tstruct pt_regs *regs = get_irq_regs();\n\tint duration;\n\tint softlockup_all_cpu_backtrace = sysctl_softlockup_all_cpu_backtrace;\n\n\tif (!watchdog_enabled)\n\t\treturn HRTIMER_NORESTART;\n\n\t/* kick the hardlockup detector */\n\twatchdog_interrupt_count();\n\n\t/* kick the softlockup detector */\n\tif (completion_done(this_cpu_ptr(&softlockup_completion))) {\n\t\treinit_completion(this_cpu_ptr(&softlockup_completion));\n\t\tstop_one_cpu_nowait(smp_processor_id(),\n\t\t\t\tsoftlockup_fn, NULL,\n\t\t\t\tthis_cpu_ptr(&softlockup_stop_work));\n\t}\n\n\t/* .. and repeat */\n\thrtimer_forward_now(hrtimer, ns_to_ktime(sample_period));\n\n\t/*\n\t * Read the current timestamp first. It might become invalid anytime\n\t * when a virtual machine is stopped by the host or when the watchog\n\t * is touched from NMI.\n\t */\n\tnow = get_timestamp();\n\t/*\n\t * If a virtual machine is stopped by the host it can look to\n\t * the watchdog like a soft lockup. This function touches the watchdog.\n\t */\n\tkvm_check_and_clear_guest_paused();\n\t/*\n\t * The stored timestamp is comparable with @now only when not touched.\n\t * It might get touched anytime from NMI. Make sure that is_softlockup()\n\t * uses the same (valid) value.\n\t */\n\tperiod_ts = READ_ONCE(*this_cpu_ptr(&watchdog_report_ts));\n\n\t/* Reset the interval when touched by known problematic code. */\n\tif (period_ts == SOFTLOCKUP_DELAY_REPORT) {\n\t\tif (unlikely(__this_cpu_read(softlockup_touch_sync))) {\n\t\t\t/*\n\t\t\t * If the time stamp was touched atomically\n\t\t\t * make sure the scheduler tick is up to date.\n\t\t\t */\n\t\t\t__this_cpu_write(softlockup_touch_sync, false);\n\t\t\tsched_clock_tick();\n\t\t}\n\n\t\tupdate_report_ts();\n\t\treturn HRTIMER_RESTART;\n\t}\n\n\t/* Check for a softlockup. */\n\ttouch_ts = __this_cpu_read(watchdog_touch_ts);\n\tduration = is_softlockup(touch_ts, period_ts, now);\n\tif (unlikely(duration)) {\n\t\t/*\n\t\t * Prevent multiple soft-lockup reports if one cpu is already\n\t\t * engaged in dumping all cpu back traces.\n\t\t */\n\t\tif (softlockup_all_cpu_backtrace) {\n\t\t\tif (test_and_set_bit_lock(0, &soft_lockup_nmi_warn))\n\t\t\t\treturn HRTIMER_RESTART;\n\t\t}\n\n\t\t/* Start period for the next softlockup warning. */\n\t\tupdate_report_ts();\n\n\t\tpr_emerg(\"BUG: soft lockup - CPU#%d stuck for %us! [%s:%d]\\n\",\n\t\t\tsmp_processor_id(), duration,\n\t\t\tcurrent->comm, task_pid_nr(current));\n\t\tprint_modules();\n\t\tprint_irqtrace_events(current);\n\t\tif (regs)\n\t\t\tshow_regs(regs);\n\t\telse\n\t\t\tdump_stack();\n\n\t\tif (softlockup_all_cpu_backtrace) {\n\t\t\ttrigger_allbutself_cpu_backtrace();\n\t\t\tclear_bit_unlock(0, &soft_lockup_nmi_warn);\n\t\t}\n\n\t\tadd_taint(TAINT_SOFTLOCKUP, LOCKDEP_STILL_OK);\n\t\tif (softlockup_panic)\n\t\t\tpanic(\"softlockup: hung tasks\");\n\t}\n\n\treturn HRTIMER_RESTART;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX"
    ],
    "globals_used": [
      "unsigned long __read_mostly watchdog_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"softlockup: hung tasks\""
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_panic_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "74-85",
          "snippet": "static int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "TAINT_SOFTLOCKUP",
            "LOCKDEP_STILL_OK"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "add_taint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "440-451",
          "snippet": "void add_taint(unsigned flag, enum lockdep_ok lockdep_ok)\n{\n\tif (lockdep_ok == LOCKDEP_NOW_UNRELIABLE && __debug_locks_off())\n\t\tpr_warn(\"Disabling lock debugging due to kernel taint\\n\");\n\n\tset_bit(flag, &tainted_mask);\n\n\tif (tainted_mask & panic_on_taint) {\n\t\tpanic_on_taint = 0;\n\t\tpanic(\"panic_on_taint set ...\");\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;",
            "unsigned long panic_on_taint;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nstatic unsigned long tainted_mask =\n\tIS_ENABLED(CONFIG_GCC_PLUGIN_RANDSTRUCT) ? (1 << TAINT_RANDSTRUCT) : 0;\nunsigned long panic_on_taint;\n\nvoid add_taint(unsigned flag, enum lockdep_ok lockdep_ok)\n{\n\tif (lockdep_ok == LOCKDEP_NOW_UNRELIABLE && __debug_locks_off())\n\t\tpr_warn(\"Disabling lock debugging due to kernel taint\\n\");\n\n\tset_bit(flag, &tainted_mask);\n\n\tif (tainted_mask & panic_on_taint) {\n\t\tpanic_on_taint = 0;\n\t\tpanic(\"panic_on_taint set ...\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "0",
            "&soft_lockup_nmi_warn"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trigger_allbutself_cpu_backtrace",
          "args": [],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_regs",
          "args": [
            "regs"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_irqtrace_events",
          "args": [
            "current"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "print_irqtrace_events",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "4085-4102",
          "snippet": "void print_irqtrace_events(struct task_struct *curr)\n{\n\tconst struct irqtrace_events *trace = &curr->irqtrace;\n\n\tprintk(\"irq event stamp: %u\\n\", trace->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_enable_event, (void *)trace->hardirq_enable_ip,\n\t\t(void *)trace->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_disable_event, (void *)trace->hardirq_disable_ip,\n\t\t(void *)trace->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_enable_event, (void *)trace->softirq_enable_ip,\n\t\t(void *)trace->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_disable_event, (void *)trace->softirq_disable_ip,\n\t\t(void *)trace->softirq_disable_ip);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid print_irqtrace_events(struct task_struct *curr)\n{\n\tconst struct irqtrace_events *trace = &curr->irqtrace;\n\n\tprintk(\"irq event stamp: %u\\n\", trace->irq_events);\n\tprintk(\"hardirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_enable_event, (void *)trace->hardirq_enable_ip,\n\t\t(void *)trace->hardirq_enable_ip);\n\tprintk(\"hardirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->hardirq_disable_event, (void *)trace->hardirq_disable_ip,\n\t\t(void *)trace->hardirq_disable_ip);\n\tprintk(\"softirqs last  enabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_enable_event, (void *)trace->softirq_enable_ip,\n\t\t(void *)trace->softirq_enable_ip);\n\tprintk(\"softirqs last disabled at (%u): [<%px>] %pS\\n\",\n\t\ttrace->softirq_disable_event, (void *)trace->softirq_disable_ip,\n\t\t(void *)trace->softirq_disable_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_modules",
          "args": [],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "print_modules",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4793-4810",
          "snippet": "void print_modules(void)\n{\n\tstruct module *mod;\n\tchar buf[MODULE_FLAGS_BUF_SIZE];\n\n\tprintk(KERN_DEFAULT \"Modules linked in:\");\n\t/* Most callers should already have preempt disabled, but make sure */\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tpr_cont(\" %s%s\", mod->name, module_flags(mod, buf));\n\t}\n\tpreempt_enable();\n\tif (last_unloaded_module[0])\n\t\tpr_cont(\" [last unloaded: %s]\", last_unloaded_module);\n\tpr_cont(\"\\n\");\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define MODULE_FLAGS_BUF_SIZE (TAINT_FLAGS_COUNT + 4)"
          ],
          "globals_used": [
            "static LIST_HEAD(modules);",
            "static char last_unloaded_module[MODULE_NAME_LEN+1];",
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\n#define MODULE_FLAGS_BUF_SIZE (TAINT_FLAGS_COUNT + 4)\n\nstatic LIST_HEAD(modules);\nstatic char last_unloaded_module[MODULE_NAME_LEN+1];\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nvoid print_modules(void)\n{\n\tstruct module *mod;\n\tchar buf[MODULE_FLAGS_BUF_SIZE];\n\n\tprintk(KERN_DEFAULT \"Modules linked in:\");\n\t/* Most callers should already have preempt disabled, but make sure */\n\tpreempt_disable();\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tpr_cont(\" %s%s\", mod->name, module_flags(mod, buf));\n\t}\n\tpreempt_enable();\n\tif (last_unloaded_module[0])\n\t\tpr_cont(\" [last unloaded: %s]\", last_unloaded_module);\n\tpr_cont(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"BUG: soft lockup - CPU#%d stuck for %us! [%s:%d]\\n\"",
            "smp_processor_id()",
            "duration",
            "current->comm",
            "task_pid_nr(current)"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_report_ts",
          "args": [],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "update_report_ts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "244-247",
          "snippet": "static void update_report_ts(void)\n{\n\t__this_cpu_write(watchdog_report_ts, get_timestamp());\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void update_report_ts(void)\n{\n\t__this_cpu_write(watchdog_report_ts, get_timestamp());\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit_lock",
          "args": [
            "0",
            "&soft_lockup_nmi_warn"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "duration"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_softlockup",
          "args": [
            "touch_ts",
            "period_ts",
            "now"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "is_softlockup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "305-315",
          "snippet": "static int is_softlockup(unsigned long touch_ts,\n\t\t\t unsigned long period_ts,\n\t\t\t unsigned long now)\n{\n\tif ((watchdog_enabled & SOFT_WATCHDOG_ENABLED) && watchdog_thresh){\n\t\t/* Warn about unreasonable delays. */\n\t\tif (time_after(now, period_ts + get_softlockup_thresh()))\n\t\t\treturn now - touch_ts;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long __read_mostly watchdog_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic int is_softlockup(unsigned long touch_ts,\n\t\t\t unsigned long period_ts,\n\t\t\t unsigned long now)\n{\n\tif ((watchdog_enabled & SOFT_WATCHDOG_ENABLED) && watchdog_thresh){\n\t\t/* Warn about unreasonable delays. */\n\t\tif (time_after(now, period_ts + get_softlockup_thresh()))\n\t\t\treturn now - touch_ts;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "watchdog_touch_ts"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_tick",
          "args": [],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_tick_stable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "406-421",
          "snippet": "void sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "softlockup_touch_sync",
            "false"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__this_cpu_read(softlockup_touch_sync)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "softlockup_touch_sync"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*this_cpu_ptr(&watchdog_report_ts)"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&watchdog_report_ts"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_check_and_clear_guest_paused",
          "args": [],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_timestamp",
          "args": [],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "get_timestamp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "226-229",
          "snippet": "static unsigned long get_timestamp(void)\n{\n\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic unsigned long get_timestamp(void)\n{\n\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_forward_now",
          "args": [
            "hrtimer",
            "ns_to_ktime(sample_period)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "sample_period"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop_one_cpu_nowait",
          "args": [
            "smp_processor_id()",
            "softlockup_fn",
            "NULL",
            "this_cpu_ptr(&softlockup_stop_work)"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "stop_one_cpu_nowait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "384-389",
          "snippet": "bool stop_one_cpu_nowait(unsigned int cpu, cpu_stop_fn_t fn, void *arg,\n\t\t\tstruct cpu_stop_work *work_buf)\n{\n\t*work_buf = (struct cpu_stop_work){ .fn = fn, .arg = arg, .caller = _RET_IP_, };\n\treturn cpu_stop_queue_work(cpu, work_buf);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nbool stop_one_cpu_nowait(unsigned int cpu, cpu_stop_fn_t fn, void *arg,\n\t\t\tstruct cpu_stop_work *work_buf)\n{\n\t*work_buf = (struct cpu_stop_work){ .fn = fn, .arg = arg, .caller = _RET_IP_, };\n\treturn cpu_stop_queue_work(cpu, work_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&softlockup_stop_work"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinit_completion",
          "args": [
            "this_cpu_ptr(&softlockup_completion)"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&softlockup_completion"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completion_done",
          "args": [
            "this_cpu_ptr(&softlockup_completion)"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "completion_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "315-330",
          "snippet": "bool completion_done(struct completion *x)\n{\n\tunsigned long flags;\n\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\t/*\n\t * If ->done, we need to wait for complete() to release ->wait.lock\n\t * otherwise we can end up freeing the completion before complete()\n\t * is done referencing it.\n\t */\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn true;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool completion_done(struct completion *x)\n{\n\tunsigned long flags;\n\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\t/*\n\t * If ->done, we need to wait for complete() to release ->wait.lock\n\t * otherwise we can end up freeing the completion before complete()\n\t * is done referencing it.\n\t */\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&softlockup_completion"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchdog_interrupt_count",
          "args": [],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_interrupt_count",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "329-332",
          "snippet": "static void watchdog_interrupt_count(void)\n{\n\t__this_cpu_inc(hrtimer_interrupts);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void watchdog_interrupt_count(void)\n{\n\t__this_cpu_inc(hrtimer_interrupts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_irq_regs",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic enum hrtimer_restart watchdog_timer_fn(struct hrtimer *hrtimer)\n{\n\tunsigned long touch_ts, period_ts, now;\n\tstruct pt_regs *regs = get_irq_regs();\n\tint duration;\n\tint softlockup_all_cpu_backtrace = sysctl_softlockup_all_cpu_backtrace;\n\n\tif (!watchdog_enabled)\n\t\treturn HRTIMER_NORESTART;\n\n\t/* kick the hardlockup detector */\n\twatchdog_interrupt_count();\n\n\t/* kick the softlockup detector */\n\tif (completion_done(this_cpu_ptr(&softlockup_completion))) {\n\t\treinit_completion(this_cpu_ptr(&softlockup_completion));\n\t\tstop_one_cpu_nowait(smp_processor_id(),\n\t\t\t\tsoftlockup_fn, NULL,\n\t\t\t\tthis_cpu_ptr(&softlockup_stop_work));\n\t}\n\n\t/* .. and repeat */\n\thrtimer_forward_now(hrtimer, ns_to_ktime(sample_period));\n\n\t/*\n\t * Read the current timestamp first. It might become invalid anytime\n\t * when a virtual machine is stopped by the host or when the watchog\n\t * is touched from NMI.\n\t */\n\tnow = get_timestamp();\n\t/*\n\t * If a virtual machine is stopped by the host it can look to\n\t * the watchdog like a soft lockup. This function touches the watchdog.\n\t */\n\tkvm_check_and_clear_guest_paused();\n\t/*\n\t * The stored timestamp is comparable with @now only when not touched.\n\t * It might get touched anytime from NMI. Make sure that is_softlockup()\n\t * uses the same (valid) value.\n\t */\n\tperiod_ts = READ_ONCE(*this_cpu_ptr(&watchdog_report_ts));\n\n\t/* Reset the interval when touched by known problematic code. */\n\tif (period_ts == SOFTLOCKUP_DELAY_REPORT) {\n\t\tif (unlikely(__this_cpu_read(softlockup_touch_sync))) {\n\t\t\t/*\n\t\t\t * If the time stamp was touched atomically\n\t\t\t * make sure the scheduler tick is up to date.\n\t\t\t */\n\t\t\t__this_cpu_write(softlockup_touch_sync, false);\n\t\t\tsched_clock_tick();\n\t\t}\n\n\t\tupdate_report_ts();\n\t\treturn HRTIMER_RESTART;\n\t}\n\n\t/* Check for a softlockup. */\n\ttouch_ts = __this_cpu_read(watchdog_touch_ts);\n\tduration = is_softlockup(touch_ts, period_ts, now);\n\tif (unlikely(duration)) {\n\t\t/*\n\t\t * Prevent multiple soft-lockup reports if one cpu is already\n\t\t * engaged in dumping all cpu back traces.\n\t\t */\n\t\tif (softlockup_all_cpu_backtrace) {\n\t\t\tif (test_and_set_bit_lock(0, &soft_lockup_nmi_warn))\n\t\t\t\treturn HRTIMER_RESTART;\n\t\t}\n\n\t\t/* Start period for the next softlockup warning. */\n\t\tupdate_report_ts();\n\n\t\tpr_emerg(\"BUG: soft lockup - CPU#%d stuck for %us! [%s:%d]\\n\",\n\t\t\tsmp_processor_id(), duration,\n\t\t\tcurrent->comm, task_pid_nr(current));\n\t\tprint_modules();\n\t\tprint_irqtrace_events(current);\n\t\tif (regs)\n\t\t\tshow_regs(regs);\n\t\telse\n\t\t\tdump_stack();\n\n\t\tif (softlockup_all_cpu_backtrace) {\n\t\t\ttrigger_allbutself_cpu_backtrace();\n\t\t\tclear_bit_unlock(0, &soft_lockup_nmi_warn);\n\t\t}\n\n\t\tadd_taint(TAINT_SOFTLOCKUP, LOCKDEP_STILL_OK);\n\t\tif (softlockup_panic)\n\t\t\tpanic(\"softlockup: hung tasks\");\n\t}\n\n\treturn HRTIMER_RESTART;\n}"
  },
  {
    "function_name": "softlockup_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "345-351",
    "snippet": "static int softlockup_fn(void *data)\n{\n\tupdate_touch_ts();\n\tcomplete(this_cpu_ptr(&softlockup_completion));\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "this_cpu_ptr(&softlockup_completion)"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&softlockup_completion"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_touch_ts",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "update_touch_ts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "250-254",
          "snippet": "static void update_touch_ts(void)\n{\n\t__this_cpu_write(watchdog_touch_ts, get_timestamp());\n\tupdate_report_ts();\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void update_touch_ts(void)\n{\n\t__this_cpu_write(watchdog_touch_ts, get_timestamp());\n\tupdate_report_ts();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int softlockup_fn(void *data)\n{\n\tupdate_touch_ts();\n\tcomplete(this_cpu_ptr(&softlockup_completion));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "watchdog_interrupt_count",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "329-332",
    "snippet": "static void watchdog_interrupt_count(void)\n{\n\t__this_cpu_inc(hrtimer_interrupts);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "hrtimer_interrupts"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void watchdog_interrupt_count(void)\n{\n\t__this_cpu_inc(hrtimer_interrupts);\n}"
  },
  {
    "function_name": "is_hardlockup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "318-327",
    "snippet": "bool is_hardlockup(void)\n{\n\tunsigned long hrint = __this_cpu_read(hrtimer_interrupts);\n\n\tif (__this_cpu_read(hrtimer_interrupts_saved) == hrint)\n\t\treturn true;\n\n\t__this_cpu_write(hrtimer_interrupts_saved, hrint);\n\treturn false;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "hrtimer_interrupts_saved",
            "hrint"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "hrtimer_interrupts_saved"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "hrtimer_interrupts"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nbool is_hardlockup(void)\n{\n\tunsigned long hrint = __this_cpu_read(hrtimer_interrupts);\n\n\tif (__this_cpu_read(hrtimer_interrupts_saved) == hrint)\n\t\treturn true;\n\n\t__this_cpu_write(hrtimer_interrupts_saved, hrint);\n\treturn false;\n}"
  },
  {
    "function_name": "is_softlockup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "305-315",
    "snippet": "static int is_softlockup(unsigned long touch_ts,\n\t\t\t unsigned long period_ts,\n\t\t\t unsigned long now)\n{\n\tif ((watchdog_enabled & SOFT_WATCHDOG_ENABLED) && watchdog_thresh){\n\t\t/* Warn about unreasonable delays. */\n\t\tif (time_after(now, period_ts + get_softlockup_thresh()))\n\t\t\treturn now - touch_ts;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long __read_mostly watchdog_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "now",
            "period_ts + get_softlockup_thresh()"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_softlockup_thresh",
          "args": [],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "get_softlockup_thresh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "216-219",
          "snippet": "static int get_softlockup_thresh(void)\n{\n\treturn watchdog_thresh * 2;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int get_softlockup_thresh(void)\n{\n\treturn watchdog_thresh * 2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic int is_softlockup(unsigned long touch_ts,\n\t\t\t unsigned long period_ts,\n\t\t\t unsigned long now)\n{\n\tif ((watchdog_enabled & SOFT_WATCHDOG_ENABLED) && watchdog_thresh){\n\t\t/* Warn about unreasonable delays. */\n\t\tif (time_after(now, period_ts + get_softlockup_thresh()))\n\t\t\treturn now - touch_ts;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "touch_softlockup_watchdog_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "299-303",
    "snippet": "void touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "watchdog_report_ts",
            "SOFTLOCKUP_DELAY_REPORT"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "softlockup_touch_sync",
            "true"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX\n\nvoid touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}"
  },
  {
    "function_name": "touch_all_softlockup_watchdogs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "280-297",
    "snippet": "void touch_all_softlockup_watchdogs(void)\n{\n\tint cpu;\n\n\t/*\n\t * watchdog_mutex cannpt be taken here, as this might be called\n\t * from (soft)interrupt context, so the access to\n\t * watchdog_allowed_cpumask might race with a concurrent update.\n\t *\n\t * The watchdog time stamp can race against a concurrent real\n\t * update as well, the only side effect might be a cycle delay for\n\t * the softlockup check.\n\t */\n\tfor_each_cpu(cpu, &watchdog_allowed_mask) {\n\t\tper_cpu(watchdog_report_ts, cpu) = SOFTLOCKUP_DELAY_REPORT;\n\t\twq_watchdog_touch(cpu);\n\t}\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(watchdog_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wq_watchdog_touch",
          "args": [
            "cpu"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "wq_watchdog_touch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5894-5900",
          "snippet": "notrace void wq_watchdog_touch(int cpu)\n{\n\tif (cpu >= 0)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n\n\twq_watchdog_touched = jiffies;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nnotrace void wq_watchdog_touch(int cpu)\n{\n\tif (cpu >= 0)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n\n\twq_watchdog_touched = jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "watchdog_report_ts",
            "cpu"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "&watchdog_allowed_mask"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX\n\nstatic DEFINE_MUTEX(watchdog_mutex);\n\nvoid touch_all_softlockup_watchdogs(void)\n{\n\tint cpu;\n\n\t/*\n\t * watchdog_mutex cannpt be taken here, as this might be called\n\t * from (soft)interrupt context, so the access to\n\t * watchdog_allowed_cpumask might race with a concurrent update.\n\t *\n\t * The watchdog time stamp can race against a concurrent real\n\t * update as well, the only side effect might be a cycle delay for\n\t * the softlockup check.\n\t */\n\tfor_each_cpu(cpu, &watchdog_allowed_mask) {\n\t\tper_cpu(watchdog_report_ts, cpu) = SOFTLOCKUP_DELAY_REPORT;\n\t\twq_watchdog_touch(cpu);\n\t}\n}"
  },
  {
    "function_name": "touch_softlockup_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "273-277",
    "snippet": "notrace void touch_softlockup_watchdog(void)\n{\n\ttouch_softlockup_watchdog_sched();\n\twq_watchdog_touch(raw_smp_processor_id());\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wq_watchdog_touch",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "wq_watchdog_touch",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "5894-5900",
          "snippet": "notrace void wq_watchdog_touch(int cpu)\n{\n\tif (cpu >= 0)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n\n\twq_watchdog_touched = jiffies;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nnotrace void wq_watchdog_touch(int cpu)\n{\n\tif (cpu >= 0)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n\n\twq_watchdog_touched = jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog_sched",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "264-271",
          "snippet": "notrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's watchdog\n\t * report period gets restarted here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX\n\nnotrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's watchdog\n\t * report period gets restarted here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nnotrace void touch_softlockup_watchdog(void)\n{\n\ttouch_softlockup_watchdog_sched();\n\twq_watchdog_touch(raw_smp_processor_id());\n}"
  },
  {
    "function_name": "touch_softlockup_watchdog_sched",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "264-271",
    "snippet": "notrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's watchdog\n\t * report period gets restarted here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_cpu_write",
          "args": [
            "watchdog_report_ts",
            "SOFTLOCKUP_DELAY_REPORT"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n#define SOFTLOCKUP_DELAY_REPORT\tULONG_MAX\n\nnotrace void touch_softlockup_watchdog_sched(void)\n{\n\t/*\n\t * Preemption can be enabled.  It doesn't matter which CPU's watchdog\n\t * report period gets restarted here, so use the raw_ operation.\n\t */\n\traw_cpu_write(watchdog_report_ts, SOFTLOCKUP_DELAY_REPORT);\n}"
  },
  {
    "function_name": "update_touch_ts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "250-254",
    "snippet": "static void update_touch_ts(void)\n{\n\t__this_cpu_write(watchdog_touch_ts, get_timestamp());\n\tupdate_report_ts();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_report_ts",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "update_report_ts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "244-247",
          "snippet": "static void update_report_ts(void)\n{\n\t__this_cpu_write(watchdog_report_ts, get_timestamp());\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void update_report_ts(void)\n{\n\t__this_cpu_write(watchdog_report_ts, get_timestamp());\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "watchdog_touch_ts",
            "get_timestamp()"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_timestamp",
          "args": [],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "get_timestamp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "226-229",
          "snippet": "static unsigned long get_timestamp(void)\n{\n\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic unsigned long get_timestamp(void)\n{\n\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void update_touch_ts(void)\n{\n\t__this_cpu_write(watchdog_touch_ts, get_timestamp());\n\tupdate_report_ts();\n}"
  },
  {
    "function_name": "update_report_ts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "244-247",
    "snippet": "static void update_report_ts(void)\n{\n\t__this_cpu_write(watchdog_report_ts, get_timestamp());\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "watchdog_report_ts",
            "get_timestamp()"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_timestamp",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "get_timestamp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "226-229",
          "snippet": "static unsigned long get_timestamp(void)\n{\n\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic unsigned long get_timestamp(void)\n{\n\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void update_report_ts(void)\n{\n\t__this_cpu_write(watchdog_report_ts, get_timestamp());\n}"
  },
  {
    "function_name": "set_sample_period",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "231-242",
    "snippet": "static void set_sample_period(void)\n{\n\t/*\n\t * convert watchdog_thresh from seconds to ns\n\t * the divide by 5 is to give hrtimer several chances (two\n\t * or three with the current relation between the soft\n\t * and hard thresholds) to increment before the\n\t * hardlockup detector generates a warning\n\t */\n\tsample_period = get_softlockup_thresh() * ((u64)NSEC_PER_SEC / 5);\n\twatchdog_update_hrtimer_threshold(sample_period);\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "watchdog_update_hrtimer_threshold",
          "args": [
            "sample_period"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "watchdog_update_hrtimer_threshold",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "50-74",
          "snippet": "void watchdog_update_hrtimer_threshold(u64 period)\n{\n\t/*\n\t * The hrtimer runs with a period of (watchdog_threshold * 2) / 5\n\t *\n\t * So it runs effectively with 2.5 times the rate of the NMI\n\t * watchdog. That means the hrtimer should fire 2-3 times before\n\t * the NMI watchdog expires. The NMI watchdog on x86 is based on\n\t * unhalted CPU cycles, so if Turbo-Mode is enabled the CPU cycles\n\t * might run way faster than expected and the NMI fires in a\n\t * smaller period than the one deduced from the nominal CPU\n\t * frequency. Depending on the Turbo-Mode factor this might be fast\n\t * enough to get the NMI period smaller than the hrtimer watchdog\n\t * period and trigger false positives.\n\t *\n\t * The sample threshold is used to check in the NMI handler whether\n\t * the minimum time between two NMI samples has elapsed. That\n\t * prevents false positives.\n\t *\n\t * Set this to 4/5 of the actual watchdog threshold period so the\n\t * hrtimer is guaranteed to fire at least once within the real\n\t * watchdog threshold.\n\t */\n\twatchdog_hrtimer_sample_threshold = period * 2;\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nvoid watchdog_update_hrtimer_threshold(u64 period)\n{\n\t/*\n\t * The hrtimer runs with a period of (watchdog_threshold * 2) / 5\n\t *\n\t * So it runs effectively with 2.5 times the rate of the NMI\n\t * watchdog. That means the hrtimer should fire 2-3 times before\n\t * the NMI watchdog expires. The NMI watchdog on x86 is based on\n\t * unhalted CPU cycles, so if Turbo-Mode is enabled the CPU cycles\n\t * might run way faster than expected and the NMI fires in a\n\t * smaller period than the one deduced from the nominal CPU\n\t * frequency. Depending on the Turbo-Mode factor this might be fast\n\t * enough to get the NMI period smaller than the hrtimer watchdog\n\t * period and trigger false positives.\n\t *\n\t * The sample threshold is used to check in the NMI handler whether\n\t * the minimum time between two NMI samples has elapsed. That\n\t * prevents false positives.\n\t *\n\t * Set this to 4/5 of the actual watchdog threshold period so the\n\t * hrtimer is guaranteed to fire at least once within the real\n\t * watchdog threshold.\n\t */\n\twatchdog_hrtimer_sample_threshold = period * 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_softlockup_thresh",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "get_softlockup_thresh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "216-219",
          "snippet": "static int get_softlockup_thresh(void)\n{\n\treturn watchdog_thresh * 2;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int get_softlockup_thresh(void)\n{\n\treturn watchdog_thresh * 2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic void set_sample_period(void)\n{\n\t/*\n\t * convert watchdog_thresh from seconds to ns\n\t * the divide by 5 is to give hrtimer several chances (two\n\t * or three with the current relation between the soft\n\t * and hard thresholds) to increment before the\n\t * hardlockup detector generates a warning\n\t */\n\tsample_period = get_softlockup_thresh() * ((u64)NSEC_PER_SEC / 5);\n\twatchdog_update_hrtimer_threshold(sample_period);\n}"
  },
  {
    "function_name": "get_timestamp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "226-229",
    "snippet": "static unsigned long get_timestamp(void)\n{\n\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "running_clock",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "running_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "479-482",
          "snippet": "u64 __weak running_clock(void)\n{\n\treturn local_clock();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nu64 __weak running_clock(void)\n{\n\treturn local_clock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic unsigned long get_timestamp(void)\n{\n\treturn running_clock() >> 30LL;  /* 2^30 ~= 10^9 */\n}"
  },
  {
    "function_name": "get_softlockup_thresh",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "216-219",
    "snippet": "static int get_softlockup_thresh(void)\n{\n\treturn watchdog_thresh * 2;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int get_softlockup_thresh(void)\n{\n\treturn watchdog_thresh * 2;\n}"
  },
  {
    "function_name": "watchdog_thresh_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "200-204",
    "snippet": "static int __init watchdog_thresh_setup(char *str)\n{\n\tget_option(&str, &watchdog_thresh);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&watchdog_thresh"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init watchdog_thresh_setup(char *str)\n{\n\tget_option(&str, &watchdog_thresh);\n\treturn 1;\n}"
  },
  {
    "function_name": "nosoftlockup_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "193-197",
    "snippet": "static int __init nosoftlockup_setup(char *str)\n{\n\tsoft_watchdog_user_enabled = 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init nosoftlockup_setup(char *str)\n{\n\tsoft_watchdog_user_enabled = 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "nowatchdog_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "186-190",
    "snippet": "static int __init nowatchdog_setup(char *str)\n{\n\twatchdog_user_enabled = 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init nowatchdog_setup(char *str)\n{\n\twatchdog_user_enabled = 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "lockup_detector_update_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "144-153",
    "snippet": "static void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (nmi_watchdog_available && nmi_watchdog_user_enabled)\n\t\twatchdog_enabled |= NMI_WATCHDOG_ENABLED;\n\tif (soft_watchdog_user_enabled)\n\t\twatchdog_enabled |= SOFT_WATCHDOG_ENABLED;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long __read_mostly watchdog_enabled;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nunsigned long __read_mostly watchdog_enabled;\n\nstatic void lockup_detector_update_enable(void)\n{\n\twatchdog_enabled = 0;\n\tif (!watchdog_user_enabled)\n\t\treturn;\n\tif (nmi_watchdog_available && nmi_watchdog_user_enabled)\n\t\twatchdog_enabled |= NMI_WATCHDOG_ENABLED;\n\tif (soft_watchdog_user_enabled)\n\t\twatchdog_enabled |= SOFT_WATCHDOG_ENABLED;\n}"
  },
  {
    "function_name": "watchdog_nmi_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "136-136",
    "snippet": "void __weak watchdog_nmi_start(void) { }",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int __weak"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nvoid __weak watchdog_nmi_start(void) { }"
  },
  {
    "function_name": "watchdog_nmi_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "123-123",
    "snippet": "void __weak watchdog_nmi_stop(void) { }",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int __weak"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nvoid __weak watchdog_nmi_stop(void) { }"
  },
  {
    "function_name": "watchdog_nmi_probe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "110-113",
    "snippet": "__init watchdog_nmi_probe(void)\n{\n\treturn hardlockup_detector_perf_init();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hardlockup_detector_perf_init",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_detector_perf_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "285-296",
          "snippet": "int __init hardlockup_detector_perf_init(void)\n{\n\tint ret = hardlockup_detector_event_create();\n\n\tif (ret) {\n\t\tpr_info(\"Perf NMI watchdog permanently disabled\\n\");\n\t} else {\n\t\tperf_event_release_kernel(this_cpu_read(watchdog_ev));\n\t\tthis_cpu_write(watchdog_ev, NULL);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct perf_event *, watchdog_ev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, watchdog_ev);\n\nint __init hardlockup_detector_perf_init(void)\n{\n\tint ret = hardlockup_detector_event_create();\n\n\tif (ret) {\n\t\tpr_info(\"Perf NMI watchdog permanently disabled\\n\");\n\t} else {\n\t\tperf_event_release_kernel(this_cpu_read(watchdog_ev));\n\t\tthis_cpu_write(watchdog_ev, NULL);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\n__init watchdog_nmi_probe(void)\n{\n\treturn hardlockup_detector_perf_init();\n}"
  },
  {
    "function_name": "watchdog_nmi_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "104-107",
    "snippet": "void __weak watchdog_nmi_disable(unsigned int cpu)\n{\n\thardlockup_detector_perf_disable();\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int __weak"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hardlockup_detector_perf_disable",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_detector_perf_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "205-216",
          "snippet": "void hardlockup_detector_perf_disable(void)\n{\n\tstruct perf_event *event = this_cpu_read(watchdog_ev);\n\n\tif (event) {\n\t\tperf_event_disable(event);\n\t\tthis_cpu_write(watchdog_ev, NULL);\n\t\tthis_cpu_write(dead_event, event);\n\t\tcpumask_set_cpu(smp_processor_id(), &dead_events_mask);\n\t\tatomic_dec(&watchdog_cpus);\n\t}\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct perf_event *, watchdog_ev);",
            "static DEFINE_PER_CPU(struct perf_event *, dead_event);",
            "static struct cpumask dead_events_mask;",
            "static atomic_t watchdog_cpus = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, watchdog_ev);\nstatic DEFINE_PER_CPU(struct perf_event *, dead_event);\nstatic struct cpumask dead_events_mask;\nstatic atomic_t watchdog_cpus = ATOMIC_INIT(0);\n\nvoid hardlockup_detector_perf_disable(void)\n{\n\tstruct perf_event *event = this_cpu_read(watchdog_ev);\n\n\tif (event) {\n\t\tperf_event_disable(event);\n\t\tthis_cpu_write(watchdog_ev, NULL);\n\t\tthis_cpu_write(dead_event, event);\n\t\tcpumask_set_cpu(smp_processor_id(), &dead_events_mask);\n\t\tatomic_dec(&watchdog_cpus);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nvoid __weak watchdog_nmi_disable(unsigned int cpu)\n{\n\thardlockup_detector_perf_disable();\n}"
  },
  {
    "function_name": "watchdog_nmi_enable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "98-102",
    "snippet": "int __weak watchdog_nmi_enable(unsigned int cpu)\n{\n\thardlockup_detector_perf_enable();\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int __weak"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hardlockup_detector_perf_enable",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_detector_perf_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "190-200",
          "snippet": "void hardlockup_detector_perf_enable(void)\n{\n\tif (hardlockup_detector_event_create())\n\t\treturn;\n\n\t/* use original value for check */\n\tif (!atomic_fetch_inc(&watchdog_cpus))\n\t\tpr_info(\"Enabled. Permanently consumes one hw-PMU counter.\\n\");\n\n\tperf_event_enable(this_cpu_read(watchdog_ev));\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct perf_event *, watchdog_ev);",
            "static atomic_t watchdog_cpus = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, watchdog_ev);\nstatic atomic_t watchdog_cpus = ATOMIC_INIT(0);\n\nvoid hardlockup_detector_perf_enable(void)\n{\n\tif (hardlockup_detector_event_create())\n\t\treturn;\n\n\t/* use original value for check */\n\tif (!atomic_fetch_inc(&watchdog_cpus))\n\t\tpr_info(\"Enabled. Permanently consumes one hw-PMU counter.\\n\");\n\n\tperf_event_enable(this_cpu_read(watchdog_ev));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nint __weak;\n\nint __weak watchdog_nmi_enable(unsigned int cpu)\n{\n\thardlockup_detector_perf_enable();\n\treturn 0;\n}"
  },
  {
    "function_name": "hardlockup_panic_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "74-85",
    "snippet": "static int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"1\"",
            "1"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"0\"",
            "1"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"nopanic\"",
            "7"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"panic\"",
            "5"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "hardlockup_detector_disable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
    "lines": "69-72",
    "snippet": "void __init hardlockup_detector_disable(void)\n{\n\tnmi_watchdog_user_enabled = 0;\n}",
    "includes": [
      "#include <linux/kvm_para.h>",
      "#include <asm/irq_regs.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/tick.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/nmi.h>",
      "#include <linux/cpu.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nvoid __init hardlockup_detector_disable(void)\n{\n\tnmi_watchdog_user_enabled = 0;\n}"
  }
]