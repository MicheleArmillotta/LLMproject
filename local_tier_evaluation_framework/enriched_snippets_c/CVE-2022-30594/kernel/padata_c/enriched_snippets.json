[
  {
    "function_name": "padata_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "1104-1141",
    "snippet": "void __init padata_init(void)\n{\n\tunsigned int i, possible_cpus;\n#ifdef CONFIG_HOTPLUG_CPU\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN, \"padata:online\",\n\t\t\t\t      padata_cpu_online, NULL);\n\tif (ret < 0)\n\t\tgoto err;\n\thp_online = ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_PADATA_DEAD, \"padata:dead\",\n\t\t\t\t      NULL, padata_cpu_dead);\n\tif (ret < 0)\n\t\tgoto remove_online_state;\n#endif\n\n\tpossible_cpus = num_possible_cpus();\n\tpadata_works = kmalloc_array(possible_cpus, sizeof(struct padata_work),\n\t\t\t\t     GFP_KERNEL);\n\tif (!padata_works)\n\t\tgoto remove_dead_state;\n\n\tfor (i = 0; i < possible_cpus; ++i)\n\t\tlist_add(&padata_works[i].pw_list, &padata_free_works);\n\n\treturn;\n\nremove_dead_state:\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_remove_multi_state(CPUHP_PADATA_DEAD);\nremove_online_state:\n\tcpuhp_remove_multi_state(hp_online);\nerr:\n#endif\n\tpr_warn(\"padata: initialization failed\\n\");\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct padata_work *padata_works;",
      "static LIST_HEAD(padata_free_works);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"padata: initialization failed\\n\""
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_remove_multi_state",
          "args": [
            "hp_online"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&padata_works[i].pw_list",
            "&padata_free_works"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "possible_cpus",
            "sizeof(struct padata_work)",
            "GFP_KERNEL"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state_multi",
          "args": [
            "CPUHP_PADATA_DEAD",
            "\"padata:dead\"",
            "NULL",
            "padata_cpu_dead"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state_multi",
          "args": [
            "CPUHP_AP_ONLINE_DYN",
            "\"padata:online\"",
            "padata_cpu_online",
            "NULL"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic struct padata_work *padata_works;\nstatic LIST_HEAD(padata_free_works);\n\nvoid __init padata_init(void)\n{\n\tunsigned int i, possible_cpus;\n#ifdef CONFIG_HOTPLUG_CPU\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN, \"padata:online\",\n\t\t\t\t      padata_cpu_online, NULL);\n\tif (ret < 0)\n\t\tgoto err;\n\thp_online = ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_PADATA_DEAD, \"padata:dead\",\n\t\t\t\t      NULL, padata_cpu_dead);\n\tif (ret < 0)\n\t\tgoto remove_online_state;\n#endif\n\n\tpossible_cpus = num_possible_cpus();\n\tpadata_works = kmalloc_array(possible_cpus, sizeof(struct padata_work),\n\t\t\t\t     GFP_KERNEL);\n\tif (!padata_works)\n\t\tgoto remove_dead_state;\n\n\tfor (i = 0; i < possible_cpus; ++i)\n\t\tlist_add(&padata_works[i].pw_list, &padata_free_works);\n\n\treturn;\n\nremove_dead_state:\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_remove_multi_state(CPUHP_PADATA_DEAD);\nremove_online_state:\n\tcpuhp_remove_multi_state(hp_online);\nerr:\n#endif\n\tpr_warn(\"padata: initialization failed\\n\");\n}"
  },
  {
    "function_name": "padata_free_shell",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "1090-1101",
    "snippet": "void padata_free_shell(struct padata_shell *ps)\n{\n\tif (!ps)\n\t\treturn;\n\n\tmutex_lock(&ps->pinst->lock);\n\tlist_del(&ps->list);\n\tpadata_free_pd(rcu_dereference_protected(ps->pd, 1));\n\tmutex_unlock(&ps->pinst->lock);\n\n\tkfree(ps);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void padata_free_pd(struct parallel_data *pd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ps"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ps->pinst->lock"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_free_pd",
          "args": [
            "rcu_dereference_protected(ps->pd, 1)"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "padata_free_pd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "602-609",
          "snippet": "static void padata_free_pd(struct parallel_data *pd)\n{\n\tfree_cpumask_var(pd->cpumask.pcpu);\n\tfree_cpumask_var(pd->cpumask.cbcpu);\n\tfree_percpu(pd->reorder_list);\n\tfree_percpu(pd->squeue);\n\tkfree(pd);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void padata_free_pd(struct parallel_data *pd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic void padata_free_pd(struct parallel_data *pd)\n{\n\tfree_cpumask_var(pd->cpumask.pcpu);\n\tfree_cpumask_var(pd->cpumask.cbcpu);\n\tfree_percpu(pd->reorder_list);\n\tfree_percpu(pd->squeue);\n\tkfree(pd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ps->pd",
            "1"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ps->list"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ps->pinst->lock"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nvoid padata_free_shell(struct padata_shell *ps)\n{\n\tif (!ps)\n\t\treturn;\n\n\tmutex_lock(&ps->pinst->lock);\n\tlist_del(&ps->list);\n\tpadata_free_pd(rcu_dereference_protected(ps->pd, 1));\n\tmutex_unlock(&ps->pinst->lock);\n\n\tkfree(ps);\n}"
  },
  {
    "function_name": "padata_alloc_shell",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "1053-1082",
    "snippet": "struct padata_shell *padata_alloc_shell(struct padata_instance *pinst)\n{\n\tstruct parallel_data *pd;\n\tstruct padata_shell *ps;\n\n\tps = kzalloc(sizeof(*ps), GFP_KERNEL);\n\tif (!ps)\n\t\tgoto out;\n\n\tps->pinst = pinst;\n\n\tcpus_read_lock();\n\tpd = padata_alloc_pd(ps);\n\tcpus_read_unlock();\n\n\tif (!pd)\n\t\tgoto out_free_ps;\n\n\tmutex_lock(&pinst->lock);\n\tRCU_INIT_POINTER(ps->pd, pd);\n\tlist_add(&ps->list, &pinst->pslist);\n\tmutex_unlock(&pinst->lock);\n\n\treturn ps;\n\nout_free_ps:\n\tkfree(ps);\nout:\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void padata_free_pd(struct parallel_data *pd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ps"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pinst->lock"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ps->list",
            "&pinst->pslist"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "ps->pd",
            "pd"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pinst->lock"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_alloc_pd",
          "args": [
            "ps"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "padata_alloc_pd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "553-600",
          "snippet": "static struct parallel_data *padata_alloc_pd(struct padata_shell *ps)\n{\n\tstruct padata_instance *pinst = ps->pinst;\n\tstruct parallel_data *pd;\n\n\tpd = kzalloc(sizeof(struct parallel_data), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto err;\n\n\tpd->reorder_list = alloc_percpu(struct padata_list);\n\tif (!pd->reorder_list)\n\t\tgoto err_free_pd;\n\n\tpd->squeue = alloc_percpu(struct padata_serial_queue);\n\tif (!pd->squeue)\n\t\tgoto err_free_reorder_list;\n\n\tpd->ps = ps;\n\n\tif (!alloc_cpumask_var(&pd->cpumask.pcpu, GFP_KERNEL))\n\t\tgoto err_free_squeue;\n\tif (!alloc_cpumask_var(&pd->cpumask.cbcpu, GFP_KERNEL))\n\t\tgoto err_free_pcpu;\n\n\tcpumask_and(pd->cpumask.pcpu, pinst->cpumask.pcpu, cpu_online_mask);\n\tcpumask_and(pd->cpumask.cbcpu, pinst->cpumask.cbcpu, cpu_online_mask);\n\n\tpadata_init_reorder_list(pd);\n\tpadata_init_squeues(pd);\n\tpd->seq_nr = -1;\n\trefcount_set(&pd->refcnt, 1);\n\tspin_lock_init(&pd->lock);\n\tpd->cpu = cpumask_first(pd->cpumask.pcpu);\n\tINIT_WORK(&pd->reorder_work, invoke_padata_reorder);\n\n\treturn pd;\n\nerr_free_pcpu:\n\tfree_cpumask_var(pd->cpumask.pcpu);\nerr_free_squeue:\n\tfree_percpu(pd->squeue);\nerr_free_reorder_list:\n\tfree_percpu(pd->reorder_list);\nerr_free_pd:\n\tkfree(pd);\nerr:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void padata_free_pd(struct parallel_data *pd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic struct parallel_data *padata_alloc_pd(struct padata_shell *ps)\n{\n\tstruct padata_instance *pinst = ps->pinst;\n\tstruct parallel_data *pd;\n\n\tpd = kzalloc(sizeof(struct parallel_data), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto err;\n\n\tpd->reorder_list = alloc_percpu(struct padata_list);\n\tif (!pd->reorder_list)\n\t\tgoto err_free_pd;\n\n\tpd->squeue = alloc_percpu(struct padata_serial_queue);\n\tif (!pd->squeue)\n\t\tgoto err_free_reorder_list;\n\n\tpd->ps = ps;\n\n\tif (!alloc_cpumask_var(&pd->cpumask.pcpu, GFP_KERNEL))\n\t\tgoto err_free_squeue;\n\tif (!alloc_cpumask_var(&pd->cpumask.cbcpu, GFP_KERNEL))\n\t\tgoto err_free_pcpu;\n\n\tcpumask_and(pd->cpumask.pcpu, pinst->cpumask.pcpu, cpu_online_mask);\n\tcpumask_and(pd->cpumask.cbcpu, pinst->cpumask.cbcpu, cpu_online_mask);\n\n\tpadata_init_reorder_list(pd);\n\tpadata_init_squeues(pd);\n\tpd->seq_nr = -1;\n\trefcount_set(&pd->refcnt, 1);\n\tspin_lock_init(&pd->lock);\n\tpd->cpu = cpumask_first(pd->cpumask.pcpu);\n\tINIT_WORK(&pd->reorder_work, invoke_padata_reorder);\n\n\treturn pd;\n\nerr_free_pcpu:\n\tfree_cpumask_var(pd->cpumask.pcpu);\nerr_free_squeue:\n\tfree_percpu(pd->squeue);\nerr_free_reorder_list:\n\tfree_percpu(pd->reorder_list);\nerr_free_pd:\n\tkfree(pd);\nerr:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ps)",
            "GFP_KERNEL"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstruct padata_shell *padata_alloc_shell(struct padata_instance *pinst)\n{\n\tstruct parallel_data *pd;\n\tstruct padata_shell *ps;\n\n\tps = kzalloc(sizeof(*ps), GFP_KERNEL);\n\tif (!ps)\n\t\tgoto out;\n\n\tps->pinst = pinst;\n\n\tcpus_read_lock();\n\tpd = padata_alloc_pd(ps);\n\tcpus_read_unlock();\n\n\tif (!pd)\n\t\tgoto out_free_ps;\n\n\tmutex_lock(&pinst->lock);\n\tRCU_INIT_POINTER(ps->pd, pd);\n\tlist_add(&ps->list, &pinst->pslist);\n\tmutex_unlock(&pinst->lock);\n\n\treturn ps;\n\nout_free_ps:\n\tkfree(ps);\nout:\n\treturn NULL;\n}"
  },
  {
    "function_name": "padata_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "1040-1043",
    "snippet": "void padata_free(struct padata_instance *pinst)\n{\n\tkobject_put(&pinst->kobj);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&pinst->kobj"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "mod_kobject_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1804-1810",
          "snippet": "static void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nstatic void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nvoid padata_free(struct padata_instance *pinst)\n{\n\tkobject_put(&pinst->kobj);\n}"
  },
  {
    "function_name": "padata_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "969-1032",
    "snippet": "struct padata_instance *padata_alloc(const char *name)\n{\n\tstruct padata_instance *pinst;\n\n\tpinst = kzalloc(sizeof(struct padata_instance), GFP_KERNEL);\n\tif (!pinst)\n\t\tgoto err;\n\n\tpinst->parallel_wq = alloc_workqueue(\"%s_parallel\", WQ_UNBOUND, 0,\n\t\t\t\t\t     name);\n\tif (!pinst->parallel_wq)\n\t\tgoto err_free_inst;\n\n\tcpus_read_lock();\n\n\tpinst->serial_wq = alloc_workqueue(\"%s_serial\", WQ_MEM_RECLAIM |\n\t\t\t\t\t   WQ_CPU_INTENSIVE, 1, name);\n\tif (!pinst->serial_wq)\n\t\tgoto err_put_cpus;\n\n\tif (!alloc_cpumask_var(&pinst->cpumask.pcpu, GFP_KERNEL))\n\t\tgoto err_free_serial_wq;\n\tif (!alloc_cpumask_var(&pinst->cpumask.cbcpu, GFP_KERNEL)) {\n\t\tfree_cpumask_var(pinst->cpumask.pcpu);\n\t\tgoto err_free_serial_wq;\n\t}\n\n\tINIT_LIST_HEAD(&pinst->pslist);\n\n\tcpumask_copy(pinst->cpumask.pcpu, cpu_possible_mask);\n\tcpumask_copy(pinst->cpumask.cbcpu, cpu_possible_mask);\n\n\tif (padata_setup_cpumasks(pinst))\n\t\tgoto err_free_masks;\n\n\t__padata_start(pinst);\n\n\tkobject_init(&pinst->kobj, &padata_attr_type);\n\tmutex_init(&pinst->lock);\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_add_instance_nocalls_cpuslocked(hp_online,\n\t\t\t\t\t\t    &pinst->cpu_online_node);\n\tcpuhp_state_add_instance_nocalls_cpuslocked(CPUHP_PADATA_DEAD,\n\t\t\t\t\t\t    &pinst->cpu_dead_node);\n#endif\n\n\tcpus_read_unlock();\n\n\treturn pinst;\n\nerr_free_masks:\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\nerr_free_serial_wq:\n\tdestroy_workqueue(pinst->serial_wq);\nerr_put_cpus:\n\tcpus_read_unlock();\n\tdestroy_workqueue(pinst->parallel_wq);\nerr_free_inst:\n\tkfree(pinst);\nerr:\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kobj_type padata_attr_type = {\n\t.sysfs_ops = &padata_sysfs_ops,\n\t.default_groups = padata_default_groups,\n\t.release = padata_sysfs_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pinst"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "pinst->parallel_wq"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4417-4501",
          "snippet": "void destroy_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tint node;\n\n\t/*\n\t * Remove it from sysfs first so that sanity check failure doesn't\n\t * lead to sysfs name conflicts.\n\t */\n\tworkqueue_sysfs_unregister(wq);\n\n\t/* drain it before proceeding with destruction */\n\tdrain_workqueue(wq);\n\n\t/* kill rescuer, if sanity checks fail, leave it w/o rescuer */\n\tif (wq->rescuer) {\n\t\tstruct worker *rescuer = wq->rescuer;\n\n\t\t/* this prevents new queueing */\n\t\traw_spin_lock_irq(&wq_mayday_lock);\n\t\twq->rescuer = NULL;\n\t\traw_spin_unlock_irq(&wq_mayday_lock);\n\n\t\t/* rescuer will empty maydays list before exiting */\n\t\tkthread_stop(rescuer->task);\n\t\tkfree(rescuer);\n\t}\n\n\t/*\n\t * Sanity checks - grab all the locks so that we wait for all\n\t * in-flight operations which may do put_pwq().\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq) {\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tif (WARN_ON(pwq_busy(pwq))) {\n\t\t\tpr_warn(\"%s: %s has the following busy pwq\\n\",\n\t\t\t\t__func__, wq->name);\n\t\t\tshow_pwq(pwq);\n\t\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tmutex_unlock(&wq_pool_mutex);\n\t\t\tshow_one_workqueue(wq);\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n\tmutex_unlock(&wq->mutex);\n\n\t/*\n\t * wq list is used to freeze wq, remove from list after\n\t * flushing is complete in case freeze races us.\n\t */\n\tlist_del_rcu(&wq->list);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq_unregister_lockdep(wq);\n\t\t/*\n\t\t * The base ref is never dropped on per-cpu pwqs.  Directly\n\t\t * schedule RCU free.\n\t\t */\n\t\tcall_rcu(&wq->rcu, rcu_free_wq);\n\t} else {\n\t\t/*\n\t\t * We're the sole accessor of @wq at this point.  Directly\n\t\t * access numa_pwq_tbl[] and dfl_pwq to put the base refs.\n\t\t * @wq will be freed when the last pwq is released.\n\t\t */\n\t\tfor_each_node(node) {\n\t\t\tpwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\t\t\tRCU_INIT_POINTER(wq->numa_pwq_tbl[node], NULL);\n\t\t\tput_pwq_unlocked(pwq);\n\t\t}\n\n\t\t/*\n\t\t * Put dfl_pwq.  @wq may be freed any time after dfl_pwq is\n\t\t * put.  Don't access it afterwards.\n\t\t */\n\t\tpwq = wq->dfl_pwq;\n\t\twq->dfl_pwq = NULL;\n\t\tput_pwq_unlocked(pwq);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_RAW_SPINLOCK(wq_mayday_lock);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_RAW_SPINLOCK(wq_mayday_lock);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid destroy_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tint node;\n\n\t/*\n\t * Remove it from sysfs first so that sanity check failure doesn't\n\t * lead to sysfs name conflicts.\n\t */\n\tworkqueue_sysfs_unregister(wq);\n\n\t/* drain it before proceeding with destruction */\n\tdrain_workqueue(wq);\n\n\t/* kill rescuer, if sanity checks fail, leave it w/o rescuer */\n\tif (wq->rescuer) {\n\t\tstruct worker *rescuer = wq->rescuer;\n\n\t\t/* this prevents new queueing */\n\t\traw_spin_lock_irq(&wq_mayday_lock);\n\t\twq->rescuer = NULL;\n\t\traw_spin_unlock_irq(&wq_mayday_lock);\n\n\t\t/* rescuer will empty maydays list before exiting */\n\t\tkthread_stop(rescuer->task);\n\t\tkfree(rescuer);\n\t}\n\n\t/*\n\t * Sanity checks - grab all the locks so that we wait for all\n\t * in-flight operations which may do put_pwq().\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq) {\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tif (WARN_ON(pwq_busy(pwq))) {\n\t\t\tpr_warn(\"%s: %s has the following busy pwq\\n\",\n\t\t\t\t__func__, wq->name);\n\t\t\tshow_pwq(pwq);\n\t\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tmutex_unlock(&wq_pool_mutex);\n\t\t\tshow_one_workqueue(wq);\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n\tmutex_unlock(&wq->mutex);\n\n\t/*\n\t * wq list is used to freeze wq, remove from list after\n\t * flushing is complete in case freeze races us.\n\t */\n\tlist_del_rcu(&wq->list);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq_unregister_lockdep(wq);\n\t\t/*\n\t\t * The base ref is never dropped on per-cpu pwqs.  Directly\n\t\t * schedule RCU free.\n\t\t */\n\t\tcall_rcu(&wq->rcu, rcu_free_wq);\n\t} else {\n\t\t/*\n\t\t * We're the sole accessor of @wq at this point.  Directly\n\t\t * access numa_pwq_tbl[] and dfl_pwq to put the base refs.\n\t\t * @wq will be freed when the last pwq is released.\n\t\t */\n\t\tfor_each_node(node) {\n\t\t\tpwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\t\t\tRCU_INIT_POINTER(wq->numa_pwq_tbl[node], NULL);\n\t\t\tput_pwq_unlocked(pwq);\n\t\t}\n\n\t\t/*\n\t\t * Put dfl_pwq.  @wq may be freed any time after dfl_pwq is\n\t\t * put.  Don't access it afterwards.\n\t\t */\n\t\tpwq = wq->dfl_pwq;\n\t\twq->dfl_pwq = NULL;\n\t\tput_pwq_unlocked(pwq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "pinst->cpumask.cbcpu"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "pinst->cpumask.pcpu"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_state_add_instance_nocalls_cpuslocked",
          "args": [
            "CPUHP_PADATA_DEAD",
            "&pinst->cpu_dead_node"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_state_add_instance_nocalls_cpuslocked",
          "args": [
            "hp_online",
            "&pinst->cpu_online_node"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&pinst->lock"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_init",
          "args": [
            "&pinst->kobj",
            "&padata_attr_type"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__padata_start",
          "args": [
            "pinst"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "611-614",
          "snippet": "static void __padata_start(struct padata_instance *pinst)\n{\n\tpinst->flags |= PADATA_INIT;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __padata_start(struct padata_instance *pinst)\n{\n\tpinst->flags |= PADATA_INIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_setup_cpumasks",
          "args": [
            "pinst"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "padata_setup_cpumasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "411-426",
          "snippet": "static int padata_setup_cpumasks(struct padata_instance *pinst)\n{\n\tstruct workqueue_attrs *attrs;\n\tint err;\n\n\tattrs = alloc_workqueue_attrs();\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\t/* Restrict parallel_wq workers to pd->cpumask.pcpu. */\n\tcpumask_copy(attrs->cpumask, pinst->cpumask.pcpu);\n\terr = apply_workqueue_attrs(pinst->parallel_wq, attrs);\n\tfree_workqueue_attrs(attrs);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void padata_free_pd(struct parallel_data *pd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic int padata_setup_cpumasks(struct padata_instance *pinst)\n{\n\tstruct workqueue_attrs *attrs;\n\tint err;\n\n\tattrs = alloc_workqueue_attrs();\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\t/* Restrict parallel_wq workers to pd->cpumask.pcpu. */\n\tcpumask_copy(attrs->cpumask, pinst->cpumask.pcpu);\n\terr = apply_workqueue_attrs(pinst->parallel_wq, attrs);\n\tfree_workqueue_attrs(attrs);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "pinst->cpumask.cbcpu",
            "cpu_possible_mask"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "pinst->cpumask.pcpu",
            "cpu_possible_mask"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pinst->pslist"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "pinst->cpumask.pcpu"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&pinst->cpumask.cbcpu",
            "GFP_KERNEL"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&pinst->cpumask.pcpu",
            "GFP_KERNEL"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"%s_serial\"",
            "WQ_MEM_RECLAIM |\n\t\t\t\t\t   WQ_CPU_INTENSIVE",
            "1",
            "name"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4298-4392",
          "snippet": "struct workqueue_struct *alloc_workqueue(const char *fmt,\n\t\t\t\t\t unsigned int flags,\n\t\t\t\t\t int max_active, ...)\n{\n\tsize_t tbl_size = 0;\n\tva_list args;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * Unbound && max_active == 1 used to imply ordered, which is no\n\t * longer the case on NUMA machines due to per-node pools.  While\n\t * alloc_ordered_workqueue() is the right way to create an ordered\n\t * workqueue, keep the previous behavior to avoid subtle breakages\n\t * on NUMA.\n\t */\n\tif ((flags & WQ_UNBOUND) && max_active == 1)\n\t\tflags |= __WQ_ORDERED;\n\n\t/* see the comment above the definition of WQ_POWER_EFFICIENT */\n\tif ((flags & WQ_POWER_EFFICIENT) && wq_power_efficient)\n\t\tflags |= WQ_UNBOUND;\n\n\t/* allocate wq and format name */\n\tif (flags & WQ_UNBOUND)\n\t\ttbl_size = nr_node_ids * sizeof(wq->numa_pwq_tbl[0]);\n\n\twq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL);\n\tif (!wq)\n\t\treturn NULL;\n\n\tif (flags & WQ_UNBOUND) {\n\t\twq->unbound_attrs = alloc_workqueue_attrs();\n\t\tif (!wq->unbound_attrs)\n\t\t\tgoto err_free_wq;\n\t}\n\n\tva_start(args, max_active);\n\tvsnprintf(wq->name, sizeof(wq->name), fmt, args);\n\tva_end(args);\n\n\tmax_active = max_active ?: WQ_DFL_ACTIVE;\n\tmax_active = wq_clamp_max_active(max_active, flags, wq->name);\n\n\t/* init wq */\n\twq->flags = flags;\n\twq->saved_max_active = max_active;\n\tmutex_init(&wq->mutex);\n\tatomic_set(&wq->nr_pwqs_to_flush, 0);\n\tINIT_LIST_HEAD(&wq->pwqs);\n\tINIT_LIST_HEAD(&wq->flusher_queue);\n\tINIT_LIST_HEAD(&wq->flusher_overflow);\n\tINIT_LIST_HEAD(&wq->maydays);\n\n\twq_init_lockdep(wq);\n\tINIT_LIST_HEAD(&wq->list);\n\n\tif (alloc_and_link_pwqs(wq) < 0)\n\t\tgoto err_unreg_lockdep;\n\n\tif (wq_online && init_rescuer(wq) < 0)\n\t\tgoto err_destroy;\n\n\tif ((wq->flags & WQ_SYSFS) && workqueue_sysfs_register(wq))\n\t\tgoto err_destroy;\n\n\t/*\n\t * wq_pool_mutex protects global freeze state and workqueues list.\n\t * Grab it, adjust max_active and add the new @wq to workqueues\n\t * list.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\tmutex_unlock(&wq->mutex);\n\n\tlist_add_tail_rcu(&wq->list, &workqueues);\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn wq;\n\nerr_unreg_lockdep:\n\twq_unregister_lockdep(wq);\n\twq_free_lockdep(wq);\nerr_free_wq:\n\tfree_workqueue_attrs(wq->unbound_attrs);\n\tkfree(wq);\n\treturn NULL;\nerr_destroy:\n\tdestroy_workqueue(wq);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_power_efficient = IS_ENABLED(CONFIG_WQ_POWER_EFFICIENT_DEFAULT);",
            "static bool wq_online;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_power_efficient = IS_ENABLED(CONFIG_WQ_POWER_EFFICIENT_DEFAULT);\nstatic bool wq_online;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\n\nstruct workqueue_struct *alloc_workqueue(const char *fmt,\n\t\t\t\t\t unsigned int flags,\n\t\t\t\t\t int max_active, ...)\n{\n\tsize_t tbl_size = 0;\n\tva_list args;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * Unbound && max_active == 1 used to imply ordered, which is no\n\t * longer the case on NUMA machines due to per-node pools.  While\n\t * alloc_ordered_workqueue() is the right way to create an ordered\n\t * workqueue, keep the previous behavior to avoid subtle breakages\n\t * on NUMA.\n\t */\n\tif ((flags & WQ_UNBOUND) && max_active == 1)\n\t\tflags |= __WQ_ORDERED;\n\n\t/* see the comment above the definition of WQ_POWER_EFFICIENT */\n\tif ((flags & WQ_POWER_EFFICIENT) && wq_power_efficient)\n\t\tflags |= WQ_UNBOUND;\n\n\t/* allocate wq and format name */\n\tif (flags & WQ_UNBOUND)\n\t\ttbl_size = nr_node_ids * sizeof(wq->numa_pwq_tbl[0]);\n\n\twq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL);\n\tif (!wq)\n\t\treturn NULL;\n\n\tif (flags & WQ_UNBOUND) {\n\t\twq->unbound_attrs = alloc_workqueue_attrs();\n\t\tif (!wq->unbound_attrs)\n\t\t\tgoto err_free_wq;\n\t}\n\n\tva_start(args, max_active);\n\tvsnprintf(wq->name, sizeof(wq->name), fmt, args);\n\tva_end(args);\n\n\tmax_active = max_active ?: WQ_DFL_ACTIVE;\n\tmax_active = wq_clamp_max_active(max_active, flags, wq->name);\n\n\t/* init wq */\n\twq->flags = flags;\n\twq->saved_max_active = max_active;\n\tmutex_init(&wq->mutex);\n\tatomic_set(&wq->nr_pwqs_to_flush, 0);\n\tINIT_LIST_HEAD(&wq->pwqs);\n\tINIT_LIST_HEAD(&wq->flusher_queue);\n\tINIT_LIST_HEAD(&wq->flusher_overflow);\n\tINIT_LIST_HEAD(&wq->maydays);\n\n\twq_init_lockdep(wq);\n\tINIT_LIST_HEAD(&wq->list);\n\n\tif (alloc_and_link_pwqs(wq) < 0)\n\t\tgoto err_unreg_lockdep;\n\n\tif (wq_online && init_rescuer(wq) < 0)\n\t\tgoto err_destroy;\n\n\tif ((wq->flags & WQ_SYSFS) && workqueue_sysfs_register(wq))\n\t\tgoto err_destroy;\n\n\t/*\n\t * wq_pool_mutex protects global freeze state and workqueues list.\n\t * Grab it, adjust max_active and add the new @wq to workqueues\n\t * list.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\tmutex_unlock(&wq->mutex);\n\n\tlist_add_tail_rcu(&wq->list, &workqueues);\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn wq;\n\nerr_unreg_lockdep:\n\twq_unregister_lockdep(wq);\n\twq_free_lockdep(wq);\nerr_free_wq:\n\tfree_workqueue_attrs(wq->unbound_attrs);\n\tkfree(wq);\n\treturn NULL;\nerr_destroy:\n\tdestroy_workqueue(wq);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct padata_instance)",
            "GFP_KERNEL"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic struct kobj_type padata_attr_type = {\n\t.sysfs_ops = &padata_sysfs_ops,\n\t.default_groups = padata_default_groups,\n\t.release = padata_sysfs_release,\n};\n\nstruct padata_instance *padata_alloc(const char *name)\n{\n\tstruct padata_instance *pinst;\n\n\tpinst = kzalloc(sizeof(struct padata_instance), GFP_KERNEL);\n\tif (!pinst)\n\t\tgoto err;\n\n\tpinst->parallel_wq = alloc_workqueue(\"%s_parallel\", WQ_UNBOUND, 0,\n\t\t\t\t\t     name);\n\tif (!pinst->parallel_wq)\n\t\tgoto err_free_inst;\n\n\tcpus_read_lock();\n\n\tpinst->serial_wq = alloc_workqueue(\"%s_serial\", WQ_MEM_RECLAIM |\n\t\t\t\t\t   WQ_CPU_INTENSIVE, 1, name);\n\tif (!pinst->serial_wq)\n\t\tgoto err_put_cpus;\n\n\tif (!alloc_cpumask_var(&pinst->cpumask.pcpu, GFP_KERNEL))\n\t\tgoto err_free_serial_wq;\n\tif (!alloc_cpumask_var(&pinst->cpumask.cbcpu, GFP_KERNEL)) {\n\t\tfree_cpumask_var(pinst->cpumask.pcpu);\n\t\tgoto err_free_serial_wq;\n\t}\n\n\tINIT_LIST_HEAD(&pinst->pslist);\n\n\tcpumask_copy(pinst->cpumask.pcpu, cpu_possible_mask);\n\tcpumask_copy(pinst->cpumask.cbcpu, cpu_possible_mask);\n\n\tif (padata_setup_cpumasks(pinst))\n\t\tgoto err_free_masks;\n\n\t__padata_start(pinst);\n\n\tkobject_init(&pinst->kobj, &padata_attr_type);\n\tmutex_init(&pinst->lock);\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_add_instance_nocalls_cpuslocked(hp_online,\n\t\t\t\t\t\t    &pinst->cpu_online_node);\n\tcpuhp_state_add_instance_nocalls_cpuslocked(CPUHP_PADATA_DEAD,\n\t\t\t\t\t\t    &pinst->cpu_dead_node);\n#endif\n\n\tcpus_read_unlock();\n\n\treturn pinst;\n\nerr_free_masks:\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\nerr_free_serial_wq:\n\tdestroy_workqueue(pinst->serial_wq);\nerr_put_cpus:\n\tcpus_read_unlock();\n\tdestroy_workqueue(pinst->parallel_wq);\nerr_free_inst:\n\tkfree(pinst);\nerr:\n\treturn NULL;\n}"
  },
  {
    "function_name": "padata_sysfs_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "937-950",
    "snippet": "static ssize_t padata_sysfs_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct padata_instance *pinst;\n\tstruct padata_sysfs_entry *pentry;\n\tssize_t ret = -EIO;\n\n\tpinst = kobj2pinst(kobj);\n\tpentry = attr2pentry(attr);\n\tif (pentry->show)\n\t\tret = pentry->store(pinst, attr, buf, count);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pentry->store",
          "args": [
            "pinst",
            "attr",
            "buf",
            "count"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attr2pentry",
          "args": [
            "attr"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobj2pinst",
          "args": [
            "kobj"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic ssize_t padata_sysfs_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct padata_instance *pinst;\n\tstruct padata_sysfs_entry *pentry;\n\tssize_t ret = -EIO;\n\n\tpinst = kobj2pinst(kobj);\n\tpentry = attr2pentry(attr);\n\tif (pentry->show)\n\t\tret = pentry->store(pinst, attr, buf, count);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "padata_sysfs_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "922-935",
    "snippet": "static ssize_t padata_sysfs_show(struct kobject *kobj,\n\t\t\t\t struct attribute *attr, char *buf)\n{\n\tstruct padata_instance *pinst;\n\tstruct padata_sysfs_entry *pentry;\n\tssize_t ret = -EIO;\n\n\tpinst = kobj2pinst(kobj);\n\tpentry = attr2pentry(attr);\n\tif (pentry->show)\n\t\tret = pentry->show(pinst, attr, buf);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pentry->show",
          "args": [
            "pinst",
            "attr",
            "buf"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attr2pentry",
          "args": [
            "attr"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobj2pinst",
          "args": [
            "kobj"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic ssize_t padata_sysfs_show(struct kobject *kobj,\n\t\t\t\t struct attribute *attr, char *buf)\n{\n\tstruct padata_instance *pinst;\n\tstruct padata_sysfs_entry *pentry;\n\tssize_t ret = -EIO;\n\n\tpinst = kobj2pinst(kobj);\n\tpentry = attr2pentry(attr);\n\tif (pentry->show)\n\t\tret = pentry->show(pinst, attr, buf);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "store_cpumask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "873-898",
    "snippet": "static ssize_t store_cpumask(struct padata_instance *pinst,\n\t\t\t     struct attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tcpumask_var_t new_cpumask;\n\tssize_t ret;\n\tint mask_type;\n\n\tif (!alloc_cpumask_var(&new_cpumask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = bitmap_parse(buf, count, cpumask_bits(new_cpumask),\n\t\t\t   nr_cpumask_bits);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmask_type = !strcmp(attr->name, \"serial_cpumask\") ?\n\t\tPADATA_CPU_SERIAL : PADATA_CPU_PARALLEL;\n\tret = padata_set_cpumask(pinst, mask_type, new_cpumask);\n\tif (!ret)\n\t\tret = count;\n\nout:\n\tfree_cpumask_var(new_cpumask);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "new_cpumask"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_set_cpumask",
          "args": [
            "pinst",
            "mask_type",
            "new_cpumask"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "padata_set_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "717-746",
          "snippet": "int padata_set_cpumask(struct padata_instance *pinst, int cpumask_type,\n\t\t       cpumask_var_t cpumask)\n{\n\tstruct cpumask *serial_mask, *parallel_mask;\n\tint err = -EINVAL;\n\n\tcpus_read_lock();\n\tmutex_lock(&pinst->lock);\n\n\tswitch (cpumask_type) {\n\tcase PADATA_CPU_PARALLEL:\n\t\tserial_mask = pinst->cpumask.cbcpu;\n\t\tparallel_mask = cpumask;\n\t\tbreak;\n\tcase PADATA_CPU_SERIAL:\n\t\tparallel_mask = pinst->cpumask.pcpu;\n\t\tserial_mask = cpumask;\n\t\tbreak;\n\tdefault:\n\t\t goto out;\n\t}\n\n\terr =  __padata_set_cpumasks(pinst, parallel_mask, serial_mask);\n\nout:\n\tmutex_unlock(&pinst->lock);\n\tcpus_read_unlock();\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nint padata_set_cpumask(struct padata_instance *pinst, int cpumask_type,\n\t\t       cpumask_var_t cpumask)\n{\n\tstruct cpumask *serial_mask, *parallel_mask;\n\tint err = -EINVAL;\n\n\tcpus_read_lock();\n\tmutex_lock(&pinst->lock);\n\n\tswitch (cpumask_type) {\n\tcase PADATA_CPU_PARALLEL:\n\t\tserial_mask = pinst->cpumask.cbcpu;\n\t\tparallel_mask = cpumask;\n\t\tbreak;\n\tcase PADATA_CPU_SERIAL:\n\t\tparallel_mask = pinst->cpumask.pcpu;\n\t\tserial_mask = cpumask;\n\t\tbreak;\n\tdefault:\n\t\t goto out;\n\t}\n\n\terr =  __padata_set_cpumasks(pinst, parallel_mask, serial_mask);\n\nout:\n\tmutex_unlock(&pinst->lock);\n\tcpus_read_unlock();\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "attr->name",
            "\"serial_cpumask\""
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_parse",
          "args": [
            "buf",
            "count",
            "cpumask_bits(new_cpumask)",
            "nr_cpumask_bits"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_bits",
          "args": [
            "new_cpumask"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&new_cpumask",
            "GFP_KERNEL"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic ssize_t store_cpumask(struct padata_instance *pinst,\n\t\t\t     struct attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tcpumask_var_t new_cpumask;\n\tssize_t ret;\n\tint mask_type;\n\n\tif (!alloc_cpumask_var(&new_cpumask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = bitmap_parse(buf, count, cpumask_bits(new_cpumask),\n\t\t\t   nr_cpumask_bits);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmask_type = !strcmp(attr->name, \"serial_cpumask\") ?\n\t\tPADATA_CPU_SERIAL : PADATA_CPU_PARALLEL;\n\tret = padata_set_cpumask(pinst, mask_type, new_cpumask);\n\tif (!ret)\n\t\tret = count;\n\nout:\n\tfree_cpumask_var(new_cpumask);\n\treturn ret;\n}"
  },
  {
    "function_name": "show_cpumask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "855-871",
    "snippet": "static ssize_t show_cpumask(struct padata_instance *pinst,\n\t\t\t    struct attribute *attr,  char *buf)\n{\n\tstruct cpumask *cpumask;\n\tssize_t len;\n\n\tmutex_lock(&pinst->lock);\n\tif (!strcmp(attr->name, \"serial_cpumask\"))\n\t\tcpumask = pinst->cpumask.cbcpu;\n\telse\n\t\tcpumask = pinst->cpumask.pcpu;\n\n\tlen = snprintf(buf, PAGE_SIZE, \"%*pb\\n\",\n\t\t       nr_cpu_ids, cpumask_bits(cpumask));\n\tmutex_unlock(&pinst->lock);\n\treturn len < PAGE_SIZE ? len : -EINVAL;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pinst->lock"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%*pb\\n\"",
            "nr_cpu_ids",
            "cpumask_bits(cpumask)"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_bits",
          "args": [
            "cpumask"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "attr->name",
            "\"serial_cpumask\""
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pinst->lock"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic ssize_t show_cpumask(struct padata_instance *pinst,\n\t\t\t    struct attribute *attr,  char *buf)\n{\n\tstruct cpumask *cpumask;\n\tssize_t len;\n\n\tmutex_lock(&pinst->lock);\n\tif (!strcmp(attr->name, \"serial_cpumask\"))\n\t\tcpumask = pinst->cpumask.cbcpu;\n\telse\n\t\tcpumask = pinst->cpumask.pcpu;\n\n\tlen = snprintf(buf, PAGE_SIZE, \"%*pb\\n\",\n\t\t       nr_cpu_ids, cpumask_bits(cpumask));\n\tmutex_unlock(&pinst->lock);\n\treturn len < PAGE_SIZE ? len : -EINVAL;\n}"
  },
  {
    "function_name": "padata_sysfs_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "842-846",
    "snippet": "static void padata_sysfs_release(struct kobject *kobj)\n{\n\tstruct padata_instance *pinst = kobj2pinst(kobj);\n\t__padata_free(pinst);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__padata_free",
          "args": [
            "pinst"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "820-835",
          "snippet": "static void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(CPUHP_PADATA_DEAD,\n\t\t\t\t\t    &pinst->cpu_dead_node);\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->cpu_online_node);\n#endif\n\n\tWARN_ON(!list_empty(&pinst->pslist));\n\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tdestroy_workqueue(pinst->serial_wq);\n\tdestroy_workqueue(pinst->parallel_wq);\n\tkfree(pinst);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(CPUHP_PADATA_DEAD,\n\t\t\t\t\t    &pinst->cpu_dead_node);\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->cpu_online_node);\n#endif\n\n\tWARN_ON(!list_empty(&pinst->pslist));\n\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tdestroy_workqueue(pinst->serial_wq);\n\tdestroy_workqueue(pinst->parallel_wq);\n\tkfree(pinst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobj2pinst",
          "args": [
            "kobj"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_sysfs_release(struct kobject *kobj)\n{\n\tstruct padata_instance *pinst = kobj2pinst(kobj);\n\t__padata_free(pinst);\n}"
  },
  {
    "function_name": "__padata_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "820-835",
    "snippet": "static void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(CPUHP_PADATA_DEAD,\n\t\t\t\t\t    &pinst->cpu_dead_node);\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->cpu_online_node);\n#endif\n\n\tWARN_ON(!list_empty(&pinst->pslist));\n\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tdestroy_workqueue(pinst->serial_wq);\n\tdestroy_workqueue(pinst->parallel_wq);\n\tkfree(pinst);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pinst"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "pinst->parallel_wq"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4417-4501",
          "snippet": "void destroy_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tint node;\n\n\t/*\n\t * Remove it from sysfs first so that sanity check failure doesn't\n\t * lead to sysfs name conflicts.\n\t */\n\tworkqueue_sysfs_unregister(wq);\n\n\t/* drain it before proceeding with destruction */\n\tdrain_workqueue(wq);\n\n\t/* kill rescuer, if sanity checks fail, leave it w/o rescuer */\n\tif (wq->rescuer) {\n\t\tstruct worker *rescuer = wq->rescuer;\n\n\t\t/* this prevents new queueing */\n\t\traw_spin_lock_irq(&wq_mayday_lock);\n\t\twq->rescuer = NULL;\n\t\traw_spin_unlock_irq(&wq_mayday_lock);\n\n\t\t/* rescuer will empty maydays list before exiting */\n\t\tkthread_stop(rescuer->task);\n\t\tkfree(rescuer);\n\t}\n\n\t/*\n\t * Sanity checks - grab all the locks so that we wait for all\n\t * in-flight operations which may do put_pwq().\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq) {\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tif (WARN_ON(pwq_busy(pwq))) {\n\t\t\tpr_warn(\"%s: %s has the following busy pwq\\n\",\n\t\t\t\t__func__, wq->name);\n\t\t\tshow_pwq(pwq);\n\t\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tmutex_unlock(&wq_pool_mutex);\n\t\t\tshow_one_workqueue(wq);\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n\tmutex_unlock(&wq->mutex);\n\n\t/*\n\t * wq list is used to freeze wq, remove from list after\n\t * flushing is complete in case freeze races us.\n\t */\n\tlist_del_rcu(&wq->list);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq_unregister_lockdep(wq);\n\t\t/*\n\t\t * The base ref is never dropped on per-cpu pwqs.  Directly\n\t\t * schedule RCU free.\n\t\t */\n\t\tcall_rcu(&wq->rcu, rcu_free_wq);\n\t} else {\n\t\t/*\n\t\t * We're the sole accessor of @wq at this point.  Directly\n\t\t * access numa_pwq_tbl[] and dfl_pwq to put the base refs.\n\t\t * @wq will be freed when the last pwq is released.\n\t\t */\n\t\tfor_each_node(node) {\n\t\t\tpwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\t\t\tRCU_INIT_POINTER(wq->numa_pwq_tbl[node], NULL);\n\t\t\tput_pwq_unlocked(pwq);\n\t\t}\n\n\t\t/*\n\t\t * Put dfl_pwq.  @wq may be freed any time after dfl_pwq is\n\t\t * put.  Don't access it afterwards.\n\t\t */\n\t\tpwq = wq->dfl_pwq;\n\t\twq->dfl_pwq = NULL;\n\t\tput_pwq_unlocked(pwq);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_RAW_SPINLOCK(wq_mayday_lock);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);",
            "static void show_pwq(struct pool_workqueue *pwq);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_RAW_SPINLOCK(wq_mayday_lock);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\nstatic void show_pwq(struct pool_workqueue *pwq);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nvoid destroy_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tint node;\n\n\t/*\n\t * Remove it from sysfs first so that sanity check failure doesn't\n\t * lead to sysfs name conflicts.\n\t */\n\tworkqueue_sysfs_unregister(wq);\n\n\t/* drain it before proceeding with destruction */\n\tdrain_workqueue(wq);\n\n\t/* kill rescuer, if sanity checks fail, leave it w/o rescuer */\n\tif (wq->rescuer) {\n\t\tstruct worker *rescuer = wq->rescuer;\n\n\t\t/* this prevents new queueing */\n\t\traw_spin_lock_irq(&wq_mayday_lock);\n\t\twq->rescuer = NULL;\n\t\traw_spin_unlock_irq(&wq_mayday_lock);\n\n\t\t/* rescuer will empty maydays list before exiting */\n\t\tkthread_stop(rescuer->task);\n\t\tkfree(rescuer);\n\t}\n\n\t/*\n\t * Sanity checks - grab all the locks so that we wait for all\n\t * in-flight operations which may do put_pwq().\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq) {\n\t\traw_spin_lock_irq(&pwq->pool->lock);\n\t\tif (WARN_ON(pwq_busy(pwq))) {\n\t\t\tpr_warn(\"%s: %s has the following busy pwq\\n\",\n\t\t\t\t__func__, wq->name);\n\t\t\tshow_pwq(pwq);\n\t\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tmutex_unlock(&wq_pool_mutex);\n\t\t\tshow_one_workqueue(wq);\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_irq(&pwq->pool->lock);\n\t}\n\tmutex_unlock(&wq->mutex);\n\n\t/*\n\t * wq list is used to freeze wq, remove from list after\n\t * flushing is complete in case freeze races us.\n\t */\n\tlist_del_rcu(&wq->list);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq_unregister_lockdep(wq);\n\t\t/*\n\t\t * The base ref is never dropped on per-cpu pwqs.  Directly\n\t\t * schedule RCU free.\n\t\t */\n\t\tcall_rcu(&wq->rcu, rcu_free_wq);\n\t} else {\n\t\t/*\n\t\t * We're the sole accessor of @wq at this point.  Directly\n\t\t * access numa_pwq_tbl[] and dfl_pwq to put the base refs.\n\t\t * @wq will be freed when the last pwq is released.\n\t\t */\n\t\tfor_each_node(node) {\n\t\t\tpwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\t\t\tRCU_INIT_POINTER(wq->numa_pwq_tbl[node], NULL);\n\t\t\tput_pwq_unlocked(pwq);\n\t\t}\n\n\t\t/*\n\t\t * Put dfl_pwq.  @wq may be freed any time after dfl_pwq is\n\t\t * put.  Don't access it afterwards.\n\t\t */\n\t\tpwq = wq->dfl_pwq;\n\t\twq->dfl_pwq = NULL;\n\t\tput_pwq_unlocked(pwq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "pinst->cpumask.cbcpu"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "pinst->cpumask.pcpu"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&pinst->pslist)"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pinst->pslist"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_state_remove_instance_nocalls",
          "args": [
            "hp_online",
            "&pinst->cpu_online_node"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_state_remove_instance_nocalls",
          "args": [
            "CPUHP_PADATA_DEAD",
            "&pinst->cpu_dead_node"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(CPUHP_PADATA_DEAD,\n\t\t\t\t\t    &pinst->cpu_dead_node);\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->cpu_online_node);\n#endif\n\n\tWARN_ON(!list_empty(&pinst->pslist));\n\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tdestroy_workqueue(pinst->serial_wq);\n\tdestroy_workqueue(pinst->parallel_wq);\n\tkfree(pinst);\n}"
  },
  {
    "function_name": "padata_cpu_dead",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "802-815",
    "snippet": "static int padata_cpu_dead(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct padata_instance *pinst;\n\tint ret;\n\n\tpinst = hlist_entry_safe(node, struct padata_instance, cpu_dead_node);\n\tif (!pinst_has_cpu(pinst, cpu))\n\t\treturn 0;\n\n\tmutex_lock(&pinst->lock);\n\tret = __padata_remove_cpu(pinst, cpu);\n\tmutex_unlock(&pinst->lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pinst->lock"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__padata_remove_cpu",
          "args": [
            "pinst",
            "cpu"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_remove_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "766-779",
          "snippet": "static int __padata_remove_cpu(struct padata_instance *pinst, int cpu)\n{\n\tint err = 0;\n\n\tif (!cpumask_test_cpu(cpu, cpu_online_mask)) {\n\t\tif (!padata_validate_cpumask(pinst, pinst->cpumask.pcpu) ||\n\t\t    !padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_stop(pinst);\n\n\t\terr = padata_replace(pinst);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic int __padata_remove_cpu(struct padata_instance *pinst, int cpu)\n{\n\tint err = 0;\n\n\tif (!cpumask_test_cpu(cpu, cpu_online_mask)) {\n\t\tif (!padata_validate_cpumask(pinst, pinst->cpumask.pcpu) ||\n\t\t    !padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_stop(pinst);\n\n\t\terr = padata_replace(pinst);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pinst->lock"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pinst_has_cpu",
          "args": [
            "pinst",
            "cpu"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "pinst_has_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "781-785",
          "snippet": "static inline int pinst_has_cpu(struct padata_instance *pinst, int cpu)\n{\n\treturn cpumask_test_cpu(cpu, pinst->cpumask.pcpu) ||\n\t\tcpumask_test_cpu(cpu, pinst->cpumask.cbcpu);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic inline int pinst_has_cpu(struct padata_instance *pinst, int cpu)\n{\n\treturn cpumask_test_cpu(cpu, pinst->cpumask.pcpu) ||\n\t\tcpumask_test_cpu(cpu, pinst->cpumask.cbcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry_safe",
          "args": [
            "node",
            "structpadata_instance",
            "cpu_dead_node"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic int padata_cpu_dead(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct padata_instance *pinst;\n\tint ret;\n\n\tpinst = hlist_entry_safe(node, struct padata_instance, cpu_dead_node);\n\tif (!pinst_has_cpu(pinst, cpu))\n\t\treturn 0;\n\n\tmutex_lock(&pinst->lock);\n\tret = __padata_remove_cpu(pinst, cpu);\n\tmutex_unlock(&pinst->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "padata_cpu_online",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "787-800",
    "snippet": "static int padata_cpu_online(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct padata_instance *pinst;\n\tint ret;\n\n\tpinst = hlist_entry_safe(node, struct padata_instance, cpu_online_node);\n\tif (!pinst_has_cpu(pinst, cpu))\n\t\treturn 0;\n\n\tmutex_lock(&pinst->lock);\n\tret = __padata_add_cpu(pinst, cpu);\n\tmutex_unlock(&pinst->lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pinst->lock"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__padata_add_cpu",
          "args": [
            "pinst",
            "cpu"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_add_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "751-764",
          "snippet": "static int __padata_add_cpu(struct padata_instance *pinst, int cpu)\n{\n\tint err = 0;\n\n\tif (cpumask_test_cpu(cpu, cpu_online_mask)) {\n\t\terr = padata_replace(pinst);\n\n\t\tif (padata_validate_cpumask(pinst, pinst->cpumask.pcpu) &&\n\t\t    padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_start(pinst);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic int __padata_add_cpu(struct padata_instance *pinst, int cpu)\n{\n\tint err = 0;\n\n\tif (cpumask_test_cpu(cpu, cpu_online_mask)) {\n\t\terr = padata_replace(pinst);\n\n\t\tif (padata_validate_cpumask(pinst, pinst->cpumask.pcpu) &&\n\t\t    padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_start(pinst);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pinst->lock"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pinst_has_cpu",
          "args": [
            "pinst",
            "cpu"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "pinst_has_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "781-785",
          "snippet": "static inline int pinst_has_cpu(struct padata_instance *pinst, int cpu)\n{\n\treturn cpumask_test_cpu(cpu, pinst->cpumask.pcpu) ||\n\t\tcpumask_test_cpu(cpu, pinst->cpumask.cbcpu);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic inline int pinst_has_cpu(struct padata_instance *pinst, int cpu)\n{\n\treturn cpumask_test_cpu(cpu, pinst->cpumask.pcpu) ||\n\t\tcpumask_test_cpu(cpu, pinst->cpumask.cbcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry_safe",
          "args": [
            "node",
            "structpadata_instance",
            "cpu_online_node"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic int padata_cpu_online(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct padata_instance *pinst;\n\tint ret;\n\n\tpinst = hlist_entry_safe(node, struct padata_instance, cpu_online_node);\n\tif (!pinst_has_cpu(pinst, cpu))\n\t\treturn 0;\n\n\tmutex_lock(&pinst->lock);\n\tret = __padata_add_cpu(pinst, cpu);\n\tmutex_unlock(&pinst->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "pinst_has_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "781-785",
    "snippet": "static inline int pinst_has_cpu(struct padata_instance *pinst, int cpu)\n{\n\treturn cpumask_test_cpu(cpu, pinst->cpumask.pcpu) ||\n\t\tcpumask_test_cpu(cpu, pinst->cpumask.cbcpu);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "pinst->cpumask.cbcpu"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "pinst->cpumask.pcpu"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic inline int pinst_has_cpu(struct padata_instance *pinst, int cpu)\n{\n\treturn cpumask_test_cpu(cpu, pinst->cpumask.pcpu) ||\n\t\tcpumask_test_cpu(cpu, pinst->cpumask.cbcpu);\n}"
  },
  {
    "function_name": "__padata_remove_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "766-779",
    "snippet": "static int __padata_remove_cpu(struct padata_instance *pinst, int cpu)\n{\n\tint err = 0;\n\n\tif (!cpumask_test_cpu(cpu, cpu_online_mask)) {\n\t\tif (!padata_validate_cpumask(pinst, pinst->cpumask.pcpu) ||\n\t\t    !padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_stop(pinst);\n\n\t\terr = padata_replace(pinst);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "padata_replace",
          "args": [
            "pinst"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "padata_replace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "641-663",
          "snippet": "static int padata_replace(struct padata_instance *pinst)\n{\n\tstruct padata_shell *ps;\n\tint err = 0;\n\n\tpinst->flags |= PADATA_RESET;\n\n\tlist_for_each_entry(ps, &pinst->pslist, list) {\n\t\terr = padata_replace_one(ps);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_continue_reverse(ps, &pinst->pslist, list)\n\t\tif (refcount_dec_and_test(&ps->opd->refcnt))\n\t\t\tpadata_free_pd(ps->opd);\n\n\tpinst->flags &= ~PADATA_RESET;\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic int padata_replace(struct padata_instance *pinst)\n{\n\tstruct padata_shell *ps;\n\tint err = 0;\n\n\tpinst->flags |= PADATA_RESET;\n\n\tlist_for_each_entry(ps, &pinst->pslist, list) {\n\t\terr = padata_replace_one(ps);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_continue_reverse(ps, &pinst->pslist, list)\n\t\tif (refcount_dec_and_test(&ps->opd->refcnt))\n\t\t\tpadata_free_pd(ps->opd);\n\n\tpinst->flags &= ~PADATA_RESET;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__padata_stop",
          "args": [
            "pinst"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "616-624",
          "snippet": "static void __padata_stop(struct padata_instance *pinst)\n{\n\tif (!(pinst->flags & PADATA_INIT))\n\t\treturn;\n\n\tpinst->flags &= ~PADATA_INIT;\n\n\tsynchronize_rcu();\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __padata_stop(struct padata_instance *pinst)\n{\n\tif (!(pinst->flags & PADATA_INIT))\n\t\treturn;\n\n\tpinst->flags &= ~PADATA_INIT;\n\n\tsynchronize_rcu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_validate_cpumask",
          "args": [
            "pinst",
            "pinst->cpumask.cbcpu"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "padata_validate_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "666-676",
          "snippet": "static bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "cpu_online_mask"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic int __padata_remove_cpu(struct padata_instance *pinst, int cpu)\n{\n\tint err = 0;\n\n\tif (!cpumask_test_cpu(cpu, cpu_online_mask)) {\n\t\tif (!padata_validate_cpumask(pinst, pinst->cpumask.pcpu) ||\n\t\t    !padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_stop(pinst);\n\n\t\terr = padata_replace(pinst);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "__padata_add_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "751-764",
    "snippet": "static int __padata_add_cpu(struct padata_instance *pinst, int cpu)\n{\n\tint err = 0;\n\n\tif (cpumask_test_cpu(cpu, cpu_online_mask)) {\n\t\terr = padata_replace(pinst);\n\n\t\tif (padata_validate_cpumask(pinst, pinst->cpumask.pcpu) &&\n\t\t    padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_start(pinst);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__padata_start",
          "args": [
            "pinst"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "611-614",
          "snippet": "static void __padata_start(struct padata_instance *pinst)\n{\n\tpinst->flags |= PADATA_INIT;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __padata_start(struct padata_instance *pinst)\n{\n\tpinst->flags |= PADATA_INIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_validate_cpumask",
          "args": [
            "pinst",
            "pinst->cpumask.cbcpu"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "padata_validate_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "666-676",
          "snippet": "static bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_replace",
          "args": [
            "pinst"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "padata_replace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "641-663",
          "snippet": "static int padata_replace(struct padata_instance *pinst)\n{\n\tstruct padata_shell *ps;\n\tint err = 0;\n\n\tpinst->flags |= PADATA_RESET;\n\n\tlist_for_each_entry(ps, &pinst->pslist, list) {\n\t\terr = padata_replace_one(ps);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_continue_reverse(ps, &pinst->pslist, list)\n\t\tif (refcount_dec_and_test(&ps->opd->refcnt))\n\t\t\tpadata_free_pd(ps->opd);\n\n\tpinst->flags &= ~PADATA_RESET;\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic int padata_replace(struct padata_instance *pinst)\n{\n\tstruct padata_shell *ps;\n\tint err = 0;\n\n\tpinst->flags |= PADATA_RESET;\n\n\tlist_for_each_entry(ps, &pinst->pslist, list) {\n\t\terr = padata_replace_one(ps);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_continue_reverse(ps, &pinst->pslist, list)\n\t\tif (refcount_dec_and_test(&ps->opd->refcnt))\n\t\t\tpadata_free_pd(ps->opd);\n\n\tpinst->flags &= ~PADATA_RESET;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "cpu_online_mask"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic int __padata_add_cpu(struct padata_instance *pinst, int cpu)\n{\n\tint err = 0;\n\n\tif (cpumask_test_cpu(cpu, cpu_online_mask)) {\n\t\terr = padata_replace(pinst);\n\n\t\tif (padata_validate_cpumask(pinst, pinst->cpumask.pcpu) &&\n\t\t    padata_validate_cpumask(pinst, pinst->cpumask.cbcpu))\n\t\t\t__padata_start(pinst);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "padata_set_cpumask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "717-746",
    "snippet": "int padata_set_cpumask(struct padata_instance *pinst, int cpumask_type,\n\t\t       cpumask_var_t cpumask)\n{\n\tstruct cpumask *serial_mask, *parallel_mask;\n\tint err = -EINVAL;\n\n\tcpus_read_lock();\n\tmutex_lock(&pinst->lock);\n\n\tswitch (cpumask_type) {\n\tcase PADATA_CPU_PARALLEL:\n\t\tserial_mask = pinst->cpumask.cbcpu;\n\t\tparallel_mask = cpumask;\n\t\tbreak;\n\tcase PADATA_CPU_SERIAL:\n\t\tparallel_mask = pinst->cpumask.pcpu;\n\t\tserial_mask = cpumask;\n\t\tbreak;\n\tdefault:\n\t\t goto out;\n\t}\n\n\terr =  __padata_set_cpumasks(pinst, parallel_mask, serial_mask);\n\nout:\n\tmutex_unlock(&pinst->lock);\n\tcpus_read_unlock();\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pinst->lock"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__padata_set_cpumasks",
          "args": [
            "pinst",
            "parallel_mask",
            "serial_mask"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_set_cpumasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "678-705",
          "snippet": "static int __padata_set_cpumasks(struct padata_instance *pinst,\n\t\t\t\t cpumask_var_t pcpumask,\n\t\t\t\t cpumask_var_t cbcpumask)\n{\n\tint valid;\n\tint err;\n\n\tvalid = padata_validate_cpumask(pinst, pcpumask);\n\tif (!valid) {\n\t\t__padata_stop(pinst);\n\t\tgoto out_replace;\n\t}\n\n\tvalid = padata_validate_cpumask(pinst, cbcpumask);\n\tif (!valid)\n\t\t__padata_stop(pinst);\n\nout_replace:\n\tcpumask_copy(pinst->cpumask.pcpu, pcpumask);\n\tcpumask_copy(pinst->cpumask.cbcpu, cbcpumask);\n\n\terr = padata_setup_cpumasks(pinst) ?: padata_replace(pinst);\n\n\tif (valid)\n\t\t__padata_start(pinst);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic int __padata_set_cpumasks(struct padata_instance *pinst,\n\t\t\t\t cpumask_var_t pcpumask,\n\t\t\t\t cpumask_var_t cbcpumask)\n{\n\tint valid;\n\tint err;\n\n\tvalid = padata_validate_cpumask(pinst, pcpumask);\n\tif (!valid) {\n\t\t__padata_stop(pinst);\n\t\tgoto out_replace;\n\t}\n\n\tvalid = padata_validate_cpumask(pinst, cbcpumask);\n\tif (!valid)\n\t\t__padata_stop(pinst);\n\nout_replace:\n\tcpumask_copy(pinst->cpumask.pcpu, pcpumask);\n\tcpumask_copy(pinst->cpumask.cbcpu, cbcpumask);\n\n\terr = padata_setup_cpumasks(pinst) ?: padata_replace(pinst);\n\n\tif (valid)\n\t\t__padata_start(pinst);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pinst->lock"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nint padata_set_cpumask(struct padata_instance *pinst, int cpumask_type,\n\t\t       cpumask_var_t cpumask)\n{\n\tstruct cpumask *serial_mask, *parallel_mask;\n\tint err = -EINVAL;\n\n\tcpus_read_lock();\n\tmutex_lock(&pinst->lock);\n\n\tswitch (cpumask_type) {\n\tcase PADATA_CPU_PARALLEL:\n\t\tserial_mask = pinst->cpumask.cbcpu;\n\t\tparallel_mask = cpumask;\n\t\tbreak;\n\tcase PADATA_CPU_SERIAL:\n\t\tparallel_mask = pinst->cpumask.pcpu;\n\t\tserial_mask = cpumask;\n\t\tbreak;\n\tdefault:\n\t\t goto out;\n\t}\n\n\terr =  __padata_set_cpumasks(pinst, parallel_mask, serial_mask);\n\nout:\n\tmutex_unlock(&pinst->lock);\n\tcpus_read_unlock();\n\n\treturn err;\n}"
  },
  {
    "function_name": "__padata_set_cpumasks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "678-705",
    "snippet": "static int __padata_set_cpumasks(struct padata_instance *pinst,\n\t\t\t\t cpumask_var_t pcpumask,\n\t\t\t\t cpumask_var_t cbcpumask)\n{\n\tint valid;\n\tint err;\n\n\tvalid = padata_validate_cpumask(pinst, pcpumask);\n\tif (!valid) {\n\t\t__padata_stop(pinst);\n\t\tgoto out_replace;\n\t}\n\n\tvalid = padata_validate_cpumask(pinst, cbcpumask);\n\tif (!valid)\n\t\t__padata_stop(pinst);\n\nout_replace:\n\tcpumask_copy(pinst->cpumask.pcpu, pcpumask);\n\tcpumask_copy(pinst->cpumask.cbcpu, cbcpumask);\n\n\terr = padata_setup_cpumasks(pinst) ?: padata_replace(pinst);\n\n\tif (valid)\n\t\t__padata_start(pinst);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__padata_start",
          "args": [
            "pinst"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "611-614",
          "snippet": "static void __padata_start(struct padata_instance *pinst)\n{\n\tpinst->flags |= PADATA_INIT;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __padata_start(struct padata_instance *pinst)\n{\n\tpinst->flags |= PADATA_INIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_replace",
          "args": [
            "pinst"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "padata_replace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "641-663",
          "snippet": "static int padata_replace(struct padata_instance *pinst)\n{\n\tstruct padata_shell *ps;\n\tint err = 0;\n\n\tpinst->flags |= PADATA_RESET;\n\n\tlist_for_each_entry(ps, &pinst->pslist, list) {\n\t\terr = padata_replace_one(ps);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_continue_reverse(ps, &pinst->pslist, list)\n\t\tif (refcount_dec_and_test(&ps->opd->refcnt))\n\t\t\tpadata_free_pd(ps->opd);\n\n\tpinst->flags &= ~PADATA_RESET;\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic int padata_replace(struct padata_instance *pinst)\n{\n\tstruct padata_shell *ps;\n\tint err = 0;\n\n\tpinst->flags |= PADATA_RESET;\n\n\tlist_for_each_entry(ps, &pinst->pslist, list) {\n\t\terr = padata_replace_one(ps);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_continue_reverse(ps, &pinst->pslist, list)\n\t\tif (refcount_dec_and_test(&ps->opd->refcnt))\n\t\t\tpadata_free_pd(ps->opd);\n\n\tpinst->flags &= ~PADATA_RESET;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_setup_cpumasks",
          "args": [
            "pinst"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "padata_setup_cpumasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "411-426",
          "snippet": "static int padata_setup_cpumasks(struct padata_instance *pinst)\n{\n\tstruct workqueue_attrs *attrs;\n\tint err;\n\n\tattrs = alloc_workqueue_attrs();\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\t/* Restrict parallel_wq workers to pd->cpumask.pcpu. */\n\tcpumask_copy(attrs->cpumask, pinst->cpumask.pcpu);\n\terr = apply_workqueue_attrs(pinst->parallel_wq, attrs);\n\tfree_workqueue_attrs(attrs);\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void padata_free_pd(struct parallel_data *pd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic int padata_setup_cpumasks(struct padata_instance *pinst)\n{\n\tstruct workqueue_attrs *attrs;\n\tint err;\n\n\tattrs = alloc_workqueue_attrs();\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\t/* Restrict parallel_wq workers to pd->cpumask.pcpu. */\n\tcpumask_copy(attrs->cpumask, pinst->cpumask.pcpu);\n\terr = apply_workqueue_attrs(pinst->parallel_wq, attrs);\n\tfree_workqueue_attrs(attrs);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "pinst->cpumask.cbcpu",
            "cbcpumask"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "pinst->cpumask.pcpu",
            "pcpumask"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__padata_stop",
          "args": [
            "pinst"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "616-624",
          "snippet": "static void __padata_stop(struct padata_instance *pinst)\n{\n\tif (!(pinst->flags & PADATA_INIT))\n\t\treturn;\n\n\tpinst->flags &= ~PADATA_INIT;\n\n\tsynchronize_rcu();\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __padata_stop(struct padata_instance *pinst)\n{\n\tif (!(pinst->flags & PADATA_INIT))\n\t\treturn;\n\n\tpinst->flags &= ~PADATA_INIT;\n\n\tsynchronize_rcu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_validate_cpumask",
          "args": [
            "pinst",
            "cbcpumask"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "padata_validate_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "666-676",
          "snippet": "static bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic int __padata_set_cpumasks(struct padata_instance *pinst,\n\t\t\t\t cpumask_var_t pcpumask,\n\t\t\t\t cpumask_var_t cbcpumask)\n{\n\tint valid;\n\tint err;\n\n\tvalid = padata_validate_cpumask(pinst, pcpumask);\n\tif (!valid) {\n\t\t__padata_stop(pinst);\n\t\tgoto out_replace;\n\t}\n\n\tvalid = padata_validate_cpumask(pinst, cbcpumask);\n\tif (!valid)\n\t\t__padata_stop(pinst);\n\nout_replace:\n\tcpumask_copy(pinst->cpumask.pcpu, pcpumask);\n\tcpumask_copy(pinst->cpumask.cbcpu, cbcpumask);\n\n\terr = padata_setup_cpumasks(pinst) ?: padata_replace(pinst);\n\n\tif (valid)\n\t\t__padata_start(pinst);\n\n\treturn err;\n}"
  },
  {
    "function_name": "padata_validate_cpumask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "666-676",
    "snippet": "static bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "cpumask",
            "cpu_online_mask"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic bool padata_validate_cpumask(struct padata_instance *pinst,\n\t\t\t\t    const struct cpumask *cpumask)\n{\n\tif (!cpumask_intersects(cpumask, cpu_online_mask)) {\n\t\tpinst->flags |= PADATA_INVALID;\n\t\treturn false;\n\t}\n\n\tpinst->flags &= ~PADATA_INVALID;\n\treturn true;\n}"
  },
  {
    "function_name": "padata_replace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "641-663",
    "snippet": "static int padata_replace(struct padata_instance *pinst)\n{\n\tstruct padata_shell *ps;\n\tint err = 0;\n\n\tpinst->flags |= PADATA_RESET;\n\n\tlist_for_each_entry(ps, &pinst->pslist, list) {\n\t\terr = padata_replace_one(ps);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_continue_reverse(ps, &pinst->pslist, list)\n\t\tif (refcount_dec_and_test(&ps->opd->refcnt))\n\t\t\tpadata_free_pd(ps->opd);\n\n\tpinst->flags &= ~PADATA_RESET;\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "padata_free_pd",
          "args": [
            "ps->opd"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "padata_free_pd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "602-609",
          "snippet": "static void padata_free_pd(struct parallel_data *pd)\n{\n\tfree_cpumask_var(pd->cpumask.pcpu);\n\tfree_cpumask_var(pd->cpumask.cbcpu);\n\tfree_percpu(pd->reorder_list);\n\tfree_percpu(pd->squeue);\n\tkfree(pd);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void padata_free_pd(struct parallel_data *pd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic void padata_free_pd(struct parallel_data *pd)\n{\n\tfree_cpumask_var(pd->cpumask.pcpu);\n\tfree_cpumask_var(pd->cpumask.cbcpu);\n\tfree_percpu(pd->reorder_list);\n\tfree_percpu(pd->squeue);\n\tkfree(pd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&ps->opd->refcnt"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue_reverse",
          "args": [
            "ps",
            "&pinst->pslist",
            "list"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_replace_one",
          "args": [
            "ps"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "padata_replace_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "627-639",
          "snippet": "static int padata_replace_one(struct padata_shell *ps)\n{\n\tstruct parallel_data *pd_new;\n\n\tpd_new = padata_alloc_pd(ps);\n\tif (!pd_new)\n\t\treturn -ENOMEM;\n\n\tps->opd = rcu_dereference_protected(ps->pd, 1);\n\trcu_assign_pointer(ps->pd, pd_new);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void padata_free_pd(struct parallel_data *pd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic int padata_replace_one(struct padata_shell *ps)\n{\n\tstruct parallel_data *pd_new;\n\n\tpd_new = padata_alloc_pd(ps);\n\tif (!pd_new)\n\t\treturn -ENOMEM;\n\n\tps->opd = rcu_dereference_protected(ps->pd, 1);\n\trcu_assign_pointer(ps->pd, pd_new);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ps",
            "&pinst->pslist",
            "list"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic int padata_replace(struct padata_instance *pinst)\n{\n\tstruct padata_shell *ps;\n\tint err = 0;\n\n\tpinst->flags |= PADATA_RESET;\n\n\tlist_for_each_entry(ps, &pinst->pslist, list) {\n\t\terr = padata_replace_one(ps);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_continue_reverse(ps, &pinst->pslist, list)\n\t\tif (refcount_dec_and_test(&ps->opd->refcnt))\n\t\t\tpadata_free_pd(ps->opd);\n\n\tpinst->flags &= ~PADATA_RESET;\n\n\treturn err;\n}"
  },
  {
    "function_name": "padata_replace_one",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "627-639",
    "snippet": "static int padata_replace_one(struct padata_shell *ps)\n{\n\tstruct parallel_data *pd_new;\n\n\tpd_new = padata_alloc_pd(ps);\n\tif (!pd_new)\n\t\treturn -ENOMEM;\n\n\tps->opd = rcu_dereference_protected(ps->pd, 1);\n\trcu_assign_pointer(ps->pd, pd_new);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void padata_free_pd(struct parallel_data *pd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "ps->pd",
            "pd_new"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "ps->pd",
            "1"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_alloc_pd",
          "args": [
            "ps"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "padata_alloc_pd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "553-600",
          "snippet": "static struct parallel_data *padata_alloc_pd(struct padata_shell *ps)\n{\n\tstruct padata_instance *pinst = ps->pinst;\n\tstruct parallel_data *pd;\n\n\tpd = kzalloc(sizeof(struct parallel_data), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto err;\n\n\tpd->reorder_list = alloc_percpu(struct padata_list);\n\tif (!pd->reorder_list)\n\t\tgoto err_free_pd;\n\n\tpd->squeue = alloc_percpu(struct padata_serial_queue);\n\tif (!pd->squeue)\n\t\tgoto err_free_reorder_list;\n\n\tpd->ps = ps;\n\n\tif (!alloc_cpumask_var(&pd->cpumask.pcpu, GFP_KERNEL))\n\t\tgoto err_free_squeue;\n\tif (!alloc_cpumask_var(&pd->cpumask.cbcpu, GFP_KERNEL))\n\t\tgoto err_free_pcpu;\n\n\tcpumask_and(pd->cpumask.pcpu, pinst->cpumask.pcpu, cpu_online_mask);\n\tcpumask_and(pd->cpumask.cbcpu, pinst->cpumask.cbcpu, cpu_online_mask);\n\n\tpadata_init_reorder_list(pd);\n\tpadata_init_squeues(pd);\n\tpd->seq_nr = -1;\n\trefcount_set(&pd->refcnt, 1);\n\tspin_lock_init(&pd->lock);\n\tpd->cpu = cpumask_first(pd->cpumask.pcpu);\n\tINIT_WORK(&pd->reorder_work, invoke_padata_reorder);\n\n\treturn pd;\n\nerr_free_pcpu:\n\tfree_cpumask_var(pd->cpumask.pcpu);\nerr_free_squeue:\n\tfree_percpu(pd->squeue);\nerr_free_reorder_list:\n\tfree_percpu(pd->reorder_list);\nerr_free_pd:\n\tkfree(pd);\nerr:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void padata_free_pd(struct parallel_data *pd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic struct parallel_data *padata_alloc_pd(struct padata_shell *ps)\n{\n\tstruct padata_instance *pinst = ps->pinst;\n\tstruct parallel_data *pd;\n\n\tpd = kzalloc(sizeof(struct parallel_data), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto err;\n\n\tpd->reorder_list = alloc_percpu(struct padata_list);\n\tif (!pd->reorder_list)\n\t\tgoto err_free_pd;\n\n\tpd->squeue = alloc_percpu(struct padata_serial_queue);\n\tif (!pd->squeue)\n\t\tgoto err_free_reorder_list;\n\n\tpd->ps = ps;\n\n\tif (!alloc_cpumask_var(&pd->cpumask.pcpu, GFP_KERNEL))\n\t\tgoto err_free_squeue;\n\tif (!alloc_cpumask_var(&pd->cpumask.cbcpu, GFP_KERNEL))\n\t\tgoto err_free_pcpu;\n\n\tcpumask_and(pd->cpumask.pcpu, pinst->cpumask.pcpu, cpu_online_mask);\n\tcpumask_and(pd->cpumask.cbcpu, pinst->cpumask.cbcpu, cpu_online_mask);\n\n\tpadata_init_reorder_list(pd);\n\tpadata_init_squeues(pd);\n\tpd->seq_nr = -1;\n\trefcount_set(&pd->refcnt, 1);\n\tspin_lock_init(&pd->lock);\n\tpd->cpu = cpumask_first(pd->cpumask.pcpu);\n\tINIT_WORK(&pd->reorder_work, invoke_padata_reorder);\n\n\treturn pd;\n\nerr_free_pcpu:\n\tfree_cpumask_var(pd->cpumask.pcpu);\nerr_free_squeue:\n\tfree_percpu(pd->squeue);\nerr_free_reorder_list:\n\tfree_percpu(pd->reorder_list);\nerr_free_pd:\n\tkfree(pd);\nerr:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic int padata_replace_one(struct padata_shell *ps)\n{\n\tstruct parallel_data *pd_new;\n\n\tpd_new = padata_alloc_pd(ps);\n\tif (!pd_new)\n\t\treturn -ENOMEM;\n\n\tps->opd = rcu_dereference_protected(ps->pd, 1);\n\trcu_assign_pointer(ps->pd, pd_new);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__padata_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "616-624",
    "snippet": "static void __padata_stop(struct padata_instance *pinst)\n{\n\tif (!(pinst->flags & PADATA_INIT))\n\t\treturn;\n\n\tpinst->flags &= ~PADATA_INIT;\n\n\tsynchronize_rcu();\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __padata_stop(struct padata_instance *pinst)\n{\n\tif (!(pinst->flags & PADATA_INIT))\n\t\treturn;\n\n\tpinst->flags &= ~PADATA_INIT;\n\n\tsynchronize_rcu();\n}"
  },
  {
    "function_name": "__padata_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "611-614",
    "snippet": "static void __padata_start(struct padata_instance *pinst)\n{\n\tpinst->flags |= PADATA_INIT;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __padata_start(struct padata_instance *pinst)\n{\n\tpinst->flags |= PADATA_INIT;\n}"
  },
  {
    "function_name": "padata_free_pd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "602-609",
    "snippet": "static void padata_free_pd(struct parallel_data *pd)\n{\n\tfree_cpumask_var(pd->cpumask.pcpu);\n\tfree_cpumask_var(pd->cpumask.cbcpu);\n\tfree_percpu(pd->reorder_list);\n\tfree_percpu(pd->squeue);\n\tkfree(pd);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void padata_free_pd(struct parallel_data *pd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pd"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "pd->squeue"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "pd->cpumask.cbcpu"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "pd->cpumask.pcpu"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic void padata_free_pd(struct parallel_data *pd)\n{\n\tfree_cpumask_var(pd->cpumask.pcpu);\n\tfree_cpumask_var(pd->cpumask.cbcpu);\n\tfree_percpu(pd->reorder_list);\n\tfree_percpu(pd->squeue);\n\tkfree(pd);\n}"
  },
  {
    "function_name": "padata_alloc_pd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "553-600",
    "snippet": "static struct parallel_data *padata_alloc_pd(struct padata_shell *ps)\n{\n\tstruct padata_instance *pinst = ps->pinst;\n\tstruct parallel_data *pd;\n\n\tpd = kzalloc(sizeof(struct parallel_data), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto err;\n\n\tpd->reorder_list = alloc_percpu(struct padata_list);\n\tif (!pd->reorder_list)\n\t\tgoto err_free_pd;\n\n\tpd->squeue = alloc_percpu(struct padata_serial_queue);\n\tif (!pd->squeue)\n\t\tgoto err_free_reorder_list;\n\n\tpd->ps = ps;\n\n\tif (!alloc_cpumask_var(&pd->cpumask.pcpu, GFP_KERNEL))\n\t\tgoto err_free_squeue;\n\tif (!alloc_cpumask_var(&pd->cpumask.cbcpu, GFP_KERNEL))\n\t\tgoto err_free_pcpu;\n\n\tcpumask_and(pd->cpumask.pcpu, pinst->cpumask.pcpu, cpu_online_mask);\n\tcpumask_and(pd->cpumask.cbcpu, pinst->cpumask.cbcpu, cpu_online_mask);\n\n\tpadata_init_reorder_list(pd);\n\tpadata_init_squeues(pd);\n\tpd->seq_nr = -1;\n\trefcount_set(&pd->refcnt, 1);\n\tspin_lock_init(&pd->lock);\n\tpd->cpu = cpumask_first(pd->cpumask.pcpu);\n\tINIT_WORK(&pd->reorder_work, invoke_padata_reorder);\n\n\treturn pd;\n\nerr_free_pcpu:\n\tfree_cpumask_var(pd->cpumask.pcpu);\nerr_free_squeue:\n\tfree_percpu(pd->squeue);\nerr_free_reorder_list:\n\tfree_percpu(pd->reorder_list);\nerr_free_pd:\n\tkfree(pd);\nerr:\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void padata_free_pd(struct parallel_data *pd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pd"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "pd->reorder_list"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "pd->cpumask.pcpu"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&pd->reorder_work",
            "invoke_padata_reorder"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "pd->cpumask.pcpu"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pd->lock"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&pd->refcnt",
            "1"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_init_squeues",
          "args": [
            "pd"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "padata_init_squeues",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "527-538",
          "snippet": "static void padata_init_squeues(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_serial_queue *squeue;\n\n\tfor_each_cpu(cpu, pd->cpumask.cbcpu) {\n\t\tsqueue = per_cpu_ptr(pd->squeue, cpu);\n\t\tsqueue->pd = pd;\n\t\t__padata_list_init(&squeue->serial);\n\t\tINIT_WORK(&squeue->work, padata_serial_worker);\n\t}\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void padata_free_pd(struct parallel_data *pd);",
            "static void __init padata_mt_helper(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\nstatic void __init padata_mt_helper(struct work_struct *work);\n\nstatic void padata_init_squeues(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_serial_queue *squeue;\n\n\tfor_each_cpu(cpu, pd->cpumask.cbcpu) {\n\t\tsqueue = per_cpu_ptr(pd->squeue, cpu);\n\t\tsqueue->pd = pd;\n\t\t__padata_list_init(&squeue->serial);\n\t\tINIT_WORK(&squeue->work, padata_serial_worker);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_init_reorder_list",
          "args": [
            "pd"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "padata_init_reorder_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "541-550",
          "snippet": "static void padata_init_reorder_list(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_list *list;\n\n\tfor_each_cpu(cpu, pd->cpumask.pcpu) {\n\t\tlist = per_cpu_ptr(pd->reorder_list, cpu);\n\t\t__padata_list_init(list);\n\t}\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void padata_free_pd(struct parallel_data *pd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic void padata_init_reorder_list(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_list *list;\n\n\tfor_each_cpu(cpu, pd->cpumask.pcpu) {\n\t\tlist = per_cpu_ptr(pd->reorder_list, cpu);\n\t\t__padata_list_init(list);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "pd->cpumask.cbcpu",
            "pinst->cpumask.cbcpu",
            "cpu_online_mask"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "pd->cpumask.pcpu",
            "pinst->cpumask.pcpu",
            "cpu_online_mask"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&pd->cpumask.cbcpu",
            "GFP_KERNEL"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&pd->cpumask.pcpu",
            "GFP_KERNEL"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structpadata_serial_queue"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct parallel_data)",
            "GFP_KERNEL"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic struct parallel_data *padata_alloc_pd(struct padata_shell *ps)\n{\n\tstruct padata_instance *pinst = ps->pinst;\n\tstruct parallel_data *pd;\n\n\tpd = kzalloc(sizeof(struct parallel_data), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto err;\n\n\tpd->reorder_list = alloc_percpu(struct padata_list);\n\tif (!pd->reorder_list)\n\t\tgoto err_free_pd;\n\n\tpd->squeue = alloc_percpu(struct padata_serial_queue);\n\tif (!pd->squeue)\n\t\tgoto err_free_reorder_list;\n\n\tpd->ps = ps;\n\n\tif (!alloc_cpumask_var(&pd->cpumask.pcpu, GFP_KERNEL))\n\t\tgoto err_free_squeue;\n\tif (!alloc_cpumask_var(&pd->cpumask.cbcpu, GFP_KERNEL))\n\t\tgoto err_free_pcpu;\n\n\tcpumask_and(pd->cpumask.pcpu, pinst->cpumask.pcpu, cpu_online_mask);\n\tcpumask_and(pd->cpumask.cbcpu, pinst->cpumask.cbcpu, cpu_online_mask);\n\n\tpadata_init_reorder_list(pd);\n\tpadata_init_squeues(pd);\n\tpd->seq_nr = -1;\n\trefcount_set(&pd->refcnt, 1);\n\tspin_lock_init(&pd->lock);\n\tpd->cpu = cpumask_first(pd->cpumask.pcpu);\n\tINIT_WORK(&pd->reorder_work, invoke_padata_reorder);\n\n\treturn pd;\n\nerr_free_pcpu:\n\tfree_cpumask_var(pd->cpumask.pcpu);\nerr_free_squeue:\n\tfree_percpu(pd->squeue);\nerr_free_reorder_list:\n\tfree_percpu(pd->reorder_list);\nerr_free_pd:\n\tkfree(pd);\nerr:\n\treturn NULL;\n}"
  },
  {
    "function_name": "padata_init_reorder_list",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "541-550",
    "snippet": "static void padata_init_reorder_list(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_list *list;\n\n\tfor_each_cpu(cpu, pd->cpumask.pcpu) {\n\t\tlist = per_cpu_ptr(pd->reorder_list, cpu);\n\t\t__padata_list_init(list);\n\t}\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void padata_free_pd(struct parallel_data *pd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__padata_list_init",
          "args": [
            "list"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_list_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "520-524",
          "snippet": "static void __padata_list_init(struct padata_list *pd_list)\n{\n\tINIT_LIST_HEAD(&pd_list->list);\n\tspin_lock_init(&pd_list->lock);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __padata_list_init(struct padata_list *pd_list)\n{\n\tINIT_LIST_HEAD(&pd_list->list);\n\tspin_lock_init(&pd_list->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pd->reorder_list",
            "cpu"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "pd->cpumask.pcpu"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic void padata_init_reorder_list(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_list *list;\n\n\tfor_each_cpu(cpu, pd->cpumask.pcpu) {\n\t\tlist = per_cpu_ptr(pd->reorder_list, cpu);\n\t\t__padata_list_init(list);\n\t}\n}"
  },
  {
    "function_name": "padata_init_squeues",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "527-538",
    "snippet": "static void padata_init_squeues(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_serial_queue *squeue;\n\n\tfor_each_cpu(cpu, pd->cpumask.cbcpu) {\n\t\tsqueue = per_cpu_ptr(pd->squeue, cpu);\n\t\tsqueue->pd = pd;\n\t\t__padata_list_init(&squeue->serial);\n\t\tINIT_WORK(&squeue->work, padata_serial_worker);\n\t}\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void padata_free_pd(struct parallel_data *pd);",
      "static void __init padata_mt_helper(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&squeue->work",
            "padata_serial_worker"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__padata_list_init",
          "args": [
            "&squeue->serial"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_list_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "520-524",
          "snippet": "static void __padata_list_init(struct padata_list *pd_list)\n{\n\tINIT_LIST_HEAD(&pd_list->list);\n\tspin_lock_init(&pd_list->lock);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __padata_list_init(struct padata_list *pd_list)\n{\n\tINIT_LIST_HEAD(&pd_list->list);\n\tspin_lock_init(&pd_list->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pd->squeue",
            "cpu"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "pd->cpumask.cbcpu"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\nstatic void __init padata_mt_helper(struct work_struct *work);\n\nstatic void padata_init_squeues(struct parallel_data *pd)\n{\n\tint cpu;\n\tstruct padata_serial_queue *squeue;\n\n\tfor_each_cpu(cpu, pd->cpumask.cbcpu) {\n\t\tsqueue = per_cpu_ptr(pd->squeue, cpu);\n\t\tsqueue->pd = pd;\n\t\t__padata_list_init(&squeue->serial);\n\t\tINIT_WORK(&squeue->work, padata_serial_worker);\n\t}\n}"
  },
  {
    "function_name": "__padata_list_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "520-524",
    "snippet": "static void __padata_list_init(struct padata_list *pd_list)\n{\n\tINIT_LIST_HEAD(&pd_list->list);\n\tspin_lock_init(&pd_list->lock);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pd_list->lock"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pd_list->list"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __padata_list_init(struct padata_list *pd_list)\n{\n\tINIT_LIST_HEAD(&pd_list->list);\n\tspin_lock_init(&pd_list->lock);\n}"
  },
  {
    "function_name": "padata_do_multithreaded",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "468-518",
    "snippet": "void __init padata_do_multithreaded(struct padata_mt_job *job)\n{\n\t/* In case threads finish at different times. */\n\tstatic const unsigned long load_balance_factor = 4;\n\tstruct padata_work my_work, *pw;\n\tstruct padata_mt_job_state ps;\n\tLIST_HEAD(works);\n\tint nworks;\n\n\tif (job->size == 0)\n\t\treturn;\n\n\t/* Ensure at least one thread when size < min_chunk. */\n\tnworks = max(job->size / job->min_chunk, 1ul);\n\tnworks = min(nworks, job->max_threads);\n\n\tif (nworks == 1) {\n\t\t/* Single thread, no coordination needed, cut to the chase. */\n\t\tjob->thread_fn(job->start, job->start + job->size, job->fn_arg);\n\t\treturn;\n\t}\n\n\tspin_lock_init(&ps.lock);\n\tinit_completion(&ps.completion);\n\tps.job\t       = job;\n\tps.nworks      = padata_work_alloc_mt(nworks, &ps, &works);\n\tps.nworks_fini = 0;\n\n\t/*\n\t * Chunk size is the amount of work a helper does per call to the\n\t * thread function.  Load balance large jobs between threads by\n\t * increasing the number of chunks, guarantee at least the minimum\n\t * chunk size from the caller, and honor the caller's alignment.\n\t */\n\tps.chunk_size = job->size / (ps.nworks * load_balance_factor);\n\tps.chunk_size = max(ps.chunk_size, job->min_chunk);\n\tps.chunk_size = roundup(ps.chunk_size, job->align);\n\n\tlist_for_each_entry(pw, &works, pw_list)\n\t\tqueue_work(system_unbound_wq, &pw->pw_work);\n\n\t/* Use the current thread, which saves starting a workqueue worker. */\n\tpadata_work_init(&my_work, padata_mt_helper, &ps, PADATA_WORK_ONSTACK);\n\tpadata_mt_helper(&my_work.pw_work);\n\n\t/* Wait for all the helpers to finish. */\n\twait_for_completion(&ps.completion);\n\n\tdestroy_work_on_stack(&my_work.pw_work);\n\tpadata_works_free(&works);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [
      "#define\tPADATA_WORK_ONSTACK\t1\t/* Work's memory is on stack */"
    ],
    "globals_used": [
      "static void __init padata_mt_helper(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "padata_works_free",
          "args": [
            "&works"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "padata_works_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "122-135",
          "snippet": "static void __init padata_works_free(struct list_head *works)\n{\n\tstruct padata_work *cur, *next;\n\n\tif (list_empty(works))\n\t\treturn;\n\n\tspin_lock(&padata_works_lock);\n\tlist_for_each_entry_safe(cur, next, works, pw_list) {\n\t\tlist_del(&cur->pw_list);\n\t\tpadata_work_free(cur);\n\t}\n\tspin_unlock(&padata_works_lock);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(padata_works_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic DEFINE_SPINLOCK(padata_works_lock);\n\nstatic void __init padata_works_free(struct list_head *works)\n{\n\tstruct padata_work *cur, *next;\n\n\tif (list_empty(works))\n\t\treturn;\n\n\tspin_lock(&padata_works_lock);\n\tlist_for_each_entry_safe(cur, next, works, pw_list) {\n\t\tlist_del(&cur->pw_list);\n\t\tpadata_work_free(cur);\n\t}\n\tspin_unlock(&padata_works_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_work_on_stack",
          "args": [
            "&my_work.pw_work"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_work_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "522-525",
          "snippet": "void destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&ps.completion"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_mt_helper",
          "args": [
            "&my_work.pw_work"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "padata_mt_helper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "428-460",
          "snippet": "static void __init padata_mt_helper(struct work_struct *w)\n{\n\tstruct padata_work *pw = container_of(w, struct padata_work, pw_work);\n\tstruct padata_mt_job_state *ps = pw->pw_data;\n\tstruct padata_mt_job *job = ps->job;\n\tbool done;\n\n\tspin_lock(&ps->lock);\n\n\twhile (job->size > 0) {\n\t\tunsigned long start, size, end;\n\n\t\tstart = job->start;\n\t\t/* So end is chunk size aligned if enough work remains. */\n\t\tsize = roundup(start + 1, ps->chunk_size) - start;\n\t\tsize = min(size, job->size);\n\t\tend = start + size;\n\n\t\tjob->start = end;\n\t\tjob->size -= size;\n\n\t\tspin_unlock(&ps->lock);\n\t\tjob->thread_fn(start, end, job->fn_arg);\n\t\tspin_lock(&ps->lock);\n\t}\n\n\t++ps->nworks_fini;\n\tdone = (ps->nworks_fini == ps->nworks);\n\tspin_unlock(&ps->lock);\n\n\tif (done)\n\t\tcomplete(&ps->completion);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __init padata_mt_helper(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __init padata_mt_helper(struct work_struct *work);\n\nstatic void __init padata_mt_helper(struct work_struct *w)\n{\n\tstruct padata_work *pw = container_of(w, struct padata_work, pw_work);\n\tstruct padata_mt_job_state *ps = pw->pw_data;\n\tstruct padata_mt_job *job = ps->job;\n\tbool done;\n\n\tspin_lock(&ps->lock);\n\n\twhile (job->size > 0) {\n\t\tunsigned long start, size, end;\n\n\t\tstart = job->start;\n\t\t/* So end is chunk size aligned if enough work remains. */\n\t\tsize = roundup(start + 1, ps->chunk_size) - start;\n\t\tsize = min(size, job->size);\n\t\tend = start + size;\n\n\t\tjob->start = end;\n\t\tjob->size -= size;\n\n\t\tspin_unlock(&ps->lock);\n\t\tjob->thread_fn(start, end, job->fn_arg);\n\t\tspin_lock(&ps->lock);\n\t}\n\n\t++ps->nworks_fini;\n\tdone = (ps->nworks_fini == ps->nworks);\n\tspin_unlock(&ps->lock);\n\n\tif (done)\n\t\tcomplete(&ps->completion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_work_init",
          "args": [
            "&my_work",
            "padata_mt_helper",
            "&ps",
            "PADATA_WORK_ONSTACK"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "padata_work_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "86-94",
          "snippet": "static void padata_work_init(struct padata_work *pw, work_func_t work_fn,\n\t\t\t     void *data, int flags)\n{\n\tif (flags & PADATA_WORK_ONSTACK)\n\t\tINIT_WORK_ONSTACK(&pw->pw_work, work_fn);\n\telse\n\t\tINIT_WORK(&pw->pw_work, work_fn);\n\tpw->pw_data = data;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [
            "#define\tPADATA_WORK_ONSTACK\t1\t/* Work's memory is on stack */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\n#define\tPADATA_WORK_ONSTACK\t1\t/* Work's memory is on stack */\n\nstatic void padata_work_init(struct padata_work *pw, work_func_t work_fn,\n\t\t\t     void *data, int flags)\n{\n\tif (flags & PADATA_WORK_ONSTACK)\n\t\tINIT_WORK_ONSTACK(&pw->pw_work, work_fn);\n\telse\n\t\tINIT_WORK(&pw->pw_work, work_fn);\n\tpw->pw_data = data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "system_unbound_wq",
            "&pw->pw_work"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "93-113",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pw",
            "&works",
            "pw_list"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "ps.chunk_size",
            "job->align"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "ps.chunk_size",
            "job->min_chunk"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_work_alloc_mt",
          "args": [
            "nworks",
            "&ps",
            "&works"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "padata_work_alloc_mt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "96-114",
          "snippet": "static int __init padata_work_alloc_mt(int nworks, void *data,\n\t\t\t\t       struct list_head *head)\n{\n\tint i;\n\n\tspin_lock(&padata_works_lock);\n\t/* Start at 1 because the current task participates in the job. */\n\tfor (i = 1; i < nworks; ++i) {\n\t\tstruct padata_work *pw = padata_work_alloc();\n\n\t\tif (!pw)\n\t\t\tbreak;\n\t\tpadata_work_init(pw, padata_mt_helper, data, 0);\n\t\tlist_add(&pw->pw_list, head);\n\t}\n\tspin_unlock(&padata_works_lock);\n\n\treturn i;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(padata_works_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic DEFINE_SPINLOCK(padata_works_lock);\n\nstatic int __init padata_work_alloc_mt(int nworks, void *data,\n\t\t\t\t       struct list_head *head)\n{\n\tint i;\n\n\tspin_lock(&padata_works_lock);\n\t/* Start at 1 because the current task participates in the job. */\n\tfor (i = 1; i < nworks; ++i) {\n\t\tstruct padata_work *pw = padata_work_alloc();\n\n\t\tif (!pw)\n\t\t\tbreak;\n\t\tpadata_work_init(pw, padata_mt_helper, data, 0);\n\t\tlist_add(&pw->pw_list, head);\n\t}\n\tspin_unlock(&padata_works_lock);\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&ps.completion"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ps.lock"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "job->thread_fn",
          "args": [
            "job->start",
            "job->start + job->size",
            "job->fn_arg"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nworks",
            "job->max_threads"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "works"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\n#define\tPADATA_WORK_ONSTACK\t1\t/* Work's memory is on stack */\n\nstatic void __init padata_mt_helper(struct work_struct *work);\n\nvoid __init padata_do_multithreaded(struct padata_mt_job *job)\n{\n\t/* In case threads finish at different times. */\n\tstatic const unsigned long load_balance_factor = 4;\n\tstruct padata_work my_work, *pw;\n\tstruct padata_mt_job_state ps;\n\tLIST_HEAD(works);\n\tint nworks;\n\n\tif (job->size == 0)\n\t\treturn;\n\n\t/* Ensure at least one thread when size < min_chunk. */\n\tnworks = max(job->size / job->min_chunk, 1ul);\n\tnworks = min(nworks, job->max_threads);\n\n\tif (nworks == 1) {\n\t\t/* Single thread, no coordination needed, cut to the chase. */\n\t\tjob->thread_fn(job->start, job->start + job->size, job->fn_arg);\n\t\treturn;\n\t}\n\n\tspin_lock_init(&ps.lock);\n\tinit_completion(&ps.completion);\n\tps.job\t       = job;\n\tps.nworks      = padata_work_alloc_mt(nworks, &ps, &works);\n\tps.nworks_fini = 0;\n\n\t/*\n\t * Chunk size is the amount of work a helper does per call to the\n\t * thread function.  Load balance large jobs between threads by\n\t * increasing the number of chunks, guarantee at least the minimum\n\t * chunk size from the caller, and honor the caller's alignment.\n\t */\n\tps.chunk_size = job->size / (ps.nworks * load_balance_factor);\n\tps.chunk_size = max(ps.chunk_size, job->min_chunk);\n\tps.chunk_size = roundup(ps.chunk_size, job->align);\n\n\tlist_for_each_entry(pw, &works, pw_list)\n\t\tqueue_work(system_unbound_wq, &pw->pw_work);\n\n\t/* Use the current thread, which saves starting a workqueue worker. */\n\tpadata_work_init(&my_work, padata_mt_helper, &ps, PADATA_WORK_ONSTACK);\n\tpadata_mt_helper(&my_work.pw_work);\n\n\t/* Wait for all the helpers to finish. */\n\twait_for_completion(&ps.completion);\n\n\tdestroy_work_on_stack(&my_work.pw_work);\n\tpadata_works_free(&works);\n}"
  },
  {
    "function_name": "padata_mt_helper",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "428-460",
    "snippet": "static void __init padata_mt_helper(struct work_struct *w)\n{\n\tstruct padata_work *pw = container_of(w, struct padata_work, pw_work);\n\tstruct padata_mt_job_state *ps = pw->pw_data;\n\tstruct padata_mt_job *job = ps->job;\n\tbool done;\n\n\tspin_lock(&ps->lock);\n\n\twhile (job->size > 0) {\n\t\tunsigned long start, size, end;\n\n\t\tstart = job->start;\n\t\t/* So end is chunk size aligned if enough work remains. */\n\t\tsize = roundup(start + 1, ps->chunk_size) - start;\n\t\tsize = min(size, job->size);\n\t\tend = start + size;\n\n\t\tjob->start = end;\n\t\tjob->size -= size;\n\n\t\tspin_unlock(&ps->lock);\n\t\tjob->thread_fn(start, end, job->fn_arg);\n\t\tspin_lock(&ps->lock);\n\t}\n\n\t++ps->nworks_fini;\n\tdone = (ps->nworks_fini == ps->nworks);\n\tspin_unlock(&ps->lock);\n\n\tif (done)\n\t\tcomplete(&ps->completion);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __init padata_mt_helper(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&ps->completion"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ps->lock"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ps->lock"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "job->thread_fn",
          "args": [
            "start",
            "end",
            "job->fn_arg"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "size",
            "job->size"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "start + 1",
            "ps->chunk_size"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "w",
            "structpadata_work",
            "pw_work"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __init padata_mt_helper(struct work_struct *work);\n\nstatic void __init padata_mt_helper(struct work_struct *w)\n{\n\tstruct padata_work *pw = container_of(w, struct padata_work, pw_work);\n\tstruct padata_mt_job_state *ps = pw->pw_data;\n\tstruct padata_mt_job *job = ps->job;\n\tbool done;\n\n\tspin_lock(&ps->lock);\n\n\twhile (job->size > 0) {\n\t\tunsigned long start, size, end;\n\n\t\tstart = job->start;\n\t\t/* So end is chunk size aligned if enough work remains. */\n\t\tsize = roundup(start + 1, ps->chunk_size) - start;\n\t\tsize = min(size, job->size);\n\t\tend = start + size;\n\n\t\tjob->start = end;\n\t\tjob->size -= size;\n\n\t\tspin_unlock(&ps->lock);\n\t\tjob->thread_fn(start, end, job->fn_arg);\n\t\tspin_lock(&ps->lock);\n\t}\n\n\t++ps->nworks_fini;\n\tdone = (ps->nworks_fini == ps->nworks);\n\tspin_unlock(&ps->lock);\n\n\tif (done)\n\t\tcomplete(&ps->completion);\n}"
  },
  {
    "function_name": "padata_setup_cpumasks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "411-426",
    "snippet": "static int padata_setup_cpumasks(struct padata_instance *pinst)\n{\n\tstruct workqueue_attrs *attrs;\n\tint err;\n\n\tattrs = alloc_workqueue_attrs();\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\t/* Restrict parallel_wq workers to pd->cpumask.pcpu. */\n\tcpumask_copy(attrs->cpumask, pinst->cpumask.pcpu);\n\terr = apply_workqueue_attrs(pinst->parallel_wq, attrs);\n\tfree_workqueue_attrs(attrs);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void padata_free_pd(struct parallel_data *pd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "attrs"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3385-3391",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_workqueue_attrs",
          "args": [
            "pinst->parallel_wq",
            "attrs"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "apply_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4115-4127",
          "snippet": "int apply_workqueue_attrs(struct workqueue_struct *wq,\n\t\t\t  const struct workqueue_attrs *attrs)\n{\n\tint ret;\n\n\tlockdep_assert_cpus_held();\n\n\tmutex_lock(&wq_pool_mutex);\n\tret = apply_workqueue_attrs_locked(wq, attrs);\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nint apply_workqueue_attrs(struct workqueue_struct *wq,\n\t\t\t  const struct workqueue_attrs *attrs)\n{\n\tint ret;\n\n\tlockdep_assert_cpus_held();\n\n\tmutex_lock(&wq_pool_mutex);\n\tret = apply_workqueue_attrs_locked(wq, attrs);\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "attrs->cpumask",
            "pinst->cpumask.pcpu"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue_attrs",
          "args": [],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue_attrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3401-3416",
          "snippet": "struct workqueue_attrs *alloc_workqueue_attrs(void)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, GFP_KERNEL))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct workqueue_attrs *alloc_workqueue_attrs(void)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, GFP_KERNEL))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic int padata_setup_cpumasks(struct padata_instance *pinst)\n{\n\tstruct workqueue_attrs *attrs;\n\tint err;\n\n\tattrs = alloc_workqueue_attrs();\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\t/* Restrict parallel_wq workers to pd->cpumask.pcpu. */\n\tcpumask_copy(attrs->cpumask, pinst->cpumask.pcpu);\n\terr = apply_workqueue_attrs(pinst->parallel_wq, attrs);\n\tfree_workqueue_attrs(attrs);\n\n\treturn err;\n}"
  },
  {
    "function_name": "padata_do_serial",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "385-408",
    "snippet": "void padata_do_serial(struct padata_priv *padata)\n{\n\tstruct parallel_data *pd = padata->pd;\n\tint hashed_cpu = padata_cpu_hash(pd, padata->seq_nr);\n\tstruct padata_list *reorder = per_cpu_ptr(pd->reorder_list, hashed_cpu);\n\tstruct padata_priv *cur;\n\n\tspin_lock(&reorder->lock);\n\t/* Sort in ascending order of sequence number. */\n\tlist_for_each_entry_reverse(cur, &reorder->list, list)\n\t\tif (cur->seq_nr < padata->seq_nr)\n\t\t\tbreak;\n\tlist_add(&padata->list, &cur->list);\n\tspin_unlock(&reorder->lock);\n\n\t/*\n\t * Ensure the addition to the reorder list is ordered correctly\n\t * with the trylock of pd->lock in padata_reorder.  Pairs with smp_mb\n\t * in padata_reorder.\n\t */\n\tsmp_mb();\n\n\tpadata_reorder(pd);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void padata_free_pd(struct parallel_data *pd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "padata_reorder",
          "args": [
            "pd"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_padata_reorder",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "333-341",
          "snippet": "static void invoke_padata_reorder(struct work_struct *work)\n{\n\tstruct parallel_data *pd;\n\n\tlocal_bh_disable();\n\tpd = container_of(work, struct parallel_data, reorder_work);\n\tpadata_reorder(pd);\n\tlocal_bh_enable();\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void padata_free_pd(struct parallel_data *pd);",
            "static void __init padata_mt_helper(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\nstatic void __init padata_mt_helper(struct work_struct *work);\n\nstatic void invoke_padata_reorder(struct work_struct *work)\n{\n\tstruct parallel_data *pd;\n\n\tlocal_bh_disable();\n\tpd = container_of(work, struct parallel_data, reorder_work);\n\tpadata_reorder(pd);\n\tlocal_bh_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&reorder->lock"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&padata->list",
            "&cur->list"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "cur",
            "&reorder->list",
            "list"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&reorder->lock"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pd->reorder_list",
            "hashed_cpu"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata_cpu_hash",
          "args": [
            "pd",
            "padata->seq_nr"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "padata_cpu_hash",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "61-70",
          "snippet": "static int padata_cpu_hash(struct parallel_data *pd, unsigned int seq_nr)\n{\n\t/*\n\t * Hash the sequence numbers to the cpus by taking\n\t * seq_nr mod. number of cpus in use.\n\t */\n\tint cpu_index = seq_nr % cpumask_weight(pd->cpumask.pcpu);\n\n\treturn padata_index_to_cpu(pd, cpu_index);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void padata_free_pd(struct parallel_data *pd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic int padata_cpu_hash(struct parallel_data *pd, unsigned int seq_nr)\n{\n\t/*\n\t * Hash the sequence numbers to the cpus by taking\n\t * seq_nr mod. number of cpus in use.\n\t */\n\tint cpu_index = seq_nr % cpumask_weight(pd->cpumask.pcpu);\n\n\treturn padata_index_to_cpu(pd, cpu_index);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nvoid padata_do_serial(struct padata_priv *padata)\n{\n\tstruct parallel_data *pd = padata->pd;\n\tint hashed_cpu = padata_cpu_hash(pd, padata->seq_nr);\n\tstruct padata_list *reorder = per_cpu_ptr(pd->reorder_list, hashed_cpu);\n\tstruct padata_priv *cur;\n\n\tspin_lock(&reorder->lock);\n\t/* Sort in ascending order of sequence number. */\n\tlist_for_each_entry_reverse(cur, &reorder->list, list)\n\t\tif (cur->seq_nr < padata->seq_nr)\n\t\t\tbreak;\n\tlist_add(&padata->list, &cur->list);\n\tspin_unlock(&reorder->lock);\n\n\t/*\n\t * Ensure the addition to the reorder list is ordered correctly\n\t * with the trylock of pd->lock in padata_reorder.  Pairs with smp_mb\n\t * in padata_reorder.\n\t */\n\tsmp_mb();\n\n\tpadata_reorder(pd);\n}"
  },
  {
    "function_name": "padata_serial_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "343-375",
    "snippet": "static void padata_serial_worker(struct work_struct *serial_work)\n{\n\tstruct padata_serial_queue *squeue;\n\tstruct parallel_data *pd;\n\tLIST_HEAD(local_list);\n\tint cnt;\n\n\tlocal_bh_disable();\n\tsqueue = container_of(serial_work, struct padata_serial_queue, work);\n\tpd = squeue->pd;\n\n\tspin_lock(&squeue->serial.lock);\n\tlist_replace_init(&squeue->serial.list, &local_list);\n\tspin_unlock(&squeue->serial.lock);\n\n\tcnt = 0;\n\n\twhile (!list_empty(&local_list)) {\n\t\tstruct padata_priv *padata;\n\n\t\tpadata = list_entry(local_list.next,\n\t\t\t\t    struct padata_priv, list);\n\n\t\tlist_del_init(&padata->list);\n\n\t\tpadata->serial(padata);\n\t\tcnt++;\n\t}\n\tlocal_bh_enable();\n\n\tif (refcount_sub_and_test(cnt, &pd->refcnt))\n\t\tpadata_free_pd(pd);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void padata_free_pd(struct parallel_data *pd);",
      "static void __init padata_mt_helper(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "padata_free_pd",
          "args": [
            "pd"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "padata_free_pd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "602-609",
          "snippet": "static void padata_free_pd(struct parallel_data *pd)\n{\n\tfree_cpumask_var(pd->cpumask.pcpu);\n\tfree_cpumask_var(pd->cpumask.cbcpu);\n\tfree_percpu(pd->reorder_list);\n\tfree_percpu(pd->squeue);\n\tkfree(pd);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void padata_free_pd(struct parallel_data *pd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic void padata_free_pd(struct parallel_data *pd)\n{\n\tfree_cpumask_var(pd->cpumask.pcpu);\n\tfree_cpumask_var(pd->cpumask.cbcpu);\n\tfree_percpu(pd->reorder_list);\n\tfree_percpu(pd->squeue);\n\tkfree(pd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_sub_and_test",
          "args": [
            "cnt",
            "&pd->refcnt"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "353-357",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata->serial",
          "args": [
            "padata"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&padata->list"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "local_list.next",
            "structpadata_priv",
            "list"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&local_list"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&squeue->serial.lock"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_replace_init",
          "args": [
            "&squeue->serial.list",
            "&local_list"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&squeue->serial.lock"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "serial_work",
            "structpadata_serial_queue",
            "work"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "local_list"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\nstatic void __init padata_mt_helper(struct work_struct *work);\n\nstatic void padata_serial_worker(struct work_struct *serial_work)\n{\n\tstruct padata_serial_queue *squeue;\n\tstruct parallel_data *pd;\n\tLIST_HEAD(local_list);\n\tint cnt;\n\n\tlocal_bh_disable();\n\tsqueue = container_of(serial_work, struct padata_serial_queue, work);\n\tpd = squeue->pd;\n\n\tspin_lock(&squeue->serial.lock);\n\tlist_replace_init(&squeue->serial.list, &local_list);\n\tspin_unlock(&squeue->serial.lock);\n\n\tcnt = 0;\n\n\twhile (!list_empty(&local_list)) {\n\t\tstruct padata_priv *padata;\n\n\t\tpadata = list_entry(local_list.next,\n\t\t\t\t    struct padata_priv, list);\n\n\t\tlist_del_init(&padata->list);\n\n\t\tpadata->serial(padata);\n\t\tcnt++;\n\t}\n\tlocal_bh_enable();\n\n\tif (refcount_sub_and_test(cnt, &pd->refcnt))\n\t\tpadata_free_pd(pd);\n}"
  },
  {
    "function_name": "invoke_padata_reorder",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "333-341",
    "snippet": "static void invoke_padata_reorder(struct work_struct *work)\n{\n\tstruct parallel_data *pd;\n\n\tlocal_bh_disable();\n\tpd = container_of(work, struct parallel_data, reorder_work);\n\tpadata_reorder(pd);\n\tlocal_bh_enable();\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void padata_free_pd(struct parallel_data *pd);",
      "static void __init padata_mt_helper(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "353-357",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_reorder",
          "args": [
            "pd"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_padata_reorder",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "333-341",
          "snippet": "static void invoke_padata_reorder(struct work_struct *work)\n{\n\tstruct parallel_data *pd;\n\n\tlocal_bh_disable();\n\tpd = container_of(work, struct parallel_data, reorder_work);\n\tpadata_reorder(pd);\n\tlocal_bh_enable();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structparallel_data",
            "reorder_work"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\nstatic void __init padata_mt_helper(struct work_struct *work);\n\nstatic void invoke_padata_reorder(struct work_struct *work)\n{\n\tstruct parallel_data *pd;\n\n\tlocal_bh_disable();\n\tpd = container_of(work, struct parallel_data, reorder_work);\n\tpadata_reorder(pd);\n\tlocal_bh_enable();\n}"
  },
  {
    "function_name": "padata_reorder",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "274-331",
    "snippet": "static void padata_reorder(struct parallel_data *pd)\n{\n\tstruct padata_instance *pinst = pd->ps->pinst;\n\tint cb_cpu;\n\tstruct padata_priv *padata;\n\tstruct padata_serial_queue *squeue;\n\tstruct padata_list *reorder;\n\n\t/*\n\t * We need to ensure that only one cpu can work on dequeueing of\n\t * the reorder queue the time. Calculating in which percpu reorder\n\t * queue the next object will arrive takes some time. A spinlock\n\t * would be highly contended. Also it is not clear in which order\n\t * the objects arrive to the reorder queues. So a cpu could wait to\n\t * get the lock just to notice that there is nothing to do at the\n\t * moment. Therefore we use a trylock and let the holder of the lock\n\t * care for all the objects enqueued during the holdtime of the lock.\n\t */\n\tif (!spin_trylock_bh(&pd->lock))\n\t\treturn;\n\n\twhile (1) {\n\t\tpadata = padata_find_next(pd, true);\n\n\t\t/*\n\t\t * If the next object that needs serialization is parallel\n\t\t * processed by another cpu and is still on it's way to the\n\t\t * cpu's reorder queue, nothing to do for now.\n\t\t */\n\t\tif (!padata)\n\t\t\tbreak;\n\n\t\tcb_cpu = padata->cb_cpu;\n\t\tsqueue = per_cpu_ptr(pd->squeue, cb_cpu);\n\n\t\tspin_lock(&squeue->serial.lock);\n\t\tlist_add_tail(&padata->list, &squeue->serial.list);\n\t\tspin_unlock(&squeue->serial.lock);\n\n\t\tqueue_work_on(cb_cpu, pinst->serial_wq, &squeue->work);\n\t}\n\n\tspin_unlock_bh(&pd->lock);\n\n\t/*\n\t * The next object that needs serialization might have arrived to\n\t * the reorder queues in the meantime.\n\t *\n\t * Ensure reorder queue is read after pd->lock is dropped so we see\n\t * new objects from another task in padata_do_serial.  Pairs with\n\t * smp_mb in padata_do_serial.\n\t */\n\tsmp_mb();\n\n\treorder = per_cpu_ptr(pd->reorder_list, pd->cpu);\n\tif (!list_empty(&reorder->list) && padata_find_next(pd, false))\n\t\tqueue_work(pinst->serial_wq, &pd->reorder_work);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void padata_free_pd(struct parallel_data *pd);",
      "static void __init padata_mt_helper(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "pinst->serial_wq",
            "&pd->reorder_work"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "93-113",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_find_next",
          "args": [
            "pd",
            "false"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "padata_find_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "238-272",
          "snippet": "static struct padata_priv *padata_find_next(struct parallel_data *pd,\n\t\t\t\t\t    bool remove_object)\n{\n\tstruct padata_priv *padata;\n\tstruct padata_list *reorder;\n\tint cpu = pd->cpu;\n\n\treorder = per_cpu_ptr(pd->reorder_list, cpu);\n\n\tspin_lock(&reorder->lock);\n\tif (list_empty(&reorder->list)) {\n\t\tspin_unlock(&reorder->lock);\n\t\treturn NULL;\n\t}\n\n\tpadata = list_entry(reorder->list.next, struct padata_priv, list);\n\n\t/*\n\t * Checks the rare case where two or more parallel jobs have hashed to\n\t * the same CPU and one of the later ones finishes first.\n\t */\n\tif (padata->seq_nr != pd->processed) {\n\t\tspin_unlock(&reorder->lock);\n\t\treturn NULL;\n\t}\n\n\tif (remove_object) {\n\t\tlist_del_init(&padata->list);\n\t\t++pd->processed;\n\t\tpd->cpu = cpumask_next_wrap(cpu, pd->cpumask.pcpu, -1, false);\n\t}\n\n\tspin_unlock(&reorder->lock);\n\treturn padata;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void padata_free_pd(struct parallel_data *pd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic struct padata_priv *padata_find_next(struct parallel_data *pd,\n\t\t\t\t\t    bool remove_object)\n{\n\tstruct padata_priv *padata;\n\tstruct padata_list *reorder;\n\tint cpu = pd->cpu;\n\n\treorder = per_cpu_ptr(pd->reorder_list, cpu);\n\n\tspin_lock(&reorder->lock);\n\tif (list_empty(&reorder->list)) {\n\t\tspin_unlock(&reorder->lock);\n\t\treturn NULL;\n\t}\n\n\tpadata = list_entry(reorder->list.next, struct padata_priv, list);\n\n\t/*\n\t * Checks the rare case where two or more parallel jobs have hashed to\n\t * the same CPU and one of the later ones finishes first.\n\t */\n\tif (padata->seq_nr != pd->processed) {\n\t\tspin_unlock(&reorder->lock);\n\t\treturn NULL;\n\t}\n\n\tif (remove_object) {\n\t\tlist_del_init(&padata->list);\n\t\t++pd->processed;\n\t\tpd->cpu = cpumask_next_wrap(cpu, pd->cpumask.pcpu, -1, false);\n\t}\n\n\tspin_unlock(&reorder->lock);\n\treturn padata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&reorder->list"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pd->reorder_list",
            "pd->cpu"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&pd->lock"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work_on",
          "args": [
            "cb_cpu",
            "pinst->serial_wq",
            "&squeue->work"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "queue_work_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1553-1568",
          "snippet": "bool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&squeue->serial.lock"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&padata->list",
            "&squeue->serial.list"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&squeue->serial.lock"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pd->squeue",
            "cb_cpu"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock_bh",
          "args": [
            "&pd->lock"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_trylock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "144-147",
          "snippet": "int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\nstatic void __init padata_mt_helper(struct work_struct *work);\n\nstatic void padata_reorder(struct parallel_data *pd)\n{\n\tstruct padata_instance *pinst = pd->ps->pinst;\n\tint cb_cpu;\n\tstruct padata_priv *padata;\n\tstruct padata_serial_queue *squeue;\n\tstruct padata_list *reorder;\n\n\t/*\n\t * We need to ensure that only one cpu can work on dequeueing of\n\t * the reorder queue the time. Calculating in which percpu reorder\n\t * queue the next object will arrive takes some time. A spinlock\n\t * would be highly contended. Also it is not clear in which order\n\t * the objects arrive to the reorder queues. So a cpu could wait to\n\t * get the lock just to notice that there is nothing to do at the\n\t * moment. Therefore we use a trylock and let the holder of the lock\n\t * care for all the objects enqueued during the holdtime of the lock.\n\t */\n\tif (!spin_trylock_bh(&pd->lock))\n\t\treturn;\n\n\twhile (1) {\n\t\tpadata = padata_find_next(pd, true);\n\n\t\t/*\n\t\t * If the next object that needs serialization is parallel\n\t\t * processed by another cpu and is still on it's way to the\n\t\t * cpu's reorder queue, nothing to do for now.\n\t\t */\n\t\tif (!padata)\n\t\t\tbreak;\n\n\t\tcb_cpu = padata->cb_cpu;\n\t\tsqueue = per_cpu_ptr(pd->squeue, cb_cpu);\n\n\t\tspin_lock(&squeue->serial.lock);\n\t\tlist_add_tail(&padata->list, &squeue->serial.list);\n\t\tspin_unlock(&squeue->serial.lock);\n\n\t\tqueue_work_on(cb_cpu, pinst->serial_wq, &squeue->work);\n\t}\n\n\tspin_unlock_bh(&pd->lock);\n\n\t/*\n\t * The next object that needs serialization might have arrived to\n\t * the reorder queues in the meantime.\n\t *\n\t * Ensure reorder queue is read after pd->lock is dropped so we see\n\t * new objects from another task in padata_do_serial.  Pairs with\n\t * smp_mb in padata_do_serial.\n\t */\n\tsmp_mb();\n\n\treorder = per_cpu_ptr(pd->reorder_list, pd->cpu);\n\tif (!list_empty(&reorder->list) && padata_find_next(pd, false))\n\t\tqueue_work(pinst->serial_wq, &pd->reorder_work);\n}"
  },
  {
    "function_name": "padata_find_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "238-272",
    "snippet": "static struct padata_priv *padata_find_next(struct parallel_data *pd,\n\t\t\t\t\t    bool remove_object)\n{\n\tstruct padata_priv *padata;\n\tstruct padata_list *reorder;\n\tint cpu = pd->cpu;\n\n\treorder = per_cpu_ptr(pd->reorder_list, cpu);\n\n\tspin_lock(&reorder->lock);\n\tif (list_empty(&reorder->list)) {\n\t\tspin_unlock(&reorder->lock);\n\t\treturn NULL;\n\t}\n\n\tpadata = list_entry(reorder->list.next, struct padata_priv, list);\n\n\t/*\n\t * Checks the rare case where two or more parallel jobs have hashed to\n\t * the same CPU and one of the later ones finishes first.\n\t */\n\tif (padata->seq_nr != pd->processed) {\n\t\tspin_unlock(&reorder->lock);\n\t\treturn NULL;\n\t}\n\n\tif (remove_object) {\n\t\tlist_del_init(&padata->list);\n\t\t++pd->processed;\n\t\tpd->cpu = cpumask_next_wrap(cpu, pd->cpumask.pcpu, -1, false);\n\t}\n\n\tspin_unlock(&reorder->lock);\n\treturn padata;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void padata_free_pd(struct parallel_data *pd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&reorder->lock"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_next_wrap",
          "args": [
            "cpu",
            "pd->cpumask.pcpu",
            "-1",
            "false"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&padata->list"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "reorder->list.next",
            "structpadata_priv",
            "list"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&reorder->list"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&reorder->lock"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pd->reorder_list",
            "cpu"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic struct padata_priv *padata_find_next(struct parallel_data *pd,\n\t\t\t\t\t    bool remove_object)\n{\n\tstruct padata_priv *padata;\n\tstruct padata_list *reorder;\n\tint cpu = pd->cpu;\n\n\treorder = per_cpu_ptr(pd->reorder_list, cpu);\n\n\tspin_lock(&reorder->lock);\n\tif (list_empty(&reorder->list)) {\n\t\tspin_unlock(&reorder->lock);\n\t\treturn NULL;\n\t}\n\n\tpadata = list_entry(reorder->list.next, struct padata_priv, list);\n\n\t/*\n\t * Checks the rare case where two or more parallel jobs have hashed to\n\t * the same CPU and one of the later ones finishes first.\n\t */\n\tif (padata->seq_nr != pd->processed) {\n\t\tspin_unlock(&reorder->lock);\n\t\treturn NULL;\n\t}\n\n\tif (remove_object) {\n\t\tlist_del_init(&padata->list);\n\t\t++pd->processed;\n\t\tpd->cpu = cpumask_next_wrap(cpu, pd->cpumask.pcpu, -1, false);\n\t}\n\n\tspin_unlock(&reorder->lock);\n\treturn padata;\n}"
  },
  {
    "function_name": "padata_do_parallel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "167-225",
    "snippet": "int padata_do_parallel(struct padata_shell *ps,\n\t\t       struct padata_priv *padata, int *cb_cpu)\n{\n\tstruct padata_instance *pinst = ps->pinst;\n\tint i, cpu, cpu_index, err;\n\tstruct parallel_data *pd;\n\tstruct padata_work *pw;\n\n\trcu_read_lock_bh();\n\n\tpd = rcu_dereference_bh(ps->pd);\n\n\terr = -EINVAL;\n\tif (!(pinst->flags & PADATA_INIT) || pinst->flags & PADATA_INVALID)\n\t\tgoto out;\n\n\tif (!cpumask_test_cpu(*cb_cpu, pd->cpumask.cbcpu)) {\n\t\tif (!cpumask_weight(pd->cpumask.cbcpu))\n\t\t\tgoto out;\n\n\t\t/* Select an alternate fallback CPU and notify the caller. */\n\t\tcpu_index = *cb_cpu % cpumask_weight(pd->cpumask.cbcpu);\n\n\t\tcpu = cpumask_first(pd->cpumask.cbcpu);\n\t\tfor (i = 0; i < cpu_index; i++)\n\t\t\tcpu = cpumask_next(cpu, pd->cpumask.cbcpu);\n\n\t\t*cb_cpu = cpu;\n\t}\n\n\terr =  -EBUSY;\n\tif ((pinst->flags & PADATA_RESET))\n\t\tgoto out;\n\n\trefcount_inc(&pd->refcnt);\n\tpadata->pd = pd;\n\tpadata->cb_cpu = *cb_cpu;\n\n\tspin_lock(&padata_works_lock);\n\tpadata->seq_nr = ++pd->seq_nr;\n\tpw = padata_work_alloc();\n\tspin_unlock(&padata_works_lock);\n\n\trcu_read_unlock_bh();\n\n\tif (pw) {\n\t\tpadata_work_init(pw, padata_parallel_worker, padata, 0);\n\t\tqueue_work(pinst->parallel_wq, &pw->pw_work);\n\t} else {\n\t\t/* Maximum works limit exceeded, run in the current task. */\n\t\tpadata->parallel(padata);\n\t}\n\n\treturn 0;\nout:\n\trcu_read_unlock_bh();\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(padata_works_lock);",
      "static void padata_free_pd(struct parallel_data *pd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_bh",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padata->parallel",
          "args": [
            "padata"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "pinst->parallel_wq",
            "&pw->pw_work"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "93-113",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_work_init",
          "args": [
            "pw",
            "padata_parallel_worker",
            "padata",
            "0"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "padata_work_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "86-94",
          "snippet": "static void padata_work_init(struct padata_work *pw, work_func_t work_fn,\n\t\t\t     void *data, int flags)\n{\n\tif (flags & PADATA_WORK_ONSTACK)\n\t\tINIT_WORK_ONSTACK(&pw->pw_work, work_fn);\n\telse\n\t\tINIT_WORK(&pw->pw_work, work_fn);\n\tpw->pw_data = data;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [
            "#define\tPADATA_WORK_ONSTACK\t1\t/* Work's memory is on stack */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\n#define\tPADATA_WORK_ONSTACK\t1\t/* Work's memory is on stack */\n\nstatic void padata_work_init(struct padata_work *pw, work_func_t work_fn,\n\t\t\t     void *data, int flags)\n{\n\tif (flags & PADATA_WORK_ONSTACK)\n\t\tINIT_WORK_ONSTACK(&pw->pw_work, work_fn);\n\telse\n\t\tINIT_WORK(&pw->pw_work, work_fn);\n\tpw->pw_data = data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_bh",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&padata_works_lock"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_work_alloc",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "padata_work_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "72-84",
          "snippet": "static struct padata_work *padata_work_alloc(void)\n{\n\tstruct padata_work *pw;\n\n\tlockdep_assert_held(&padata_works_lock);\n\n\tif (list_empty(&padata_free_works))\n\t\treturn NULL;\t/* No more work items allowed to be queued. */\n\n\tpw = list_first_entry(&padata_free_works, struct padata_work, pw_list);\n\tlist_del(&pw->pw_list);\n\treturn pw;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(padata_works_lock);",
            "static LIST_HEAD(padata_free_works);",
            "static void __init padata_mt_helper(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic DEFINE_SPINLOCK(padata_works_lock);\nstatic LIST_HEAD(padata_free_works);\nstatic void __init padata_mt_helper(struct work_struct *work);\n\nstatic struct padata_work *padata_work_alloc(void)\n{\n\tstruct padata_work *pw;\n\n\tlockdep_assert_held(&padata_works_lock);\n\n\tif (list_empty(&padata_free_works))\n\t\treturn NULL;\t/* No more work items allowed to be queued. */\n\n\tpw = list_first_entry(&padata_free_works, struct padata_work, pw_list);\n\tlist_del(&pw->pw_list);\n\treturn pw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&padata_works_lock"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_inc",
          "args": [
            "&pd->refcnt"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events.c",
          "lines": "53-56",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/syscall.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/syscall.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "cpu",
            "pd->cpumask.cbcpu"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "pd->cpumask.cbcpu"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "pd->cpumask.cbcpu"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "pd->cpumask.cbcpu"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "*cb_cpu",
            "pd->cpumask.cbcpu"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_bh",
          "args": [
            "ps->pd"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_bh",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "330-337",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic DEFINE_SPINLOCK(padata_works_lock);\nstatic void padata_free_pd(struct parallel_data *pd);\n\nint padata_do_parallel(struct padata_shell *ps,\n\t\t       struct padata_priv *padata, int *cb_cpu)\n{\n\tstruct padata_instance *pinst = ps->pinst;\n\tint i, cpu, cpu_index, err;\n\tstruct parallel_data *pd;\n\tstruct padata_work *pw;\n\n\trcu_read_lock_bh();\n\n\tpd = rcu_dereference_bh(ps->pd);\n\n\terr = -EINVAL;\n\tif (!(pinst->flags & PADATA_INIT) || pinst->flags & PADATA_INVALID)\n\t\tgoto out;\n\n\tif (!cpumask_test_cpu(*cb_cpu, pd->cpumask.cbcpu)) {\n\t\tif (!cpumask_weight(pd->cpumask.cbcpu))\n\t\t\tgoto out;\n\n\t\t/* Select an alternate fallback CPU and notify the caller. */\n\t\tcpu_index = *cb_cpu % cpumask_weight(pd->cpumask.cbcpu);\n\n\t\tcpu = cpumask_first(pd->cpumask.cbcpu);\n\t\tfor (i = 0; i < cpu_index; i++)\n\t\t\tcpu = cpumask_next(cpu, pd->cpumask.cbcpu);\n\n\t\t*cb_cpu = cpu;\n\t}\n\n\terr =  -EBUSY;\n\tif ((pinst->flags & PADATA_RESET))\n\t\tgoto out;\n\n\trefcount_inc(&pd->refcnt);\n\tpadata->pd = pd;\n\tpadata->cb_cpu = *cb_cpu;\n\n\tspin_lock(&padata_works_lock);\n\tpadata->seq_nr = ++pd->seq_nr;\n\tpw = padata_work_alloc();\n\tspin_unlock(&padata_works_lock);\n\n\trcu_read_unlock_bh();\n\n\tif (pw) {\n\t\tpadata_work_init(pw, padata_parallel_worker, padata, 0);\n\t\tqueue_work(pinst->parallel_wq, &pw->pw_work);\n\t} else {\n\t\t/* Maximum works limit exceeded, run in the current task. */\n\t\tpadata->parallel(padata);\n\t}\n\n\treturn 0;\nout:\n\trcu_read_unlock_bh();\n\n\treturn err;\n}"
  },
  {
    "function_name": "padata_parallel_worker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "137-149",
    "snippet": "static void padata_parallel_worker(struct work_struct *parallel_work)\n{\n\tstruct padata_work *pw = container_of(parallel_work, struct padata_work,\n\t\t\t\t\t      pw_work);\n\tstruct padata_priv *padata = pw->pw_data;\n\n\tlocal_bh_disable();\n\tpadata->parallel(padata);\n\tspin_lock(&padata_works_lock);\n\tpadata_work_free(pw);\n\tspin_unlock(&padata_works_lock);\n\tlocal_bh_enable();\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(padata_works_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "353-357",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&padata_works_lock"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_work_free",
          "args": [
            "pw"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "padata_work_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "116-120",
          "snippet": "static void padata_work_free(struct padata_work *pw)\n{\n\tlockdep_assert_held(&padata_works_lock);\n\tlist_add(&pw->pw_list, &padata_free_works);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(padata_works_lock);",
            "static LIST_HEAD(padata_free_works);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic DEFINE_SPINLOCK(padata_works_lock);\nstatic LIST_HEAD(padata_free_works);\n\nstatic void padata_work_free(struct padata_work *pw)\n{\n\tlockdep_assert_held(&padata_works_lock);\n\tlist_add(&pw->pw_list, &padata_free_works);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&padata_works_lock"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata->parallel",
          "args": [
            "padata"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "parallel_work",
            "structpadata_work",
            "pw_work"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic DEFINE_SPINLOCK(padata_works_lock);\n\nstatic void padata_parallel_worker(struct work_struct *parallel_work)\n{\n\tstruct padata_work *pw = container_of(parallel_work, struct padata_work,\n\t\t\t\t\t      pw_work);\n\tstruct padata_priv *padata = pw->pw_data;\n\n\tlocal_bh_disable();\n\tpadata->parallel(padata);\n\tspin_lock(&padata_works_lock);\n\tpadata_work_free(pw);\n\tspin_unlock(&padata_works_lock);\n\tlocal_bh_enable();\n}"
  },
  {
    "function_name": "padata_works_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "122-135",
    "snippet": "static void __init padata_works_free(struct list_head *works)\n{\n\tstruct padata_work *cur, *next;\n\n\tif (list_empty(works))\n\t\treturn;\n\n\tspin_lock(&padata_works_lock);\n\tlist_for_each_entry_safe(cur, next, works, pw_list) {\n\t\tlist_del(&cur->pw_list);\n\t\tpadata_work_free(cur);\n\t}\n\tspin_unlock(&padata_works_lock);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(padata_works_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&padata_works_lock"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_work_free",
          "args": [
            "cur"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "padata_work_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "116-120",
          "snippet": "static void padata_work_free(struct padata_work *pw)\n{\n\tlockdep_assert_held(&padata_works_lock);\n\tlist_add(&pw->pw_list, &padata_free_works);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(padata_works_lock);",
            "static LIST_HEAD(padata_free_works);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic DEFINE_SPINLOCK(padata_works_lock);\nstatic LIST_HEAD(padata_free_works);\n\nstatic void padata_work_free(struct padata_work *pw)\n{\n\tlockdep_assert_held(&padata_works_lock);\n\tlist_add(&pw->pw_list, &padata_free_works);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cur->pw_list"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "cur",
            "next",
            "works",
            "pw_list"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&padata_works_lock"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "works"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic DEFINE_SPINLOCK(padata_works_lock);\n\nstatic void __init padata_works_free(struct list_head *works)\n{\n\tstruct padata_work *cur, *next;\n\n\tif (list_empty(works))\n\t\treturn;\n\n\tspin_lock(&padata_works_lock);\n\tlist_for_each_entry_safe(cur, next, works, pw_list) {\n\t\tlist_del(&cur->pw_list);\n\t\tpadata_work_free(cur);\n\t}\n\tspin_unlock(&padata_works_lock);\n}"
  },
  {
    "function_name": "padata_work_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "116-120",
    "snippet": "static void padata_work_free(struct padata_work *pw)\n{\n\tlockdep_assert_held(&padata_works_lock);\n\tlist_add(&pw->pw_list, &padata_free_works);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(padata_works_lock);",
      "static LIST_HEAD(padata_free_works);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&pw->pw_list",
            "&padata_free_works"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&padata_works_lock"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic DEFINE_SPINLOCK(padata_works_lock);\nstatic LIST_HEAD(padata_free_works);\n\nstatic void padata_work_free(struct padata_work *pw)\n{\n\tlockdep_assert_held(&padata_works_lock);\n\tlist_add(&pw->pw_list, &padata_free_works);\n}"
  },
  {
    "function_name": "padata_work_alloc_mt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "96-114",
    "snippet": "static int __init padata_work_alloc_mt(int nworks, void *data,\n\t\t\t\t       struct list_head *head)\n{\n\tint i;\n\n\tspin_lock(&padata_works_lock);\n\t/* Start at 1 because the current task participates in the job. */\n\tfor (i = 1; i < nworks; ++i) {\n\t\tstruct padata_work *pw = padata_work_alloc();\n\n\t\tif (!pw)\n\t\t\tbreak;\n\t\tpadata_work_init(pw, padata_mt_helper, data, 0);\n\t\tlist_add(&pw->pw_list, head);\n\t}\n\tspin_unlock(&padata_works_lock);\n\n\treturn i;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(padata_works_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&padata_works_lock"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&pw->pw_list",
            "head"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_work_init",
          "args": [
            "pw",
            "padata_mt_helper",
            "data",
            "0"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "padata_work_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "86-94",
          "snippet": "static void padata_work_init(struct padata_work *pw, work_func_t work_fn,\n\t\t\t     void *data, int flags)\n{\n\tif (flags & PADATA_WORK_ONSTACK)\n\t\tINIT_WORK_ONSTACK(&pw->pw_work, work_fn);\n\telse\n\t\tINIT_WORK(&pw->pw_work, work_fn);\n\tpw->pw_data = data;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [
            "#define\tPADATA_WORK_ONSTACK\t1\t/* Work's memory is on stack */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\n#define\tPADATA_WORK_ONSTACK\t1\t/* Work's memory is on stack */\n\nstatic void padata_work_init(struct padata_work *pw, work_func_t work_fn,\n\t\t\t     void *data, int flags)\n{\n\tif (flags & PADATA_WORK_ONSTACK)\n\t\tINIT_WORK_ONSTACK(&pw->pw_work, work_fn);\n\telse\n\t\tINIT_WORK(&pw->pw_work, work_fn);\n\tpw->pw_data = data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "padata_work_alloc",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "padata_work_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "72-84",
          "snippet": "static struct padata_work *padata_work_alloc(void)\n{\n\tstruct padata_work *pw;\n\n\tlockdep_assert_held(&padata_works_lock);\n\n\tif (list_empty(&padata_free_works))\n\t\treturn NULL;\t/* No more work items allowed to be queued. */\n\n\tpw = list_first_entry(&padata_free_works, struct padata_work, pw_list);\n\tlist_del(&pw->pw_list);\n\treturn pw;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(padata_works_lock);",
            "static LIST_HEAD(padata_free_works);",
            "static void __init padata_mt_helper(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic DEFINE_SPINLOCK(padata_works_lock);\nstatic LIST_HEAD(padata_free_works);\nstatic void __init padata_mt_helper(struct work_struct *work);\n\nstatic struct padata_work *padata_work_alloc(void)\n{\n\tstruct padata_work *pw;\n\n\tlockdep_assert_held(&padata_works_lock);\n\n\tif (list_empty(&padata_free_works))\n\t\treturn NULL;\t/* No more work items allowed to be queued. */\n\n\tpw = list_first_entry(&padata_free_works, struct padata_work, pw_list);\n\tlist_del(&pw->pw_list);\n\treturn pw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&padata_works_lock"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic DEFINE_SPINLOCK(padata_works_lock);\n\nstatic int __init padata_work_alloc_mt(int nworks, void *data,\n\t\t\t\t       struct list_head *head)\n{\n\tint i;\n\n\tspin_lock(&padata_works_lock);\n\t/* Start at 1 because the current task participates in the job. */\n\tfor (i = 1; i < nworks; ++i) {\n\t\tstruct padata_work *pw = padata_work_alloc();\n\n\t\tif (!pw)\n\t\t\tbreak;\n\t\tpadata_work_init(pw, padata_mt_helper, data, 0);\n\t\tlist_add(&pw->pw_list, head);\n\t}\n\tspin_unlock(&padata_works_lock);\n\n\treturn i;\n}"
  },
  {
    "function_name": "padata_work_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "86-94",
    "snippet": "static void padata_work_init(struct padata_work *pw, work_func_t work_fn,\n\t\t\t     void *data, int flags)\n{\n\tif (flags & PADATA_WORK_ONSTACK)\n\t\tINIT_WORK_ONSTACK(&pw->pw_work, work_fn);\n\telse\n\t\tINIT_WORK(&pw->pw_work, work_fn);\n\tpw->pw_data = data;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [
      "#define\tPADATA_WORK_ONSTACK\t1\t/* Work's memory is on stack */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&pw->pw_work",
            "work_fn"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK_ONSTACK",
          "args": [
            "&pw->pw_work",
            "work_fn"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\n#define\tPADATA_WORK_ONSTACK\t1\t/* Work's memory is on stack */\n\nstatic void padata_work_init(struct padata_work *pw, work_func_t work_fn,\n\t\t\t     void *data, int flags)\n{\n\tif (flags & PADATA_WORK_ONSTACK)\n\t\tINIT_WORK_ONSTACK(&pw->pw_work, work_fn);\n\telse\n\t\tINIT_WORK(&pw->pw_work, work_fn);\n\tpw->pw_data = data;\n}"
  },
  {
    "function_name": "padata_work_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "72-84",
    "snippet": "static struct padata_work *padata_work_alloc(void)\n{\n\tstruct padata_work *pw;\n\n\tlockdep_assert_held(&padata_works_lock);\n\n\tif (list_empty(&padata_free_works))\n\t\treturn NULL;\t/* No more work items allowed to be queued. */\n\n\tpw = list_first_entry(&padata_free_works, struct padata_work, pw_list);\n\tlist_del(&pw->pw_list);\n\treturn pw;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(padata_works_lock);",
      "static LIST_HEAD(padata_free_works);",
      "static void __init padata_mt_helper(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pw->pw_list"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&padata_free_works",
            "structpadata_work",
            "pw_list"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&padata_free_works"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&padata_works_lock"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic DEFINE_SPINLOCK(padata_works_lock);\nstatic LIST_HEAD(padata_free_works);\nstatic void __init padata_mt_helper(struct work_struct *work);\n\nstatic struct padata_work *padata_work_alloc(void)\n{\n\tstruct padata_work *pw;\n\n\tlockdep_assert_held(&padata_works_lock);\n\n\tif (list_empty(&padata_free_works))\n\t\treturn NULL;\t/* No more work items allowed to be queued. */\n\n\tpw = list_first_entry(&padata_free_works, struct padata_work, pw_list);\n\tlist_del(&pw->pw_list);\n\treturn pw;\n}"
  },
  {
    "function_name": "padata_cpu_hash",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "61-70",
    "snippet": "static int padata_cpu_hash(struct parallel_data *pd, unsigned int seq_nr)\n{\n\t/*\n\t * Hash the sequence numbers to the cpus by taking\n\t * seq_nr mod. number of cpus in use.\n\t */\n\tint cpu_index = seq_nr % cpumask_weight(pd->cpumask.pcpu);\n\n\treturn padata_index_to_cpu(pd, cpu_index);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void padata_free_pd(struct parallel_data *pd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "padata_index_to_cpu",
          "args": [
            "pd",
            "cpu_index"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "padata_index_to_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "50-59",
          "snippet": "static int padata_index_to_cpu(struct parallel_data *pd, int cpu_index)\n{\n\tint cpu, target_cpu;\n\n\ttarget_cpu = cpumask_first(pd->cpumask.pcpu);\n\tfor (cpu = 0; cpu < cpu_index; cpu++)\n\t\ttarget_cpu = cpumask_next(target_cpu, pd->cpumask.pcpu);\n\n\treturn target_cpu;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void padata_free_pd(struct parallel_data *pd);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic int padata_index_to_cpu(struct parallel_data *pd, int cpu_index)\n{\n\tint cpu, target_cpu;\n\n\ttarget_cpu = cpumask_first(pd->cpumask.pcpu);\n\tfor (cpu = 0; cpu < cpu_index; cpu++)\n\t\ttarget_cpu = cpumask_next(target_cpu, pd->cpumask.pcpu);\n\n\treturn target_cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "pd->cpumask.pcpu"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic int padata_cpu_hash(struct parallel_data *pd, unsigned int seq_nr)\n{\n\t/*\n\t * Hash the sequence numbers to the cpus by taking\n\t * seq_nr mod. number of cpus in use.\n\t */\n\tint cpu_index = seq_nr % cpumask_weight(pd->cpumask.pcpu);\n\n\treturn padata_index_to_cpu(pd, cpu_index);\n}"
  },
  {
    "function_name": "padata_index_to_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
    "lines": "50-59",
    "snippet": "static int padata_index_to_cpu(struct parallel_data *pd, int cpu_index)\n{\n\tint cpu, target_cpu;\n\n\ttarget_cpu = cpumask_first(pd->cpumask.pcpu);\n\tfor (cpu = 0; cpu < cpu_index; cpu++)\n\t\ttarget_cpu = cpumask_next(target_cpu, pd->cpumask.pcpu);\n\n\treturn target_cpu;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/sysfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/padata.h>",
      "#include <linux/cpu.h>",
      "#include <linux/err.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/export.h>",
      "#include <linux/completion.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void padata_free_pd(struct parallel_data *pd);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "target_cpu",
            "pd->cpumask.pcpu"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "pd->cpumask.pcpu"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void padata_free_pd(struct parallel_data *pd);\n\nstatic int padata_index_to_cpu(struct parallel_data *pd, int cpu_index)\n{\n\tint cpu, target_cpu;\n\n\ttarget_cpu = cpumask_first(pd->cpumask.pcpu);\n\tfor (cpu = 0; cpu < cpu_index; cpu++)\n\t\ttarget_cpu = cpumask_next(target_cpu, pd->cpumask.pcpu);\n\n\treturn target_cpu;\n}"
  }
]