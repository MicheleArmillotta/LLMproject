[
  {
    "function_name": "freezer_parent_freezing_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "445-451",
    "snippet": "static u64 freezer_parent_freezing_read(struct cgroup_subsys_state *css,\n\t\t\t\t\tstruct cftype *cft)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\n\treturn (bool)(freezer->state & CGROUP_FREEZING_PARENT);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_freezer",
          "args": [
            "css"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "css_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "50-53",
          "snippet": "static inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic u64 freezer_parent_freezing_read(struct cgroup_subsys_state *css,\n\t\t\t\t\tstruct cftype *cft)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\n\treturn (bool)(freezer->state & CGROUP_FREEZING_PARENT);\n}"
  },
  {
    "function_name": "freezer_self_freezing_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "437-443",
    "snippet": "static u64 freezer_self_freezing_read(struct cgroup_subsys_state *css,\n\t\t\t\t      struct cftype *cft)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\n\treturn (bool)(freezer->state & CGROUP_FREEZING_SELF);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_freezer",
          "args": [
            "css"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "css_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "50-53",
          "snippet": "static inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic u64 freezer_self_freezing_read(struct cgroup_subsys_state *css,\n\t\t\t\t      struct cftype *cft)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\n\treturn (bool)(freezer->state & CGROUP_FREEZING_SELF);\n}"
  },
  {
    "function_name": "freezer_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "419-435",
    "snippet": "static ssize_t freezer_write(struct kernfs_open_file *of,\n\t\t\t     char *buf, size_t nbytes, loff_t off)\n{\n\tbool freeze;\n\n\tbuf = strstrip(buf);\n\n\tif (strcmp(buf, freezer_state_strs(0)) == 0)\n\t\tfreeze = false;\n\telse if (strcmp(buf, freezer_state_strs(CGROUP_FROZEN)) == 0)\n\t\tfreeze = true;\n\telse\n\t\treturn -EINVAL;\n\n\tfreezer_change_state(css_freezer(of_css(of)), freeze);\n\treturn nbytes;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freezer_change_state",
          "args": [
            "css_freezer(of_css(of))",
            "freeze"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_change_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "385-417",
          "snippet": "static void freezer_change_state(struct freezer *freezer, bool freeze)\n{\n\tstruct cgroup_subsys_state *pos;\n\n\t/*\n\t * Update all its descendants in pre-order traversal.  Each\n\t * descendant will try to inherit its parent's FREEZING state as\n\t * CGROUP_FREEZING_PARENT.\n\t */\n\tmutex_lock(&freezer_mutex);\n\trcu_read_lock();\n\tcss_for_each_descendant_pre(pos, &freezer->css) {\n\t\tstruct freezer *pos_f = css_freezer(pos);\n\t\tstruct freezer *parent = parent_freezer(pos_f);\n\n\t\tif (!css_tryget_online(pos))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tif (pos_f == freezer)\n\t\t\tfreezer_apply_state(pos_f, freeze,\n\t\t\t\t\t    CGROUP_FREEZING_SELF);\n\t\telse\n\t\t\tfreezer_apply_state(pos_f,\n\t\t\t\t\t    parent->state & CGROUP_FREEZING,\n\t\t\t\t\t    CGROUP_FREEZING_PARENT);\n\n\t\trcu_read_lock();\n\t\tcss_put(pos);\n\t}\n\trcu_read_unlock();\n\tmutex_unlock(&freezer_mutex);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(freezer_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(freezer_mutex);\n\nstatic void freezer_change_state(struct freezer *freezer, bool freeze)\n{\n\tstruct cgroup_subsys_state *pos;\n\n\t/*\n\t * Update all its descendants in pre-order traversal.  Each\n\t * descendant will try to inherit its parent's FREEZING state as\n\t * CGROUP_FREEZING_PARENT.\n\t */\n\tmutex_lock(&freezer_mutex);\n\trcu_read_lock();\n\tcss_for_each_descendant_pre(pos, &freezer->css) {\n\t\tstruct freezer *pos_f = css_freezer(pos);\n\t\tstruct freezer *parent = parent_freezer(pos_f);\n\n\t\tif (!css_tryget_online(pos))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tif (pos_f == freezer)\n\t\t\tfreezer_apply_state(pos_f, freeze,\n\t\t\t\t\t    CGROUP_FREEZING_SELF);\n\t\telse\n\t\t\tfreezer_apply_state(pos_f,\n\t\t\t\t\t    parent->state & CGROUP_FREEZING,\n\t\t\t\t\t    CGROUP_FREEZING_PARENT);\n\n\t\trcu_read_lock();\n\t\tcss_put(pos);\n\t}\n\trcu_read_unlock();\n\tmutex_unlock(&freezer_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_freezer",
          "args": [
            "of_css(of)"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "css_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "50-53",
          "snippet": "static inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "of_css",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "652-669",
          "snippet": "struct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (CGROUP_HAS_SUBSYS_CONFIG && cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (CGROUP_HAS_SUBSYS_CONFIG && cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "freezer_state_strs(CGROUP_FROZEN)"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezer_state_strs",
          "args": [
            "CGROUP_FROZEN"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state_strs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "76-83",
          "snippet": "static const char *freezer_state_strs(unsigned int state)\n{\n\tif (state & CGROUP_FROZEN)\n\t\treturn \"FROZEN\";\n\tif (state & CGROUP_FREEZING)\n\t\treturn \"FREEZING\";\n\treturn \"THAWED\";\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic const char *freezer_state_strs(unsigned int state)\n{\n\tif (state & CGROUP_FROZEN)\n\t\treturn \"FROZEN\";\n\tif (state & CGROUP_FREEZING)\n\t\treturn \"FREEZING\";\n\treturn \"THAWED\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic ssize_t freezer_write(struct kernfs_open_file *of,\n\t\t\t     char *buf, size_t nbytes, loff_t off)\n{\n\tbool freeze;\n\n\tbuf = strstrip(buf);\n\n\tif (strcmp(buf, freezer_state_strs(0)) == 0)\n\t\tfreeze = false;\n\telse if (strcmp(buf, freezer_state_strs(CGROUP_FROZEN)) == 0)\n\t\tfreeze = true;\n\telse\n\t\treturn -EINVAL;\n\n\tfreezer_change_state(css_freezer(of_css(of)), freeze);\n\treturn nbytes;\n}"
  },
  {
    "function_name": "freezer_change_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "385-417",
    "snippet": "static void freezer_change_state(struct freezer *freezer, bool freeze)\n{\n\tstruct cgroup_subsys_state *pos;\n\n\t/*\n\t * Update all its descendants in pre-order traversal.  Each\n\t * descendant will try to inherit its parent's FREEZING state as\n\t * CGROUP_FREEZING_PARENT.\n\t */\n\tmutex_lock(&freezer_mutex);\n\trcu_read_lock();\n\tcss_for_each_descendant_pre(pos, &freezer->css) {\n\t\tstruct freezer *pos_f = css_freezer(pos);\n\t\tstruct freezer *parent = parent_freezer(pos_f);\n\n\t\tif (!css_tryget_online(pos))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tif (pos_f == freezer)\n\t\t\tfreezer_apply_state(pos_f, freeze,\n\t\t\t\t\t    CGROUP_FREEZING_SELF);\n\t\telse\n\t\t\tfreezer_apply_state(pos_f,\n\t\t\t\t\t    parent->state & CGROUP_FREEZING,\n\t\t\t\t\t    CGROUP_FREEZING_PARENT);\n\n\t\trcu_read_lock();\n\t\tcss_put(pos);\n\t}\n\trcu_read_unlock();\n\tmutex_unlock(&freezer_mutex);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(freezer_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&freezer_mutex"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "pos"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezer_apply_state",
          "args": [
            "pos_f",
            "parent->state & CGROUP_FREEZING",
            "CGROUP_FREEZING_PARENT"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_apply_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "349-375",
          "snippet": "static void freezer_apply_state(struct freezer *freezer, bool freeze,\n\t\t\t\tunsigned int state)\n{\n\t/* also synchronizes against task migration, see freezer_attach() */\n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZER_ONLINE))\n\t\treturn;\n\n\tif (freeze) {\n\t\tif (!(freezer->state & CGROUP_FREEZING))\n\t\t\tatomic_inc(&system_freezing_cnt);\n\t\tfreezer->state |= state;\n\t\tfreeze_cgroup(freezer);\n\t} else {\n\t\tbool was_freezing = freezer->state & CGROUP_FREEZING;\n\n\t\tfreezer->state &= ~state;\n\n\t\tif (!(freezer->state & CGROUP_FREEZING)) {\n\t\t\tif (was_freezing)\n\t\t\t\tatomic_dec(&system_freezing_cnt);\n\t\t\tfreezer->state &= ~CGROUP_FROZEN;\n\t\t\tunfreeze_cgroup(freezer);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(freezer_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(freezer_mutex);\n\nstatic void freezer_apply_state(struct freezer *freezer, bool freeze,\n\t\t\t\tunsigned int state)\n{\n\t/* also synchronizes against task migration, see freezer_attach() */\n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZER_ONLINE))\n\t\treturn;\n\n\tif (freeze) {\n\t\tif (!(freezer->state & CGROUP_FREEZING))\n\t\t\tatomic_inc(&system_freezing_cnt);\n\t\tfreezer->state |= state;\n\t\tfreeze_cgroup(freezer);\n\t} else {\n\t\tbool was_freezing = freezer->state & CGROUP_FREEZING;\n\n\t\tfreezer->state &= ~state;\n\n\t\tif (!(freezer->state & CGROUP_FREEZING)) {\n\t\t\tif (was_freezing)\n\t\t\t\tatomic_dec(&system_freezing_cnt);\n\t\t\tfreezer->state &= ~CGROUP_FROZEN;\n\t\t\tunfreeze_cgroup(freezer);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "pos"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_freezer",
          "args": [
            "pos_f"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "parent_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "60-63",
          "snippet": "static struct freezer *parent_freezer(struct freezer *freezer)\n{\n\treturn css_freezer(freezer->css.parent);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic struct freezer *parent_freezer(struct freezer *freezer)\n{\n\treturn css_freezer(freezer->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_freezer",
          "args": [
            "pos"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "css_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "50-53",
          "snippet": "static inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_for_each_descendant_pre",
          "args": [
            "pos",
            "&freezer->css"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&freezer_mutex"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(freezer_mutex);\n\nstatic void freezer_change_state(struct freezer *freezer, bool freeze)\n{\n\tstruct cgroup_subsys_state *pos;\n\n\t/*\n\t * Update all its descendants in pre-order traversal.  Each\n\t * descendant will try to inherit its parent's FREEZING state as\n\t * CGROUP_FREEZING_PARENT.\n\t */\n\tmutex_lock(&freezer_mutex);\n\trcu_read_lock();\n\tcss_for_each_descendant_pre(pos, &freezer->css) {\n\t\tstruct freezer *pos_f = css_freezer(pos);\n\t\tstruct freezer *parent = parent_freezer(pos_f);\n\n\t\tif (!css_tryget_online(pos))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tif (pos_f == freezer)\n\t\t\tfreezer_apply_state(pos_f, freeze,\n\t\t\t\t\t    CGROUP_FREEZING_SELF);\n\t\telse\n\t\t\tfreezer_apply_state(pos_f,\n\t\t\t\t\t    parent->state & CGROUP_FREEZING,\n\t\t\t\t\t    CGROUP_FREEZING_PARENT);\n\n\t\trcu_read_lock();\n\t\tcss_put(pos);\n\t}\n\trcu_read_unlock();\n\tmutex_unlock(&freezer_mutex);\n}"
  },
  {
    "function_name": "freezer_apply_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "349-375",
    "snippet": "static void freezer_apply_state(struct freezer *freezer, bool freeze,\n\t\t\t\tunsigned int state)\n{\n\t/* also synchronizes against task migration, see freezer_attach() */\n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZER_ONLINE))\n\t\treturn;\n\n\tif (freeze) {\n\t\tif (!(freezer->state & CGROUP_FREEZING))\n\t\t\tatomic_inc(&system_freezing_cnt);\n\t\tfreezer->state |= state;\n\t\tfreeze_cgroup(freezer);\n\t} else {\n\t\tbool was_freezing = freezer->state & CGROUP_FREEZING;\n\n\t\tfreezer->state &= ~state;\n\n\t\tif (!(freezer->state & CGROUP_FREEZING)) {\n\t\t\tif (was_freezing)\n\t\t\t\tatomic_dec(&system_freezing_cnt);\n\t\t\tfreezer->state &= ~CGROUP_FROZEN;\n\t\t\tunfreeze_cgroup(freezer);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(freezer_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unfreeze_cgroup",
          "args": [
            "freezer"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "unfreeze_cgroup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "329-338",
          "snippet": "static void unfreeze_cgroup(struct freezer *freezer)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&freezer->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\t__thaw_task(task);\n\tcss_task_iter_end(&it);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void unfreeze_cgroup(struct freezer *freezer)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&freezer->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\t__thaw_task(task);\n\tcss_task_iter_end(&it);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&system_freezing_cnt"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&system_freezing_cnt"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&freezer_mutex"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(freezer_mutex);\n\nstatic void freezer_apply_state(struct freezer *freezer, bool freeze,\n\t\t\t\tunsigned int state)\n{\n\t/* also synchronizes against task migration, see freezer_attach() */\n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZER_ONLINE))\n\t\treturn;\n\n\tif (freeze) {\n\t\tif (!(freezer->state & CGROUP_FREEZING))\n\t\t\tatomic_inc(&system_freezing_cnt);\n\t\tfreezer->state |= state;\n\t\tfreeze_cgroup(freezer);\n\t} else {\n\t\tbool was_freezing = freezer->state & CGROUP_FREEZING;\n\n\t\tfreezer->state &= ~state;\n\n\t\tif (!(freezer->state & CGROUP_FREEZING)) {\n\t\t\tif (was_freezing)\n\t\t\t\tatomic_dec(&system_freezing_cnt);\n\t\t\tfreezer->state &= ~CGROUP_FROZEN;\n\t\t\tunfreeze_cgroup(freezer);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "unfreeze_cgroup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "329-338",
    "snippet": "static void unfreeze_cgroup(struct freezer *freezer)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&freezer->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\t__thaw_task(task);\n\tcss_task_iter_end(&it);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_task_iter_end",
          "args": [
            "&it"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4761-4775",
          "snippet": "void css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__thaw_task",
          "args": [
            "task"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "__thaw_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/freezer.c",
          "lines": "146-154",
          "snippet": "void __thaw_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (frozen(p))\n\t\twake_up_process(p);\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(freezer_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic DEFINE_SPINLOCK(freezer_lock);\n\nvoid __thaw_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (frozen(p))\n\t\twake_up_process(p);\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_next",
          "args": [
            "&it"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4730-4753",
          "snippet": "struct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_start",
          "args": [
            "&freezer->css",
            "0",
            "&it"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4700-4720",
          "snippet": "void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void unfreeze_cgroup(struct freezer *freezer)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&freezer->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\t__thaw_task(task);\n\tcss_task_iter_end(&it);\n}"
  },
  {
    "function_name": "freeze_cgroup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "318-327",
    "snippet": "static void freeze_cgroup(struct freezer *freezer)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&freezer->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tfreeze_task(task);\n\tcss_task_iter_end(&it);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_task_iter_end",
          "args": [
            "&it"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4761-4775",
          "snippet": "void css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeze_task",
          "args": [
            "task"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "freeze_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/freezer.c",
          "lines": "115-144",
          "snippet": "bool freeze_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\t/*\n\t * This check can race with freezer_do_not_count, but worst case that\n\t * will result in an extra wakeup being sent to the task.  It does not\n\t * race with freezer_count(), the barriers in freezer_count() and\n\t * freezer_should_skip() ensure that either freezer_count() sees\n\t * freezing == true in try_to_freeze() and freezes, or\n\t * freezer_should_skip() sees !PF_FREEZE_SKIP and freezes the task\n\t * normally.\n\t */\n\tif (freezer_should_skip(p))\n\t\treturn false;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (!freezing(p) || frozen(p)) {\n\t\tspin_unlock_irqrestore(&freezer_lock, flags);\n\t\treturn false;\n\t}\n\n\tif (!(p->flags & PF_KTHREAD))\n\t\tfake_signal_wake_up(p);\n\telse\n\t\twake_up_state(p, TASK_INTERRUPTIBLE);\n\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n\treturn true;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(freezer_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic DEFINE_SPINLOCK(freezer_lock);\n\nbool freeze_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\t/*\n\t * This check can race with freezer_do_not_count, but worst case that\n\t * will result in an extra wakeup being sent to the task.  It does not\n\t * race with freezer_count(), the barriers in freezer_count() and\n\t * freezer_should_skip() ensure that either freezer_count() sees\n\t * freezing == true in try_to_freeze() and freezes, or\n\t * freezer_should_skip() sees !PF_FREEZE_SKIP and freezes the task\n\t * normally.\n\t */\n\tif (freezer_should_skip(p))\n\t\treturn false;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (!freezing(p) || frozen(p)) {\n\t\tspin_unlock_irqrestore(&freezer_lock, flags);\n\t\treturn false;\n\t}\n\n\tif (!(p->flags & PF_KTHREAD))\n\t\tfake_signal_wake_up(p);\n\telse\n\t\twake_up_state(p, TASK_INTERRUPTIBLE);\n\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_next",
          "args": [
            "&it"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4730-4753",
          "snippet": "struct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_start",
          "args": [
            "&freezer->css",
            "0",
            "&it"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4700-4720",
          "snippet": "void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void freeze_cgroup(struct freezer *freezer)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&freezer->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tfreeze_task(task);\n\tcss_task_iter_end(&it);\n}"
  },
  {
    "function_name": "freezer_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "291-316",
    "snippet": "static int freezer_read(struct seq_file *m, void *v)\n{\n\tstruct cgroup_subsys_state *css = seq_css(m), *pos;\n\n\tmutex_lock(&freezer_mutex);\n\trcu_read_lock();\n\n\t/* update states bottom-up */\n\tcss_for_each_descendant_post(pos, css) {\n\t\tif (!css_tryget_online(pos))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tupdate_if_frozen(pos);\n\n\t\trcu_read_lock();\n\t\tcss_put(pos);\n\t}\n\n\trcu_read_unlock();\n\tmutex_unlock(&freezer_mutex);\n\n\tseq_puts(m, freezer_state_strs(css_freezer(css)->state));\n\tseq_putc(m, '\\n');\n\treturn 0;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(freezer_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "freezer_state_strs(css_freezer(css)->state)"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezer_state_strs",
          "args": [
            "css_freezer(css)->state"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "freezer_state_strs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "76-83",
          "snippet": "static const char *freezer_state_strs(unsigned int state)\n{\n\tif (state & CGROUP_FROZEN)\n\t\treturn \"FROZEN\";\n\tif (state & CGROUP_FREEZING)\n\t\treturn \"FREEZING\";\n\treturn \"THAWED\";\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic const char *freezer_state_strs(unsigned int state)\n{\n\tif (state & CGROUP_FROZEN)\n\t\treturn \"FROZEN\";\n\tif (state & CGROUP_FREEZING)\n\t\treturn \"FREEZING\";\n\treturn \"THAWED\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_freezer",
          "args": [
            "css"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "css_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "50-53",
          "snippet": "static inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&freezer_mutex"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "pos"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_if_frozen",
          "args": [
            "pos"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "update_if_frozen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "244-289",
          "snippet": "static void update_if_frozen(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\tstruct cgroup_subsys_state *pos;\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZING) ||\n\t    (freezer->state & CGROUP_FROZEN))\n\t\treturn;\n\n\t/* are all (live) children frozen? */\n\trcu_read_lock();\n\tcss_for_each_child(pos, css) {\n\t\tstruct freezer *child = css_freezer(pos);\n\n\t\tif ((child->state & CGROUP_FREEZER_ONLINE) &&\n\t\t    !(child->state & CGROUP_FROZEN)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/* are all tasks frozen? */\n\tcss_task_iter_start(css, 0, &it);\n\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tif (freezing(task)) {\n\t\t\t/*\n\t\t\t * freezer_should_skip() indicates that the task\n\t\t\t * should be skipped when determining freezing\n\t\t\t * completion.  Consider it frozen in addition to\n\t\t\t * the usual frozen condition.\n\t\t\t */\n\t\t\tif (!frozen(task) && !freezer_should_skip(task))\n\t\t\t\tgoto out_iter_end;\n\t\t}\n\t}\n\n\tfreezer->state |= CGROUP_FROZEN;\nout_iter_end:\n\tcss_task_iter_end(&it);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(freezer_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(freezer_mutex);\n\nstatic void update_if_frozen(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\tstruct cgroup_subsys_state *pos;\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZING) ||\n\t    (freezer->state & CGROUP_FROZEN))\n\t\treturn;\n\n\t/* are all (live) children frozen? */\n\trcu_read_lock();\n\tcss_for_each_child(pos, css) {\n\t\tstruct freezer *child = css_freezer(pos);\n\n\t\tif ((child->state & CGROUP_FREEZER_ONLINE) &&\n\t\t    !(child->state & CGROUP_FROZEN)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/* are all tasks frozen? */\n\tcss_task_iter_start(css, 0, &it);\n\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tif (freezing(task)) {\n\t\t\t/*\n\t\t\t * freezer_should_skip() indicates that the task\n\t\t\t * should be skipped when determining freezing\n\t\t\t * completion.  Consider it frozen in addition to\n\t\t\t * the usual frozen condition.\n\t\t\t */\n\t\t\tif (!frozen(task) && !freezer_should_skip(task))\n\t\t\t\tgoto out_iter_end;\n\t\t}\n\t}\n\n\tfreezer->state |= CGROUP_FROZEN;\nout_iter_end:\n\tcss_task_iter_end(&it);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "pos"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_for_each_descendant_post",
          "args": [
            "pos",
            "css"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&freezer_mutex"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(freezer_mutex);\n\nstatic int freezer_read(struct seq_file *m, void *v)\n{\n\tstruct cgroup_subsys_state *css = seq_css(m), *pos;\n\n\tmutex_lock(&freezer_mutex);\n\trcu_read_lock();\n\n\t/* update states bottom-up */\n\tcss_for_each_descendant_post(pos, css) {\n\t\tif (!css_tryget_online(pos))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tupdate_if_frozen(pos);\n\n\t\trcu_read_lock();\n\t\tcss_put(pos);\n\t}\n\n\trcu_read_unlock();\n\tmutex_unlock(&freezer_mutex);\n\n\tseq_puts(m, freezer_state_strs(css_freezer(css)->state));\n\tseq_putc(m, '\\n');\n\treturn 0;\n}"
  },
  {
    "function_name": "update_if_frozen",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "244-289",
    "snippet": "static void update_if_frozen(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\tstruct cgroup_subsys_state *pos;\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZING) ||\n\t    (freezer->state & CGROUP_FROZEN))\n\t\treturn;\n\n\t/* are all (live) children frozen? */\n\trcu_read_lock();\n\tcss_for_each_child(pos, css) {\n\t\tstruct freezer *child = css_freezer(pos);\n\n\t\tif ((child->state & CGROUP_FREEZER_ONLINE) &&\n\t\t    !(child->state & CGROUP_FROZEN)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/* are all tasks frozen? */\n\tcss_task_iter_start(css, 0, &it);\n\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tif (freezing(task)) {\n\t\t\t/*\n\t\t\t * freezer_should_skip() indicates that the task\n\t\t\t * should be skipped when determining freezing\n\t\t\t * completion.  Consider it frozen in addition to\n\t\t\t * the usual frozen condition.\n\t\t\t */\n\t\t\tif (!frozen(task) && !freezer_should_skip(task))\n\t\t\t\tgoto out_iter_end;\n\t\t}\n\t}\n\n\tfreezer->state |= CGROUP_FROZEN;\nout_iter_end:\n\tcss_task_iter_end(&it);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(freezer_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_task_iter_end",
          "args": [
            "&it"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4761-4775",
          "snippet": "void css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezer_should_skip",
          "args": [
            "task"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "frozen",
          "args": [
            "task"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "update_if_frozen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "244-289",
          "snippet": "static void update_if_frozen(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\tstruct cgroup_subsys_state *pos;\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZING) ||\n\t    (freezer->state & CGROUP_FROZEN))\n\t\treturn;\n\n\t/* are all (live) children frozen? */\n\trcu_read_lock();\n\tcss_for_each_child(pos, css) {\n\t\tstruct freezer *child = css_freezer(pos);\n\n\t\tif ((child->state & CGROUP_FREEZER_ONLINE) &&\n\t\t    !(child->state & CGROUP_FROZEN)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/* are all tasks frozen? */\n\tcss_task_iter_start(css, 0, &it);\n\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tif (freezing(task)) {\n\t\t\t/*\n\t\t\t * freezer_should_skip() indicates that the task\n\t\t\t * should be skipped when determining freezing\n\t\t\t * completion.  Consider it frozen in addition to\n\t\t\t * the usual frozen condition.\n\t\t\t */\n\t\t\tif (!frozen(task) && !freezer_should_skip(task))\n\t\t\t\tgoto out_iter_end;\n\t\t}\n\t}\n\n\tfreezer->state |= CGROUP_FROZEN;\nout_iter_end:\n\tcss_task_iter_end(&it);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "task"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_freezing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "65-74",
          "snippet": "bool cgroup_freezing(struct task_struct *task)\n{\n\tbool ret;\n\n\trcu_read_lock();\n\tret = task_freezer(task)->state & CGROUP_FREEZING;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nbool cgroup_freezing(struct task_struct *task)\n{\n\tbool ret;\n\n\trcu_read_lock();\n\tret = task_freezer(task)->state & CGROUP_FREEZING;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_next",
          "args": [
            "&it"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4730-4753",
          "snippet": "struct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_start",
          "args": [
            "css",
            "0",
            "&it"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4700-4720",
          "snippet": "void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_freezer",
          "args": [
            "pos"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "css_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "50-53",
          "snippet": "static inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_for_each_child",
          "args": [
            "pos",
            "css"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&freezer_mutex"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(freezer_mutex);\n\nstatic void update_if_frozen(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\tstruct cgroup_subsys_state *pos;\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZING) ||\n\t    (freezer->state & CGROUP_FROZEN))\n\t\treturn;\n\n\t/* are all (live) children frozen? */\n\trcu_read_lock();\n\tcss_for_each_child(pos, css) {\n\t\tstruct freezer *child = css_freezer(pos);\n\n\t\tif ((child->state & CGROUP_FREEZER_ONLINE) &&\n\t\t    !(child->state & CGROUP_FROZEN)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/* are all tasks frozen? */\n\tcss_task_iter_start(css, 0, &it);\n\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tif (freezing(task)) {\n\t\t\t/*\n\t\t\t * freezer_should_skip() indicates that the task\n\t\t\t * should be skipped when determining freezing\n\t\t\t * completion.  Consider it frozen in addition to\n\t\t\t * the usual frozen condition.\n\t\t\t */\n\t\t\tif (!frozen(task) && !freezer_should_skip(task))\n\t\t\t\tgoto out_iter_end;\n\t\t}\n\t}\n\n\tfreezer->state |= CGROUP_FROZEN;\nout_iter_end:\n\tcss_task_iter_end(&it);\n}"
  },
  {
    "function_name": "freezer_fork",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "203-226",
    "snippet": "static void freezer_fork(struct task_struct *task)\n{\n\tstruct freezer *freezer;\n\n\t/*\n\t * The root cgroup is non-freezable, so we can skip locking the\n\t * freezer.  This is safe regardless of race with task migration.\n\t * If we didn't race or won, skipping is obviously the right thing\n\t * to do.  If we lost and root is the new cgroup, noop is still the\n\t * right thing to do.\n\t */\n\tif (task_css_is_root(task, freezer_cgrp_id))\n\t\treturn;\n\n\tmutex_lock(&freezer_mutex);\n\trcu_read_lock();\n\n\tfreezer = task_freezer(task);\n\tif (freezer->state & CGROUP_FREEZING)\n\t\tfreeze_task(task);\n\n\trcu_read_unlock();\n\tmutex_unlock(&freezer_mutex);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(freezer_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&freezer_mutex"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeze_task",
          "args": [
            "task"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "freeze_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/freezer.c",
          "lines": "115-144",
          "snippet": "bool freeze_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\t/*\n\t * This check can race with freezer_do_not_count, but worst case that\n\t * will result in an extra wakeup being sent to the task.  It does not\n\t * race with freezer_count(), the barriers in freezer_count() and\n\t * freezer_should_skip() ensure that either freezer_count() sees\n\t * freezing == true in try_to_freeze() and freezes, or\n\t * freezer_should_skip() sees !PF_FREEZE_SKIP and freezes the task\n\t * normally.\n\t */\n\tif (freezer_should_skip(p))\n\t\treturn false;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (!freezing(p) || frozen(p)) {\n\t\tspin_unlock_irqrestore(&freezer_lock, flags);\n\t\treturn false;\n\t}\n\n\tif (!(p->flags & PF_KTHREAD))\n\t\tfake_signal_wake_up(p);\n\telse\n\t\twake_up_state(p, TASK_INTERRUPTIBLE);\n\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n\treturn true;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(freezer_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic DEFINE_SPINLOCK(freezer_lock);\n\nbool freeze_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\t/*\n\t * This check can race with freezer_do_not_count, but worst case that\n\t * will result in an extra wakeup being sent to the task.  It does not\n\t * race with freezer_count(), the barriers in freezer_count() and\n\t * freezer_should_skip() ensure that either freezer_count() sees\n\t * freezing == true in try_to_freeze() and freezes, or\n\t * freezer_should_skip() sees !PF_FREEZE_SKIP and freezes the task\n\t * normally.\n\t */\n\tif (freezer_should_skip(p))\n\t\treturn false;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (!freezing(p) || frozen(p)) {\n\t\tspin_unlock_irqrestore(&freezer_lock, flags);\n\t\treturn false;\n\t}\n\n\tif (!(p->flags & PF_KTHREAD))\n\t\tfake_signal_wake_up(p);\n\telse\n\t\twake_up_state(p, TASK_INTERRUPTIBLE);\n\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_freezer",
          "args": [
            "task"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "task_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "55-58",
          "snippet": "static inline struct freezer *task_freezer(struct task_struct *task)\n{\n\treturn css_freezer(task_css(task, freezer_cgrp_id));\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic inline struct freezer *task_freezer(struct task_struct *task)\n{\n\treturn css_freezer(task_css(task, freezer_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&freezer_mutex"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_is_root",
          "args": [
            "task",
            "freezer_cgrp_id"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(freezer_mutex);\n\nstatic void freezer_fork(struct task_struct *task)\n{\n\tstruct freezer *freezer;\n\n\t/*\n\t * The root cgroup is non-freezable, so we can skip locking the\n\t * freezer.  This is safe regardless of race with task migration.\n\t * If we didn't race or won, skipping is obviously the right thing\n\t * to do.  If we lost and root is the new cgroup, noop is still the\n\t * right thing to do.\n\t */\n\tif (task_css_is_root(task, freezer_cgrp_id))\n\t\treturn;\n\n\tmutex_lock(&freezer_mutex);\n\trcu_read_lock();\n\n\tfreezer = task_freezer(task);\n\tif (freezer->state & CGROUP_FREEZING)\n\t\tfreeze_task(task);\n\n\trcu_read_unlock();\n\tmutex_unlock(&freezer_mutex);\n}"
  },
  {
    "function_name": "freezer_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "158-191",
    "snippet": "static void freezer_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *new_css;\n\n\tmutex_lock(&freezer_mutex);\n\n\t/*\n\t * Make the new tasks conform to the current state of @new_css.\n\t * For simplicity, when migrating any task to a FROZEN cgroup, we\n\t * revert it to FREEZING and let update_if_frozen() determine the\n\t * correct state later.\n\t *\n\t * Tasks in @tset are on @new_css but may not conform to its\n\t * current state before executing the following - !frozen tasks may\n\t * be visible in a FROZEN cgroup and frozen tasks in a THAWED one.\n\t */\n\tcgroup_taskset_for_each(task, new_css, tset) {\n\t\tstruct freezer *freezer = css_freezer(new_css);\n\n\t\tif (!(freezer->state & CGROUP_FREEZING)) {\n\t\t\t__thaw_task(task);\n\t\t} else {\n\t\t\tfreeze_task(task);\n\t\t\t/* clear FROZEN and propagate upwards */\n\t\t\twhile (freezer && (freezer->state & CGROUP_FROZEN)) {\n\t\t\t\tfreezer->state &= ~CGROUP_FROZEN;\n\t\t\t\tfreezer = parent_freezer(freezer);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&freezer_mutex);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(freezer_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&freezer_mutex"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_freezer",
          "args": [
            "freezer"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "parent_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "60-63",
          "snippet": "static struct freezer *parent_freezer(struct freezer *freezer)\n{\n\treturn css_freezer(freezer->css.parent);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic struct freezer *parent_freezer(struct freezer *freezer)\n{\n\treturn css_freezer(freezer->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeze_task",
          "args": [
            "task"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "freeze_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/freezer.c",
          "lines": "115-144",
          "snippet": "bool freeze_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\t/*\n\t * This check can race with freezer_do_not_count, but worst case that\n\t * will result in an extra wakeup being sent to the task.  It does not\n\t * race with freezer_count(), the barriers in freezer_count() and\n\t * freezer_should_skip() ensure that either freezer_count() sees\n\t * freezing == true in try_to_freeze() and freezes, or\n\t * freezer_should_skip() sees !PF_FREEZE_SKIP and freezes the task\n\t * normally.\n\t */\n\tif (freezer_should_skip(p))\n\t\treturn false;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (!freezing(p) || frozen(p)) {\n\t\tspin_unlock_irqrestore(&freezer_lock, flags);\n\t\treturn false;\n\t}\n\n\tif (!(p->flags & PF_KTHREAD))\n\t\tfake_signal_wake_up(p);\n\telse\n\t\twake_up_state(p, TASK_INTERRUPTIBLE);\n\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n\treturn true;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(freezer_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic DEFINE_SPINLOCK(freezer_lock);\n\nbool freeze_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\t/*\n\t * This check can race with freezer_do_not_count, but worst case that\n\t * will result in an extra wakeup being sent to the task.  It does not\n\t * race with freezer_count(), the barriers in freezer_count() and\n\t * freezer_should_skip() ensure that either freezer_count() sees\n\t * freezing == true in try_to_freeze() and freezes, or\n\t * freezer_should_skip() sees !PF_FREEZE_SKIP and freezes the task\n\t * normally.\n\t */\n\tif (freezer_should_skip(p))\n\t\treturn false;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (!freezing(p) || frozen(p)) {\n\t\tspin_unlock_irqrestore(&freezer_lock, flags);\n\t\treturn false;\n\t}\n\n\tif (!(p->flags & PF_KTHREAD))\n\t\tfake_signal_wake_up(p);\n\telse\n\t\twake_up_state(p, TASK_INTERRUPTIBLE);\n\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__thaw_task",
          "args": [
            "task"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "__thaw_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/freezer.c",
          "lines": "146-154",
          "snippet": "void __thaw_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (frozen(p))\n\t\twake_up_process(p);\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(freezer_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic DEFINE_SPINLOCK(freezer_lock);\n\nvoid __thaw_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (frozen(p))\n\t\twake_up_process(p);\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_freezer",
          "args": [
            "new_css"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "css_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "50-53",
          "snippet": "static inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_taskset_for_each",
          "args": [
            "task",
            "new_css",
            "tset"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&freezer_mutex"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(freezer_mutex);\n\nstatic void freezer_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *new_css;\n\n\tmutex_lock(&freezer_mutex);\n\n\t/*\n\t * Make the new tasks conform to the current state of @new_css.\n\t * For simplicity, when migrating any task to a FROZEN cgroup, we\n\t * revert it to FREEZING and let update_if_frozen() determine the\n\t * correct state later.\n\t *\n\t * Tasks in @tset are on @new_css but may not conform to its\n\t * current state before executing the following - !frozen tasks may\n\t * be visible in a FROZEN cgroup and frozen tasks in a THAWED one.\n\t */\n\tcgroup_taskset_for_each(task, new_css, tset) {\n\t\tstruct freezer *freezer = css_freezer(new_css);\n\n\t\tif (!(freezer->state & CGROUP_FREEZING)) {\n\t\t\t__thaw_task(task);\n\t\t} else {\n\t\t\tfreeze_task(task);\n\t\t\t/* clear FROZEN and propagate upwards */\n\t\t\twhile (freezer && (freezer->state & CGROUP_FROZEN)) {\n\t\t\t\tfreezer->state &= ~CGROUP_FROZEN;\n\t\t\t\tfreezer = parent_freezer(freezer);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&freezer_mutex);\n}"
  },
  {
    "function_name": "freezer_css_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "144-147",
    "snippet": "static void freezer_css_free(struct cgroup_subsys_state *css)\n{\n\tkfree(css_freezer(css));\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "css_freezer(css)"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_freezer",
          "args": [
            "css"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "css_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "50-53",
          "snippet": "static inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void freezer_css_free(struct cgroup_subsys_state *css)\n{\n\tkfree(css_freezer(css));\n}"
  },
  {
    "function_name": "freezer_css_offline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "130-142",
    "snippet": "static void freezer_css_offline(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\n\tmutex_lock(&freezer_mutex);\n\n\tif (freezer->state & CGROUP_FREEZING)\n\t\tatomic_dec(&system_freezing_cnt);\n\n\tfreezer->state = 0;\n\n\tmutex_unlock(&freezer_mutex);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(freezer_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&freezer_mutex"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&system_freezing_cnt"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&freezer_mutex"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_freezer",
          "args": [
            "css"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "css_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "50-53",
          "snippet": "static inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(freezer_mutex);\n\nstatic void freezer_css_offline(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\n\tmutex_lock(&freezer_mutex);\n\n\tif (freezer->state & CGROUP_FREEZING)\n\t\tatomic_dec(&system_freezing_cnt);\n\n\tfreezer->state = 0;\n\n\tmutex_unlock(&freezer_mutex);\n}"
  },
  {
    "function_name": "freezer_css_online",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "105-121",
    "snippet": "static int freezer_css_online(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\tstruct freezer *parent = parent_freezer(freezer);\n\n\tmutex_lock(&freezer_mutex);\n\n\tfreezer->state |= CGROUP_FREEZER_ONLINE;\n\n\tif (parent && (parent->state & CGROUP_FREEZING)) {\n\t\tfreezer->state |= CGROUP_FREEZING_PARENT | CGROUP_FROZEN;\n\t\tatomic_inc(&system_freezing_cnt);\n\t}\n\n\tmutex_unlock(&freezer_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(freezer_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&freezer_mutex"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&system_freezing_cnt"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&freezer_mutex"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_freezer",
          "args": [
            "freezer"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "parent_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "60-63",
          "snippet": "static struct freezer *parent_freezer(struct freezer *freezer)\n{\n\treturn css_freezer(freezer->css.parent);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic struct freezer *parent_freezer(struct freezer *freezer)\n{\n\treturn css_freezer(freezer->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_freezer",
          "args": [
            "css"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "css_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "50-53",
          "snippet": "static inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(freezer_mutex);\n\nstatic int freezer_css_online(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\tstruct freezer *parent = parent_freezer(freezer);\n\n\tmutex_lock(&freezer_mutex);\n\n\tfreezer->state |= CGROUP_FREEZER_ONLINE;\n\n\tif (parent && (parent->state & CGROUP_FREEZING)) {\n\t\tfreezer->state |= CGROUP_FREEZING_PARENT | CGROUP_FROZEN;\n\t\tatomic_inc(&system_freezing_cnt);\n\t}\n\n\tmutex_unlock(&freezer_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "freezer_css_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "85-95",
    "snippet": "static struct cgroup_subsys_state *\nfreezer_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct freezer *freezer;\n\n\tfreezer = kzalloc(sizeof(struct freezer), GFP_KERNEL);\n\tif (!freezer)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn &freezer->css;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct freezer)",
            "GFP_KERNEL"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic struct cgroup_subsys_state *\nfreezer_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct freezer *freezer;\n\n\tfreezer = kzalloc(sizeof(struct freezer), GFP_KERNEL);\n\tif (!freezer)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn &freezer->css;\n}"
  },
  {
    "function_name": "freezer_state_strs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "76-83",
    "snippet": "static const char *freezer_state_strs(unsigned int state)\n{\n\tif (state & CGROUP_FROZEN)\n\t\treturn \"FROZEN\";\n\tif (state & CGROUP_FREEZING)\n\t\treturn \"FREEZING\";\n\treturn \"THAWED\";\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic const char *freezer_state_strs(unsigned int state)\n{\n\tif (state & CGROUP_FROZEN)\n\t\treturn \"FROZEN\";\n\tif (state & CGROUP_FREEZING)\n\t\treturn \"FREEZING\";\n\treturn \"THAWED\";\n}"
  },
  {
    "function_name": "cgroup_freezing",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "65-74",
    "snippet": "bool cgroup_freezing(struct task_struct *task)\n{\n\tbool ret;\n\n\trcu_read_lock();\n\tret = task_freezer(task)->state & CGROUP_FREEZING;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_freezer",
          "args": [
            "task"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "task_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "55-58",
          "snippet": "static inline struct freezer *task_freezer(struct task_struct *task)\n{\n\treturn css_freezer(task_css(task, freezer_cgrp_id));\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic inline struct freezer *task_freezer(struct task_struct *task)\n{\n\treturn css_freezer(task_css(task, freezer_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nbool cgroup_freezing(struct task_struct *task)\n{\n\tbool ret;\n\n\trcu_read_lock();\n\tret = task_freezer(task)->state & CGROUP_FREEZING;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "parent_freezer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "60-63",
    "snippet": "static struct freezer *parent_freezer(struct freezer *freezer)\n{\n\treturn css_freezer(freezer->css.parent);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_freezer",
          "args": [
            "freezer->css.parent"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "css_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "50-53",
          "snippet": "static inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic struct freezer *parent_freezer(struct freezer *freezer)\n{\n\treturn css_freezer(freezer->css.parent);\n}"
  },
  {
    "function_name": "task_freezer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "55-58",
    "snippet": "static inline struct freezer *task_freezer(struct task_struct *task)\n{\n\treturn css_freezer(task_css(task, freezer_cgrp_id));\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_freezer",
          "args": [
            "task_css(task, freezer_cgrp_id)"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "css_freezer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
          "lines": "50-53",
          "snippet": "static inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css",
          "args": [
            "task",
            "freezer_cgrp_id"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic inline struct freezer *task_freezer(struct task_struct *task)\n{\n\treturn css_freezer(task_css(task, freezer_cgrp_id));\n}"
  },
  {
    "function_name": "css_freezer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/legacy_freezer.c",
    "lines": "50-53",
    "snippet": "static inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "css",
            "structfreezer",
            "css"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : NULL;\n}"
  }
]