[
  {
    "function_name": "kdb_send_sig",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4773-4802",
    "snippet": "void kdb_send_sig(struct task_struct *t, int sig)\n{\n\tstatic struct task_struct *kdb_prev_t;\n\tint new_t, ret;\n\tif (!spin_trylock(&t->sighand->siglock)) {\n\t\tkdb_printf(\"Can't do kill command now.\\n\"\n\t\t\t   \"The sigmask lock is held somewhere else in \"\n\t\t\t   \"kernel, try again later\\n\");\n\t\treturn;\n\t}\n\tnew_t = kdb_prev_t != t;\n\tkdb_prev_t = t;\n\tif (!task_is_running(t) && new_t) {\n\t\tspin_unlock(&t->sighand->siglock);\n\t\tkdb_printf(\"Process is not RUNNING, sending a signal from \"\n\t\t\t   \"kdb risks deadlock\\n\"\n\t\t\t   \"on the run queue locks. \"\n\t\t\t   \"The signal has _not_ been sent.\\n\"\n\t\t\t   \"Reissue the kill command if you want to risk \"\n\t\t\t   \"the deadlock.\\n\");\n\t\treturn;\n\t}\n\tret = send_signal(sig, SEND_SIG_PRIV, t, PIDTYPE_PID);\n\tspin_unlock(&t->sighand->siglock);\n\tif (ret)\n\t\tkdb_printf(\"Fail to deliver Signal %d to process %d.\\n\",\n\t\t\t   sig, t->pid);\n\telse\n\t\tkdb_printf(\"Signal %d is sent to process %d.\\n\", sig, t->pid);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Signal %d is sent to process %d.\\n\"",
            "sig",
            "t->pid"
          ],
          "line": 4801
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&t->sighand->siglock"
          ],
          "line": 4796
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_signal",
          "args": [
            "sig",
            "SEND_SIG_PRIV",
            "t",
            "PIDTYPE_PID"
          ],
          "line": 4795
        },
        "resolved": true,
        "details": {
          "function_name": "send_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1215-1249",
          "snippet": "static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\t/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */\n\tbool force = false;\n\n\tif (info == SEND_SIG_NOINFO) {\n\t\t/* Force if sent from an ancestor pid namespace */\n\t\tforce = !task_pid_nr_ns(current, task_active_pid_ns(t));\n\t} else if (info == SEND_SIG_PRIV) {\n\t\t/* Don't ignore kernel generated signals */\n\t\tforce = true;\n\t} else if (has_si_pid_and_uid(info)) {\n\t\t/* SIGKILL and SIGSTOP is special or has ids */\n\t\tstruct user_namespace *t_user_ns;\n\n\t\trcu_read_lock();\n\t\tt_user_ns = task_cred_xxx(t, user_ns);\n\t\tif (current_user_ns() != t_user_ns) {\n\t\t\tkuid_t uid = make_kuid(current_user_ns(), info->si_uid);\n\t\t\tinfo->si_uid = from_kuid_munged(t_user_ns, uid);\n\t\t}\n\t\trcu_read_unlock();\n\n\t\t/* A kernel generated signal? */\n\t\tforce = (info->si_code == SI_KERNEL);\n\n\t\t/* From an ancestor pid namespace? */\n\t\tif (!task_pid_nr_ns(current, task_active_pid_ns(t))) {\n\t\t\tinfo->si_pid = 0;\n\t\t\tforce = true;\n\t\t}\n\t}\n\treturn __send_signal(sig, info, t, type, force);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\t/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */\n\tbool force = false;\n\n\tif (info == SEND_SIG_NOINFO) {\n\t\t/* Force if sent from an ancestor pid namespace */\n\t\tforce = !task_pid_nr_ns(current, task_active_pid_ns(t));\n\t} else if (info == SEND_SIG_PRIV) {\n\t\t/* Don't ignore kernel generated signals */\n\t\tforce = true;\n\t} else if (has_si_pid_and_uid(info)) {\n\t\t/* SIGKILL and SIGSTOP is special or has ids */\n\t\tstruct user_namespace *t_user_ns;\n\n\t\trcu_read_lock();\n\t\tt_user_ns = task_cred_xxx(t, user_ns);\n\t\tif (current_user_ns() != t_user_ns) {\n\t\t\tkuid_t uid = make_kuid(current_user_ns(), info->si_uid);\n\t\t\tinfo->si_uid = from_kuid_munged(t_user_ns, uid);\n\t\t}\n\t\trcu_read_unlock();\n\n\t\t/* A kernel generated signal? */\n\t\tforce = (info->si_code == SI_KERNEL);\n\n\t\t/* From an ancestor pid namespace? */\n\t\tif (!task_pid_nr_ns(current, task_active_pid_ns(t))) {\n\t\t\tinfo->si_pid = 0;\n\t\t\tforce = true;\n\t\t}\n\t}\n\treturn __send_signal(sig, info, t, type, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_is_running",
          "args": [
            "t"
          ],
          "line": 4785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&t->sighand->siglock"
          ],
          "line": 4777
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_trylock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "144-147",
          "snippet": "int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid kdb_send_sig(struct task_struct *t, int sig)\n{\n\tstatic struct task_struct *kdb_prev_t;\n\tint new_t, ret;\n\tif (!spin_trylock(&t->sighand->siglock)) {\n\t\tkdb_printf(\"Can't do kill command now.\\n\"\n\t\t\t   \"The sigmask lock is held somewhere else in \"\n\t\t\t   \"kernel, try again later\\n\");\n\t\treturn;\n\t}\n\tnew_t = kdb_prev_t != t;\n\tkdb_prev_t = t;\n\tif (!task_is_running(t) && new_t) {\n\t\tspin_unlock(&t->sighand->siglock);\n\t\tkdb_printf(\"Process is not RUNNING, sending a signal from \"\n\t\t\t   \"kdb risks deadlock\\n\"\n\t\t\t   \"on the run queue locks. \"\n\t\t\t   \"The signal has _not_ been sent.\\n\"\n\t\t\t   \"Reissue the kill command if you want to risk \"\n\t\t\t   \"the deadlock.\\n\");\n\t\treturn;\n\t}\n\tret = send_signal(sig, SEND_SIG_PRIV, t, PIDTYPE_PID);\n\tspin_unlock(&t->sighand->siglock);\n\tif (ret)\n\t\tkdb_printf(\"Fail to deliver Signal %d to process %d.\\n\",\n\t\t\t   sig, t->pid);\n\telse\n\t\tkdb_printf(\"Signal %d is sent to process %d.\\n\", sig, t->pid);\n}"
  },
  {
    "function_name": "signals_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4758-4763",
    "snippet": "void __init signals_init(void)\n{\n\tsiginfo_buildtime_checks();\n\n\tsigqueue_cachep = KMEM_CACHE(sigqueue, SLAB_PANIC | SLAB_ACCOUNT);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *sigqueue_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "sigqueue",
            "SLAB_PANIC | SLAB_ACCOUNT"
          ],
          "line": 4762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginfo_buildtime_checks",
          "args": [],
          "line": 4760
        },
        "resolved": true,
        "details": {
          "function_name": "siginfo_buildtime_checks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "4686-4756",
          "snippet": "static inline void siginfo_buildtime_checks(void)\n{\n\tBUILD_BUG_ON(sizeof(struct siginfo) != SI_MAX_SIZE);\n\n\t/* Verify the offsets in the two siginfos match */\n#define CHECK_OFFSET(field) \\\n\tBUILD_BUG_ON(offsetof(siginfo_t, field) != offsetof(kernel_siginfo_t, field))\n\n\t/* kill */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\n\t/* timer */\n\tCHECK_OFFSET(si_tid);\n\tCHECK_OFFSET(si_overrun);\n\tCHECK_OFFSET(si_value);\n\n\t/* rt */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\tCHECK_OFFSET(si_value);\n\n\t/* sigchld */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\tCHECK_OFFSET(si_status);\n\tCHECK_OFFSET(si_utime);\n\tCHECK_OFFSET(si_stime);\n\n\t/* sigfault */\n\tCHECK_OFFSET(si_addr);\n\tCHECK_OFFSET(si_trapno);\n\tCHECK_OFFSET(si_addr_lsb);\n\tCHECK_OFFSET(si_lower);\n\tCHECK_OFFSET(si_upper);\n\tCHECK_OFFSET(si_pkey);\n\tCHECK_OFFSET(si_perf_data);\n\tCHECK_OFFSET(si_perf_type);\n\n\t/* sigpoll */\n\tCHECK_OFFSET(si_band);\n\tCHECK_OFFSET(si_fd);\n\n\t/* sigsys */\n\tCHECK_OFFSET(si_call_addr);\n\tCHECK_OFFSET(si_syscall);\n\tCHECK_OFFSET(si_arch);\n#undef CHECK_OFFSET\n\n\t/* usb asyncio */\n\tBUILD_BUG_ON(offsetof(struct siginfo, si_pid) !=\n\t\t     offsetof(struct siginfo, si_addr));\n\tif (sizeof(int) == sizeof(void __user *)) {\n\t\tBUILD_BUG_ON(sizeof_field(struct siginfo, si_pid) !=\n\t\t\t     sizeof(void __user *));\n\t} else {\n\t\tBUILD_BUG_ON((sizeof_field(struct siginfo, si_pid) +\n\t\t\t      sizeof_field(struct siginfo, si_uid)) !=\n\t\t\t     sizeof(void __user *));\n\t\tBUILD_BUG_ON(offsetofend(struct siginfo, si_pid) !=\n\t\t\t     offsetof(struct siginfo, si_uid));\n\t}\n#ifdef CONFIG_COMPAT\n\tBUILD_BUG_ON(offsetof(struct compat_siginfo, si_pid) !=\n\t\t     offsetof(struct compat_siginfo, si_addr));\n\tBUILD_BUG_ON(sizeof_field(struct compat_siginfo, si_pid) !=\n\t\t     sizeof(compat_uptr_t));\n\tBUILD_BUG_ON(sizeof_field(struct compat_siginfo, si_pid) !=\n\t\t     sizeof_field(struct siginfo, si_pid));\n#endif\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline void siginfo_buildtime_checks(void)\n{\n\tBUILD_BUG_ON(sizeof(struct siginfo) != SI_MAX_SIZE);\n\n\t/* Verify the offsets in the two siginfos match */\n#define CHECK_OFFSET(field) \\\n\tBUILD_BUG_ON(offsetof(siginfo_t, field) != offsetof(kernel_siginfo_t, field))\n\n\t/* kill */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\n\t/* timer */\n\tCHECK_OFFSET(si_tid);\n\tCHECK_OFFSET(si_overrun);\n\tCHECK_OFFSET(si_value);\n\n\t/* rt */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\tCHECK_OFFSET(si_value);\n\n\t/* sigchld */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\tCHECK_OFFSET(si_status);\n\tCHECK_OFFSET(si_utime);\n\tCHECK_OFFSET(si_stime);\n\n\t/* sigfault */\n\tCHECK_OFFSET(si_addr);\n\tCHECK_OFFSET(si_trapno);\n\tCHECK_OFFSET(si_addr_lsb);\n\tCHECK_OFFSET(si_lower);\n\tCHECK_OFFSET(si_upper);\n\tCHECK_OFFSET(si_pkey);\n\tCHECK_OFFSET(si_perf_data);\n\tCHECK_OFFSET(si_perf_type);\n\n\t/* sigpoll */\n\tCHECK_OFFSET(si_band);\n\tCHECK_OFFSET(si_fd);\n\n\t/* sigsys */\n\tCHECK_OFFSET(si_call_addr);\n\tCHECK_OFFSET(si_syscall);\n\tCHECK_OFFSET(si_arch);\n#undef CHECK_OFFSET\n\n\t/* usb asyncio */\n\tBUILD_BUG_ON(offsetof(struct siginfo, si_pid) !=\n\t\t     offsetof(struct siginfo, si_addr));\n\tif (sizeof(int) == sizeof(void __user *)) {\n\t\tBUILD_BUG_ON(sizeof_field(struct siginfo, si_pid) !=\n\t\t\t     sizeof(void __user *));\n\t} else {\n\t\tBUILD_BUG_ON((sizeof_field(struct siginfo, si_pid) +\n\t\t\t      sizeof_field(struct siginfo, si_uid)) !=\n\t\t\t     sizeof(void __user *));\n\t\tBUILD_BUG_ON(offsetofend(struct siginfo, si_pid) !=\n\t\t\t     offsetof(struct siginfo, si_uid));\n\t}\n#ifdef CONFIG_COMPAT\n\tBUILD_BUG_ON(offsetof(struct compat_siginfo, si_pid) !=\n\t\t     offsetof(struct compat_siginfo, si_addr));\n\tBUILD_BUG_ON(sizeof_field(struct compat_siginfo, si_pid) !=\n\t\t     sizeof(compat_uptr_t));\n\tBUILD_BUG_ON(sizeof_field(struct compat_siginfo, si_pid) !=\n\t\t     sizeof_field(struct siginfo, si_pid));\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nvoid __init signals_init(void)\n{\n\tsiginfo_buildtime_checks();\n\n\tsigqueue_cachep = KMEM_CACHE(sigqueue, SLAB_PANIC | SLAB_ACCOUNT);\n}"
  },
  {
    "function_name": "siginfo_buildtime_checks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4686-4756",
    "snippet": "static inline void siginfo_buildtime_checks(void)\n{\n\tBUILD_BUG_ON(sizeof(struct siginfo) != SI_MAX_SIZE);\n\n\t/* Verify the offsets in the two siginfos match */\n#define CHECK_OFFSET(field) \\\n\tBUILD_BUG_ON(offsetof(siginfo_t, field) != offsetof(kernel_siginfo_t, field))\n\n\t/* kill */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\n\t/* timer */\n\tCHECK_OFFSET(si_tid);\n\tCHECK_OFFSET(si_overrun);\n\tCHECK_OFFSET(si_value);\n\n\t/* rt */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\tCHECK_OFFSET(si_value);\n\n\t/* sigchld */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\tCHECK_OFFSET(si_status);\n\tCHECK_OFFSET(si_utime);\n\tCHECK_OFFSET(si_stime);\n\n\t/* sigfault */\n\tCHECK_OFFSET(si_addr);\n\tCHECK_OFFSET(si_trapno);\n\tCHECK_OFFSET(si_addr_lsb);\n\tCHECK_OFFSET(si_lower);\n\tCHECK_OFFSET(si_upper);\n\tCHECK_OFFSET(si_pkey);\n\tCHECK_OFFSET(si_perf_data);\n\tCHECK_OFFSET(si_perf_type);\n\n\t/* sigpoll */\n\tCHECK_OFFSET(si_band);\n\tCHECK_OFFSET(si_fd);\n\n\t/* sigsys */\n\tCHECK_OFFSET(si_call_addr);\n\tCHECK_OFFSET(si_syscall);\n\tCHECK_OFFSET(si_arch);\n#undef CHECK_OFFSET\n\n\t/* usb asyncio */\n\tBUILD_BUG_ON(offsetof(struct siginfo, si_pid) !=\n\t\t     offsetof(struct siginfo, si_addr));\n\tif (sizeof(int) == sizeof(void __user *)) {\n\t\tBUILD_BUG_ON(sizeof_field(struct siginfo, si_pid) !=\n\t\t\t     sizeof(void __user *));\n\t} else {\n\t\tBUILD_BUG_ON((sizeof_field(struct siginfo, si_pid) +\n\t\t\t      sizeof_field(struct siginfo, si_uid)) !=\n\t\t\t     sizeof(void __user *));\n\t\tBUILD_BUG_ON(offsetofend(struct siginfo, si_pid) !=\n\t\t\t     offsetof(struct siginfo, si_uid));\n\t}\n#ifdef CONFIG_COMPAT\n\tBUILD_BUG_ON(offsetof(struct compat_siginfo, si_pid) !=\n\t\t     offsetof(struct compat_siginfo, si_addr));\n\tBUILD_BUG_ON(sizeof_field(struct compat_siginfo, si_pid) !=\n\t\t     sizeof(compat_uptr_t));\n\tBUILD_BUG_ON(sizeof_field(struct compat_siginfo, si_pid) !=\n\t\t     sizeof_field(struct siginfo, si_pid));\n#endif\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sizeof_field",
          "args": [
            "structsiginfo",
            "si_pid"
          ],
          "line": 4754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct compat_siginfo, si_pid) !=\n\t\t     offsetof(struct compat_siginfo, si_addr)"
          ],
          "line": 4749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sizeof_field",
          "args": [
            "structsiginfo",
            "si_uid"
          ],
          "line": 4743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct siginfo, si_pid) !=\n\t\t     offsetof(struct siginfo, si_addr)"
          ],
          "line": 4736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_arch"
          ],
          "line": 4732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_syscall"
          ],
          "line": 4731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_call_addr"
          ],
          "line": 4730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_fd"
          ],
          "line": 4727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_band"
          ],
          "line": 4726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_perf_type"
          ],
          "line": 4723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_perf_data"
          ],
          "line": 4722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_pkey"
          ],
          "line": 4721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_upper"
          ],
          "line": 4720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_lower"
          ],
          "line": 4719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_addr_lsb"
          ],
          "line": 4718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_trapno"
          ],
          "line": 4717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_addr"
          ],
          "line": 4716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_stime"
          ],
          "line": 4713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_utime"
          ],
          "line": 4712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_status"
          ],
          "line": 4711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_uid"
          ],
          "line": 4710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_pid"
          ],
          "line": 4709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_value"
          ],
          "line": 4706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_uid"
          ],
          "line": 4705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_pid"
          ],
          "line": 4704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_value"
          ],
          "line": 4701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_overrun"
          ],
          "line": 4700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_tid"
          ],
          "line": 4699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_uid"
          ],
          "line": 4696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_pid"
          ],
          "line": 4695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(struct siginfo) != SI_MAX_SIZE"
          ],
          "line": 4688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline void siginfo_buildtime_checks(void)\n{\n\tBUILD_BUG_ON(sizeof(struct siginfo) != SI_MAX_SIZE);\n\n\t/* Verify the offsets in the two siginfos match */\n#define CHECK_OFFSET(field) \\\n\tBUILD_BUG_ON(offsetof(siginfo_t, field) != offsetof(kernel_siginfo_t, field))\n\n\t/* kill */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\n\t/* timer */\n\tCHECK_OFFSET(si_tid);\n\tCHECK_OFFSET(si_overrun);\n\tCHECK_OFFSET(si_value);\n\n\t/* rt */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\tCHECK_OFFSET(si_value);\n\n\t/* sigchld */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\tCHECK_OFFSET(si_status);\n\tCHECK_OFFSET(si_utime);\n\tCHECK_OFFSET(si_stime);\n\n\t/* sigfault */\n\tCHECK_OFFSET(si_addr);\n\tCHECK_OFFSET(si_trapno);\n\tCHECK_OFFSET(si_addr_lsb);\n\tCHECK_OFFSET(si_lower);\n\tCHECK_OFFSET(si_upper);\n\tCHECK_OFFSET(si_pkey);\n\tCHECK_OFFSET(si_perf_data);\n\tCHECK_OFFSET(si_perf_type);\n\n\t/* sigpoll */\n\tCHECK_OFFSET(si_band);\n\tCHECK_OFFSET(si_fd);\n\n\t/* sigsys */\n\tCHECK_OFFSET(si_call_addr);\n\tCHECK_OFFSET(si_syscall);\n\tCHECK_OFFSET(si_arch);\n#undef CHECK_OFFSET\n\n\t/* usb asyncio */\n\tBUILD_BUG_ON(offsetof(struct siginfo, si_pid) !=\n\t\t     offsetof(struct siginfo, si_addr));\n\tif (sizeof(int) == sizeof(void __user *)) {\n\t\tBUILD_BUG_ON(sizeof_field(struct siginfo, si_pid) !=\n\t\t\t     sizeof(void __user *));\n\t} else {\n\t\tBUILD_BUG_ON((sizeof_field(struct siginfo, si_pid) +\n\t\t\t      sizeof_field(struct siginfo, si_uid)) !=\n\t\t\t     sizeof(void __user *));\n\t\tBUILD_BUG_ON(offsetofend(struct siginfo, si_pid) !=\n\t\t\t     offsetof(struct siginfo, si_uid));\n\t}\n#ifdef CONFIG_COMPAT\n\tBUILD_BUG_ON(offsetof(struct compat_siginfo, si_pid) !=\n\t\t     offsetof(struct compat_siginfo, si_addr));\n\tBUILD_BUG_ON(sizeof_field(struct compat_siginfo, si_pid) !=\n\t\t     sizeof(compat_uptr_t));\n\tBUILD_BUG_ON(sizeof_field(struct compat_siginfo, si_pid) !=\n\t\t     sizeof_field(struct siginfo, si_pid));\n#endif\n}"
  },
  {
    "function_name": "arch_vma_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4681-4684",
    "snippet": "__weak const char *arch_vma_name(struct vm_area_struct *vma)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\n__weak const char *arch_vma_name(struct vm_area_struct *vma)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "sigsuspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4617-4628",
    "snippet": "static int sigsuspend(sigset_t *set)\n{\n\tcurrent->saved_sigmask = current->blocked;\n\tset_current_blocked(set);\n\n\twhile (!signal_pending(current)) {\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule();\n\t}\n\tset_restore_sigmask();\n\treturn -ERESTARTNOHAND;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_restore_sigmask",
          "args": [],
          "line": 4626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 4624
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 4623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 4622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_blocked",
          "args": [
            "set"
          ],
          "line": 4620
        },
        "resolved": true,
        "details": {
          "function_name": "__set_current_blocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3039-3053",
          "snippet": "void __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int sigsuspend(sigset_t *set)\n{\n\tcurrent->saved_sigmask = current->blocked;\n\tset_current_blocked(set);\n\n\twhile (!signal_pending(current)) {\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule();\n\t}\n\tset_restore_sigmask();\n\treturn -ERESTARTNOHAND;\n}"
  },
  {
    "function_name": "__compat_save_altstack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4308-4317",
    "snippet": "int __compat_save_altstack(compat_stack_t __user *uss, unsigned long sp)\n{\n\tint err;\n\tstruct task_struct *t = current;\n\terr = __put_user(ptr_to_compat((void __user *)t->sas_ss_sp),\n\t\t\t &uss->ss_sp) |\n\t\t__put_user(t->sas_ss_flags, &uss->ss_flags) |\n\t\t__put_user(t->sas_ss_size, &uss->ss_size);\n\treturn err;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "t->sas_ss_size",
            "&uss->ss_size"
          ],
          "line": 4315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "t->sas_ss_flags",
            "&uss->ss_flags"
          ],
          "line": 4314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "ptr_to_compat((void __user *)t->sas_ss_sp)",
            "&uss->ss_sp"
          ],
          "line": 4312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "(void __user *)t->sas_ss_sp"
          ],
          "line": 4312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint __compat_save_altstack(compat_stack_t __user *uss, unsigned long sp)\n{\n\tint err;\n\tstruct task_struct *t = current;\n\terr = __put_user(ptr_to_compat((void __user *)t->sas_ss_sp),\n\t\t\t &uss->ss_sp) |\n\t\t__put_user(t->sas_ss_flags, &uss->ss_flags) |\n\t\t__put_user(t->sas_ss_size, &uss->ss_size);\n\treturn err;\n}"
  },
  {
    "function_name": "compat_restore_altstack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4301-4306",
    "snippet": "int compat_restore_altstack(const compat_stack_t __user *uss)\n{\n\tint err = do_compat_sigaltstack(uss, NULL);\n\t/* squash all but -EFAULT for now */\n\treturn err == -EFAULT ? err : 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_compat_sigaltstack",
          "args": [
            "uss",
            "NULL"
          ],
          "line": 4303
        },
        "resolved": true,
        "details": {
          "function_name": "do_compat_sigaltstack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "4265-4292",
          "snippet": "static int do_compat_sigaltstack(const compat_stack_t __user *uss_ptr,\n\t\t\t\t compat_stack_t __user *uoss_ptr)\n{\n\tstack_t uss, uoss;\n\tint ret;\n\n\tif (uss_ptr) {\n\t\tcompat_stack_t uss32;\n\t\tif (copy_from_user(&uss32, uss_ptr, sizeof(compat_stack_t)))\n\t\t\treturn -EFAULT;\n\t\tuss.ss_sp = compat_ptr(uss32.ss_sp);\n\t\tuss.ss_flags = uss32.ss_flags;\n\t\tuss.ss_size = uss32.ss_size;\n\t}\n\tret = do_sigaltstack(uss_ptr ? &uss : NULL, &uoss,\n\t\t\t     compat_user_stack_pointer(),\n\t\t\t     COMPAT_MINSIGSTKSZ);\n\tif (ret >= 0 && uoss_ptr)  {\n\t\tcompat_stack_t old;\n\t\tmemset(&old, 0, sizeof(old));\n\t\told.ss_sp = ptr_to_compat(uoss.ss_sp);\n\t\told.ss_flags = uoss.ss_flags;\n\t\told.ss_size = uoss.ss_size;\n\t\tif (copy_to_user(uoss_ptr, &old, sizeof(compat_stack_t)))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int do_compat_sigaltstack(const compat_stack_t __user *uss_ptr,\n\t\t\t\t compat_stack_t __user *uoss_ptr)\n{\n\tstack_t uss, uoss;\n\tint ret;\n\n\tif (uss_ptr) {\n\t\tcompat_stack_t uss32;\n\t\tif (copy_from_user(&uss32, uss_ptr, sizeof(compat_stack_t)))\n\t\t\treturn -EFAULT;\n\t\tuss.ss_sp = compat_ptr(uss32.ss_sp);\n\t\tuss.ss_flags = uss32.ss_flags;\n\t\tuss.ss_size = uss32.ss_size;\n\t}\n\tret = do_sigaltstack(uss_ptr ? &uss : NULL, &uoss,\n\t\t\t     compat_user_stack_pointer(),\n\t\t\t     COMPAT_MINSIGSTKSZ);\n\tif (ret >= 0 && uoss_ptr)  {\n\t\tcompat_stack_t old;\n\t\tmemset(&old, 0, sizeof(old));\n\t\told.ss_sp = ptr_to_compat(uoss.ss_sp);\n\t\told.ss_flags = uoss.ss_flags;\n\t\told.ss_size = uoss.ss_size;\n\t\tif (copy_to_user(uoss_ptr, &old, sizeof(compat_stack_t)))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint compat_restore_altstack(const compat_stack_t __user *uss)\n{\n\tint err = do_compat_sigaltstack(uss, NULL);\n\t/* squash all but -EFAULT for now */\n\treturn err == -EFAULT ? err : 0;\n}"
  },
  {
    "function_name": "do_compat_sigaltstack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4265-4292",
    "snippet": "static int do_compat_sigaltstack(const compat_stack_t __user *uss_ptr,\n\t\t\t\t compat_stack_t __user *uoss_ptr)\n{\n\tstack_t uss, uoss;\n\tint ret;\n\n\tif (uss_ptr) {\n\t\tcompat_stack_t uss32;\n\t\tif (copy_from_user(&uss32, uss_ptr, sizeof(compat_stack_t)))\n\t\t\treturn -EFAULT;\n\t\tuss.ss_sp = compat_ptr(uss32.ss_sp);\n\t\tuss.ss_flags = uss32.ss_flags;\n\t\tuss.ss_size = uss32.ss_size;\n\t}\n\tret = do_sigaltstack(uss_ptr ? &uss : NULL, &uoss,\n\t\t\t     compat_user_stack_pointer(),\n\t\t\t     COMPAT_MINSIGSTKSZ);\n\tif (ret >= 0 && uoss_ptr)  {\n\t\tcompat_stack_t old;\n\t\tmemset(&old, 0, sizeof(old));\n\t\told.ss_sp = ptr_to_compat(uoss.ss_sp);\n\t\told.ss_flags = uoss.ss_flags;\n\t\told.ss_size = uoss.ss_size;\n\t\tif (copy_to_user(uoss_ptr, &old, sizeof(compat_stack_t)))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uoss_ptr",
            "&old",
            "sizeof(compat_stack_t)"
          ],
          "line": 4288
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "uoss.ss_sp"
          ],
          "line": 4285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&old",
            "0",
            "sizeof(old)"
          ],
          "line": 4284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_sigaltstack",
          "args": [
            "uss_ptr ? &uss : NULL",
            "&uoss",
            "compat_user_stack_pointer()",
            "COMPAT_MINSIGSTKSZ"
          ],
          "line": 4279
        },
        "resolved": true,
        "details": {
          "function_name": "do_sigaltstack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "4172-4228",
          "snippet": "static int\ndo_sigaltstack (const stack_t *ss, stack_t *oss, unsigned long sp,\n\t\tsize_t min_ss_size)\n{\n\tstruct task_struct *t = current;\n\tint ret = 0;\n\n\tif (oss) {\n\t\tmemset(oss, 0, sizeof(stack_t));\n\t\toss->ss_sp = (void __user *) t->sas_ss_sp;\n\t\toss->ss_size = t->sas_ss_size;\n\t\toss->ss_flags = sas_ss_flags(sp) |\n\t\t\t(current->sas_ss_flags & SS_FLAG_BITS);\n\t}\n\n\tif (ss) {\n\t\tvoid __user *ss_sp = ss->ss_sp;\n\t\tsize_t ss_size = ss->ss_size;\n\t\tunsigned ss_flags = ss->ss_flags;\n\t\tint ss_mode;\n\n\t\tif (unlikely(on_sig_stack(sp)))\n\t\t\treturn -EPERM;\n\n\t\tss_mode = ss_flags & ~SS_FLAG_BITS;\n\t\tif (unlikely(ss_mode != SS_DISABLE && ss_mode != SS_ONSTACK &&\n\t\t\t\tss_mode != 0))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Return before taking any locks if no actual\n\t\t * sigaltstack changes were requested.\n\t\t */\n\t\tif (t->sas_ss_sp == (unsigned long)ss_sp &&\n\t\t    t->sas_ss_size == ss_size &&\n\t\t    t->sas_ss_flags == ss_flags)\n\t\t\treturn 0;\n\n\t\tsigaltstack_lock();\n\t\tif (ss_mode == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\tif (unlikely(ss_size < min_ss_size))\n\t\t\t\tret = -ENOMEM;\n\t\t\tif (!sigaltstack_size_valid(ss_size))\n\t\t\t\tret = -ENOMEM;\n\t\t}\n\t\tif (!ret) {\n\t\t\tt->sas_ss_sp = (unsigned long) ss_sp;\n\t\t\tt->sas_ss_size = ss_size;\n\t\t\tt->sas_ss_flags = ss_flags;\n\t\t}\n\t\tsigaltstack_unlock();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int\ndo_sigaltstack (const stack_t *ss, stack_t *oss, unsigned long sp,\n\t\tsize_t min_ss_size)\n{\n\tstruct task_struct *t = current;\n\tint ret = 0;\n\n\tif (oss) {\n\t\tmemset(oss, 0, sizeof(stack_t));\n\t\toss->ss_sp = (void __user *) t->sas_ss_sp;\n\t\toss->ss_size = t->sas_ss_size;\n\t\toss->ss_flags = sas_ss_flags(sp) |\n\t\t\t(current->sas_ss_flags & SS_FLAG_BITS);\n\t}\n\n\tif (ss) {\n\t\tvoid __user *ss_sp = ss->ss_sp;\n\t\tsize_t ss_size = ss->ss_size;\n\t\tunsigned ss_flags = ss->ss_flags;\n\t\tint ss_mode;\n\n\t\tif (unlikely(on_sig_stack(sp)))\n\t\t\treturn -EPERM;\n\n\t\tss_mode = ss_flags & ~SS_FLAG_BITS;\n\t\tif (unlikely(ss_mode != SS_DISABLE && ss_mode != SS_ONSTACK &&\n\t\t\t\tss_mode != 0))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Return before taking any locks if no actual\n\t\t * sigaltstack changes were requested.\n\t\t */\n\t\tif (t->sas_ss_sp == (unsigned long)ss_sp &&\n\t\t    t->sas_ss_size == ss_size &&\n\t\t    t->sas_ss_flags == ss_flags)\n\t\t\treturn 0;\n\n\t\tsigaltstack_lock();\n\t\tif (ss_mode == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\tif (unlikely(ss_size < min_ss_size))\n\t\t\t\tret = -ENOMEM;\n\t\t\tif (!sigaltstack_size_valid(ss_size))\n\t\t\t\tret = -ENOMEM;\n\t\t}\n\t\tif (!ret) {\n\t\t\tt->sas_ss_sp = (unsigned long) ss_sp;\n\t\t\tt->sas_ss_size = ss_size;\n\t\t\tt->sas_ss_flags = ss_flags;\n\t\t}\n\t\tsigaltstack_unlock();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_user_stack_pointer",
          "args": [],
          "line": 4280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "uss32.ss_sp"
          ],
          "line": 4275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&uss32",
            "uss_ptr",
            "sizeof(compat_stack_t)"
          ],
          "line": 4273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int do_compat_sigaltstack(const compat_stack_t __user *uss_ptr,\n\t\t\t\t compat_stack_t __user *uoss_ptr)\n{\n\tstack_t uss, uoss;\n\tint ret;\n\n\tif (uss_ptr) {\n\t\tcompat_stack_t uss32;\n\t\tif (copy_from_user(&uss32, uss_ptr, sizeof(compat_stack_t)))\n\t\t\treturn -EFAULT;\n\t\tuss.ss_sp = compat_ptr(uss32.ss_sp);\n\t\tuss.ss_flags = uss32.ss_flags;\n\t\tuss.ss_size = uss32.ss_size;\n\t}\n\tret = do_sigaltstack(uss_ptr ? &uss : NULL, &uoss,\n\t\t\t     compat_user_stack_pointer(),\n\t\t\t     COMPAT_MINSIGSTKSZ);\n\tif (ret >= 0 && uoss_ptr)  {\n\t\tcompat_stack_t old;\n\t\tmemset(&old, 0, sizeof(old));\n\t\told.ss_sp = ptr_to_compat(uoss.ss_sp);\n\t\told.ss_flags = uoss.ss_flags;\n\t\told.ss_size = uoss.ss_size;\n\t\tif (copy_to_user(uoss_ptr, &old, sizeof(compat_stack_t)))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__save_altstack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4255-4262",
    "snippet": "int __save_altstack(stack_t __user *uss, unsigned long sp)\n{\n\tstruct task_struct *t = current;\n\tint err = __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |\n\t\t__put_user(t->sas_ss_flags, &uss->ss_flags) |\n\t\t__put_user(t->sas_ss_size, &uss->ss_size);\n\treturn err;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "t->sas_ss_size",
            "&uss->ss_size"
          ],
          "line": 4260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "t->sas_ss_flags",
            "&uss->ss_flags"
          ],
          "line": 4259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(void __user *)t->sas_ss_sp",
            "&uss->ss_sp"
          ],
          "line": 4258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint __save_altstack(stack_t __user *uss, unsigned long sp)\n{\n\tstruct task_struct *t = current;\n\tint err = __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |\n\t\t__put_user(t->sas_ss_flags, &uss->ss_flags) |\n\t\t__put_user(t->sas_ss_size, &uss->ss_size);\n\treturn err;\n}"
  },
  {
    "function_name": "restore_altstack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4244-4253",
    "snippet": "int restore_altstack(const stack_t __user *uss)\n{\n\tstack_t new;\n\tif (copy_from_user(&new, uss, sizeof(stack_t)))\n\t\treturn -EFAULT;\n\t(void)do_sigaltstack(&new, NULL, current_user_stack_pointer(),\n\t\t\t     MINSIGSTKSZ);\n\t/* squash all but EFAULT for now */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_sigaltstack",
          "args": [
            "&new",
            "NULL",
            "current_user_stack_pointer()",
            "MINSIGSTKSZ"
          ],
          "line": 4249
        },
        "resolved": true,
        "details": {
          "function_name": "do_sigaltstack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "4172-4228",
          "snippet": "static int\ndo_sigaltstack (const stack_t *ss, stack_t *oss, unsigned long sp,\n\t\tsize_t min_ss_size)\n{\n\tstruct task_struct *t = current;\n\tint ret = 0;\n\n\tif (oss) {\n\t\tmemset(oss, 0, sizeof(stack_t));\n\t\toss->ss_sp = (void __user *) t->sas_ss_sp;\n\t\toss->ss_size = t->sas_ss_size;\n\t\toss->ss_flags = sas_ss_flags(sp) |\n\t\t\t(current->sas_ss_flags & SS_FLAG_BITS);\n\t}\n\n\tif (ss) {\n\t\tvoid __user *ss_sp = ss->ss_sp;\n\t\tsize_t ss_size = ss->ss_size;\n\t\tunsigned ss_flags = ss->ss_flags;\n\t\tint ss_mode;\n\n\t\tif (unlikely(on_sig_stack(sp)))\n\t\t\treturn -EPERM;\n\n\t\tss_mode = ss_flags & ~SS_FLAG_BITS;\n\t\tif (unlikely(ss_mode != SS_DISABLE && ss_mode != SS_ONSTACK &&\n\t\t\t\tss_mode != 0))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Return before taking any locks if no actual\n\t\t * sigaltstack changes were requested.\n\t\t */\n\t\tif (t->sas_ss_sp == (unsigned long)ss_sp &&\n\t\t    t->sas_ss_size == ss_size &&\n\t\t    t->sas_ss_flags == ss_flags)\n\t\t\treturn 0;\n\n\t\tsigaltstack_lock();\n\t\tif (ss_mode == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\tif (unlikely(ss_size < min_ss_size))\n\t\t\t\tret = -ENOMEM;\n\t\t\tif (!sigaltstack_size_valid(ss_size))\n\t\t\t\tret = -ENOMEM;\n\t\t}\n\t\tif (!ret) {\n\t\t\tt->sas_ss_sp = (unsigned long) ss_sp;\n\t\t\tt->sas_ss_size = ss_size;\n\t\t\tt->sas_ss_flags = ss_flags;\n\t\t}\n\t\tsigaltstack_unlock();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int\ndo_sigaltstack (const stack_t *ss, stack_t *oss, unsigned long sp,\n\t\tsize_t min_ss_size)\n{\n\tstruct task_struct *t = current;\n\tint ret = 0;\n\n\tif (oss) {\n\t\tmemset(oss, 0, sizeof(stack_t));\n\t\toss->ss_sp = (void __user *) t->sas_ss_sp;\n\t\toss->ss_size = t->sas_ss_size;\n\t\toss->ss_flags = sas_ss_flags(sp) |\n\t\t\t(current->sas_ss_flags & SS_FLAG_BITS);\n\t}\n\n\tif (ss) {\n\t\tvoid __user *ss_sp = ss->ss_sp;\n\t\tsize_t ss_size = ss->ss_size;\n\t\tunsigned ss_flags = ss->ss_flags;\n\t\tint ss_mode;\n\n\t\tif (unlikely(on_sig_stack(sp)))\n\t\t\treturn -EPERM;\n\n\t\tss_mode = ss_flags & ~SS_FLAG_BITS;\n\t\tif (unlikely(ss_mode != SS_DISABLE && ss_mode != SS_ONSTACK &&\n\t\t\t\tss_mode != 0))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Return before taking any locks if no actual\n\t\t * sigaltstack changes were requested.\n\t\t */\n\t\tif (t->sas_ss_sp == (unsigned long)ss_sp &&\n\t\t    t->sas_ss_size == ss_size &&\n\t\t    t->sas_ss_flags == ss_flags)\n\t\t\treturn 0;\n\n\t\tsigaltstack_lock();\n\t\tif (ss_mode == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\tif (unlikely(ss_size < min_ss_size))\n\t\t\t\tret = -ENOMEM;\n\t\t\tif (!sigaltstack_size_valid(ss_size))\n\t\t\t\tret = -ENOMEM;\n\t\t}\n\t\tif (!ret) {\n\t\t\tt->sas_ss_sp = (unsigned long) ss_sp;\n\t\t\tt->sas_ss_size = ss_size;\n\t\t\tt->sas_ss_flags = ss_flags;\n\t\t}\n\t\tsigaltstack_unlock();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_stack_pointer",
          "args": [],
          "line": 4249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&new",
            "uss",
            "sizeof(stack_t)"
          ],
          "line": 4247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint restore_altstack(const stack_t __user *uss)\n{\n\tstack_t new;\n\tif (copy_from_user(&new, uss, sizeof(stack_t)))\n\t\treturn -EFAULT;\n\t(void)do_sigaltstack(&new, NULL, current_user_stack_pointer(),\n\t\t\t     MINSIGSTKSZ);\n\t/* squash all but EFAULT for now */\n\treturn 0;\n}"
  },
  {
    "function_name": "do_sigaltstack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4172-4228",
    "snippet": "static int\ndo_sigaltstack (const stack_t *ss, stack_t *oss, unsigned long sp,\n\t\tsize_t min_ss_size)\n{\n\tstruct task_struct *t = current;\n\tint ret = 0;\n\n\tif (oss) {\n\t\tmemset(oss, 0, sizeof(stack_t));\n\t\toss->ss_sp = (void __user *) t->sas_ss_sp;\n\t\toss->ss_size = t->sas_ss_size;\n\t\toss->ss_flags = sas_ss_flags(sp) |\n\t\t\t(current->sas_ss_flags & SS_FLAG_BITS);\n\t}\n\n\tif (ss) {\n\t\tvoid __user *ss_sp = ss->ss_sp;\n\t\tsize_t ss_size = ss->ss_size;\n\t\tunsigned ss_flags = ss->ss_flags;\n\t\tint ss_mode;\n\n\t\tif (unlikely(on_sig_stack(sp)))\n\t\t\treturn -EPERM;\n\n\t\tss_mode = ss_flags & ~SS_FLAG_BITS;\n\t\tif (unlikely(ss_mode != SS_DISABLE && ss_mode != SS_ONSTACK &&\n\t\t\t\tss_mode != 0))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Return before taking any locks if no actual\n\t\t * sigaltstack changes were requested.\n\t\t */\n\t\tif (t->sas_ss_sp == (unsigned long)ss_sp &&\n\t\t    t->sas_ss_size == ss_size &&\n\t\t    t->sas_ss_flags == ss_flags)\n\t\t\treturn 0;\n\n\t\tsigaltstack_lock();\n\t\tif (ss_mode == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\tif (unlikely(ss_size < min_ss_size))\n\t\t\t\tret = -ENOMEM;\n\t\t\tif (!sigaltstack_size_valid(ss_size))\n\t\t\t\tret = -ENOMEM;\n\t\t}\n\t\tif (!ret) {\n\t\t\tt->sas_ss_sp = (unsigned long) ss_sp;\n\t\t\tt->sas_ss_size = ss_size;\n\t\t\tt->sas_ss_flags = ss_flags;\n\t\t}\n\t\tsigaltstack_unlock();\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigaltstack_unlock",
          "args": [],
          "line": 4225
        },
        "resolved": true,
        "details": {
          "function_name": "sigaltstack_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "4169-4169",
          "snippet": "static inline void sigaltstack_unlock(void) { }",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline void sigaltstack_unlock(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "sigaltstack_size_valid",
          "args": [
            "ss_size"
          ],
          "line": 4217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ss_size < min_ss_size"
          ],
          "line": 4215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaltstack_lock",
          "args": [],
          "line": 4210
        },
        "resolved": true,
        "details": {
          "function_name": "sigaltstack_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "4168-4168",
          "snippet": "static inline void sigaltstack_lock(void) { }",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline void sigaltstack_lock(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ss_mode != SS_DISABLE && ss_mode != SS_ONSTACK &&\n\t\t\t\tss_mode != 0"
          ],
          "line": 4197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "on_sig_stack(sp)"
          ],
          "line": 4193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_sig_stack",
          "args": [
            "sp"
          ],
          "line": 4193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sas_ss_flags",
          "args": [
            "sp"
          ],
          "line": 4183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "oss",
            "0",
            "sizeof(stack_t)"
          ],
          "line": 4180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int\ndo_sigaltstack (const stack_t *ss, stack_t *oss, unsigned long sp,\n\t\tsize_t min_ss_size)\n{\n\tstruct task_struct *t = current;\n\tint ret = 0;\n\n\tif (oss) {\n\t\tmemset(oss, 0, sizeof(stack_t));\n\t\toss->ss_sp = (void __user *) t->sas_ss_sp;\n\t\toss->ss_size = t->sas_ss_size;\n\t\toss->ss_flags = sas_ss_flags(sp) |\n\t\t\t(current->sas_ss_flags & SS_FLAG_BITS);\n\t}\n\n\tif (ss) {\n\t\tvoid __user *ss_sp = ss->ss_sp;\n\t\tsize_t ss_size = ss->ss_size;\n\t\tunsigned ss_flags = ss->ss_flags;\n\t\tint ss_mode;\n\n\t\tif (unlikely(on_sig_stack(sp)))\n\t\t\treturn -EPERM;\n\n\t\tss_mode = ss_flags & ~SS_FLAG_BITS;\n\t\tif (unlikely(ss_mode != SS_DISABLE && ss_mode != SS_ONSTACK &&\n\t\t\t\tss_mode != 0))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Return before taking any locks if no actual\n\t\t * sigaltstack changes were requested.\n\t\t */\n\t\tif (t->sas_ss_sp == (unsigned long)ss_sp &&\n\t\t    t->sas_ss_size == ss_size &&\n\t\t    t->sas_ss_flags == ss_flags)\n\t\t\treturn 0;\n\n\t\tsigaltstack_lock();\n\t\tif (ss_mode == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\tif (unlikely(ss_size < min_ss_size))\n\t\t\t\tret = -ENOMEM;\n\t\t\tif (!sigaltstack_size_valid(ss_size))\n\t\t\t\tret = -ENOMEM;\n\t\t}\n\t\tif (!ret) {\n\t\t\tt->sas_ss_sp = (unsigned long) ss_sp;\n\t\t\tt->sas_ss_size = ss_size;\n\t\t\tt->sas_ss_flags = ss_flags;\n\t\t}\n\t\tsigaltstack_unlock();\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "sigaltstack_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4169-4169",
    "snippet": "static inline void sigaltstack_unlock(void) { }",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline void sigaltstack_unlock(void) { }"
  },
  {
    "function_name": "sigaltstack_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4168-4168",
    "snippet": "static inline void sigaltstack_lock(void) { }",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline void sigaltstack_lock(void) { }"
  },
  {
    "function_name": "sigaltstack_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4162-4166",
    "snippet": "static inline void sigaltstack_unlock(void)\n\t__releases(&current->sighand->siglock)\n{\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 4165
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 4163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline void sigaltstack_unlock(void)\n\t__releases(&current->sighand->siglock)\n{\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
  },
  {
    "function_name": "sigaltstack_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4156-4160",
    "snippet": "static inline void sigaltstack_lock(void)\n\t__acquires(&current->sighand->siglock)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 4159
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 4157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline void sigaltstack_lock(void)\n\t__acquires(&current->sighand->siglock)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n}"
  },
  {
    "function_name": "do_sigaction",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4090-4153",
    "snippet": "int do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)\n{\n\tstruct task_struct *p = current, *t;\n\tstruct k_sigaction *k;\n\tsigset_t mask;\n\n\tif (!valid_signal(sig) || sig < 1 || (act && sig_kernel_only(sig)))\n\t\treturn -EINVAL;\n\n\tk = &p->sighand->action[sig-1];\n\n\tspin_lock_irq(&p->sighand->siglock);\n\tif (k->sa.sa_flags & SA_IMMUTABLE) {\n\t\tspin_unlock_irq(&p->sighand->siglock);\n\t\treturn -EINVAL;\n\t}\n\tif (oact)\n\t\t*oact = *k;\n\n\t/*\n\t * Make sure that we never accidentally claim to support SA_UNSUPPORTED,\n\t * e.g. by having an architecture use the bit in their uapi.\n\t */\n\tBUILD_BUG_ON(UAPI_SA_FLAGS & SA_UNSUPPORTED);\n\n\t/*\n\t * Clear unknown flag bits in order to allow userspace to detect missing\n\t * support for flag bits and to allow the kernel to use non-uapi bits\n\t * internally.\n\t */\n\tif (act)\n\t\tact->sa.sa_flags &= UAPI_SA_FLAGS;\n\tif (oact)\n\t\toact->sa.sa_flags &= UAPI_SA_FLAGS;\n\n\tsigaction_compat_abi(act, oact);\n\n\tif (act) {\n\t\tsigdelsetmask(&act->sa.sa_mask,\n\t\t\t      sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t\t*k = *act;\n\t\t/*\n\t\t * POSIX 3.3.1.3:\n\t\t *  \"Setting a signal action to SIG_IGN for a signal that is\n\t\t *   pending shall cause the pending signal to be discarded,\n\t\t *   whether or not it is blocked.\"\n\t\t *\n\t\t *  \"Setting a signal action to SIG_DFL for a signal that is\n\t\t *   pending and whose default action is to ignore the signal\n\t\t *   (for example, SIGCHLD), shall cause the pending signal to\n\t\t *   be discarded, whether or not it is blocked\"\n\t\t */\n\t\tif (sig_handler_ignored(sig_handler(p, sig), sig)) {\n\t\t\tsigemptyset(&mask);\n\t\t\tsigaddset(&mask, sig);\n\t\t\tflush_sigqueue_mask(&mask, &p->signal->shared_pending);\n\t\t\tfor_each_thread(p, t)\n\t\t\t\tflush_sigqueue_mask(&mask, &t->pending);\n\t\t}\n\t}\n\n\tspin_unlock_irq(&p->sighand->siglock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&p->sighand->siglock"
          ],
          "line": 4151
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_sigqueue_mask",
          "args": [
            "&mask",
            "&t->pending"
          ],
          "line": 4147
        },
        "resolved": true,
        "details": {
          "function_name": "flush_sigqueue_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "783-799",
          "snippet": "static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 4146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&mask",
            "sig"
          ],
          "line": 4144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&mask"
          ],
          "line": 4143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_handler_ignored",
          "args": [
            "sig_handler(p, sig)",
            "sig"
          ],
          "line": 4142
        },
        "resolved": true,
        "details": {
          "function_name": "sig_handler_ignored",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "72-77",
          "snippet": "static inline bool sig_handler_ignored(void __user *handler, int sig)\n{\n\t/* Is it explicitly or implicitly ignored? */\n\treturn handler == SIG_IGN ||\n\t       (handler == SIG_DFL && sig_kernel_ignore(sig));\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool sig_handler_ignored(void __user *handler, int sig)\n{\n\t/* Is it explicitly or implicitly ignored? */\n\treturn handler == SIG_IGN ||\n\t       (handler == SIG_DFL && sig_kernel_ignore(sig));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigdelsetmask",
          "args": [
            "&act->sa.sa_mask",
            "sigmask(SIGKILL) | sigmask(SIGSTOP)"
          ],
          "line": 4128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGSTOP"
          ],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGKILL"
          ],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction_compat_abi",
          "args": [
            "act",
            "oact"
          ],
          "line": 4125
        },
        "resolved": true,
        "details": {
          "function_name": "sigaction_compat_abi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "4085-4088",
          "snippet": "void __weak sigaction_compat_abi(struct k_sigaction *act,\n\t\tstruct k_sigaction *oact)\n{\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid __weak sigaction_compat_abi(struct k_sigaction *act,\n\t\tstruct k_sigaction *oact)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "UAPI_SA_FLAGS & SA_UNSUPPORTED"
          ],
          "line": 4113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&p->sighand->siglock"
          ],
          "line": 4101
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sig_kernel_only",
          "args": [
            "sig"
          ],
          "line": 4096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_signal",
          "args": [
            "sig"
          ],
          "line": 4096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)\n{\n\tstruct task_struct *p = current, *t;\n\tstruct k_sigaction *k;\n\tsigset_t mask;\n\n\tif (!valid_signal(sig) || sig < 1 || (act && sig_kernel_only(sig)))\n\t\treturn -EINVAL;\n\n\tk = &p->sighand->action[sig-1];\n\n\tspin_lock_irq(&p->sighand->siglock);\n\tif (k->sa.sa_flags & SA_IMMUTABLE) {\n\t\tspin_unlock_irq(&p->sighand->siglock);\n\t\treturn -EINVAL;\n\t}\n\tif (oact)\n\t\t*oact = *k;\n\n\t/*\n\t * Make sure that we never accidentally claim to support SA_UNSUPPORTED,\n\t * e.g. by having an architecture use the bit in their uapi.\n\t */\n\tBUILD_BUG_ON(UAPI_SA_FLAGS & SA_UNSUPPORTED);\n\n\t/*\n\t * Clear unknown flag bits in order to allow userspace to detect missing\n\t * support for flag bits and to allow the kernel to use non-uapi bits\n\t * internally.\n\t */\n\tif (act)\n\t\tact->sa.sa_flags &= UAPI_SA_FLAGS;\n\tif (oact)\n\t\toact->sa.sa_flags &= UAPI_SA_FLAGS;\n\n\tsigaction_compat_abi(act, oact);\n\n\tif (act) {\n\t\tsigdelsetmask(&act->sa.sa_mask,\n\t\t\t      sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t\t*k = *act;\n\t\t/*\n\t\t * POSIX 3.3.1.3:\n\t\t *  \"Setting a signal action to SIG_IGN for a signal that is\n\t\t *   pending shall cause the pending signal to be discarded,\n\t\t *   whether or not it is blocked.\"\n\t\t *\n\t\t *  \"Setting a signal action to SIG_DFL for a signal that is\n\t\t *   pending and whose default action is to ignore the signal\n\t\t *   (for example, SIGCHLD), shall cause the pending signal to\n\t\t *   be discarded, whether or not it is blocked\"\n\t\t */\n\t\tif (sig_handler_ignored(sig_handler(p, sig), sig)) {\n\t\t\tsigemptyset(&mask);\n\t\t\tsigaddset(&mask, sig);\n\t\t\tflush_sigqueue_mask(&mask, &p->signal->shared_pending);\n\t\t\tfor_each_thread(p, t)\n\t\t\t\tflush_sigqueue_mask(&mask, &t->pending);\n\t\t}\n\t}\n\n\tspin_unlock_irq(&p->sighand->siglock);\n\treturn 0;\n}"
  },
  {
    "function_name": "sigaction_compat_abi",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4085-4088",
    "snippet": "void __weak sigaction_compat_abi(struct k_sigaction *act,\n\t\tstruct k_sigaction *oact)\n{\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid __weak sigaction_compat_abi(struct k_sigaction *act,\n\t\tstruct k_sigaction *oact)\n{\n}"
  },
  {
    "function_name": "kernel_sigaction",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4067-4082",
    "snippet": "void kernel_sigaction(int sig, __sighandler_t action)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->sighand->action[sig - 1].sa.sa_handler = action;\n\tif (action == SIG_IGN) {\n\t\tsigset_t mask;\n\n\t\tsigemptyset(&mask);\n\t\tsigaddset(&mask, sig);\n\n\t\tflush_sigqueue_mask(&mask, &current->signal->shared_pending);\n\t\tflush_sigqueue_mask(&mask, &current->pending);\n\t\trecalc_sigpending();\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 4081
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 4079
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "182-187",
          "snippet": "void recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_sigqueue_mask",
          "args": [
            "&mask",
            "&current->pending"
          ],
          "line": 4078
        },
        "resolved": true,
        "details": {
          "function_name": "flush_sigqueue_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "783-799",
          "snippet": "static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&mask",
            "sig"
          ],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&mask"
          ],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 4069
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid kernel_sigaction(int sig, __sighandler_t action)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->sighand->action[sig - 1].sa.sa_handler = action;\n\tif (action == SIG_IGN) {\n\t\tsigset_t mask;\n\n\t\tsigemptyset(&mask);\n\t\tsigaddset(&mask, sig);\n\n\t\tflush_sigqueue_mask(&mask, &current->signal->shared_pending);\n\t\tflush_sigqueue_mask(&mask, &current->pending);\n\t\trecalc_sigpending();\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
  },
  {
    "function_name": "do_rt_tgsigqueueinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4023-4037",
    "snippet": "static int do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, kernel_siginfo_t *info)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif ((info->si_code >= 0 || info->si_code == SI_TKILL) &&\n\t    (task_pid_vnr(current) != pid))\n\t\treturn -EPERM;\n\n\treturn do_send_specific(tgid, pid, sig, info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_send_specific",
          "args": [
            "tgid",
            "pid",
            "sig",
            "info"
          ],
          "line": 4036
        },
        "resolved": true,
        "details": {
          "function_name": "do_send_specific",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3901-3929",
          "snippet": "static int\ndo_send_specific(pid_t tgid, pid_t pid, int sig, struct kernel_siginfo *info)\n{\n\tstruct task_struct *p;\n\tint error = -ESRCH;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\t/*\n\t\t * The null signal is a permissions and process existence\n\t\t * probe.  No signal is actually delivered.\n\t\t */\n\t\tif (!error && sig) {\n\t\t\terror = do_send_sig_info(sig, info, p, PIDTYPE_PID);\n\t\t\t/*\n\t\t\t * If lock_task_sighand() failed we pretend the task\n\t\t\t * dies after receiving the signal. The window is tiny,\n\t\t\t * and the signal is private anyway.\n\t\t\t */\n\t\t\tif (unlikely(error == -ESRCH))\n\t\t\t\terror = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int\ndo_send_specific(pid_t tgid, pid_t pid, int sig, struct kernel_siginfo *info)\n{\n\tstruct task_struct *p;\n\tint error = -ESRCH;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\t/*\n\t\t * The null signal is a permissions and process existence\n\t\t * probe.  No signal is actually delivered.\n\t\t */\n\t\tif (!error && sig) {\n\t\t\terror = do_send_sig_info(sig, info, p, PIDTYPE_PID);\n\t\t\t/*\n\t\t\t * If lock_task_sighand() failed we pretend the task\n\t\t\t * dies after receiving the signal. The window is tiny,\n\t\t\t * and the signal is private anyway.\n\t\t\t */\n\t\t\tif (unlikely(error == -ESRCH))\n\t\t\t\terror = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "current"
          ],
          "line": 4033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, kernel_siginfo_t *info)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif ((info->si_code >= 0 || info->si_code == SI_TKILL) &&\n\t    (task_pid_vnr(current) != pid))\n\t\treturn -EPERM;\n\n\treturn do_send_specific(tgid, pid, sig, info);\n}"
  },
  {
    "function_name": "do_rt_sigqueueinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3980-3991",
    "snippet": "static int do_rt_sigqueueinfo(pid_t pid, int sig, kernel_siginfo_t *info)\n{\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif ((info->si_code >= 0 || info->si_code == SI_TKILL) &&\n\t    (task_pid_vnr(current) != pid))\n\t\treturn -EPERM;\n\n\t/* POSIX.1b doesn't mention process groups.  */\n\treturn kill_proc_info(sig, info, pid);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_proc_info",
          "args": [
            "sig",
            "info",
            "pid"
          ],
          "line": 3990
        },
        "resolved": true,
        "details": {
          "function_name": "kill_proc_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1491-1498",
          "snippet": "static int kill_proc_info(int sig, struct kernel_siginfo *info, pid_t pid)\n{\n\tint error;\n\trcu_read_lock();\n\terror = kill_pid_info(sig, info, find_vpid(pid));\n\trcu_read_unlock();\n\treturn error;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int kill_proc_info(int sig, struct kernel_siginfo *info, pid_t pid)\n{\n\tint error;\n\trcu_read_lock();\n\terror = kill_pid_info(sig, info, find_vpid(pid));\n\trcu_read_unlock();\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "current"
          ],
          "line": 3986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int do_rt_sigqueueinfo(pid_t pid, int sig, kernel_siginfo_t *info)\n{\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif ((info->si_code >= 0 || info->si_code == SI_TKILL) &&\n\t    (task_pid_vnr(current) != pid))\n\t\treturn -EPERM;\n\n\t/* POSIX.1b doesn't mention process groups.  */\n\treturn kill_proc_info(sig, info, pid);\n}"
  },
  {
    "function_name": "do_tkill",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3931-3943",
    "snippet": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn do_send_specific(tgid, pid, sig, &info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_send_specific",
          "args": [
            "tgid",
            "pid",
            "sig",
            "&info"
          ],
          "line": 3942
        },
        "resolved": true,
        "details": {
          "function_name": "do_send_specific",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3901-3929",
          "snippet": "static int\ndo_send_specific(pid_t tgid, pid_t pid, int sig, struct kernel_siginfo *info)\n{\n\tstruct task_struct *p;\n\tint error = -ESRCH;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\t/*\n\t\t * The null signal is a permissions and process existence\n\t\t * probe.  No signal is actually delivered.\n\t\t */\n\t\tif (!error && sig) {\n\t\t\terror = do_send_sig_info(sig, info, p, PIDTYPE_PID);\n\t\t\t/*\n\t\t\t * If lock_task_sighand() failed we pretend the task\n\t\t\t * dies after receiving the signal. The window is tiny,\n\t\t\t * and the signal is private anyway.\n\t\t\t */\n\t\t\tif (unlikely(error == -ESRCH))\n\t\t\t\terror = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int\ndo_send_specific(pid_t tgid, pid_t pid, int sig, struct kernel_siginfo *info)\n{\n\tstruct task_struct *p;\n\tint error = -ESRCH;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\t/*\n\t\t * The null signal is a permissions and process existence\n\t\t * probe.  No signal is actually delivered.\n\t\t */\n\t\tif (!error && sig) {\n\t\t\terror = do_send_sig_info(sig, info, p, PIDTYPE_PID);\n\t\t\t/*\n\t\t\t * If lock_task_sighand() failed we pretend the task\n\t\t\t * dies after receiving the signal. The window is tiny,\n\t\t\t * and the signal is private anyway.\n\t\t\t */\n\t\t\tif (unlikely(error == -ESRCH))\n\t\t\t\terror = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "current_uid()"
          ],
          "line": 3940
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 3940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 3940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_vnr",
          "args": [
            "current"
          ],
          "line": 3939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 3935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn do_send_specific(tgid, pid, sig, &info);\n}"
  },
  {
    "function_name": "do_send_specific",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3901-3929",
    "snippet": "static int\ndo_send_specific(pid_t tgid, pid_t pid, int sig, struct kernel_siginfo *info)\n{\n\tstruct task_struct *p;\n\tint error = -ESRCH;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\t/*\n\t\t * The null signal is a permissions and process existence\n\t\t * probe.  No signal is actually delivered.\n\t\t */\n\t\tif (!error && sig) {\n\t\t\terror = do_send_sig_info(sig, info, p, PIDTYPE_PID);\n\t\t\t/*\n\t\t\t * If lock_task_sighand() failed we pretend the task\n\t\t\t * dies after receiving the signal. The window is tiny,\n\t\t\t * and the signal is private anyway.\n\t\t\t */\n\t\t\tif (unlikely(error == -ESRCH))\n\t\t\t\terror = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3926
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error == -ESRCH"
          ],
          "line": 3922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_send_sig_info",
          "args": [
            "sig",
            "info",
            "p",
            "PIDTYPE_PID"
          ],
          "line": 3916
        },
        "resolved": true,
        "details": {
          "function_name": "do_send_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1290-1302",
          "snippet": "int do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n\t\t\tenum pid_type type)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, type);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n\t\t\tenum pid_type type)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, type);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_kill_permission",
          "args": [
            "sig",
            "info",
            "p"
          ],
          "line": 3910
        },
        "resolved": true,
        "details": {
          "function_name": "check_kill_permission",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "831-865",
          "snippet": "static int check_kill_permission(int sig, struct kernel_siginfo *info,\n\t\t\t\t struct task_struct *t)\n{\n\tstruct pid *sid;\n\tint error;\n\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\tif (!si_fromuser(info))\n\t\treturn 0;\n\n\terror = audit_signal_info(sig, t); /* Let audit system see the signal */\n\tif (error)\n\t\treturn error;\n\n\tif (!same_thread_group(current, t) &&\n\t    !kill_ok_by_cred(t)) {\n\t\tswitch (sig) {\n\t\tcase SIGCONT:\n\t\t\tsid = task_session(t);\n\t\t\t/*\n\t\t\t * We don't return the error if sid == NULL. The\n\t\t\t * task was unhashed, the caller must notice this.\n\t\t\t */\n\t\t\tif (!sid || sid == task_session(current))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn security_task_kill(t, info, sig, NULL);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int check_kill_permission(int sig, struct kernel_siginfo *info,\n\t\t\t\t struct task_struct *t)\n{\n\tstruct pid *sid;\n\tint error;\n\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\tif (!si_fromuser(info))\n\t\treturn 0;\n\n\terror = audit_signal_info(sig, t); /* Let audit system see the signal */\n\tif (error)\n\t\treturn error;\n\n\tif (!same_thread_group(current, t) &&\n\t    !kill_ok_by_cred(t)) {\n\t\tswitch (sig) {\n\t\tcase SIGCONT:\n\t\t\tsid = task_session(t);\n\t\t\t/*\n\t\t\t * We don't return the error if sid == NULL. The\n\t\t\t * task was unhashed, the caller must notice this.\n\t\t\t */\n\t\t\tif (!sid || sid == task_session(current))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn security_task_kill(t, info, sig, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid_vnr",
          "args": [
            "p"
          ],
          "line": 3909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 3908
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_vpid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "420-423",
          "snippet": "struct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3907
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int\ndo_send_specific(pid_t tgid, pid_t pid, int sig, struct kernel_siginfo *info)\n{\n\tstruct task_struct *p;\n\tint error = -ESRCH;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\t/*\n\t\t * The null signal is a permissions and process existence\n\t\t * probe.  No signal is actually delivered.\n\t\t */\n\t\tif (!error && sig) {\n\t\t\terror = do_send_sig_info(sig, info, p, PIDTYPE_PID);\n\t\t\t/*\n\t\t\t * If lock_task_sighand() failed we pretend the task\n\t\t\t * dies after receiving the signal. The window is tiny,\n\t\t\t * and the signal is private anyway.\n\t\t\t */\n\t\t\tif (unlikely(error == -ESRCH))\n\t\t\t\terror = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}"
  },
  {
    "function_name": "pidfd_to_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3820-3829",
    "snippet": "static struct pid *pidfd_to_pid(const struct file *file)\n{\n\tstruct pid *pid;\n\n\tpid = pidfd_pid(file);\n\tif (!IS_ERR(pid))\n\t\treturn pid;\n\n\treturn tgid_pidfd_to_pid(file);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tgid_pidfd_to_pid",
          "args": [
            "file"
          ],
          "line": 3828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pid"
          ],
          "line": 3825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pidfd_pid",
          "args": [
            "file"
          ],
          "line": 3824
        },
        "resolved": true,
        "details": {
          "function_name": "access_pidfd_pidns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3788-3802",
          "snippet": "static bool access_pidfd_pidns(struct pid *pid)\n{\n\tstruct pid_namespace *active = task_active_pid_ns(current);\n\tstruct pid_namespace *p = ns_of_pid(pid);\n\n\tfor (;;) {\n\t\tif (!p)\n\t\t\treturn false;\n\t\tif (p == active)\n\t\t\tbreak;\n\t\tp = p->parent;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool access_pidfd_pidns(struct pid *pid)\n{\n\tstruct pid_namespace *active = task_active_pid_ns(current);\n\tstruct pid_namespace *p = ns_of_pid(pid);\n\n\tfor (;;) {\n\t\tif (!p)\n\t\t\treturn false;\n\t\tif (p == active)\n\t\t\tbreak;\n\t\tp = p->parent;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct pid *pidfd_to_pid(const struct file *file)\n{\n\tstruct pid *pid;\n\n\tpid = pidfd_pid(file);\n\tif (!IS_ERR(pid))\n\t\treturn pid;\n\n\treturn tgid_pidfd_to_pid(file);\n}"
  },
  {
    "function_name": "copy_siginfo_from_user_any",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3804-3818",
    "snippet": "static int copy_siginfo_from_user_any(kernel_siginfo_t *kinfo,\n\t\tsiginfo_t __user *info)\n{\n#ifdef CONFIG_COMPAT\n\t/*\n\t * Avoid hooking up compat syscalls and instead handle necessary\n\t * conversions here. Note, this is a stop-gap measure and should not be\n\t * considered a generic solution.\n\t */\n\tif (in_compat_syscall())\n\t\treturn copy_siginfo_from_user32(\n\t\t\tkinfo, (struct compat_siginfo __user *)info);\n#endif\n\treturn copy_siginfo_from_user(kinfo, info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_siginfo_from_user",
          "args": [
            "kinfo",
            "info"
          ],
          "line": 3817
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_from_user_any",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3804-3818",
          "snippet": "static int copy_siginfo_from_user_any(kernel_siginfo_t *kinfo,\n\t\tsiginfo_t __user *info)\n{\n#ifdef CONFIG_COMPAT\n\t/*\n\t * Avoid hooking up compat syscalls and instead handle necessary\n\t * conversions here. Note, this is a stop-gap measure and should not be\n\t * considered a generic solution.\n\t */\n\tif (in_compat_syscall())\n\t\treturn copy_siginfo_from_user32(\n\t\t\tkinfo, (struct compat_siginfo __user *)info);\n#endif\n\treturn copy_siginfo_from_user(kinfo, info);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "copy_siginfo_from_user32",
          "args": [
            "kinfo",
            "(struct compat_siginfo __user *)info"
          ],
          "line": 3814
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_from_user32",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3553-3562",
          "snippet": "int copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_compat_syscall",
          "args": [],
          "line": 3813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int copy_siginfo_from_user_any(kernel_siginfo_t *kinfo,\n\t\tsiginfo_t __user *info)\n{\n#ifdef CONFIG_COMPAT\n\t/*\n\t * Avoid hooking up compat syscalls and instead handle necessary\n\t * conversions here. Note, this is a stop-gap measure and should not be\n\t * considered a generic solution.\n\t */\n\tif (in_compat_syscall())\n\t\treturn copy_siginfo_from_user32(\n\t\t\tkinfo, (struct compat_siginfo __user *)info);\n#endif\n\treturn copy_siginfo_from_user(kinfo, info);\n}"
  },
  {
    "function_name": "access_pidfd_pidns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3788-3802",
    "snippet": "static bool access_pidfd_pidns(struct pid *pid)\n{\n\tstruct pid_namespace *active = task_active_pid_ns(current);\n\tstruct pid_namespace *p = ns_of_pid(pid);\n\n\tfor (;;) {\n\t\tif (!p)\n\t\t\treturn false;\n\t\tif (p == active)\n\t\t\tbreak;\n\t\tp = p->parent;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_of_pid",
          "args": [
            "pid"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 3790
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "507-510",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool access_pidfd_pidns(struct pid *pid)\n{\n\tstruct pid_namespace *active = task_active_pid_ns(current);\n\tstruct pid_namespace *p = ns_of_pid(pid);\n\n\tfor (;;) {\n\t\tif (!p)\n\t\t\treturn false;\n\t\tif (p == active)\n\t\t\tbreak;\n\t\tp = p->parent;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "prepare_kill_siginfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3759-3767",
    "snippet": "static inline void prepare_kill_siginfo(int sig, struct kernel_siginfo *info)\n{\n\tclear_siginfo(info);\n\tinfo->si_signo = sig;\n\tinfo->si_errno = 0;\n\tinfo->si_code = SI_USER;\n\tinfo->si_pid = task_tgid_vnr(current);\n\tinfo->si_uid = from_kuid_munged(current_user_ns(), current_uid());\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "current_uid()"
          ],
          "line": 3766
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 3766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 3766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_vnr",
          "args": [
            "current"
          ],
          "line": 3765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "info"
          ],
          "line": 3761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline void prepare_kill_siginfo(int sig, struct kernel_siginfo *info)\n{\n\tclear_siginfo(info);\n\tinfo->si_signo = sig;\n\tinfo->si_errno = 0;\n\tinfo->si_code = SI_USER;\n\tinfo->si_pid = task_tgid_vnr(current);\n\tinfo->si_uid = from_kuid_munged(current_user_ns(), current_uid());\n}"
  },
  {
    "function_name": "do_sigtimedwait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3571-3620",
    "snippet": "static int do_sigtimedwait(const sigset_t *which, kernel_siginfo_t *info,\n\t\t    const struct timespec64 *ts)\n{\n\tktime_t *to = NULL, timeout = KTIME_MAX;\n\tstruct task_struct *tsk = current;\n\tsigset_t mask = *which;\n\tenum pid_type type;\n\tint sig, ret = 0;\n\n\tif (ts) {\n\t\tif (!timespec64_valid(ts))\n\t\t\treturn -EINVAL;\n\t\ttimeout = timespec64_to_ktime(*ts);\n\t\tto = &timeout;\n\t}\n\n\t/*\n\t * Invert the set of allowed signals to get those we want to block.\n\t */\n\tsigdelsetmask(&mask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\tsignotset(&mask);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tsig = dequeue_signal(tsk, &mask, info, &type);\n\tif (!sig && timeout) {\n\t\t/*\n\t\t * None ready, temporarily unblock those we're interested\n\t\t * while we are sleeping in so that we'll be awakened when\n\t\t * they arrive. Unblocking is always fine, we can avoid\n\t\t * set_current_blocked().\n\t\t */\n\t\ttsk->real_blocked = tsk->blocked;\n\t\tsigandsets(&tsk->blocked, &tsk->blocked, &mask);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tret = freezable_schedule_hrtimeout_range(to, tsk->timer_slack_ns,\n\t\t\t\t\t\t\t HRTIMER_MODE_REL);\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\t__set_task_blocked(tsk, &tsk->real_blocked);\n\t\tsigemptyset(&tsk->real_blocked);\n\t\tsig = dequeue_signal(tsk, &mask, info, &type);\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (sig)\n\t\treturn sig;\n\treturn ret ? -EINTR : -EAGAIN;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 3615
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_signal",
          "args": [
            "tsk",
            "&mask",
            "info",
            "&type"
          ],
          "line": 3613
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "629-707",
          "snippet": "int dequeue_signal(struct task_struct *tsk, sigset_t *mask,\n\t\t   kernel_siginfo_t *info, enum pid_type *type)\n{\n\tbool resched_timer = false;\n\tint signr;\n\n\t/* We only dequeue private signals from ourselves, we don't let\n\t * signalfd steal them\n\t */\n\t*type = PIDTYPE_PID;\n\tsignr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);\n\tif (!signr) {\n\t\t*type = PIDTYPE_TGID;\n\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,\n\t\t\t\t\t mask, info, &resched_timer);\n#ifdef CONFIG_POSIX_TIMERS\n\t\t/*\n\t\t * itimer signal ?\n\t\t *\n\t\t * itimers are process shared and we restart periodic\n\t\t * itimers in the signal delivery path to prevent DoS\n\t\t * attacks in the high resolution timer case. This is\n\t\t * compliant with the old way of self-restarting\n\t\t * itimers, as the SIGALRM is a legacy signal and only\n\t\t * queued once. Changing the restart behaviour to\n\t\t * restart the timer in the signal dequeue path is\n\t\t * reducing the timer noise on heavy loaded !highres\n\t\t * systems too.\n\t\t */\n\t\tif (unlikely(signr == SIGALRM)) {\n\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;\n\n\t\t\tif (!hrtimer_is_queued(tmr) &&\n\t\t\t    tsk->signal->it_real_incr != 0) {\n\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),\n\t\t\t\t\t\ttsk->signal->it_real_incr);\n\t\t\t\thrtimer_restart(tmr);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\trecalc_sigpending();\n\tif (!signr)\n\t\treturn 0;\n\n\tif (unlikely(sig_kernel_stop(signr))) {\n\t\t/*\n\t\t * Set a marker that we have dequeued a stop signal.  Our\n\t\t * caller might release the siglock and then the pending\n\t\t * stop signal it is about to process is no longer in the\n\t\t * pending bitmasks, but must still be cleared by a SIGCONT\n\t\t * (and overruled by a SIGKILL).  So those cases clear this\n\t\t * shared flag after we've set it.  Note that this flag may\n\t\t * remain set after the signal we return is ignored or\n\t\t * handled.  That doesn't matter because its only purpose\n\t\t * is to alert stop-signal processing code when another\n\t\t * processor has come along and cleared the flag.\n\t\t */\n\t\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\t}\n#ifdef CONFIG_POSIX_TIMERS\n\tif (resched_timer) {\n\t\t/*\n\t\t * Release the siglock to ensure proper locking order\n\t\t * of timer locks outside of siglocks.  Note, we leave\n\t\t * irqs disabled here, since the posix-timers code is\n\t\t * about to disable them again anyway.\n\t\t */\n\t\tspin_unlock(&tsk->sighand->siglock);\n\t\tposixtimer_rearm(info);\n\t\tspin_lock(&tsk->sighand->siglock);\n\n\t\t/* Don't expose the si_sys_private value to userspace */\n\t\tinfo->si_sys_private = 0;\n\t}\n#endif\n\treturn signr;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint dequeue_signal(struct task_struct *tsk, sigset_t *mask,\n\t\t   kernel_siginfo_t *info, enum pid_type *type)\n{\n\tbool resched_timer = false;\n\tint signr;\n\n\t/* We only dequeue private signals from ourselves, we don't let\n\t * signalfd steal them\n\t */\n\t*type = PIDTYPE_PID;\n\tsignr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);\n\tif (!signr) {\n\t\t*type = PIDTYPE_TGID;\n\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,\n\t\t\t\t\t mask, info, &resched_timer);\n#ifdef CONFIG_POSIX_TIMERS\n\t\t/*\n\t\t * itimer signal ?\n\t\t *\n\t\t * itimers are process shared and we restart periodic\n\t\t * itimers in the signal delivery path to prevent DoS\n\t\t * attacks in the high resolution timer case. This is\n\t\t * compliant with the old way of self-restarting\n\t\t * itimers, as the SIGALRM is a legacy signal and only\n\t\t * queued once. Changing the restart behaviour to\n\t\t * restart the timer in the signal dequeue path is\n\t\t * reducing the timer noise on heavy loaded !highres\n\t\t * systems too.\n\t\t */\n\t\tif (unlikely(signr == SIGALRM)) {\n\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;\n\n\t\t\tif (!hrtimer_is_queued(tmr) &&\n\t\t\t    tsk->signal->it_real_incr != 0) {\n\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),\n\t\t\t\t\t\ttsk->signal->it_real_incr);\n\t\t\t\thrtimer_restart(tmr);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\trecalc_sigpending();\n\tif (!signr)\n\t\treturn 0;\n\n\tif (unlikely(sig_kernel_stop(signr))) {\n\t\t/*\n\t\t * Set a marker that we have dequeued a stop signal.  Our\n\t\t * caller might release the siglock and then the pending\n\t\t * stop signal it is about to process is no longer in the\n\t\t * pending bitmasks, but must still be cleared by a SIGCONT\n\t\t * (and overruled by a SIGKILL).  So those cases clear this\n\t\t * shared flag after we've set it.  Note that this flag may\n\t\t * remain set after the signal we return is ignored or\n\t\t * handled.  That doesn't matter because its only purpose\n\t\t * is to alert stop-signal processing code when another\n\t\t * processor has come along and cleared the flag.\n\t\t */\n\t\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\t}\n#ifdef CONFIG_POSIX_TIMERS\n\tif (resched_timer) {\n\t\t/*\n\t\t * Release the siglock to ensure proper locking order\n\t\t * of timer locks outside of siglocks.  Note, we leave\n\t\t * irqs disabled here, since the posix-timers code is\n\t\t * about to disable them again anyway.\n\t\t */\n\t\tspin_unlock(&tsk->sighand->siglock);\n\t\tposixtimer_rearm(info);\n\t\tspin_lock(&tsk->sighand->siglock);\n\n\t\t/* Don't expose the si_sys_private value to userspace */\n\t\tinfo->si_sys_private = 0;\n\t}\n#endif\n\treturn signr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&tsk->real_blocked"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_task_blocked",
          "args": [
            "tsk",
            "&tsk->real_blocked"
          ],
          "line": 3611
        },
        "resolved": true,
        "details": {
          "function_name": "__set_task_blocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3014-3024",
          "snippet": "static void __set_task_blocked(struct task_struct *tsk, const sigset_t *newset)\n{\n\tif (task_sigpending(tsk) && !thread_group_empty(tsk)) {\n\t\tsigset_t newblocked;\n\t\t/* A set of now blocked but previously unblocked signals. */\n\t\tsigandnsets(&newblocked, newset, &current->blocked);\n\t\tretarget_shared_pending(tsk, &newblocked);\n\t}\n\ttsk->blocked = *newset;\n\trecalc_sigpending();\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void __set_task_blocked(struct task_struct *tsk, const sigset_t *newset)\n{\n\tif (task_sigpending(tsk) && !thread_group_empty(tsk)) {\n\t\tsigset_t newblocked;\n\t\t/* A set of now blocked but previously unblocked signals. */\n\t\tsigandnsets(&newblocked, newset, &current->blocked);\n\t\tretarget_shared_pending(tsk, &newblocked);\n\t}\n\ttsk->blocked = *newset;\n\trecalc_sigpending();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 3610
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezable_schedule_hrtimeout_range",
          "args": [
            "to",
            "tsk->timer_slack_ns",
            "HRTIMER_MODE_REL"
          ],
          "line": 3608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 3607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 3604
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "182-187",
          "snippet": "void recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigandsets",
          "args": [
            "&tsk->blocked",
            "&tsk->blocked",
            "&mask"
          ],
          "line": 3603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signotset",
          "args": [
            "&mask"
          ],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelsetmask",
          "args": [
            "&mask",
            "sigmask(SIGKILL) | sigmask(SIGSTOP)"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGSTOP"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGKILL"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "*ts"
          ],
          "line": 3583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_valid",
          "args": [
            "ts"
          ],
          "line": 3581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int do_sigtimedwait(const sigset_t *which, kernel_siginfo_t *info,\n\t\t    const struct timespec64 *ts)\n{\n\tktime_t *to = NULL, timeout = KTIME_MAX;\n\tstruct task_struct *tsk = current;\n\tsigset_t mask = *which;\n\tenum pid_type type;\n\tint sig, ret = 0;\n\n\tif (ts) {\n\t\tif (!timespec64_valid(ts))\n\t\t\treturn -EINVAL;\n\t\ttimeout = timespec64_to_ktime(*ts);\n\t\tto = &timeout;\n\t}\n\n\t/*\n\t * Invert the set of allowed signals to get those we want to block.\n\t */\n\tsigdelsetmask(&mask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\tsignotset(&mask);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tsig = dequeue_signal(tsk, &mask, info, &type);\n\tif (!sig && timeout) {\n\t\t/*\n\t\t * None ready, temporarily unblock those we're interested\n\t\t * while we are sleeping in so that we'll be awakened when\n\t\t * they arrive. Unblocking is always fine, we can avoid\n\t\t * set_current_blocked().\n\t\t */\n\t\ttsk->real_blocked = tsk->blocked;\n\t\tsigandsets(&tsk->blocked, &tsk->blocked, &mask);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tret = freezable_schedule_hrtimeout_range(to, tsk->timer_slack_ns,\n\t\t\t\t\t\t\t HRTIMER_MODE_REL);\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\t__set_task_blocked(tsk, &tsk->real_blocked);\n\t\tsigemptyset(&tsk->real_blocked);\n\t\tsig = dequeue_signal(tsk, &mask, info, &type);\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (sig)\n\t\treturn sig;\n\treturn ret ? -EINTR : -EAGAIN;\n}"
  },
  {
    "function_name": "copy_siginfo_from_user32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3553-3562",
    "snippet": "int copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "post_copy_siginfo_from_user32",
          "args": [
            "to",
            "&from"
          ],
          "line": 3561
        },
        "resolved": true,
        "details": {
          "function_name": "post_copy_siginfo_from_user32",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3466-3539",
          "snippet": "static int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tbreak;\n\tcase SIL_FAULT_TRAPNO:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_trapno = from->si_trapno;\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_perf_data = from->si_perf_data;\n\t\tto->si_perf_type = from->si_perf_type;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tbreak;\n\tcase SIL_FAULT_TRAPNO:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_trapno = from->si_trapno;\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_perf_data = from->si_perf_data;\n\t\tto->si_perf_type = from->si_perf_type;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&from",
            "ufrom",
            "sizeof(struct compat_siginfo)"
          ],
          "line": 3558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}"
  },
  {
    "function_name": "__copy_siginfo_from_user32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3541-3551",
    "snippet": "static int __copy_siginfo_from_user32(int signo, struct kernel_siginfo *to,\n\t\t\t\t      const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\tfrom.si_signo = signo;\n\treturn post_copy_siginfo_from_user32(to, &from);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "post_copy_siginfo_from_user32",
          "args": [
            "to",
            "&from"
          ],
          "line": 3550
        },
        "resolved": true,
        "details": {
          "function_name": "post_copy_siginfo_from_user32",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3466-3539",
          "snippet": "static int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tbreak;\n\tcase SIL_FAULT_TRAPNO:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_trapno = from->si_trapno;\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_perf_data = from->si_perf_data;\n\t\tto->si_perf_type = from->si_perf_type;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tbreak;\n\tcase SIL_FAULT_TRAPNO:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_trapno = from->si_trapno;\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_perf_data = from->si_perf_data;\n\t\tto->si_perf_type = from->si_perf_type;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&from",
            "ufrom",
            "sizeof(struct compat_siginfo)"
          ],
          "line": 3546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int __copy_siginfo_from_user32(int signo, struct kernel_siginfo *to,\n\t\t\t\t      const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\tfrom.si_signo = signo;\n\treturn post_copy_siginfo_from_user32(to, &from);\n}"
  },
  {
    "function_name": "post_copy_siginfo_from_user32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3466-3539",
    "snippet": "static int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tbreak;\n\tcase SIL_FAULT_TRAPNO:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_trapno = from->si_trapno;\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_perf_data = from->si_perf_data;\n\t\tto->si_perf_type = from->si_perf_type;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "from->si_call_addr"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_x32_syscall",
          "args": [],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "from->si_addr"
          ],
          "line": 3508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "from->si_addr"
          ],
          "line": 3504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "from->si_upper"
          ],
          "line": 3501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "from->si_lower"
          ],
          "line": 3500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "from->si_addr"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "from->si_addr"
          ],
          "line": 3495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "from->si_addr"
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "from->si_addr"
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginfo_layout",
          "args": [
            "from->si_signo",
            "from->si_code"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "siginfo_layout",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3283-3321",
          "snippet": "enum siginfo_layout siginfo_layout(unsigned sig, int si_code)\n{\n\tenum siginfo_layout layout = SIL_KILL;\n\tif ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n\t\tif ((sig < ARRAY_SIZE(sig_sicodes)) &&\n\t\t    (si_code <= sig_sicodes[sig].limit)) {\n\t\t\tlayout = sig_sicodes[sig].layout;\n\t\t\t/* Handle the exceptions */\n\t\t\tif ((sig == SIGBUS) &&\n\t\t\t    (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n\t\t\t\tlayout = SIL_FAULT_MCEERR;\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n\t\t\t\tlayout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n\t\t\t\tlayout = SIL_FAULT_PKUERR;\n#endif\n\t\t\telse if ((sig == SIGTRAP) && (si_code == TRAP_PERF))\n\t\t\t\tlayout = SIL_FAULT_PERF_EVENT;\n\t\t\telse if (IS_ENABLED(CONFIG_SPARC) &&\n\t\t\t\t (sig == SIGILL) && (si_code == ILL_ILLTRP))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t\telse if (IS_ENABLED(CONFIG_ALPHA) &&\n\t\t\t\t ((sig == SIGFPE) ||\n\t\t\t\t  ((sig == SIGTRAP) && (si_code == TRAP_UNK))))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\tlayout = SIL_POLL;\n\t} else {\n\t\tif (si_code == SI_TIMER)\n\t\t\tlayout = SIL_TIMER;\n\t\telse if (si_code == SI_SIGIO)\n\t\t\tlayout = SIL_POLL;\n\t\telse if (si_code < 0)\n\t\t\tlayout = SIL_RT;\n\t}\n\treturn layout;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};\n\nenum siginfo_layout siginfo_layout(unsigned sig, int si_code)\n{\n\tenum siginfo_layout layout = SIL_KILL;\n\tif ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n\t\tif ((sig < ARRAY_SIZE(sig_sicodes)) &&\n\t\t    (si_code <= sig_sicodes[sig].limit)) {\n\t\t\tlayout = sig_sicodes[sig].layout;\n\t\t\t/* Handle the exceptions */\n\t\t\tif ((sig == SIGBUS) &&\n\t\t\t    (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n\t\t\t\tlayout = SIL_FAULT_MCEERR;\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n\t\t\t\tlayout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n\t\t\t\tlayout = SIL_FAULT_PKUERR;\n#endif\n\t\t\telse if ((sig == SIGTRAP) && (si_code == TRAP_PERF))\n\t\t\t\tlayout = SIL_FAULT_PERF_EVENT;\n\t\t\telse if (IS_ENABLED(CONFIG_SPARC) &&\n\t\t\t\t (sig == SIGILL) && (si_code == ILL_ILLTRP))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t\telse if (IS_ENABLED(CONFIG_ALPHA) &&\n\t\t\t\t ((sig == SIGFPE) ||\n\t\t\t\t  ((sig == SIGTRAP) && (si_code == TRAP_UNK))))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\tlayout = SIL_POLL;\n\t} else {\n\t\tif (si_code == SI_TIMER)\n\t\t\tlayout = SIL_TIMER;\n\t\telse if (si_code == SI_SIGIO)\n\t\t\tlayout = SIL_POLL;\n\t\telse if (si_code < 0)\n\t\t\tlayout = SIL_RT;\n\t}\n\treturn layout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "to"
          ],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tbreak;\n\tcase SIL_FAULT_TRAPNO:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_trapno = from->si_trapno;\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_perf_data = from->si_perf_data;\n\t\tto->si_perf_type = from->si_perf_type;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__copy_siginfo_to_user32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3455-3464",
    "snippet": "int __copy_siginfo_to_user32(struct compat_siginfo __user *to,\n\t\t\t   const struct kernel_siginfo *from)\n{\n\tstruct compat_siginfo new;\n\n\tcopy_siginfo_to_external32(&new, from);\n\tif (copy_to_user(to, &new, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "to",
            "&new",
            "sizeof(struct compat_siginfo)"
          ],
          "line": 3461
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_siginfo_to_external32",
          "args": [
            "&new",
            "from"
          ],
          "line": 3460
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_to_external32",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3388-3453",
          "snippet": "void copy_siginfo_to_external32(struct compat_siginfo *to,\n\t\tconst struct kernel_siginfo *from)\n{\n\tmemset(to, 0, sizeof(*to));\n\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tbreak;\n\tcase SIL_FAULT_TRAPNO:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_trapno = from->si_trapno;\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_lower = ptr_to_compat(from->si_lower);\n\t\tto->si_upper = ptr_to_compat(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_perf_data = from->si_perf_data;\n\t\tto->si_perf_type = from->si_perf_type;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_status = from->si_status;\n\t\tto->si_utime = from->si_utime;\n\t\tto->si_stime = from->si_stime;\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = ptr_to_compat(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid copy_siginfo_to_external32(struct compat_siginfo *to,\n\t\tconst struct kernel_siginfo *from)\n{\n\tmemset(to, 0, sizeof(*to));\n\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tbreak;\n\tcase SIL_FAULT_TRAPNO:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_trapno = from->si_trapno;\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_lower = ptr_to_compat(from->si_lower);\n\t\tto->si_upper = ptr_to_compat(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_perf_data = from->si_perf_data;\n\t\tto->si_perf_type = from->si_perf_type;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_status = from->si_status;\n\t\tto->si_utime = from->si_utime;\n\t\tto->si_stime = from->si_stime;\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = ptr_to_compat(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint __copy_siginfo_to_user32(struct compat_siginfo __user *to,\n\t\t\t   const struct kernel_siginfo *from)\n{\n\tstruct compat_siginfo new;\n\n\tcopy_siginfo_to_external32(&new, from);\n\tif (copy_to_user(to, &new, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_siginfo_to_external32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3388-3453",
    "snippet": "void copy_siginfo_to_external32(struct compat_siginfo *to,\n\t\tconst struct kernel_siginfo *from)\n{\n\tmemset(to, 0, sizeof(*to));\n\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tbreak;\n\tcase SIL_FAULT_TRAPNO:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_trapno = from->si_trapno;\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_lower = ptr_to_compat(from->si_lower);\n\t\tto->si_upper = ptr_to_compat(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_perf_data = from->si_perf_data;\n\t\tto->si_perf_type = from->si_perf_type;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_status = from->si_status;\n\t\tto->si_utime = from->si_utime;\n\t\tto->si_stime = from->si_stime;\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = ptr_to_compat(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "from->si_call_addr"
          ],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "from->si_addr"
          ],
          "line": 3431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "from->si_addr"
          ],
          "line": 3427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "from->si_upper"
          ],
          "line": 3424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "from->si_lower"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "from->si_addr"
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "from->si_addr"
          ],
          "line": 3418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "from->si_addr"
          ],
          "line": 3414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "from->si_addr"
          ],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginfo_layout",
          "args": [
            "from->si_signo",
            "from->si_code"
          ],
          "line": 3396
        },
        "resolved": true,
        "details": {
          "function_name": "siginfo_layout",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3283-3321",
          "snippet": "enum siginfo_layout siginfo_layout(unsigned sig, int si_code)\n{\n\tenum siginfo_layout layout = SIL_KILL;\n\tif ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n\t\tif ((sig < ARRAY_SIZE(sig_sicodes)) &&\n\t\t    (si_code <= sig_sicodes[sig].limit)) {\n\t\t\tlayout = sig_sicodes[sig].layout;\n\t\t\t/* Handle the exceptions */\n\t\t\tif ((sig == SIGBUS) &&\n\t\t\t    (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n\t\t\t\tlayout = SIL_FAULT_MCEERR;\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n\t\t\t\tlayout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n\t\t\t\tlayout = SIL_FAULT_PKUERR;\n#endif\n\t\t\telse if ((sig == SIGTRAP) && (si_code == TRAP_PERF))\n\t\t\t\tlayout = SIL_FAULT_PERF_EVENT;\n\t\t\telse if (IS_ENABLED(CONFIG_SPARC) &&\n\t\t\t\t (sig == SIGILL) && (si_code == ILL_ILLTRP))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t\telse if (IS_ENABLED(CONFIG_ALPHA) &&\n\t\t\t\t ((sig == SIGFPE) ||\n\t\t\t\t  ((sig == SIGTRAP) && (si_code == TRAP_UNK))))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\tlayout = SIL_POLL;\n\t} else {\n\t\tif (si_code == SI_TIMER)\n\t\t\tlayout = SIL_TIMER;\n\t\telse if (si_code == SI_SIGIO)\n\t\t\tlayout = SIL_POLL;\n\t\telse if (si_code < 0)\n\t\t\tlayout = SIL_RT;\n\t}\n\treturn layout;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};\n\nenum siginfo_layout siginfo_layout(unsigned sig, int si_code)\n{\n\tenum siginfo_layout layout = SIL_KILL;\n\tif ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n\t\tif ((sig < ARRAY_SIZE(sig_sicodes)) &&\n\t\t    (si_code <= sig_sicodes[sig].limit)) {\n\t\t\tlayout = sig_sicodes[sig].layout;\n\t\t\t/* Handle the exceptions */\n\t\t\tif ((sig == SIGBUS) &&\n\t\t\t    (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n\t\t\t\tlayout = SIL_FAULT_MCEERR;\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n\t\t\t\tlayout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n\t\t\t\tlayout = SIL_FAULT_PKUERR;\n#endif\n\t\t\telse if ((sig == SIGTRAP) && (si_code == TRAP_PERF))\n\t\t\t\tlayout = SIL_FAULT_PERF_EVENT;\n\t\t\telse if (IS_ENABLED(CONFIG_SPARC) &&\n\t\t\t\t (sig == SIGILL) && (si_code == ILL_ILLTRP))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t\telse if (IS_ENABLED(CONFIG_ALPHA) &&\n\t\t\t\t ((sig == SIGFPE) ||\n\t\t\t\t  ((sig == SIGTRAP) && (si_code == TRAP_UNK))))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\tlayout = SIL_POLL;\n\t} else {\n\t\tif (si_code == SI_TIMER)\n\t\t\tlayout = SIL_TIMER;\n\t\telse if (si_code == SI_SIGIO)\n\t\t\tlayout = SIL_POLL;\n\t\telse if (si_code < 0)\n\t\t\tlayout = SIL_RT;\n\t}\n\treturn layout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "to",
            "0",
            "sizeof(*to)"
          ],
          "line": 3391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid copy_siginfo_to_external32(struct compat_siginfo *to,\n\t\tconst struct kernel_siginfo *from)\n{\n\tmemset(to, 0, sizeof(*to));\n\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tbreak;\n\tcase SIL_FAULT_TRAPNO:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_trapno = from->si_trapno;\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_lower = ptr_to_compat(from->si_lower);\n\t\tto->si_upper = ptr_to_compat(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tto->si_addr = ptr_to_compat(from->si_addr);\n\t\tto->si_perf_data = from->si_perf_data;\n\t\tto->si_perf_type = from->si_perf_type;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_status = from->si_status;\n\t\tto->si_utime = from->si_utime;\n\t\tto->si_stime = from->si_stime;\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = ptr_to_compat(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "copy_siginfo_from_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3370-3375",
    "snippet": "int copy_siginfo_from_user(kernel_siginfo_t *to, const siginfo_t __user *from)\n{\n\tif (copy_from_user(to, from, sizeof(struct kernel_siginfo)))\n\t\treturn -EFAULT;\n\treturn post_copy_siginfo_from_user(to, from);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "post_copy_siginfo_from_user",
          "args": [
            "to",
            "from"
          ],
          "line": 3374
        },
        "resolved": true,
        "details": {
          "function_name": "post_copy_siginfo_from_user32",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3466-3539",
          "snippet": "static int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tbreak;\n\tcase SIL_FAULT_TRAPNO:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_trapno = from->si_trapno;\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_perf_data = from->si_perf_data;\n\t\tto->si_perf_type = from->si_perf_type;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tbreak;\n\tcase SIL_FAULT_TRAPNO:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_trapno = from->si_trapno;\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_perf_data = from->si_perf_data;\n\t\tto->si_perf_type = from->si_perf_type;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "to",
            "from",
            "sizeof(struct kernel_siginfo)"
          ],
          "line": 3372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_siginfo_from_user(kernel_siginfo_t *to, const siginfo_t __user *from)\n{\n\tif (copy_from_user(to, from, sizeof(struct kernel_siginfo)))\n\t\treturn -EFAULT;\n\treturn post_copy_siginfo_from_user(to, from);\n}"
  },
  {
    "function_name": "__copy_siginfo_from_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3361-3368",
    "snippet": "static int __copy_siginfo_from_user(int signo, kernel_siginfo_t *to,\n\t\t\t\t    const siginfo_t __user *from)\n{\n\tif (copy_from_user(to, from, sizeof(struct kernel_siginfo)))\n\t\treturn -EFAULT;\n\tto->si_signo = signo;\n\treturn post_copy_siginfo_from_user(to, from);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "post_copy_siginfo_from_user",
          "args": [
            "to",
            "from"
          ],
          "line": 3367
        },
        "resolved": true,
        "details": {
          "function_name": "post_copy_siginfo_from_user32",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3466-3539",
          "snippet": "static int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tbreak;\n\tcase SIL_FAULT_TRAPNO:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_trapno = from->si_trapno;\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_perf_data = from->si_perf_data;\n\t\tto->si_perf_type = from->si_perf_type;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tbreak;\n\tcase SIL_FAULT_TRAPNO:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_trapno = from->si_trapno;\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n\t\tto->si_perf_data = from->si_perf_data;\n\t\tto->si_perf_type = from->si_perf_type;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "to",
            "from",
            "sizeof(struct kernel_siginfo)"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int __copy_siginfo_from_user(int signo, kernel_siginfo_t *to,\n\t\t\t\t    const siginfo_t __user *from)\n{\n\tif (copy_from_user(to, from, sizeof(struct kernel_siginfo)))\n\t\treturn -EFAULT;\n\tto->si_signo = signo;\n\treturn post_copy_siginfo_from_user(to, from);\n}"
  },
  {
    "function_name": "post_copy_siginfo_from_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3338-3359",
    "snippet": "static int post_copy_siginfo_from_user(kernel_siginfo_t *info,\n\t\t\t\t       const siginfo_t __user *from)\n{\n\tif (unlikely(!known_siginfo_layout(info->si_signo, info->si_code))) {\n\t\tchar __user *expansion = si_expansion(from);\n\t\tchar buf[SI_EXPANSION_SIZE];\n\t\tint i;\n\t\t/*\n\t\t * An unknown si_code might need more than\n\t\t * sizeof(struct kernel_siginfo) bytes.  Verify all of the\n\t\t * extra bytes are 0.  This guarantees copy_siginfo_to_user\n\t\t * will return this data to userspace exactly.\n\t\t */\n\t\tif (copy_from_user(&buf, expansion, SI_EXPANSION_SIZE))\n\t\t\treturn -EFAULT;\n\t\tfor (i = 0; i < SI_EXPANSION_SIZE; i++) {\n\t\t\tif (buf[i] != 0)\n\t\t\t\treturn -E2BIG;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&buf",
            "expansion",
            "SI_EXPANSION_SIZE"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "si_expansion",
          "args": [
            "from"
          ],
          "line": 3342
        },
        "resolved": true,
        "details": {
          "function_name": "si_expansion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3323-3326",
          "snippet": "static inline char __user *si_expansion(const siginfo_t __user *info)\n{\n\treturn ((char __user *)info) + sizeof(struct kernel_siginfo);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline char __user *si_expansion(const siginfo_t __user *info)\n{\n\treturn ((char __user *)info) + sizeof(struct kernel_siginfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!known_siginfo_layout(info->si_signo, info->si_code)"
          ],
          "line": 3341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "known_siginfo_layout",
          "args": [
            "info->si_signo",
            "info->si_code"
          ],
          "line": 3341
        },
        "resolved": true,
        "details": {
          "function_name": "known_siginfo_layout",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3264-3281",
          "snippet": "static bool known_siginfo_layout(unsigned sig, int si_code)\n{\n\tif (si_code == SI_KERNEL)\n\t\treturn true;\n\telse if ((si_code > SI_USER)) {\n\t\tif (sig_specific_sicodes(sig)) {\n\t\t\tif (si_code <= sig_sicodes[sig].limit)\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\treturn true;\n\t}\n\telse if (si_code >= SI_DETHREAD)\n\t\treturn true;\n\telse if (si_code == SI_ASYNCNL)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};\n\nstatic bool known_siginfo_layout(unsigned sig, int si_code)\n{\n\tif (si_code == SI_KERNEL)\n\t\treturn true;\n\telse if ((si_code > SI_USER)) {\n\t\tif (sig_specific_sicodes(sig)) {\n\t\t\tif (si_code <= sig_sicodes[sig].limit)\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\treturn true;\n\t}\n\telse if (si_code >= SI_DETHREAD)\n\t\treturn true;\n\telse if (si_code == SI_ASYNCNL)\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int post_copy_siginfo_from_user(kernel_siginfo_t *info,\n\t\t\t\t       const siginfo_t __user *from)\n{\n\tif (unlikely(!known_siginfo_layout(info->si_signo, info->si_code))) {\n\t\tchar __user *expansion = si_expansion(from);\n\t\tchar buf[SI_EXPANSION_SIZE];\n\t\tint i;\n\t\t/*\n\t\t * An unknown si_code might need more than\n\t\t * sizeof(struct kernel_siginfo) bytes.  Verify all of the\n\t\t * extra bytes are 0.  This guarantees copy_siginfo_to_user\n\t\t * will return this data to userspace exactly.\n\t\t */\n\t\tif (copy_from_user(&buf, expansion, SI_EXPANSION_SIZE))\n\t\t\treturn -EFAULT;\n\t\tfor (i = 0; i < SI_EXPANSION_SIZE; i++) {\n\t\t\tif (buf[i] != 0)\n\t\t\t\treturn -E2BIG;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_siginfo_to_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3328-3336",
    "snippet": "int copy_siginfo_to_user(siginfo_t __user *to, const kernel_siginfo_t *from)\n{\n\tchar __user *expansion = si_expansion(to);\n\tif (copy_to_user(to, from , sizeof(struct kernel_siginfo)))\n\t\treturn -EFAULT;\n\tif (clear_user(expansion, SI_EXPANSION_SIZE))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_user",
          "args": [
            "expansion",
            "SI_EXPANSION_SIZE"
          ],
          "line": 3333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "to",
            "from",
            "sizeof(struct kernel_siginfo)"
          ],
          "line": 3331
        },
        "resolved": true,
        "details": {
          "function_name": "sched_attr_copy_to_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7847-7876",
          "snippet": "static int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "si_expansion",
          "args": [
            "to"
          ],
          "line": 3330
        },
        "resolved": true,
        "details": {
          "function_name": "si_expansion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3323-3326",
          "snippet": "static inline char __user *si_expansion(const siginfo_t __user *info)\n{\n\treturn ((char __user *)info) + sizeof(struct kernel_siginfo);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline char __user *si_expansion(const siginfo_t __user *info)\n{\n\treturn ((char __user *)info) + sizeof(struct kernel_siginfo);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_siginfo_to_user(siginfo_t __user *to, const kernel_siginfo_t *from)\n{\n\tchar __user *expansion = si_expansion(to);\n\tif (copy_to_user(to, from , sizeof(struct kernel_siginfo)))\n\t\treturn -EFAULT;\n\tif (clear_user(expansion, SI_EXPANSION_SIZE))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "si_expansion",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3323-3326",
    "snippet": "static inline char __user *si_expansion(const siginfo_t __user *info)\n{\n\treturn ((char __user *)info) + sizeof(struct kernel_siginfo);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline char __user *si_expansion(const siginfo_t __user *info)\n{\n\treturn ((char __user *)info) + sizeof(struct kernel_siginfo);\n}"
  },
  {
    "function_name": "siginfo_layout",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3283-3321",
    "snippet": "enum siginfo_layout siginfo_layout(unsigned sig, int si_code)\n{\n\tenum siginfo_layout layout = SIL_KILL;\n\tif ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n\t\tif ((sig < ARRAY_SIZE(sig_sicodes)) &&\n\t\t    (si_code <= sig_sicodes[sig].limit)) {\n\t\t\tlayout = sig_sicodes[sig].layout;\n\t\t\t/* Handle the exceptions */\n\t\t\tif ((sig == SIGBUS) &&\n\t\t\t    (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n\t\t\t\tlayout = SIL_FAULT_MCEERR;\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n\t\t\t\tlayout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n\t\t\t\tlayout = SIL_FAULT_PKUERR;\n#endif\n\t\t\telse if ((sig == SIGTRAP) && (si_code == TRAP_PERF))\n\t\t\t\tlayout = SIL_FAULT_PERF_EVENT;\n\t\t\telse if (IS_ENABLED(CONFIG_SPARC) &&\n\t\t\t\t (sig == SIGILL) && (si_code == ILL_ILLTRP))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t\telse if (IS_ENABLED(CONFIG_ALPHA) &&\n\t\t\t\t ((sig == SIGFPE) ||\n\t\t\t\t  ((sig == SIGTRAP) && (si_code == TRAP_UNK))))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\tlayout = SIL_POLL;\n\t} else {\n\t\tif (si_code == SI_TIMER)\n\t\t\tlayout = SIL_TIMER;\n\t\telse if (si_code == SI_SIGIO)\n\t\t\tlayout = SIL_POLL;\n\t\telse if (si_code < 0)\n\t\t\tlayout = SIL_RT;\n\t}\n\treturn layout;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "sig_sicodes"
          ],
          "line": 3287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};\n\nenum siginfo_layout siginfo_layout(unsigned sig, int si_code)\n{\n\tenum siginfo_layout layout = SIL_KILL;\n\tif ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n\t\tif ((sig < ARRAY_SIZE(sig_sicodes)) &&\n\t\t    (si_code <= sig_sicodes[sig].limit)) {\n\t\t\tlayout = sig_sicodes[sig].layout;\n\t\t\t/* Handle the exceptions */\n\t\t\tif ((sig == SIGBUS) &&\n\t\t\t    (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n\t\t\t\tlayout = SIL_FAULT_MCEERR;\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n\t\t\t\tlayout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n\t\t\t\tlayout = SIL_FAULT_PKUERR;\n#endif\n\t\t\telse if ((sig == SIGTRAP) && (si_code == TRAP_PERF))\n\t\t\t\tlayout = SIL_FAULT_PERF_EVENT;\n\t\t\telse if (IS_ENABLED(CONFIG_SPARC) &&\n\t\t\t\t (sig == SIGILL) && (si_code == ILL_ILLTRP))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t\telse if (IS_ENABLED(CONFIG_ALPHA) &&\n\t\t\t\t ((sig == SIGFPE) ||\n\t\t\t\t  ((sig == SIGTRAP) && (si_code == TRAP_UNK))))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\tlayout = SIL_POLL;\n\t} else {\n\t\tif (si_code == SI_TIMER)\n\t\t\tlayout = SIL_TIMER;\n\t\telse if (si_code == SI_SIGIO)\n\t\t\tlayout = SIL_POLL;\n\t\telse if (si_code < 0)\n\t\t\tlayout = SIL_RT;\n\t}\n\treturn layout;\n}"
  },
  {
    "function_name": "known_siginfo_layout",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3264-3281",
    "snippet": "static bool known_siginfo_layout(unsigned sig, int si_code)\n{\n\tif (si_code == SI_KERNEL)\n\t\treturn true;\n\telse if ((si_code > SI_USER)) {\n\t\tif (sig_specific_sicodes(sig)) {\n\t\t\tif (si_code <= sig_sicodes[sig].limit)\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\treturn true;\n\t}\n\telse if (si_code >= SI_DETHREAD)\n\t\treturn true;\n\telse if (si_code == SI_ASYNCNL)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sig_specific_sicodes",
          "args": [
            "sig"
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};\n\nstatic bool known_siginfo_layout(unsigned sig, int si_code)\n{\n\tif (si_code == SI_KERNEL)\n\t\treturn true;\n\telse if ((si_code > SI_USER)) {\n\t\tif (sig_specific_sicodes(sig)) {\n\t\t\tif (si_code <= sig_sicodes[sig].limit)\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\treturn true;\n\t}\n\telse if (si_code >= SI_DETHREAD)\n\t\treturn true;\n\telse if (si_code == SI_ASYNCNL)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "do_sigpending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3201-3210",
    "snippet": "static void do_sigpending(sigset_t *set)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tsigorsets(set, &current->pending.signal,\n\t\t  &current->signal->shared_pending.signal);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t/* Outside the lock because only this thread touches it.  */\n\tsigandsets(set, &current->blocked, set);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigandsets",
          "args": [
            "set",
            "&current->blocked",
            "set"
          ],
          "line": 3209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 3206
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigorsets",
          "args": [
            "set",
            "&current->pending.signal",
            "&current->signal->shared_pending.signal"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 3203
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void do_sigpending(sigset_t *set)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tsigorsets(set, &current->pending.signal,\n\t\t  &current->signal->shared_pending.signal);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t/* Outside the lock because only this thread touches it.  */\n\tsigandsets(set, &current->blocked, set);\n}"
  },
  {
    "function_name": "set_compat_user_sigmask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3119-3136",
    "snippet": "int set_compat_user_sigmask(const compat_sigset_t __user *umask,\n\t\t\t    size_t sigsetsize)\n{\n\tsigset_t kmask;\n\n\tif (!umask)\n\t\treturn 0;\n\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\treturn -EINVAL;\n\tif (get_compat_sigset(&kmask, umask))\n\t\treturn -EFAULT;\n\n\tset_restore_sigmask();\n\tcurrent->saved_sigmask = current->blocked;\n\tset_current_blocked(&kmask);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_current_blocked",
          "args": [
            "&kmask"
          ],
          "line": 3133
        },
        "resolved": true,
        "details": {
          "function_name": "__set_current_blocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3039-3053",
          "snippet": "void __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_restore_sigmask",
          "args": [],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_compat_sigset",
          "args": [
            "&kmask",
            "umask"
          ],
          "line": 3128
        },
        "resolved": true,
        "details": {
          "function_name": "get_compat_sigset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/compat.c",
          "lines": "249-270",
          "snippet": "int\nget_compat_sigset(sigset_t *set, const compat_sigset_t __user *compat)\n{\n#ifdef __BIG_ENDIAN\n\tcompat_sigset_t v;\n\tif (copy_from_user(&v, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n\tswitch (_NSIG_WORDS) {\n\tcase 4: set->sig[3] = v.sig[6] | (((long)v.sig[7]) << 32 );\n\t\tfallthrough;\n\tcase 3: set->sig[2] = v.sig[4] | (((long)v.sig[5]) << 32 );\n\t\tfallthrough;\n\tcase 2: set->sig[1] = v.sig[2] | (((long)v.sig[3]) << 32 );\n\t\tfallthrough;\n\tcase 1: set->sig[0] = v.sig[0] | (((long)v.sig[1]) << 32 );\n\t}\n#else\n\tif (copy_from_user(set, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/gfp.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/times.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/migrate.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nint\nget_compat_sigset(sigset_t *set, const compat_sigset_t __user *compat)\n{\n#ifdef __BIG_ENDIAN\n\tcompat_sigset_t v;\n\tif (copy_from_user(&v, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n\tswitch (_NSIG_WORDS) {\n\tcase 4: set->sig[3] = v.sig[6] | (((long)v.sig[7]) << 32 );\n\t\tfallthrough;\n\tcase 3: set->sig[2] = v.sig[4] | (((long)v.sig[5]) << 32 );\n\t\tfallthrough;\n\tcase 2: set->sig[1] = v.sig[2] | (((long)v.sig[3]) << 32 );\n\t\tfallthrough;\n\tcase 1: set->sig[0] = v.sig[0] | (((long)v.sig[1]) << 32 );\n\t}\n#else\n\tif (copy_from_user(set, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n#endif\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint set_compat_user_sigmask(const compat_sigset_t __user *umask,\n\t\t\t    size_t sigsetsize)\n{\n\tsigset_t kmask;\n\n\tif (!umask)\n\t\treturn 0;\n\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\treturn -EINVAL;\n\tif (get_compat_sigset(&kmask, umask))\n\t\treturn -EFAULT;\n\n\tset_restore_sigmask();\n\tcurrent->saved_sigmask = current->blocked;\n\tset_current_blocked(&kmask);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "set_user_sigmask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3100-3116",
    "snippet": "int set_user_sigmask(const sigset_t __user *umask, size_t sigsetsize)\n{\n\tsigset_t kmask;\n\n\tif (!umask)\n\t\treturn 0;\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&kmask, umask, sizeof(sigset_t)))\n\t\treturn -EFAULT;\n\n\tset_restore_sigmask();\n\tcurrent->saved_sigmask = current->blocked;\n\tset_current_blocked(&kmask);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_current_blocked",
          "args": [
            "&kmask"
          ],
          "line": 3113
        },
        "resolved": true,
        "details": {
          "function_name": "__set_current_blocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3039-3053",
          "snippet": "void __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_restore_sigmask",
          "args": [],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&kmask",
            "umask",
            "sizeof(sigset_t)"
          ],
          "line": 3108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint set_user_sigmask(const sigset_t __user *umask, size_t sigsetsize)\n{\n\tsigset_t kmask;\n\n\tif (!umask)\n\t\treturn 0;\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&kmask, umask, sizeof(sigset_t)))\n\t\treturn -EFAULT;\n\n\tset_restore_sigmask();\n\tcurrent->saved_sigmask = current->blocked;\n\tset_current_blocked(&kmask);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sigprocmask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3063-3088",
    "snippet": "int sigprocmask(int how, sigset_t *set, sigset_t *oldset)\n{\n\tstruct task_struct *tsk = current;\n\tsigset_t newset;\n\n\t/* Lockless, only current can change ->blocked, never from irq */\n\tif (oldset)\n\t\t*oldset = tsk->blocked;\n\n\tswitch (how) {\n\tcase SIG_BLOCK:\n\t\tsigorsets(&newset, &tsk->blocked, set);\n\t\tbreak;\n\tcase SIG_UNBLOCK:\n\t\tsigandnsets(&newset, &tsk->blocked, set);\n\t\tbreak;\n\tcase SIG_SETMASK:\n\t\tnewset = *set;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t__set_current_blocked(&newset);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_blocked",
          "args": [
            "&newset"
          ],
          "line": 3086
        },
        "resolved": true,
        "details": {
          "function_name": "__set_current_blocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3039-3053",
          "snippet": "void __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigandnsets",
          "args": [
            "&newset",
            "&tsk->blocked",
            "set"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigorsets",
          "args": [
            "&newset",
            "&tsk->blocked",
            "set"
          ],
          "line": 3074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint sigprocmask(int how, sigset_t *set, sigset_t *oldset)\n{\n\tstruct task_struct *tsk = current;\n\tsigset_t newset;\n\n\t/* Lockless, only current can change ->blocked, never from irq */\n\tif (oldset)\n\t\t*oldset = tsk->blocked;\n\n\tswitch (how) {\n\tcase SIG_BLOCK:\n\t\tsigorsets(&newset, &tsk->blocked, set);\n\t\tbreak;\n\tcase SIG_UNBLOCK:\n\t\tsigandnsets(&newset, &tsk->blocked, set);\n\t\tbreak;\n\tcase SIG_SETMASK:\n\t\tnewset = *set;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t__set_current_blocked(&newset);\n\treturn 0;\n}"
  },
  {
    "function_name": "__set_current_blocked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3039-3053",
    "snippet": "void __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 3052
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_task_blocked",
          "args": [
            "tsk",
            "newset"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "__set_task_blocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3014-3024",
          "snippet": "static void __set_task_blocked(struct task_struct *tsk, const sigset_t *newset)\n{\n\tif (task_sigpending(tsk) && !thread_group_empty(tsk)) {\n\t\tsigset_t newblocked;\n\t\t/* A set of now blocked but previously unblocked signals. */\n\t\tsigandnsets(&newblocked, newset, &current->blocked);\n\t\tretarget_shared_pending(tsk, &newblocked);\n\t}\n\ttsk->blocked = *newset;\n\trecalc_sigpending();\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void __set_task_blocked(struct task_struct *tsk, const sigset_t *newset)\n{\n\tif (task_sigpending(tsk) && !thread_group_empty(tsk)) {\n\t\tsigset_t newblocked;\n\t\t/* A set of now blocked but previously unblocked signals. */\n\t\tsigandnsets(&newblocked, newset, &current->blocked);\n\t\tretarget_shared_pending(tsk, &newblocked);\n\t}\n\ttsk->blocked = *newset;\n\trecalc_sigpending();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigequalsets",
          "args": [
            "&tsk->blocked",
            "newset"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}"
  },
  {
    "function_name": "set_current_blocked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3033-3037",
    "snippet": "void set_current_blocked(sigset_t *newset)\n{\n\tsigdelsetmask(newset, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t__set_current_blocked(newset);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_blocked",
          "args": [
            "newset"
          ],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "__set_current_blocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3039-3053",
          "snippet": "void __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigdelsetmask",
          "args": [
            "newset",
            "sigmask(SIGKILL) | sigmask(SIGSTOP)"
          ],
          "line": 3035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGSTOP"
          ],
          "line": 3035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGKILL"
          ],
          "line": 3035
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid set_current_blocked(sigset_t *newset)\n{\n\tsigdelsetmask(newset, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t__set_current_blocked(newset);\n}"
  },
  {
    "function_name": "__set_task_blocked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3014-3024",
    "snippet": "static void __set_task_blocked(struct task_struct *tsk, const sigset_t *newset)\n{\n\tif (task_sigpending(tsk) && !thread_group_empty(tsk)) {\n\t\tsigset_t newblocked;\n\t\t/* A set of now blocked but previously unblocked signals. */\n\t\tsigandnsets(&newblocked, newset, &current->blocked);\n\t\tretarget_shared_pending(tsk, &newblocked);\n\t}\n\ttsk->blocked = *newset;\n\trecalc_sigpending();\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 3023
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "182-187",
          "snippet": "void recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "retarget_shared_pending",
          "args": [
            "tsk",
            "&newblocked"
          ],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "retarget_shared_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2919-2944",
          "snippet": "static void retarget_shared_pending(struct task_struct *tsk, sigset_t *which)\n{\n\tsigset_t retarget;\n\tstruct task_struct *t;\n\n\tsigandsets(&retarget, &tsk->signal->shared_pending.signal, which);\n\tif (sigisemptyset(&retarget))\n\t\treturn;\n\n\tt = tsk;\n\twhile_each_thread(tsk, t) {\n\t\tif (t->flags & PF_EXITING)\n\t\t\tcontinue;\n\n\t\tif (!has_pending_signals(&retarget, &t->blocked))\n\t\t\tcontinue;\n\t\t/* Remove the signals this thread can handle. */\n\t\tsigandsets(&retarget, &retarget, &t->blocked);\n\n\t\tif (!task_sigpending(t))\n\t\t\tsignal_wake_up(t, 0);\n\n\t\tif (sigisemptyset(&retarget))\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void retarget_shared_pending(struct task_struct *tsk, sigset_t *which)\n{\n\tsigset_t retarget;\n\tstruct task_struct *t;\n\n\tsigandsets(&retarget, &tsk->signal->shared_pending.signal, which);\n\tif (sigisemptyset(&retarget))\n\t\treturn;\n\n\tt = tsk;\n\twhile_each_thread(tsk, t) {\n\t\tif (t->flags & PF_EXITING)\n\t\t\tcontinue;\n\n\t\tif (!has_pending_signals(&retarget, &t->blocked))\n\t\t\tcontinue;\n\t\t/* Remove the signals this thread can handle. */\n\t\tsigandsets(&retarget, &retarget, &t->blocked);\n\n\t\tif (!task_sigpending(t))\n\t\t\tsignal_wake_up(t, 0);\n\n\t\tif (sigisemptyset(&retarget))\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigandnsets",
          "args": [
            "&newblocked",
            "newset",
            "&current->blocked"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "tsk"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_sigpending",
          "args": [
            "tsk"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void __set_task_blocked(struct task_struct *tsk, const sigset_t *newset)\n{\n\tif (task_sigpending(tsk) && !thread_group_empty(tsk)) {\n\t\tsigset_t newblocked;\n\t\t/* A set of now blocked but previously unblocked signals. */\n\t\tsigandnsets(&newblocked, newset, &current->blocked);\n\t\tretarget_shared_pending(tsk, &newblocked);\n\t}\n\ttsk->blocked = *newset;\n\trecalc_sigpending();\n}"
  },
  {
    "function_name": "do_no_restart_syscall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3009-3012",
    "snippet": "long do_no_restart_syscall(struct restart_block *param)\n{\n\treturn -EINTR;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nlong do_no_restart_syscall(struct restart_block *param)\n{\n\treturn -EINTR;\n}"
  },
  {
    "function_name": "exit_signals",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "2946-2994",
    "snippet": "void exit_signals(struct task_struct *tsk)\n{\n\tint group_stop = 0;\n\tsigset_t unblocked;\n\n\t/*\n\t * @tsk is about to have PF_EXITING set - lock out users which\n\t * expect stable threadgroup.\n\t */\n\tcgroup_threadgroup_change_begin(tsk);\n\n\tif (thread_group_empty(tsk) || (tsk->signal->flags & SIGNAL_GROUP_EXIT)) {\n\t\ttsk->flags |= PF_EXITING;\n\t\tcgroup_threadgroup_change_end(tsk);\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t/*\n\t * From now this task is not visible for group-wide signals,\n\t * see wants_signal(), do_signal_stop().\n\t */\n\ttsk->flags |= PF_EXITING;\n\n\tcgroup_threadgroup_change_end(tsk);\n\n\tif (!task_sigpending(tsk))\n\t\tgoto out;\n\n\tunblocked = tsk->blocked;\n\tsignotset(&unblocked);\n\tretarget_shared_pending(tsk, &unblocked);\n\n\tif (unlikely(tsk->jobctl & JOBCTL_STOP_PENDING) &&\n\t    task_participate_group_stop(tsk))\n\t\tgroup_stop = CLD_STOPPED;\nout:\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\t/*\n\t * If group stop has completed, deliver the notification.  This\n\t * should always go to the real parent of the group leader.\n\t */\n\tif (unlikely(group_stop)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(tsk, false, group_stop);\n\t\tread_unlock(&tasklist_lock);\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 2992
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_notify_parent_cldstop",
          "args": [
            "tsk",
            "false",
            "group_stop"
          ],
          "line": 2991
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent_cldstop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2125-2181",
          "snippet": "static void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 2990
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "group_stop"
          ],
          "line": 2989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 2983
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_participate_group_stop",
          "args": [
            "tsk"
          ],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "task_participate_group_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "365-389",
          "snippet": "static bool task_participate_group_stop(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n\tif (!consume)\n\t\treturn false;\n\n\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))\n\t\tsig->group_stop_count--;\n\n\t/*\n\t * Tell the caller to notify completion iff we are entering into a\n\t * fresh group stop.  Read comment in do_signal_stop() for details.\n\t */\n\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool task_participate_group_stop(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n\tif (!consume)\n\t\treturn false;\n\n\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))\n\t\tsig->group_stop_count--;\n\n\t/*\n\t * Tell the caller to notify completion iff we are entering into a\n\t * fresh group stop.  Read comment in do_signal_stop() for details.\n\t */\n\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tsk->jobctl & JOBCTL_STOP_PENDING"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retarget_shared_pending",
          "args": [
            "tsk",
            "&unblocked"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "retarget_shared_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2919-2944",
          "snippet": "static void retarget_shared_pending(struct task_struct *tsk, sigset_t *which)\n{\n\tsigset_t retarget;\n\tstruct task_struct *t;\n\n\tsigandsets(&retarget, &tsk->signal->shared_pending.signal, which);\n\tif (sigisemptyset(&retarget))\n\t\treturn;\n\n\tt = tsk;\n\twhile_each_thread(tsk, t) {\n\t\tif (t->flags & PF_EXITING)\n\t\t\tcontinue;\n\n\t\tif (!has_pending_signals(&retarget, &t->blocked))\n\t\t\tcontinue;\n\t\t/* Remove the signals this thread can handle. */\n\t\tsigandsets(&retarget, &retarget, &t->blocked);\n\n\t\tif (!task_sigpending(t))\n\t\t\tsignal_wake_up(t, 0);\n\n\t\tif (sigisemptyset(&retarget))\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void retarget_shared_pending(struct task_struct *tsk, sigset_t *which)\n{\n\tsigset_t retarget;\n\tstruct task_struct *t;\n\n\tsigandsets(&retarget, &tsk->signal->shared_pending.signal, which);\n\tif (sigisemptyset(&retarget))\n\t\treturn;\n\n\tt = tsk;\n\twhile_each_thread(tsk, t) {\n\t\tif (t->flags & PF_EXITING)\n\t\t\tcontinue;\n\n\t\tif (!has_pending_signals(&retarget, &t->blocked))\n\t\t\tcontinue;\n\t\t/* Remove the signals this thread can handle. */\n\t\tsigandsets(&retarget, &retarget, &t->blocked);\n\n\t\tif (!task_sigpending(t))\n\t\t\tsignal_wake_up(t, 0);\n\n\t\tif (sigisemptyset(&retarget))\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "signotset",
          "args": [
            "&unblocked"
          ],
          "line": 2976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_sigpending",
          "args": [
            "tsk"
          ],
          "line": 2972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_threadgroup_change_end",
          "args": [
            "tsk"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 2963
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_threadgroup_change_end",
          "args": [
            "tsk"
          ],
          "line": 2959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "tsk"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_threadgroup_change_begin",
          "args": [
            "tsk"
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid exit_signals(struct task_struct *tsk)\n{\n\tint group_stop = 0;\n\tsigset_t unblocked;\n\n\t/*\n\t * @tsk is about to have PF_EXITING set - lock out users which\n\t * expect stable threadgroup.\n\t */\n\tcgroup_threadgroup_change_begin(tsk);\n\n\tif (thread_group_empty(tsk) || (tsk->signal->flags & SIGNAL_GROUP_EXIT)) {\n\t\ttsk->flags |= PF_EXITING;\n\t\tcgroup_threadgroup_change_end(tsk);\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t/*\n\t * From now this task is not visible for group-wide signals,\n\t * see wants_signal(), do_signal_stop().\n\t */\n\ttsk->flags |= PF_EXITING;\n\n\tcgroup_threadgroup_change_end(tsk);\n\n\tif (!task_sigpending(tsk))\n\t\tgoto out;\n\n\tunblocked = tsk->blocked;\n\tsignotset(&unblocked);\n\tretarget_shared_pending(tsk, &unblocked);\n\n\tif (unlikely(tsk->jobctl & JOBCTL_STOP_PENDING) &&\n\t    task_participate_group_stop(tsk))\n\t\tgroup_stop = CLD_STOPPED;\nout:\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\t/*\n\t * If group stop has completed, deliver the notification.  This\n\t * should always go to the real parent of the group leader.\n\t */\n\tif (unlikely(group_stop)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(tsk, false, group_stop);\n\t\tread_unlock(&tasklist_lock);\n\t}\n}"
  },
  {
    "function_name": "retarget_shared_pending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "2919-2944",
    "snippet": "static void retarget_shared_pending(struct task_struct *tsk, sigset_t *which)\n{\n\tsigset_t retarget;\n\tstruct task_struct *t;\n\n\tsigandsets(&retarget, &tsk->signal->shared_pending.signal, which);\n\tif (sigisemptyset(&retarget))\n\t\treturn;\n\n\tt = tsk;\n\twhile_each_thread(tsk, t) {\n\t\tif (t->flags & PF_EXITING)\n\t\t\tcontinue;\n\n\t\tif (!has_pending_signals(&retarget, &t->blocked))\n\t\t\tcontinue;\n\t\t/* Remove the signals this thread can handle. */\n\t\tsigandsets(&retarget, &retarget, &t->blocked);\n\n\t\tif (!task_sigpending(t))\n\t\t\tsignal_wake_up(t, 0);\n\n\t\tif (sigisemptyset(&retarget))\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigisemptyset",
          "args": [
            "&retarget"
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_wake_up",
          "args": [
            "t",
            "0"
          ],
          "line": 2939
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "763-775",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_sigpending",
          "args": [
            "t"
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigandsets",
          "args": [
            "&retarget",
            "&retarget",
            "&t->blocked"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_pending_signals",
          "args": [
            "&retarget",
            "&t->blocked"
          ],
          "line": 2933
        },
        "resolved": true,
        "details": {
          "function_name": "has_pending_signals",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "126-150",
          "snippet": "static inline bool has_pending_signals(sigset_t *signal, sigset_t *blocked)\n{\n\tunsigned long ready;\n\tlong i;\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = _NSIG_WORDS, ready = 0; --i >= 0 ;)\n\t\t\tready |= signal->sig[i] &~ blocked->sig[i];\n\t\tbreak;\n\n\tcase 4: ready  = signal->sig[3] &~ blocked->sig[3];\n\t\tready |= signal->sig[2] &~ blocked->sig[2];\n\t\tready |= signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 2: ready  = signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 1: ready  = signal->sig[0] &~ blocked->sig[0];\n\t}\n\treturn ready !=\t0;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool has_pending_signals(sigset_t *signal, sigset_t *blocked)\n{\n\tunsigned long ready;\n\tlong i;\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = _NSIG_WORDS, ready = 0; --i >= 0 ;)\n\t\t\tready |= signal->sig[i] &~ blocked->sig[i];\n\t\tbreak;\n\n\tcase 4: ready  = signal->sig[3] &~ blocked->sig[3];\n\t\tready |= signal->sig[2] &~ blocked->sig[2];\n\t\tready |= signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 2: ready  = signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 1: ready  = signal->sig[0] &~ blocked->sig[0];\n\t}\n\treturn ready !=\t0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "tsk",
            "t"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigisemptyset",
          "args": [
            "&retarget"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigandsets",
          "args": [
            "&retarget",
            "&tsk->signal->shared_pending.signal",
            "which"
          ],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void retarget_shared_pending(struct task_struct *tsk, sigset_t *which)\n{\n\tsigset_t retarget;\n\tstruct task_struct *t;\n\n\tsigandsets(&retarget, &tsk->signal->shared_pending.signal, which);\n\tif (sigisemptyset(&retarget))\n\t\treturn;\n\n\tt = tsk;\n\twhile_each_thread(tsk, t) {\n\t\tif (t->flags & PF_EXITING)\n\t\t\tcontinue;\n\n\t\tif (!has_pending_signals(&retarget, &t->blocked))\n\t\t\tcontinue;\n\t\t/* Remove the signals this thread can handle. */\n\t\tsigandsets(&retarget, &retarget, &t->blocked);\n\n\t\tif (!task_sigpending(t))\n\t\t\tsignal_wake_up(t, 0);\n\n\t\tif (sigisemptyset(&retarget))\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "signal_setup_done",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "2906-2912",
    "snippet": "void signal_setup_done(int failed, struct ksignal *ksig, int stepping)\n{\n\tif (failed)\n\t\tforce_sigsegv(ksig->sig);\n\telse\n\t\tsignal_delivered(ksig, stepping);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_delivered",
          "args": [
            "ksig",
            "stepping"
          ],
          "line": 2911
        },
        "resolved": true,
        "details": {
          "function_name": "signal_delivered",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2886-2904",
          "snippet": "static void signal_delivered(struct ksignal *ksig, int stepping)\n{\n\tsigset_t blocked;\n\n\t/* A signal was successfully delivered, and the\n\t   saved sigmask was stored on the signal frame,\n\t   and will be restored by sigreturn.  So we can\n\t   simply clear the restore sigmask flag.  */\n\tclear_restore_sigmask();\n\n\tsigorsets(&blocked, &current->blocked, &ksig->ka.sa.sa_mask);\n\tif (!(ksig->ka.sa.sa_flags & SA_NODEFER))\n\t\tsigaddset(&blocked, ksig->sig);\n\tset_current_blocked(&blocked);\n\tif (current->sas_ss_flags & SS_AUTODISARM)\n\t\tsas_ss_reset(current);\n\tif (stepping)\n\t\tptrace_notify(SIGTRAP, 0);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void signal_delivered(struct ksignal *ksig, int stepping)\n{\n\tsigset_t blocked;\n\n\t/* A signal was successfully delivered, and the\n\t   saved sigmask was stored on the signal frame,\n\t   and will be restored by sigreturn.  So we can\n\t   simply clear the restore sigmask flag.  */\n\tclear_restore_sigmask();\n\n\tsigorsets(&blocked, &current->blocked, &ksig->ka.sa.sa_mask);\n\tif (!(ksig->ka.sa.sa_flags & SA_NODEFER))\n\t\tsigaddset(&blocked, ksig->sig);\n\tset_current_blocked(&blocked);\n\tif (current->sas_ss_flags & SS_AUTODISARM)\n\t\tsas_ss_reset(current);\n\tif (stepping)\n\t\tptrace_notify(SIGTRAP, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_sigsegv",
          "args": [
            "ksig->sig"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "force_sigsegv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1696-1702",
          "snippet": "void force_sigsegv(int sig)\n{\n\tif (sig == SIGSEGV)\n\t\tforce_fatal_sig(SIGSEGV);\n\telse\n\t\tforce_sig(SIGSEGV);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid force_sigsegv(int sig)\n{\n\tif (sig == SIGSEGV)\n\t\tforce_fatal_sig(SIGSEGV);\n\telse\n\t\tforce_sig(SIGSEGV);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_setup_done(int failed, struct ksignal *ksig, int stepping)\n{\n\tif (failed)\n\t\tforce_sigsegv(ksig->sig);\n\telse\n\t\tsignal_delivered(ksig, stepping);\n}"
  },
  {
    "function_name": "signal_delivered",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "2886-2904",
    "snippet": "static void signal_delivered(struct ksignal *ksig, int stepping)\n{\n\tsigset_t blocked;\n\n\t/* A signal was successfully delivered, and the\n\t   saved sigmask was stored on the signal frame,\n\t   and will be restored by sigreturn.  So we can\n\t   simply clear the restore sigmask flag.  */\n\tclear_restore_sigmask();\n\n\tsigorsets(&blocked, &current->blocked, &ksig->ka.sa.sa_mask);\n\tif (!(ksig->ka.sa.sa_flags & SA_NODEFER))\n\t\tsigaddset(&blocked, ksig->sig);\n\tset_current_blocked(&blocked);\n\tif (current->sas_ss_flags & SS_AUTODISARM)\n\t\tsas_ss_reset(current);\n\tif (stepping)\n\t\tptrace_notify(SIGTRAP, 0);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrace_notify",
          "args": [
            "SIGTRAP",
            "0"
          ],
          "line": 2903
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_notify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2354-2366",
          "snippet": "int ptrace_notify(int exit_code, unsigned long message)\n{\n\tint signr;\n\n\tBUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);\n\tif (unlikely(task_work_pending(current)))\n\t\ttask_work_run();\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tsignr = ptrace_do_notify(SIGTRAP, exit_code, CLD_TRAPPED, message);\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn signr;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint ptrace_notify(int exit_code, unsigned long message)\n{\n\tint signr;\n\n\tBUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);\n\tif (unlikely(task_work_pending(current)))\n\t\ttask_work_run();\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tsignr = ptrace_do_notify(SIGTRAP, exit_code, CLD_TRAPPED, message);\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn signr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sas_ss_reset",
          "args": [
            "current"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_blocked",
          "args": [
            "&blocked"
          ],
          "line": 2899
        },
        "resolved": true,
        "details": {
          "function_name": "__set_current_blocked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3039-3053",
          "snippet": "void __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&blocked",
            "ksig->sig"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigorsets",
          "args": [
            "&blocked",
            "&current->blocked",
            "&ksig->ka.sa.sa_mask"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_restore_sigmask",
          "args": [],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void signal_delivered(struct ksignal *ksig, int stepping)\n{\n\tsigset_t blocked;\n\n\t/* A signal was successfully delivered, and the\n\t   saved sigmask was stored on the signal frame,\n\t   and will be restored by sigreturn.  So we can\n\t   simply clear the restore sigmask flag.  */\n\tclear_restore_sigmask();\n\n\tsigorsets(&blocked, &current->blocked, &ksig->ka.sa.sa_mask);\n\tif (!(ksig->ka.sa.sa_flags & SA_NODEFER))\n\t\tsigaddset(&blocked, ksig->sig);\n\tset_current_blocked(&blocked);\n\tif (current->sas_ss_flags & SS_AUTODISARM)\n\t\tsas_ss_reset(current);\n\tif (stepping)\n\t\tptrace_notify(SIGTRAP, 0);\n}"
  },
  {
    "function_name": "get_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "2632-2874",
    "snippet": "bool get_signal(struct ksignal *ksig)\n{\n\tstruct sighand_struct *sighand = current->sighand;\n\tstruct signal_struct *signal = current->signal;\n\tint signr;\n\n\tclear_notify_signal();\n\tif (unlikely(task_work_pending(current)))\n\t\ttask_work_run();\n\n\tif (!task_sigpending(current))\n\t\treturn false;\n\n\tif (unlikely(uprobe_deny_signal()))\n\t\treturn false;\n\n\t/*\n\t * Do this once, we can't return to user-mode if freezing() == T.\n\t * do_signal_stop() and ptrace_stop() do freezable_schedule() and\n\t * thus do not need another check after return.\n\t */\n\ttry_to_freeze();\n\nrelock:\n\tspin_lock_irq(&sighand->siglock);\n\n\t/*\n\t * Every stopped thread goes here after wakeup. Check to see if\n\t * we should notify the parent, prepare_signal(SIGCONT) encodes\n\t * the CLD_ si_code into SIGNAL_CLD_MASK bits.\n\t */\n\tif (unlikely(signal->flags & SIGNAL_CLD_MASK)) {\n\t\tint why;\n\n\t\tif (signal->flags & SIGNAL_CLD_CONTINUED)\n\t\t\twhy = CLD_CONTINUED;\n\t\telse\n\t\t\twhy = CLD_STOPPED;\n\n\t\tsignal->flags &= ~SIGNAL_CLD_MASK;\n\n\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\t/*\n\t\t * Notify the parent that we're continuing.  This event is\n\t\t * always per-process and doesn't make whole lot of sense\n\t\t * for ptracers, who shouldn't consume the state via\n\t\t * wait(2) either, but, for backward compatibility, notify\n\t\t * the ptracer of the group leader too unless it's gonna be\n\t\t * a duplicate.\n\t\t */\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\tif (ptrace_reparented(current->group_leader))\n\t\t\tdo_notify_parent_cldstop(current->group_leader,\n\t\t\t\t\t\ttrue, why);\n\t\tread_unlock(&tasklist_lock);\n\n\t\tgoto relock;\n\t}\n\n\tfor (;;) {\n\t\tstruct k_sigaction *ka;\n\t\tenum pid_type type;\n\n\t\t/* Has this task already been marked for death? */\n\t\tif ((signal->flags & SIGNAL_GROUP_EXIT) ||\n\t\t     signal->group_exec_task) {\n\t\t\tksig->info.si_signo = signr = SIGKILL;\n\t\t\tsigdelset(&current->pending.signal, SIGKILL);\n\t\t\ttrace_signal_deliver(SIGKILL, SEND_SIG_NOINFO,\n\t\t\t\t&sighand->action[SIGKILL - 1]);\n\t\t\trecalc_sigpending();\n\t\t\tgoto fatal;\n\t\t}\n\n\t\tif (unlikely(current->jobctl & JOBCTL_STOP_PENDING) &&\n\t\t    do_signal_stop(0))\n\t\t\tgoto relock;\n\n\t\tif (unlikely(current->jobctl &\n\t\t\t     (JOBCTL_TRAP_MASK | JOBCTL_TRAP_FREEZE))) {\n\t\t\tif (current->jobctl & JOBCTL_TRAP_MASK) {\n\t\t\t\tdo_jobctl_trap();\n\t\t\t\tspin_unlock_irq(&sighand->siglock);\n\t\t\t} else if (current->jobctl & JOBCTL_TRAP_FREEZE)\n\t\t\t\tdo_freezer_trap();\n\n\t\t\tgoto relock;\n\t\t}\n\n\t\t/*\n\t\t * If the task is leaving the frozen state, let's update\n\t\t * cgroup counters and reset the frozen bit.\n\t\t */\n\t\tif (unlikely(cgroup_task_frozen(current))) {\n\t\t\tspin_unlock_irq(&sighand->siglock);\n\t\t\tcgroup_leave_frozen(false);\n\t\t\tgoto relock;\n\t\t}\n\n\t\t/*\n\t\t * Signals generated by the execution of an instruction\n\t\t * need to be delivered before any other pending signals\n\t\t * so that the instruction pointer in the signal stack\n\t\t * frame points to the faulting instruction.\n\t\t */\n\t\ttype = PIDTYPE_PID;\n\t\tsignr = dequeue_synchronous_signal(&ksig->info);\n\t\tif (!signr)\n\t\t\tsignr = dequeue_signal(current, &current->blocked,\n\t\t\t\t\t       &ksig->info, &type);\n\n\t\tif (!signr)\n\t\t\tbreak; /* will return 0 */\n\n\t\tif (unlikely(current->ptrace) && (signr != SIGKILL) &&\n\t\t    !(sighand->action[signr -1].sa.sa_flags & SA_IMMUTABLE)) {\n\t\t\tsignr = ptrace_signal(signr, &ksig->info, type);\n\t\t\tif (!signr)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tka = &sighand->action[signr-1];\n\n\t\t/* Trace actually delivered signals. */\n\t\ttrace_signal_deliver(signr, &ksig->info, ka);\n\n\t\tif (ka->sa.sa_handler == SIG_IGN) /* Do nothing.  */\n\t\t\tcontinue;\n\t\tif (ka->sa.sa_handler != SIG_DFL) {\n\t\t\t/* Run the handler.  */\n\t\t\tksig->ka = *ka;\n\n\t\t\tif (ka->sa.sa_flags & SA_ONESHOT)\n\t\t\t\tka->sa.sa_handler = SIG_DFL;\n\n\t\t\tbreak; /* will return non-zero \"signr\" value */\n\t\t}\n\n\t\t/*\n\t\t * Now we are doing the default action for this signal.\n\t\t */\n\t\tif (sig_kernel_ignore(signr)) /* Default is nothing. */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Global init gets no signals it doesn't want.\n\t\t * Container-init gets no signals it doesn't want from same\n\t\t * container.\n\t\t *\n\t\t * Note that if global/container-init sees a sig_kernel_only()\n\t\t * signal here, the signal must have been generated internally\n\t\t * or must have come from an ancestor namespace. In either\n\t\t * case, the signal cannot be dropped.\n\t\t */\n\t\tif (unlikely(signal->flags & SIGNAL_UNKILLABLE) &&\n\t\t\t\t!sig_kernel_only(signr))\n\t\t\tcontinue;\n\n\t\tif (sig_kernel_stop(signr)) {\n\t\t\t/*\n\t\t\t * The default action is to stop all threads in\n\t\t\t * the thread group.  The job control signals\n\t\t\t * do nothing in an orphaned pgrp, but SIGSTOP\n\t\t\t * always works.  Note that siglock needs to be\n\t\t\t * dropped during the call to is_orphaned_pgrp()\n\t\t\t * because of lock ordering with tasklist_lock.\n\t\t\t * This allows an intervening SIGCONT to be posted.\n\t\t\t * We need to check for that and bail out if necessary.\n\t\t\t */\n\t\t\tif (signr != SIGSTOP) {\n\t\t\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\t\t\t/* signals can be posted during this window */\n\n\t\t\t\tif (is_current_pgrp_orphaned())\n\t\t\t\t\tgoto relock;\n\n\t\t\t\tspin_lock_irq(&sighand->siglock);\n\t\t\t}\n\n\t\t\tif (likely(do_signal_stop(ksig->info.si_signo))) {\n\t\t\t\t/* It released the siglock.  */\n\t\t\t\tgoto relock;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We didn't actually stop, due to a race\n\t\t\t * with SIGCONT or something like that.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\tfatal:\n\t\tspin_unlock_irq(&sighand->siglock);\n\t\tif (unlikely(cgroup_task_frozen(current)))\n\t\t\tcgroup_leave_frozen(true);\n\n\t\t/*\n\t\t * Anything else is fatal, maybe with a core dump.\n\t\t */\n\t\tcurrent->flags |= PF_SIGNALED;\n\n\t\tif (sig_kernel_coredump(signr)) {\n\t\t\tif (print_fatal_signals)\n\t\t\t\tprint_fatal_signal(ksig->info.si_signo);\n\t\t\tproc_coredump_connector(current);\n\t\t\t/*\n\t\t\t * If it was able to dump core, this kills all\n\t\t\t * other threads in the group and synchronizes with\n\t\t\t * their demise.  If we lost the race with another\n\t\t\t * thread getting here, it set group_exit_code\n\t\t\t * first and our do_group_exit call below will use\n\t\t\t * that value and ignore the one we pass it.\n\t\t\t */\n\t\t\tdo_coredump(&ksig->info);\n\t\t}\n\n\t\t/*\n\t\t * PF_IO_WORKER threads will catch and exit on fatal signals\n\t\t * themselves. They have cleanup that must be performed, so\n\t\t * we cannot call do_exit() on their behalf.\n\t\t */\n\t\tif (current->flags & PF_IO_WORKER)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Death signals, no core dump.\n\t\t */\n\t\tdo_group_exit(ksig->info.si_signo);\n\t\t/* NOTREACHED */\n\t}\n\tspin_unlock_irq(&sighand->siglock);\nout:\n\tksig->sig = signr;\n\n\tif (!(ksig->ka.sa.sa_flags & SA_EXPOSE_TAGBITS))\n\t\thide_si_addr_tag_bits(ksig);\n\n\treturn ksig->sig > 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int print_fatal_signals"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hide_si_addr_tag_bits",
          "args": [
            "ksig"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "hide_si_addr_tag_bits",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2610-2630",
          "snippet": "static void hide_si_addr_tag_bits(struct ksignal *ksig)\n{\n\tswitch (siginfo_layout(ksig->sig, ksig->info.si_code)) {\n\tcase SIL_FAULT:\n\tcase SIL_FAULT_TRAPNO:\n\tcase SIL_FAULT_MCEERR:\n\tcase SIL_FAULT_BNDERR:\n\tcase SIL_FAULT_PKUERR:\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tksig->info.si_addr = arch_untagged_si_addr(\n\t\t\tksig->info.si_addr, ksig->sig, ksig->info.si_code);\n\t\tbreak;\n\tcase SIL_KILL:\n\tcase SIL_TIMER:\n\tcase SIL_POLL:\n\tcase SIL_CHLD:\n\tcase SIL_RT:\n\tcase SIL_SYS:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void hide_si_addr_tag_bits(struct ksignal *ksig)\n{\n\tswitch (siginfo_layout(ksig->sig, ksig->info.si_code)) {\n\tcase SIL_FAULT:\n\tcase SIL_FAULT_TRAPNO:\n\tcase SIL_FAULT_MCEERR:\n\tcase SIL_FAULT_BNDERR:\n\tcase SIL_FAULT_PKUERR:\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tksig->info.si_addr = arch_untagged_si_addr(\n\t\t\tksig->info.si_addr, ksig->sig, ksig->info.si_code);\n\t\tbreak;\n\tcase SIL_KILL:\n\tcase SIL_TIMER:\n\tcase SIL_POLL:\n\tcase SIL_CHLD:\n\tcase SIL_RT:\n\tcase SIL_SYS:\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&sighand->siglock"
          ],
          "line": 2866
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_group_exit",
          "args": [
            "ksig->info.si_signo"
          ],
          "line": 2863
        },
        "resolved": true,
        "details": {
          "function_name": "do_group_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "910-938",
          "snippet": "void\ndo_group_exit(int exit_code)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tif (sig->flags & SIGNAL_GROUP_EXIT)\n\t\texit_code = sig->group_exit_code;\n\telse if (sig->group_exec_task)\n\t\texit_code = 0;\n\telse if (!thread_group_empty(current)) {\n\t\tstruct sighand_struct *const sighand = current->sighand;\n\n\t\tspin_lock_irq(&sighand->siglock);\n\t\tif (sig->flags & SIGNAL_GROUP_EXIT)\n\t\t\t/* Another thread got here before we took the lock.  */\n\t\t\texit_code = sig->group_exit_code;\n\t\telse if (sig->group_exec_task)\n\t\t\texit_code = 0;\n\t\telse {\n\t\t\tsig->group_exit_code = exit_code;\n\t\t\tsig->flags = SIGNAL_GROUP_EXIT;\n\t\t\tzap_other_threads(current);\n\t\t}\n\t\tspin_unlock_irq(&sighand->siglock);\n\t}\n\n\tdo_exit(exit_code);\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid\ndo_group_exit(int exit_code)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tif (sig->flags & SIGNAL_GROUP_EXIT)\n\t\texit_code = sig->group_exit_code;\n\telse if (sig->group_exec_task)\n\t\texit_code = 0;\n\telse if (!thread_group_empty(current)) {\n\t\tstruct sighand_struct *const sighand = current->sighand;\n\n\t\tspin_lock_irq(&sighand->siglock);\n\t\tif (sig->flags & SIGNAL_GROUP_EXIT)\n\t\t\t/* Another thread got here before we took the lock.  */\n\t\t\texit_code = sig->group_exit_code;\n\t\telse if (sig->group_exec_task)\n\t\t\texit_code = 0;\n\t\telse {\n\t\t\tsig->group_exit_code = exit_code;\n\t\t\tsig->flags = SIGNAL_GROUP_EXIT;\n\t\t\tzap_other_threads(current);\n\t\t}\n\t\tspin_unlock_irq(&sighand->siglock);\n\t}\n\n\tdo_exit(exit_code);\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_coredump",
          "args": [
            "&ksig->info"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_coredump_connector",
          "args": [
            "current"
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_fatal_signal",
          "args": [
            "ksig->info.si_signo"
          ],
          "line": 2839
        },
        "resolved": true,
        "details": {
          "function_name": "setup_print_fatal_signals",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1275-1280",
          "snippet": "static int __init setup_print_fatal_signals(char *str)\n{\n\tget_option (&str, &print_fatal_signals);\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int print_fatal_signals"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint print_fatal_signals;\n\nstatic int __init setup_print_fatal_signals(char *str)\n{\n\tget_option (&str, &print_fatal_signals);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sig_kernel_coredump",
          "args": [
            "signr"
          ],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_leave_frozen",
          "args": [
            "true"
          ],
          "line": 2830
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_leave_frozen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "131-149",
          "snippet": "void cgroup_leave_frozen(bool always_leave)\n{\n\tstruct cgroup *cgrp;\n\n\tspin_lock_irq(&css_set_lock);\n\tcgrp = task_dfl_cgroup(current);\n\tif (always_leave || !test_bit(CGRP_FREEZE, &cgrp->flags)) {\n\t\tcgroup_dec_frozen_cnt(cgrp);\n\t\tcgroup_update_frozen(cgrp);\n\t\tWARN_ON_ONCE(!current->frozen);\n\t\tcurrent->frozen = false;\n\t} else if (!(current->jobctl & JOBCTL_TRAP_FREEZE)) {\n\t\tspin_lock(&current->sighand->siglock);\n\t\tcurrent->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tset_thread_flag(TIF_SIGPENDING);\n\t\tspin_unlock(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_leave_frozen(bool always_leave)\n{\n\tstruct cgroup *cgrp;\n\n\tspin_lock_irq(&css_set_lock);\n\tcgrp = task_dfl_cgroup(current);\n\tif (always_leave || !test_bit(CGRP_FREEZE, &cgrp->flags)) {\n\t\tcgroup_dec_frozen_cnt(cgrp);\n\t\tcgroup_update_frozen(cgrp);\n\t\tWARN_ON_ONCE(!current->frozen);\n\t\tcurrent->frozen = false;\n\t} else if (!(current->jobctl & JOBCTL_TRAP_FREEZE)) {\n\t\tspin_lock(&current->sighand->siglock);\n\t\tcurrent->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tset_thread_flag(TIF_SIGPENDING);\n\t\tspin_unlock(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cgroup_task_frozen(current)"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_task_frozen",
          "args": [
            "current"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "do_signal_stop(ksig->info.si_signo)"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_signal_stop",
          "args": [
            "ksig->info.si_signo"
          ],
          "line": 2815
        },
        "resolved": true,
        "details": {
          "function_name": "do_signal_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2390-2492",
          "snippet": "static bool do_signal_stop(int signr)\n\t__releases(&current->sighand->siglock)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tif (!(current->jobctl & JOBCTL_STOP_PENDING)) {\n\t\tunsigned long gstop = JOBCTL_STOP_PENDING | JOBCTL_STOP_CONSUME;\n\t\tstruct task_struct *t;\n\n\t\t/* signr will be recorded in task->jobctl for retries */\n\t\tWARN_ON_ONCE(signr & ~JOBCTL_STOP_SIGMASK);\n\n\t\tif (!likely(current->jobctl & JOBCTL_STOP_DEQUEUED) ||\n\t\t    unlikely(sig->flags & SIGNAL_GROUP_EXIT) ||\n\t\t    unlikely(sig->group_exec_task))\n\t\t\treturn false;\n\t\t/*\n\t\t * There is no group stop already in progress.  We must\n\t\t * initiate one now.\n\t\t *\n\t\t * While ptraced, a task may be resumed while group stop is\n\t\t * still in effect and then receive a stop signal and\n\t\t * initiate another group stop.  This deviates from the\n\t\t * usual behavior as two consecutive stop signals can't\n\t\t * cause two group stops when !ptraced.  That is why we\n\t\t * also check !task_is_stopped(t) below.\n\t\t *\n\t\t * The condition can be distinguished by testing whether\n\t\t * SIGNAL_STOP_STOPPED is already set.  Don't generate\n\t\t * group_exit_code in such case.\n\t\t *\n\t\t * This is not necessary for SIGNAL_STOP_CONTINUED because\n\t\t * an intervening stop signal is required to cause two\n\t\t * continued events regardless of ptrace.\n\t\t */\n\t\tif (!(sig->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsig->group_exit_code = signr;\n\n\t\tsig->group_stop_count = 0;\n\n\t\tif (task_set_jobctl_pending(current, signr | gstop))\n\t\t\tsig->group_stop_count++;\n\n\t\tt = current;\n\t\twhile_each_thread(current, t) {\n\t\t\t/*\n\t\t\t * Setting state to TASK_STOPPED for a group\n\t\t\t * stop is always done with the siglock held,\n\t\t\t * so this check has no races.\n\t\t\t */\n\t\t\tif (!task_is_stopped(t) &&\n\t\t\t    task_set_jobctl_pending(t, signr | gstop)) {\n\t\t\t\tsig->group_stop_count++;\n\t\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\t\tsignal_wake_up(t, 0);\n\t\t\t\telse\n\t\t\t\t\tptrace_trap_notify(t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (likely(!current->ptrace)) {\n\t\tint notify = 0;\n\n\t\t/*\n\t\t * If there are no other threads in the group, or if there\n\t\t * is a group stop in progress and we are the last to stop,\n\t\t * report to the parent.\n\t\t */\n\t\tif (task_participate_group_stop(current))\n\t\t\tnotify = CLD_STOPPED;\n\n\t\tset_special_state(TASK_STOPPED);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\t\t/*\n\t\t * Notify the parent of the group stop completion.  Because\n\t\t * we're not holding either the siglock or tasklist_lock\n\t\t * here, ptracer may attach inbetween; however, this is for\n\t\t * group stop and should always be delivered to the real\n\t\t * parent of the group leader.  The new ptracer will get\n\t\t * its notification when this task transitions into\n\t\t * TASK_TRACED.\n\t\t */\n\t\tif (notify) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tdo_notify_parent_cldstop(current, false, notify);\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\n\t\t/* Now we don't run again until woken by SIGCONT or SIGKILL */\n\t\tcgroup_enter_frozen();\n\t\tfreezable_schedule();\n\t\treturn true;\n\t} else {\n\t\t/*\n\t\t * While ptraced, group stop is handled by STOP trap.\n\t\t * Schedule it and let the caller deal with it.\n\t\t */\n\t\ttask_set_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool do_signal_stop(int signr)\n\t__releases(&current->sighand->siglock)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tif (!(current->jobctl & JOBCTL_STOP_PENDING)) {\n\t\tunsigned long gstop = JOBCTL_STOP_PENDING | JOBCTL_STOP_CONSUME;\n\t\tstruct task_struct *t;\n\n\t\t/* signr will be recorded in task->jobctl for retries */\n\t\tWARN_ON_ONCE(signr & ~JOBCTL_STOP_SIGMASK);\n\n\t\tif (!likely(current->jobctl & JOBCTL_STOP_DEQUEUED) ||\n\t\t    unlikely(sig->flags & SIGNAL_GROUP_EXIT) ||\n\t\t    unlikely(sig->group_exec_task))\n\t\t\treturn false;\n\t\t/*\n\t\t * There is no group stop already in progress.  We must\n\t\t * initiate one now.\n\t\t *\n\t\t * While ptraced, a task may be resumed while group stop is\n\t\t * still in effect and then receive a stop signal and\n\t\t * initiate another group stop.  This deviates from the\n\t\t * usual behavior as two consecutive stop signals can't\n\t\t * cause two group stops when !ptraced.  That is why we\n\t\t * also check !task_is_stopped(t) below.\n\t\t *\n\t\t * The condition can be distinguished by testing whether\n\t\t * SIGNAL_STOP_STOPPED is already set.  Don't generate\n\t\t * group_exit_code in such case.\n\t\t *\n\t\t * This is not necessary for SIGNAL_STOP_CONTINUED because\n\t\t * an intervening stop signal is required to cause two\n\t\t * continued events regardless of ptrace.\n\t\t */\n\t\tif (!(sig->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsig->group_exit_code = signr;\n\n\t\tsig->group_stop_count = 0;\n\n\t\tif (task_set_jobctl_pending(current, signr | gstop))\n\t\t\tsig->group_stop_count++;\n\n\t\tt = current;\n\t\twhile_each_thread(current, t) {\n\t\t\t/*\n\t\t\t * Setting state to TASK_STOPPED for a group\n\t\t\t * stop is always done with the siglock held,\n\t\t\t * so this check has no races.\n\t\t\t */\n\t\t\tif (!task_is_stopped(t) &&\n\t\t\t    task_set_jobctl_pending(t, signr | gstop)) {\n\t\t\t\tsig->group_stop_count++;\n\t\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\t\tsignal_wake_up(t, 0);\n\t\t\t\telse\n\t\t\t\t\tptrace_trap_notify(t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (likely(!current->ptrace)) {\n\t\tint notify = 0;\n\n\t\t/*\n\t\t * If there are no other threads in the group, or if there\n\t\t * is a group stop in progress and we are the last to stop,\n\t\t * report to the parent.\n\t\t */\n\t\tif (task_participate_group_stop(current))\n\t\t\tnotify = CLD_STOPPED;\n\n\t\tset_special_state(TASK_STOPPED);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\t\t/*\n\t\t * Notify the parent of the group stop completion.  Because\n\t\t * we're not holding either the siglock or tasklist_lock\n\t\t * here, ptracer may attach inbetween; however, this is for\n\t\t * group stop and should always be delivered to the real\n\t\t * parent of the group leader.  The new ptracer will get\n\t\t * its notification when this task transitions into\n\t\t * TASK_TRACED.\n\t\t */\n\t\tif (notify) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tdo_notify_parent_cldstop(current, false, notify);\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\n\t\t/* Now we don't run again until woken by SIGCONT or SIGKILL */\n\t\tcgroup_enter_frozen();\n\t\tfreezable_schedule();\n\t\treturn true;\n\t} else {\n\t\t/*\n\t\t * While ptraced, group stop is handled by STOP trap.\n\t\t * Schedule it and let the caller deal with it.\n\t\t */\n\t\ttask_set_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&sighand->siglock"
          ],
          "line": 2812
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_current_pgrp_orphaned",
          "args": [],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "is_current_pgrp_orphaned",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "290-299",
          "snippet": "int is_current_pgrp_orphaned(void)\n{\n\tint retval;\n\n\tread_lock(&tasklist_lock);\n\tretval = will_become_orphaned_pgrp(task_pgrp(current), NULL);\n\tread_unlock(&tasklist_lock);\n\n\treturn retval;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint is_current_pgrp_orphaned(void)\n{\n\tint retval;\n\n\tread_lock(&tasklist_lock);\n\tretval = will_become_orphaned_pgrp(task_pgrp(current), NULL);\n\tread_unlock(&tasklist_lock);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sig_kernel_stop",
          "args": [
            "signr"
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_kernel_only",
          "args": [
            "signr"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "signal->flags & SIGNAL_UNKILLABLE"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_kernel_ignore",
          "args": [
            "signr"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_signal_deliver",
          "args": [
            "signr",
            "&ksig->info",
            "ka"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_signal",
          "args": [
            "signr",
            "&ksig->info",
            "type"
          ],
          "line": 2751
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2564-2608",
          "snippet": "static int ptrace_signal(int signr, kernel_siginfo_t *info, enum pid_type type)\n{\n\t/*\n\t * We do not check sig_kernel_stop(signr) but set this marker\n\t * unconditionally because we do not know whether debugger will\n\t * change signr. This flag has no meaning unless we are going\n\t * to stop after return from ptrace_stop(). In this case it will\n\t * be checked in do_signal_stop(), we should only stop if it was\n\t * not cleared by SIGCONT while we were sleeping. See also the\n\t * comment in dequeue_signal().\n\t */\n\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\tsignr = ptrace_stop(signr, CLD_TRAPPED, 0, 0, info);\n\n\t/* We're back.  Did the debugger cancel the sig?  */\n\tif (signr == 0)\n\t\treturn signr;\n\n\t/*\n\t * Update the siginfo structure if the signal has\n\t * changed.  If the debugger wanted something\n\t * specific in the siginfo structure then it should\n\t * have updated *info via PTRACE_SETSIGINFO.\n\t */\n\tif (signr != info->si_signo) {\n\t\tclear_siginfo(info);\n\t\tinfo->si_signo = signr;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\trcu_read_lock();\n\t\tinfo->si_pid = task_pid_vnr(current->parent);\n\t\tinfo->si_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t\ttask_uid(current->parent));\n\t\trcu_read_unlock();\n\t}\n\n\t/* If the (new) signal is now blocked, requeue it.  */\n\tif (sigismember(&current->blocked, signr) ||\n\t    fatal_signal_pending(current)) {\n\t\tsend_signal(signr, info, current, type);\n\t\tsignr = 0;\n\t}\n\n\treturn signr;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int ptrace_signal(int signr, kernel_siginfo_t *info, enum pid_type type)\n{\n\t/*\n\t * We do not check sig_kernel_stop(signr) but set this marker\n\t * unconditionally because we do not know whether debugger will\n\t * change signr. This flag has no meaning unless we are going\n\t * to stop after return from ptrace_stop(). In this case it will\n\t * be checked in do_signal_stop(), we should only stop if it was\n\t * not cleared by SIGCONT while we were sleeping. See also the\n\t * comment in dequeue_signal().\n\t */\n\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\tsignr = ptrace_stop(signr, CLD_TRAPPED, 0, 0, info);\n\n\t/* We're back.  Did the debugger cancel the sig?  */\n\tif (signr == 0)\n\t\treturn signr;\n\n\t/*\n\t * Update the siginfo structure if the signal has\n\t * changed.  If the debugger wanted something\n\t * specific in the siginfo structure then it should\n\t * have updated *info via PTRACE_SETSIGINFO.\n\t */\n\tif (signr != info->si_signo) {\n\t\tclear_siginfo(info);\n\t\tinfo->si_signo = signr;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\trcu_read_lock();\n\t\tinfo->si_pid = task_pid_vnr(current->parent);\n\t\tinfo->si_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t\ttask_uid(current->parent));\n\t\trcu_read_unlock();\n\t}\n\n\t/* If the (new) signal is now blocked, requeue it.  */\n\tif (sigismember(&current->blocked, signr) ||\n\t    fatal_signal_pending(current)) {\n\t\tsend_signal(signr, info, current, type);\n\t\tsignr = 0;\n\t}\n\n\treturn signr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->ptrace"
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dequeue_signal",
          "args": [
            "current",
            "&current->blocked",
            "&ksig->info",
            "&type"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "629-707",
          "snippet": "int dequeue_signal(struct task_struct *tsk, sigset_t *mask,\n\t\t   kernel_siginfo_t *info, enum pid_type *type)\n{\n\tbool resched_timer = false;\n\tint signr;\n\n\t/* We only dequeue private signals from ourselves, we don't let\n\t * signalfd steal them\n\t */\n\t*type = PIDTYPE_PID;\n\tsignr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);\n\tif (!signr) {\n\t\t*type = PIDTYPE_TGID;\n\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,\n\t\t\t\t\t mask, info, &resched_timer);\n#ifdef CONFIG_POSIX_TIMERS\n\t\t/*\n\t\t * itimer signal ?\n\t\t *\n\t\t * itimers are process shared and we restart periodic\n\t\t * itimers in the signal delivery path to prevent DoS\n\t\t * attacks in the high resolution timer case. This is\n\t\t * compliant with the old way of self-restarting\n\t\t * itimers, as the SIGALRM is a legacy signal and only\n\t\t * queued once. Changing the restart behaviour to\n\t\t * restart the timer in the signal dequeue path is\n\t\t * reducing the timer noise on heavy loaded !highres\n\t\t * systems too.\n\t\t */\n\t\tif (unlikely(signr == SIGALRM)) {\n\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;\n\n\t\t\tif (!hrtimer_is_queued(tmr) &&\n\t\t\t    tsk->signal->it_real_incr != 0) {\n\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),\n\t\t\t\t\t\ttsk->signal->it_real_incr);\n\t\t\t\thrtimer_restart(tmr);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\trecalc_sigpending();\n\tif (!signr)\n\t\treturn 0;\n\n\tif (unlikely(sig_kernel_stop(signr))) {\n\t\t/*\n\t\t * Set a marker that we have dequeued a stop signal.  Our\n\t\t * caller might release the siglock and then the pending\n\t\t * stop signal it is about to process is no longer in the\n\t\t * pending bitmasks, but must still be cleared by a SIGCONT\n\t\t * (and overruled by a SIGKILL).  So those cases clear this\n\t\t * shared flag after we've set it.  Note that this flag may\n\t\t * remain set after the signal we return is ignored or\n\t\t * handled.  That doesn't matter because its only purpose\n\t\t * is to alert stop-signal processing code when another\n\t\t * processor has come along and cleared the flag.\n\t\t */\n\t\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\t}\n#ifdef CONFIG_POSIX_TIMERS\n\tif (resched_timer) {\n\t\t/*\n\t\t * Release the siglock to ensure proper locking order\n\t\t * of timer locks outside of siglocks.  Note, we leave\n\t\t * irqs disabled here, since the posix-timers code is\n\t\t * about to disable them again anyway.\n\t\t */\n\t\tspin_unlock(&tsk->sighand->siglock);\n\t\tposixtimer_rearm(info);\n\t\tspin_lock(&tsk->sighand->siglock);\n\n\t\t/* Don't expose the si_sys_private value to userspace */\n\t\tinfo->si_sys_private = 0;\n\t}\n#endif\n\treturn signr;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint dequeue_signal(struct task_struct *tsk, sigset_t *mask,\n\t\t   kernel_siginfo_t *info, enum pid_type *type)\n{\n\tbool resched_timer = false;\n\tint signr;\n\n\t/* We only dequeue private signals from ourselves, we don't let\n\t * signalfd steal them\n\t */\n\t*type = PIDTYPE_PID;\n\tsignr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);\n\tif (!signr) {\n\t\t*type = PIDTYPE_TGID;\n\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,\n\t\t\t\t\t mask, info, &resched_timer);\n#ifdef CONFIG_POSIX_TIMERS\n\t\t/*\n\t\t * itimer signal ?\n\t\t *\n\t\t * itimers are process shared and we restart periodic\n\t\t * itimers in the signal delivery path to prevent DoS\n\t\t * attacks in the high resolution timer case. This is\n\t\t * compliant with the old way of self-restarting\n\t\t * itimers, as the SIGALRM is a legacy signal and only\n\t\t * queued once. Changing the restart behaviour to\n\t\t * restart the timer in the signal dequeue path is\n\t\t * reducing the timer noise on heavy loaded !highres\n\t\t * systems too.\n\t\t */\n\t\tif (unlikely(signr == SIGALRM)) {\n\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;\n\n\t\t\tif (!hrtimer_is_queued(tmr) &&\n\t\t\t    tsk->signal->it_real_incr != 0) {\n\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),\n\t\t\t\t\t\ttsk->signal->it_real_incr);\n\t\t\t\thrtimer_restart(tmr);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\trecalc_sigpending();\n\tif (!signr)\n\t\treturn 0;\n\n\tif (unlikely(sig_kernel_stop(signr))) {\n\t\t/*\n\t\t * Set a marker that we have dequeued a stop signal.  Our\n\t\t * caller might release the siglock and then the pending\n\t\t * stop signal it is about to process is no longer in the\n\t\t * pending bitmasks, but must still be cleared by a SIGCONT\n\t\t * (and overruled by a SIGKILL).  So those cases clear this\n\t\t * shared flag after we've set it.  Note that this flag may\n\t\t * remain set after the signal we return is ignored or\n\t\t * handled.  That doesn't matter because its only purpose\n\t\t * is to alert stop-signal processing code when another\n\t\t * processor has come along and cleared the flag.\n\t\t */\n\t\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\t}\n#ifdef CONFIG_POSIX_TIMERS\n\tif (resched_timer) {\n\t\t/*\n\t\t * Release the siglock to ensure proper locking order\n\t\t * of timer locks outside of siglocks.  Note, we leave\n\t\t * irqs disabled here, since the posix-timers code is\n\t\t * about to disable them again anyway.\n\t\t */\n\t\tspin_unlock(&tsk->sighand->siglock);\n\t\tposixtimer_rearm(info);\n\t\tspin_lock(&tsk->sighand->siglock);\n\n\t\t/* Don't expose the si_sys_private value to userspace */\n\t\tinfo->si_sys_private = 0;\n\t}\n#endif\n\treturn signr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_synchronous_signal",
          "args": [
            "&ksig->info"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_synchronous_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "710-750",
          "snippet": "static int dequeue_synchronous_signal(kernel_siginfo_t *info)\n{\n\tstruct task_struct *tsk = current;\n\tstruct sigpending *pending = &tsk->pending;\n\tstruct sigqueue *q, *sync = NULL;\n\n\t/*\n\t * Might a synchronous signal be in the queue?\n\t */\n\tif (!((pending->signal.sig[0] & ~tsk->blocked.sig[0]) & SYNCHRONOUS_MASK))\n\t\treturn 0;\n\n\t/*\n\t * Return the first synchronous signal in the queue.\n\t */\n\tlist_for_each_entry(q, &pending->list, list) {\n\t\t/* Synchronous signals have a positive si_code */\n\t\tif ((q->info.si_code > SI_USER) &&\n\t\t    (sigmask(q->info.si_signo) & SYNCHRONOUS_MASK)) {\n\t\t\tsync = q;\n\t\t\tgoto next;\n\t\t}\n\t}\n\treturn 0;\nnext:\n\t/*\n\t * Check if there is another siginfo for the same signal.\n\t */\n\tlist_for_each_entry_continue(q, &pending->list, list) {\n\t\tif (q->info.si_signo == sync->info.si_signo)\n\t\t\tgoto still_pending;\n\t}\n\n\tsigdelset(&pending->signal, sync->info.si_signo);\n\trecalc_sigpending();\nstill_pending:\n\tlist_del_init(&sync->list);\n\tcopy_siginfo(info, &sync->info);\n\t__sigqueue_free(sync);\n\treturn info->si_signo;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define SYNCHRONOUS_MASK \\\n\t(sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \\\n\t sigmask(SIGTRAP) | sigmask(SIGFPE) | sigmask(SIGSYS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\n#define SYNCHRONOUS_MASK \\\n\t(sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \\\n\t sigmask(SIGTRAP) | sigmask(SIGFPE) | sigmask(SIGSYS))\n\nstatic int dequeue_synchronous_signal(kernel_siginfo_t *info)\n{\n\tstruct task_struct *tsk = current;\n\tstruct sigpending *pending = &tsk->pending;\n\tstruct sigqueue *q, *sync = NULL;\n\n\t/*\n\t * Might a synchronous signal be in the queue?\n\t */\n\tif (!((pending->signal.sig[0] & ~tsk->blocked.sig[0]) & SYNCHRONOUS_MASK))\n\t\treturn 0;\n\n\t/*\n\t * Return the first synchronous signal in the queue.\n\t */\n\tlist_for_each_entry(q, &pending->list, list) {\n\t\t/* Synchronous signals have a positive si_code */\n\t\tif ((q->info.si_code > SI_USER) &&\n\t\t    (sigmask(q->info.si_signo) & SYNCHRONOUS_MASK)) {\n\t\t\tsync = q;\n\t\t\tgoto next;\n\t\t}\n\t}\n\treturn 0;\nnext:\n\t/*\n\t * Check if there is another siginfo for the same signal.\n\t */\n\tlist_for_each_entry_continue(q, &pending->list, list) {\n\t\tif (q->info.si_signo == sync->info.si_signo)\n\t\t\tgoto still_pending;\n\t}\n\n\tsigdelset(&pending->signal, sync->info.si_signo);\n\trecalc_sigpending();\nstill_pending:\n\tlist_del_init(&sync->list);\n\tcopy_siginfo(info, &sync->info);\n\t__sigqueue_free(sync);\n\treturn info->si_signo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cgroup_task_frozen(current)"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_task_frozen",
          "args": [
            "current"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_freezer_trap",
          "args": [],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "do_freezer_trap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2537-2562",
          "snippet": "static void do_freezer_trap(void)\n\t__releases(&current->sighand->siglock)\n{\n\t/*\n\t * If there are other trap bits pending except JOBCTL_TRAP_FREEZE,\n\t * let's make another loop to give it a chance to be handled.\n\t * In any case, we'll return back.\n\t */\n\tif ((current->jobctl & (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) !=\n\t     JOBCTL_TRAP_FREEZE) {\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\treturn;\n\t}\n\n\t/*\n\t * Now we're sure that there is no pending fatal signal and no\n\t * pending traps. Clear TIF_SIGPENDING to not get out of schedule()\n\t * immediately (if there is a non-fatal signal pending), and\n\t * put the task into sleep.\n\t */\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\tclear_thread_flag(TIF_SIGPENDING);\n\tspin_unlock_irq(&current->sighand->siglock);\n\tcgroup_enter_frozen();\n\tfreezable_schedule();\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void do_freezer_trap(void)\n\t__releases(&current->sighand->siglock)\n{\n\t/*\n\t * If there are other trap bits pending except JOBCTL_TRAP_FREEZE,\n\t * let's make another loop to give it a chance to be handled.\n\t * In any case, we'll return back.\n\t */\n\tif ((current->jobctl & (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) !=\n\t     JOBCTL_TRAP_FREEZE) {\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\treturn;\n\t}\n\n\t/*\n\t * Now we're sure that there is no pending fatal signal and no\n\t * pending traps. Clear TIF_SIGPENDING to not get out of schedule()\n\t * immediately (if there is a non-fatal signal pending), and\n\t * put the task into sleep.\n\t */\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\tclear_thread_flag(TIF_SIGPENDING);\n\tspin_unlock_irq(&current->sighand->siglock);\n\tcgroup_enter_frozen();\n\tfreezable_schedule();\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_jobctl_trap",
          "args": [],
          "line": 2716
        },
        "resolved": true,
        "details": {
          "function_name": "do_jobctl_trap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2509-2525",
          "snippet": "static void do_jobctl_trap(void)\n{\n\tstruct signal_struct *signal = current->signal;\n\tint signr = current->jobctl & JOBCTL_STOP_SIGMASK;\n\n\tif (current->ptrace & PT_SEIZED) {\n\t\tif (!signal->group_stop_count &&\n\t\t    !(signal->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsignr = SIGTRAP;\n\t\tWARN_ON_ONCE(!signr);\n\t\tptrace_do_notify(signr, signr | (PTRACE_EVENT_STOP << 8),\n\t\t\t\t CLD_STOPPED, 0);\n\t} else {\n\t\tWARN_ON_ONCE(!signr);\n\t\tptrace_stop(signr, CLD_STOPPED, 0, 0, NULL);\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void do_jobctl_trap(void)\n{\n\tstruct signal_struct *signal = current->signal;\n\tint signr = current->jobctl & JOBCTL_STOP_SIGMASK;\n\n\tif (current->ptrace & PT_SEIZED) {\n\t\tif (!signal->group_stop_count &&\n\t\t    !(signal->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsignr = SIGTRAP;\n\t\tWARN_ON_ONCE(!signr);\n\t\tptrace_do_notify(signr, signr | (PTRACE_EVENT_STOP << 8),\n\t\t\t\t CLD_STOPPED, 0);\n\t} else {\n\t\tWARN_ON_ONCE(!signr);\n\t\tptrace_stop(signr, CLD_STOPPED, 0, 0, NULL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->jobctl &\n\t\t\t     (JOBCTL_TRAP_MASK | JOBCTL_TRAP_FREEZE)"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->jobctl & JOBCTL_STOP_PENDING"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 2705
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "182-187",
          "snippet": "void recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_signal_deliver",
          "args": [
            "SIGKILL",
            "SEND_SIG_NOINFO",
            "&sighand->action[SIGKILL - 1]"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&current->pending.signal",
            "SIGKILL"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 2689
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_notify_parent_cldstop",
          "args": [
            "current->group_leader",
            "true",
            "why"
          ],
          "line": 2687
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent_cldstop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2125-2181",
          "snippet": "static void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_reparented",
          "args": [
            "current->group_leader"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "signal->flags & SIGNAL_CLD_MASK"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "uprobe_deny_signal()"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_deny_signal",
          "args": [],
          "line": 2645
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_deny_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/uprobes.c",
          "lines": "1966-1988",
          "snippet": "bool uprobe_deny_signal(void)\n{\n\tstruct task_struct *t = current;\n\tstruct uprobe_task *utask = t->utask;\n\n\tif (likely(!utask || !utask->active_uprobe))\n\t\treturn false;\n\n\tWARN_ON_ONCE(utask->state != UTASK_SSTEP);\n\n\tif (task_sigpending(t)) {\n\t\tspin_lock_irq(&t->sighand->siglock);\n\t\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\tspin_unlock_irq(&t->sighand->siglock);\n\n\t\tif (__fatal_signal_pending(t) || arch_uprobe_xol_was_trapped(t)) {\n\t\t\tutask->state = UTASK_SSTEP_TRAPPED;\n\t\t\tset_tsk_thread_flag(t, TIF_UPROBE);\n\t\t}\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/khugepaged.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool uprobe_deny_signal(void)\n{\n\tstruct task_struct *t = current;\n\tstruct uprobe_task *utask = t->utask;\n\n\tif (likely(!utask || !utask->active_uprobe))\n\t\treturn false;\n\n\tWARN_ON_ONCE(utask->state != UTASK_SSTEP);\n\n\tif (task_sigpending(t)) {\n\t\tspin_lock_irq(&t->sighand->siglock);\n\t\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\tspin_unlock_irq(&t->sighand->siglock);\n\n\t\tif (__fatal_signal_pending(t) || arch_uprobe_xol_was_trapped(t)) {\n\t\t\tutask->state = UTASK_SSTEP_TRAPPED;\n\t\t\tset_tsk_thread_flag(t, TIF_UPROBE);\n\t\t}\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_sigpending",
          "args": [
            "current"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_work_run",
          "args": [],
          "line": 2640
        },
        "resolved": true,
        "details": {
          "function_name": "task_work_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/task_work.c",
          "lines": "131-169",
          "snippet": "void task_work_run(void)\n{\n\tstruct task_struct *task = current;\n\tstruct callback_head *work, *head, *next;\n\n\tfor (;;) {\n\t\t/*\n\t\t * work->func() can do task_work_add(), do not set\n\t\t * work_exited unless the list is empty.\n\t\t */\n\t\tdo {\n\t\t\thead = NULL;\n\t\t\twork = READ_ONCE(task->task_works);\n\t\t\tif (!work) {\n\t\t\t\tif (task->flags & PF_EXITING)\n\t\t\t\t\thead = &work_exited;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (cmpxchg(&task->task_works, work, head) != work);\n\n\t\tif (!work)\n\t\t\tbreak;\n\t\t/*\n\t\t * Synchronize with task_work_cancel(). It can not remove\n\t\t * the first entry == work, cmpxchg(task_works) must fail.\n\t\t * But it can remove another entry from the ->next list.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tdo {\n\t\t\tnext = work->next;\n\t\t\twork->func(work);\n\t\t\twork = next;\n\t\t\tcond_resched();\n\t\t} while (work);\n\t}\n}",
          "includes": [
            "#include <linux/resume_user_mode.h>",
            "#include <linux/task_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct callback_head work_exited;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/resume_user_mode.h>\n#include <linux/task_work.h>\n#include <linux/spinlock.h>\n\nstatic struct callback_head work_exited;\n\nvoid task_work_run(void)\n{\n\tstruct task_struct *task = current;\n\tstruct callback_head *work, *head, *next;\n\n\tfor (;;) {\n\t\t/*\n\t\t * work->func() can do task_work_add(), do not set\n\t\t * work_exited unless the list is empty.\n\t\t */\n\t\tdo {\n\t\t\thead = NULL;\n\t\t\twork = READ_ONCE(task->task_works);\n\t\t\tif (!work) {\n\t\t\t\tif (task->flags & PF_EXITING)\n\t\t\t\t\thead = &work_exited;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (cmpxchg(&task->task_works, work, head) != work);\n\n\t\tif (!work)\n\t\t\tbreak;\n\t\t/*\n\t\t * Synchronize with task_work_cancel(). It can not remove\n\t\t * the first entry == work, cmpxchg(task_works) must fail.\n\t\t * But it can remove another entry from the ->next list.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tdo {\n\t\t\tnext = work->next;\n\t\t\twork->func(work);\n\t\t\twork = next;\n\t\t\tcond_resched();\n\t\t} while (work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "task_work_pending(current)"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_work_pending",
          "args": [
            "current"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_notify_signal",
          "args": [],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint print_fatal_signals;\n\nbool get_signal(struct ksignal *ksig)\n{\n\tstruct sighand_struct *sighand = current->sighand;\n\tstruct signal_struct *signal = current->signal;\n\tint signr;\n\n\tclear_notify_signal();\n\tif (unlikely(task_work_pending(current)))\n\t\ttask_work_run();\n\n\tif (!task_sigpending(current))\n\t\treturn false;\n\n\tif (unlikely(uprobe_deny_signal()))\n\t\treturn false;\n\n\t/*\n\t * Do this once, we can't return to user-mode if freezing() == T.\n\t * do_signal_stop() and ptrace_stop() do freezable_schedule() and\n\t * thus do not need another check after return.\n\t */\n\ttry_to_freeze();\n\nrelock:\n\tspin_lock_irq(&sighand->siglock);\n\n\t/*\n\t * Every stopped thread goes here after wakeup. Check to see if\n\t * we should notify the parent, prepare_signal(SIGCONT) encodes\n\t * the CLD_ si_code into SIGNAL_CLD_MASK bits.\n\t */\n\tif (unlikely(signal->flags & SIGNAL_CLD_MASK)) {\n\t\tint why;\n\n\t\tif (signal->flags & SIGNAL_CLD_CONTINUED)\n\t\t\twhy = CLD_CONTINUED;\n\t\telse\n\t\t\twhy = CLD_STOPPED;\n\n\t\tsignal->flags &= ~SIGNAL_CLD_MASK;\n\n\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\t/*\n\t\t * Notify the parent that we're continuing.  This event is\n\t\t * always per-process and doesn't make whole lot of sense\n\t\t * for ptracers, who shouldn't consume the state via\n\t\t * wait(2) either, but, for backward compatibility, notify\n\t\t * the ptracer of the group leader too unless it's gonna be\n\t\t * a duplicate.\n\t\t */\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\tif (ptrace_reparented(current->group_leader))\n\t\t\tdo_notify_parent_cldstop(current->group_leader,\n\t\t\t\t\t\ttrue, why);\n\t\tread_unlock(&tasklist_lock);\n\n\t\tgoto relock;\n\t}\n\n\tfor (;;) {\n\t\tstruct k_sigaction *ka;\n\t\tenum pid_type type;\n\n\t\t/* Has this task already been marked for death? */\n\t\tif ((signal->flags & SIGNAL_GROUP_EXIT) ||\n\t\t     signal->group_exec_task) {\n\t\t\tksig->info.si_signo = signr = SIGKILL;\n\t\t\tsigdelset(&current->pending.signal, SIGKILL);\n\t\t\ttrace_signal_deliver(SIGKILL, SEND_SIG_NOINFO,\n\t\t\t\t&sighand->action[SIGKILL - 1]);\n\t\t\trecalc_sigpending();\n\t\t\tgoto fatal;\n\t\t}\n\n\t\tif (unlikely(current->jobctl & JOBCTL_STOP_PENDING) &&\n\t\t    do_signal_stop(0))\n\t\t\tgoto relock;\n\n\t\tif (unlikely(current->jobctl &\n\t\t\t     (JOBCTL_TRAP_MASK | JOBCTL_TRAP_FREEZE))) {\n\t\t\tif (current->jobctl & JOBCTL_TRAP_MASK) {\n\t\t\t\tdo_jobctl_trap();\n\t\t\t\tspin_unlock_irq(&sighand->siglock);\n\t\t\t} else if (current->jobctl & JOBCTL_TRAP_FREEZE)\n\t\t\t\tdo_freezer_trap();\n\n\t\t\tgoto relock;\n\t\t}\n\n\t\t/*\n\t\t * If the task is leaving the frozen state, let's update\n\t\t * cgroup counters and reset the frozen bit.\n\t\t */\n\t\tif (unlikely(cgroup_task_frozen(current))) {\n\t\t\tspin_unlock_irq(&sighand->siglock);\n\t\t\tcgroup_leave_frozen(false);\n\t\t\tgoto relock;\n\t\t}\n\n\t\t/*\n\t\t * Signals generated by the execution of an instruction\n\t\t * need to be delivered before any other pending signals\n\t\t * so that the instruction pointer in the signal stack\n\t\t * frame points to the faulting instruction.\n\t\t */\n\t\ttype = PIDTYPE_PID;\n\t\tsignr = dequeue_synchronous_signal(&ksig->info);\n\t\tif (!signr)\n\t\t\tsignr = dequeue_signal(current, &current->blocked,\n\t\t\t\t\t       &ksig->info, &type);\n\n\t\tif (!signr)\n\t\t\tbreak; /* will return 0 */\n\n\t\tif (unlikely(current->ptrace) && (signr != SIGKILL) &&\n\t\t    !(sighand->action[signr -1].sa.sa_flags & SA_IMMUTABLE)) {\n\t\t\tsignr = ptrace_signal(signr, &ksig->info, type);\n\t\t\tif (!signr)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tka = &sighand->action[signr-1];\n\n\t\t/* Trace actually delivered signals. */\n\t\ttrace_signal_deliver(signr, &ksig->info, ka);\n\n\t\tif (ka->sa.sa_handler == SIG_IGN) /* Do nothing.  */\n\t\t\tcontinue;\n\t\tif (ka->sa.sa_handler != SIG_DFL) {\n\t\t\t/* Run the handler.  */\n\t\t\tksig->ka = *ka;\n\n\t\t\tif (ka->sa.sa_flags & SA_ONESHOT)\n\t\t\t\tka->sa.sa_handler = SIG_DFL;\n\n\t\t\tbreak; /* will return non-zero \"signr\" value */\n\t\t}\n\n\t\t/*\n\t\t * Now we are doing the default action for this signal.\n\t\t */\n\t\tif (sig_kernel_ignore(signr)) /* Default is nothing. */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Global init gets no signals it doesn't want.\n\t\t * Container-init gets no signals it doesn't want from same\n\t\t * container.\n\t\t *\n\t\t * Note that if global/container-init sees a sig_kernel_only()\n\t\t * signal here, the signal must have been generated internally\n\t\t * or must have come from an ancestor namespace. In either\n\t\t * case, the signal cannot be dropped.\n\t\t */\n\t\tif (unlikely(signal->flags & SIGNAL_UNKILLABLE) &&\n\t\t\t\t!sig_kernel_only(signr))\n\t\t\tcontinue;\n\n\t\tif (sig_kernel_stop(signr)) {\n\t\t\t/*\n\t\t\t * The default action is to stop all threads in\n\t\t\t * the thread group.  The job control signals\n\t\t\t * do nothing in an orphaned pgrp, but SIGSTOP\n\t\t\t * always works.  Note that siglock needs to be\n\t\t\t * dropped during the call to is_orphaned_pgrp()\n\t\t\t * because of lock ordering with tasklist_lock.\n\t\t\t * This allows an intervening SIGCONT to be posted.\n\t\t\t * We need to check for that and bail out if necessary.\n\t\t\t */\n\t\t\tif (signr != SIGSTOP) {\n\t\t\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\t\t\t/* signals can be posted during this window */\n\n\t\t\t\tif (is_current_pgrp_orphaned())\n\t\t\t\t\tgoto relock;\n\n\t\t\t\tspin_lock_irq(&sighand->siglock);\n\t\t\t}\n\n\t\t\tif (likely(do_signal_stop(ksig->info.si_signo))) {\n\t\t\t\t/* It released the siglock.  */\n\t\t\t\tgoto relock;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We didn't actually stop, due to a race\n\t\t\t * with SIGCONT or something like that.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\tfatal:\n\t\tspin_unlock_irq(&sighand->siglock);\n\t\tif (unlikely(cgroup_task_frozen(current)))\n\t\t\tcgroup_leave_frozen(true);\n\n\t\t/*\n\t\t * Anything else is fatal, maybe with a core dump.\n\t\t */\n\t\tcurrent->flags |= PF_SIGNALED;\n\n\t\tif (sig_kernel_coredump(signr)) {\n\t\t\tif (print_fatal_signals)\n\t\t\t\tprint_fatal_signal(ksig->info.si_signo);\n\t\t\tproc_coredump_connector(current);\n\t\t\t/*\n\t\t\t * If it was able to dump core, this kills all\n\t\t\t * other threads in the group and synchronizes with\n\t\t\t * their demise.  If we lost the race with another\n\t\t\t * thread getting here, it set group_exit_code\n\t\t\t * first and our do_group_exit call below will use\n\t\t\t * that value and ignore the one we pass it.\n\t\t\t */\n\t\t\tdo_coredump(&ksig->info);\n\t\t}\n\n\t\t/*\n\t\t * PF_IO_WORKER threads will catch and exit on fatal signals\n\t\t * themselves. They have cleanup that must be performed, so\n\t\t * we cannot call do_exit() on their behalf.\n\t\t */\n\t\tif (current->flags & PF_IO_WORKER)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Death signals, no core dump.\n\t\t */\n\t\tdo_group_exit(ksig->info.si_signo);\n\t\t/* NOTREACHED */\n\t}\n\tspin_unlock_irq(&sighand->siglock);\nout:\n\tksig->sig = signr;\n\n\tif (!(ksig->ka.sa.sa_flags & SA_EXPOSE_TAGBITS))\n\t\thide_si_addr_tag_bits(ksig);\n\n\treturn ksig->sig > 0;\n}"
  },
  {
    "function_name": "hide_si_addr_tag_bits",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "2610-2630",
    "snippet": "static void hide_si_addr_tag_bits(struct ksignal *ksig)\n{\n\tswitch (siginfo_layout(ksig->sig, ksig->info.si_code)) {\n\tcase SIL_FAULT:\n\tcase SIL_FAULT_TRAPNO:\n\tcase SIL_FAULT_MCEERR:\n\tcase SIL_FAULT_BNDERR:\n\tcase SIL_FAULT_PKUERR:\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tksig->info.si_addr = arch_untagged_si_addr(\n\t\t\tksig->info.si_addr, ksig->sig, ksig->info.si_code);\n\t\tbreak;\n\tcase SIL_KILL:\n\tcase SIL_TIMER:\n\tcase SIL_POLL:\n\tcase SIL_CHLD:\n\tcase SIL_RT:\n\tcase SIL_SYS:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_untagged_si_addr",
          "args": [
            "ksig->info.si_addr",
            "ksig->sig",
            "ksig->info.si_code"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginfo_layout",
          "args": [
            "ksig->sig",
            "ksig->info.si_code"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "siginfo_layout",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3283-3321",
          "snippet": "enum siginfo_layout siginfo_layout(unsigned sig, int si_code)\n{\n\tenum siginfo_layout layout = SIL_KILL;\n\tif ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n\t\tif ((sig < ARRAY_SIZE(sig_sicodes)) &&\n\t\t    (si_code <= sig_sicodes[sig].limit)) {\n\t\t\tlayout = sig_sicodes[sig].layout;\n\t\t\t/* Handle the exceptions */\n\t\t\tif ((sig == SIGBUS) &&\n\t\t\t    (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n\t\t\t\tlayout = SIL_FAULT_MCEERR;\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n\t\t\t\tlayout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n\t\t\t\tlayout = SIL_FAULT_PKUERR;\n#endif\n\t\t\telse if ((sig == SIGTRAP) && (si_code == TRAP_PERF))\n\t\t\t\tlayout = SIL_FAULT_PERF_EVENT;\n\t\t\telse if (IS_ENABLED(CONFIG_SPARC) &&\n\t\t\t\t (sig == SIGILL) && (si_code == ILL_ILLTRP))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t\telse if (IS_ENABLED(CONFIG_ALPHA) &&\n\t\t\t\t ((sig == SIGFPE) ||\n\t\t\t\t  ((sig == SIGTRAP) && (si_code == TRAP_UNK))))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\tlayout = SIL_POLL;\n\t} else {\n\t\tif (si_code == SI_TIMER)\n\t\t\tlayout = SIL_TIMER;\n\t\telse if (si_code == SI_SIGIO)\n\t\t\tlayout = SIL_POLL;\n\t\telse if (si_code < 0)\n\t\t\tlayout = SIL_RT;\n\t}\n\treturn layout;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};\n\nenum siginfo_layout siginfo_layout(unsigned sig, int si_code)\n{\n\tenum siginfo_layout layout = SIL_KILL;\n\tif ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n\t\tif ((sig < ARRAY_SIZE(sig_sicodes)) &&\n\t\t    (si_code <= sig_sicodes[sig].limit)) {\n\t\t\tlayout = sig_sicodes[sig].layout;\n\t\t\t/* Handle the exceptions */\n\t\t\tif ((sig == SIGBUS) &&\n\t\t\t    (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n\t\t\t\tlayout = SIL_FAULT_MCEERR;\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n\t\t\t\tlayout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n\t\t\t\tlayout = SIL_FAULT_PKUERR;\n#endif\n\t\t\telse if ((sig == SIGTRAP) && (si_code == TRAP_PERF))\n\t\t\t\tlayout = SIL_FAULT_PERF_EVENT;\n\t\t\telse if (IS_ENABLED(CONFIG_SPARC) &&\n\t\t\t\t (sig == SIGILL) && (si_code == ILL_ILLTRP))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t\telse if (IS_ENABLED(CONFIG_ALPHA) &&\n\t\t\t\t ((sig == SIGFPE) ||\n\t\t\t\t  ((sig == SIGTRAP) && (si_code == TRAP_UNK))))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\tlayout = SIL_POLL;\n\t} else {\n\t\tif (si_code == SI_TIMER)\n\t\t\tlayout = SIL_TIMER;\n\t\telse if (si_code == SI_SIGIO)\n\t\t\tlayout = SIL_POLL;\n\t\telse if (si_code < 0)\n\t\t\tlayout = SIL_RT;\n\t}\n\treturn layout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void hide_si_addr_tag_bits(struct ksignal *ksig)\n{\n\tswitch (siginfo_layout(ksig->sig, ksig->info.si_code)) {\n\tcase SIL_FAULT:\n\tcase SIL_FAULT_TRAPNO:\n\tcase SIL_FAULT_MCEERR:\n\tcase SIL_FAULT_BNDERR:\n\tcase SIL_FAULT_PKUERR:\n\tcase SIL_FAULT_PERF_EVENT:\n\t\tksig->info.si_addr = arch_untagged_si_addr(\n\t\t\tksig->info.si_addr, ksig->sig, ksig->info.si_code);\n\t\tbreak;\n\tcase SIL_KILL:\n\tcase SIL_TIMER:\n\tcase SIL_POLL:\n\tcase SIL_CHLD:\n\tcase SIL_RT:\n\tcase SIL_SYS:\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "ptrace_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "2564-2608",
    "snippet": "static int ptrace_signal(int signr, kernel_siginfo_t *info, enum pid_type type)\n{\n\t/*\n\t * We do not check sig_kernel_stop(signr) but set this marker\n\t * unconditionally because we do not know whether debugger will\n\t * change signr. This flag has no meaning unless we are going\n\t * to stop after return from ptrace_stop(). In this case it will\n\t * be checked in do_signal_stop(), we should only stop if it was\n\t * not cleared by SIGCONT while we were sleeping. See also the\n\t * comment in dequeue_signal().\n\t */\n\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\tsignr = ptrace_stop(signr, CLD_TRAPPED, 0, 0, info);\n\n\t/* We're back.  Did the debugger cancel the sig?  */\n\tif (signr == 0)\n\t\treturn signr;\n\n\t/*\n\t * Update the siginfo structure if the signal has\n\t * changed.  If the debugger wanted something\n\t * specific in the siginfo structure then it should\n\t * have updated *info via PTRACE_SETSIGINFO.\n\t */\n\tif (signr != info->si_signo) {\n\t\tclear_siginfo(info);\n\t\tinfo->si_signo = signr;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\trcu_read_lock();\n\t\tinfo->si_pid = task_pid_vnr(current->parent);\n\t\tinfo->si_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t\ttask_uid(current->parent));\n\t\trcu_read_unlock();\n\t}\n\n\t/* If the (new) signal is now blocked, requeue it.  */\n\tif (sigismember(&current->blocked, signr) ||\n\t    fatal_signal_pending(current)) {\n\t\tsend_signal(signr, info, current, type);\n\t\tsignr = 0;\n\t}\n\n\treturn signr;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_signal",
          "args": [
            "signr",
            "info",
            "current",
            "type"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "send_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1215-1249",
          "snippet": "static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\t/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */\n\tbool force = false;\n\n\tif (info == SEND_SIG_NOINFO) {\n\t\t/* Force if sent from an ancestor pid namespace */\n\t\tforce = !task_pid_nr_ns(current, task_active_pid_ns(t));\n\t} else if (info == SEND_SIG_PRIV) {\n\t\t/* Don't ignore kernel generated signals */\n\t\tforce = true;\n\t} else if (has_si_pid_and_uid(info)) {\n\t\t/* SIGKILL and SIGSTOP is special or has ids */\n\t\tstruct user_namespace *t_user_ns;\n\n\t\trcu_read_lock();\n\t\tt_user_ns = task_cred_xxx(t, user_ns);\n\t\tif (current_user_ns() != t_user_ns) {\n\t\t\tkuid_t uid = make_kuid(current_user_ns(), info->si_uid);\n\t\t\tinfo->si_uid = from_kuid_munged(t_user_ns, uid);\n\t\t}\n\t\trcu_read_unlock();\n\n\t\t/* A kernel generated signal? */\n\t\tforce = (info->si_code == SI_KERNEL);\n\n\t\t/* From an ancestor pid namespace? */\n\t\tif (!task_pid_nr_ns(current, task_active_pid_ns(t))) {\n\t\t\tinfo->si_pid = 0;\n\t\t\tforce = true;\n\t\t}\n\t}\n\treturn __send_signal(sig, info, t, type, force);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\t/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */\n\tbool force = false;\n\n\tif (info == SEND_SIG_NOINFO) {\n\t\t/* Force if sent from an ancestor pid namespace */\n\t\tforce = !task_pid_nr_ns(current, task_active_pid_ns(t));\n\t} else if (info == SEND_SIG_PRIV) {\n\t\t/* Don't ignore kernel generated signals */\n\t\tforce = true;\n\t} else if (has_si_pid_and_uid(info)) {\n\t\t/* SIGKILL and SIGSTOP is special or has ids */\n\t\tstruct user_namespace *t_user_ns;\n\n\t\trcu_read_lock();\n\t\tt_user_ns = task_cred_xxx(t, user_ns);\n\t\tif (current_user_ns() != t_user_ns) {\n\t\t\tkuid_t uid = make_kuid(current_user_ns(), info->si_uid);\n\t\t\tinfo->si_uid = from_kuid_munged(t_user_ns, uid);\n\t\t}\n\t\trcu_read_unlock();\n\n\t\t/* A kernel generated signal? */\n\t\tforce = (info->si_code == SI_KERNEL);\n\n\t\t/* From an ancestor pid namespace? */\n\t\tif (!task_pid_nr_ns(current, task_active_pid_ns(t))) {\n\t\t\tinfo->si_pid = 0;\n\t\t\tforce = true;\n\t\t}\n\t}\n\treturn __send_signal(sig, info, t, type, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&current->blocked",
            "signr"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "task_uid(current->parent)"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "current->parent"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "current->parent"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "info"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_stop",
          "args": [
            "signr",
            "CLD_TRAPPED",
            "0",
            "0",
            "info"
          ],
          "line": 2576
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2195-2338",
          "snippet": "static int ptrace_stop(int exit_code, int why, int clear_code,\n\t\t\tunsigned long message, kernel_siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\tbool read_code = true;\n\n\tif (arch_ptrace_stop_needed()) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\n\t/*\n\t * schedule() will not sleep if there is a pending signal that\n\t * can awaken the task.\n\t */\n\tset_special_state(TASK_TRACED);\n\n\t/*\n\t * We're committing to trapping.  TRACED should be visible before\n\t * TRAPPING is cleared; otherwise, the tracer might fail do_wait().\n\t * Also, transition to TRACED and updates to ->jobctl should be\n\t * atomic with respect to siglock and should be done after the arch\n\t * hook as siglock is released and regrabbed across it.\n\t *\n\t *     TRACER\t\t\t\t    TRACEE\n\t *\n\t *     ptrace_attach()\n\t * [L]   wait_on_bit(JOBCTL_TRAPPING)\t[S] set_special_state(TRACED)\n\t *     do_wait()\n\t *       set_current_state()                smp_wmb();\n\t *       ptrace_do_wait()\n\t *         wait_task_stopped()\n\t *           task_stopped_code()\n\t * [L]         task_is_traced()\t\t[S] task_clear_jobctl_trapping();\n\t */\n\tsmp_wmb();\n\n\tcurrent->ptrace_message = message;\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/*\n\t * If @why is CLD_STOPPED, we're trapping to participate in a group\n\t * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered\n\t * across siglock relocks since INTERRUPT was scheduled, PENDING\n\t * could be clear now.  We act as if SIGCONT is received after\n\t * TASK_TRACED is entered - ignore it.\n\t */\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t/* any trap clears pending STOP trap, STOP trap clears NOTIFY */\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t/* entering a trap, clear TRAPPING */\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (likely(current->ptrace)) {\n\t\t/*\n\t\t * Notify parents of the stop.\n\t\t *\n\t\t * While ptraced, there are two parents - the ptracer and\n\t\t * the real_parent of the group_leader.  The ptracer should\n\t\t * know about every stop while the real parent is only\n\t\t * interested in the completion of group stop.  The states\n\t\t * for the two don't interact with each other.  Notify\n\t\t * separately unless they're gonna be duplicates.\n\t\t */\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tcgroup_enter_frozen();\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t\tcgroup_leave_frozen(true);\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t *\n\t\t * If @gstop_done, the ptracer went away between group stop\n\t\t * completion and here.  During detach, it would have set\n\t\t * JOBCTL_STOP_PENDING on us and we'll re-enter\n\t\t * TASK_STOPPED in do_signal_stop() on return, so notifying\n\t\t * the real parent of the group stop completion is enough.\n\t\t */\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/* tasklist protects us from ptrace_freeze_traced() */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tread_code = false;\n\t\tif (clear_code)\n\t\t\texit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (read_code)\n\t\texit_code = current->exit_code;\n\tcurrent->last_siginfo = NULL;\n\tcurrent->ptrace_message = 0;\n\tcurrent->exit_code = 0;\n\n\t/* LISTENING can be set only during STOP traps, clear it */\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n\treturn exit_code;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int ptrace_stop(int exit_code, int why, int clear_code,\n\t\t\tunsigned long message, kernel_siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\tbool read_code = true;\n\n\tif (arch_ptrace_stop_needed()) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\n\t/*\n\t * schedule() will not sleep if there is a pending signal that\n\t * can awaken the task.\n\t */\n\tset_special_state(TASK_TRACED);\n\n\t/*\n\t * We're committing to trapping.  TRACED should be visible before\n\t * TRAPPING is cleared; otherwise, the tracer might fail do_wait().\n\t * Also, transition to TRACED and updates to ->jobctl should be\n\t * atomic with respect to siglock and should be done after the arch\n\t * hook as siglock is released and regrabbed across it.\n\t *\n\t *     TRACER\t\t\t\t    TRACEE\n\t *\n\t *     ptrace_attach()\n\t * [L]   wait_on_bit(JOBCTL_TRAPPING)\t[S] set_special_state(TRACED)\n\t *     do_wait()\n\t *       set_current_state()                smp_wmb();\n\t *       ptrace_do_wait()\n\t *         wait_task_stopped()\n\t *           task_stopped_code()\n\t * [L]         task_is_traced()\t\t[S] task_clear_jobctl_trapping();\n\t */\n\tsmp_wmb();\n\n\tcurrent->ptrace_message = message;\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/*\n\t * If @why is CLD_STOPPED, we're trapping to participate in a group\n\t * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered\n\t * across siglock relocks since INTERRUPT was scheduled, PENDING\n\t * could be clear now.  We act as if SIGCONT is received after\n\t * TASK_TRACED is entered - ignore it.\n\t */\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t/* any trap clears pending STOP trap, STOP trap clears NOTIFY */\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t/* entering a trap, clear TRAPPING */\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (likely(current->ptrace)) {\n\t\t/*\n\t\t * Notify parents of the stop.\n\t\t *\n\t\t * While ptraced, there are two parents - the ptracer and\n\t\t * the real_parent of the group_leader.  The ptracer should\n\t\t * know about every stop while the real parent is only\n\t\t * interested in the completion of group stop.  The states\n\t\t * for the two don't interact with each other.  Notify\n\t\t * separately unless they're gonna be duplicates.\n\t\t */\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tcgroup_enter_frozen();\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t\tcgroup_leave_frozen(true);\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t *\n\t\t * If @gstop_done, the ptracer went away between group stop\n\t\t * completion and here.  During detach, it would have set\n\t\t * JOBCTL_STOP_PENDING on us and we'll re-enter\n\t\t * TASK_STOPPED in do_signal_stop() on return, so notifying\n\t\t * the real parent of the group stop completion is enough.\n\t\t */\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/* tasklist protects us from ptrace_freeze_traced() */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tread_code = false;\n\t\tif (clear_code)\n\t\t\texit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (read_code)\n\t\texit_code = current->exit_code;\n\tcurrent->last_siginfo = NULL;\n\tcurrent->ptrace_message = 0;\n\tcurrent->exit_code = 0;\n\n\t/* LISTENING can be set only during STOP traps, clear it */\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n\treturn exit_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int ptrace_signal(int signr, kernel_siginfo_t *info, enum pid_type type)\n{\n\t/*\n\t * We do not check sig_kernel_stop(signr) but set this marker\n\t * unconditionally because we do not know whether debugger will\n\t * change signr. This flag has no meaning unless we are going\n\t * to stop after return from ptrace_stop(). In this case it will\n\t * be checked in do_signal_stop(), we should only stop if it was\n\t * not cleared by SIGCONT while we were sleeping. See also the\n\t * comment in dequeue_signal().\n\t */\n\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\tsignr = ptrace_stop(signr, CLD_TRAPPED, 0, 0, info);\n\n\t/* We're back.  Did the debugger cancel the sig?  */\n\tif (signr == 0)\n\t\treturn signr;\n\n\t/*\n\t * Update the siginfo structure if the signal has\n\t * changed.  If the debugger wanted something\n\t * specific in the siginfo structure then it should\n\t * have updated *info via PTRACE_SETSIGINFO.\n\t */\n\tif (signr != info->si_signo) {\n\t\tclear_siginfo(info);\n\t\tinfo->si_signo = signr;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\trcu_read_lock();\n\t\tinfo->si_pid = task_pid_vnr(current->parent);\n\t\tinfo->si_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t\ttask_uid(current->parent));\n\t\trcu_read_unlock();\n\t}\n\n\t/* If the (new) signal is now blocked, requeue it.  */\n\tif (sigismember(&current->blocked, signr) ||\n\t    fatal_signal_pending(current)) {\n\t\tsend_signal(signr, info, current, type);\n\t\tsignr = 0;\n\t}\n\n\treturn signr;\n}"
  },
  {
    "function_name": "do_freezer_trap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "2537-2562",
    "snippet": "static void do_freezer_trap(void)\n\t__releases(&current->sighand->siglock)\n{\n\t/*\n\t * If there are other trap bits pending except JOBCTL_TRAP_FREEZE,\n\t * let's make another loop to give it a chance to be handled.\n\t * In any case, we'll return back.\n\t */\n\tif ((current->jobctl & (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) !=\n\t     JOBCTL_TRAP_FREEZE) {\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\treturn;\n\t}\n\n\t/*\n\t * Now we're sure that there is no pending fatal signal and no\n\t * pending traps. Clear TIF_SIGPENDING to not get out of schedule()\n\t * immediately (if there is a non-fatal signal pending), and\n\t * put the task into sleep.\n\t */\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\tclear_thread_flag(TIF_SIGPENDING);\n\tspin_unlock_irq(&current->sighand->siglock);\n\tcgroup_enter_frozen();\n\tfreezable_schedule();\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freezable_schedule",
          "args": [],
          "line": 2561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_enter_frozen",
          "args": [],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_enter_frozen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "107-120",
          "snippet": "void cgroup_enter_frozen(void)\n{\n\tstruct cgroup *cgrp;\n\n\tif (current->frozen)\n\t\treturn;\n\n\tspin_lock_irq(&css_set_lock);\n\tcurrent->frozen = true;\n\tcgrp = task_dfl_cgroup(current);\n\tcgroup_inc_frozen_cnt(cgrp);\n\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_enter_frozen(void)\n{\n\tstruct cgroup *cgrp;\n\n\tif (current->frozen)\n\t\treturn;\n\n\tspin_lock_irq(&css_set_lock);\n\tcurrent->frozen = true;\n\tcgrp = task_dfl_cgroup(current);\n\tcgroup_inc_frozen_cnt(cgrp);\n\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2559
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_thread_flag",
          "args": [
            "TIF_SIGPENDING"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void do_freezer_trap(void)\n\t__releases(&current->sighand->siglock)\n{\n\t/*\n\t * If there are other trap bits pending except JOBCTL_TRAP_FREEZE,\n\t * let's make another loop to give it a chance to be handled.\n\t * In any case, we'll return back.\n\t */\n\tif ((current->jobctl & (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) !=\n\t     JOBCTL_TRAP_FREEZE) {\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\treturn;\n\t}\n\n\t/*\n\t * Now we're sure that there is no pending fatal signal and no\n\t * pending traps. Clear TIF_SIGPENDING to not get out of schedule()\n\t * immediately (if there is a non-fatal signal pending), and\n\t * put the task into sleep.\n\t */\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\tclear_thread_flag(TIF_SIGPENDING);\n\tspin_unlock_irq(&current->sighand->siglock);\n\tcgroup_enter_frozen();\n\tfreezable_schedule();\n}"
  },
  {
    "function_name": "do_jobctl_trap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "2509-2525",
    "snippet": "static void do_jobctl_trap(void)\n{\n\tstruct signal_struct *signal = current->signal;\n\tint signr = current->jobctl & JOBCTL_STOP_SIGMASK;\n\n\tif (current->ptrace & PT_SEIZED) {\n\t\tif (!signal->group_stop_count &&\n\t\t    !(signal->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsignr = SIGTRAP;\n\t\tWARN_ON_ONCE(!signr);\n\t\tptrace_do_notify(signr, signr | (PTRACE_EVENT_STOP << 8),\n\t\t\t\t CLD_STOPPED, 0);\n\t} else {\n\t\tWARN_ON_ONCE(!signr);\n\t\tptrace_stop(signr, CLD_STOPPED, 0, 0, NULL);\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrace_stop",
          "args": [
            "signr",
            "CLD_STOPPED",
            "0",
            "0",
            "NULL"
          ],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2195-2338",
          "snippet": "static int ptrace_stop(int exit_code, int why, int clear_code,\n\t\t\tunsigned long message, kernel_siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\tbool read_code = true;\n\n\tif (arch_ptrace_stop_needed()) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\n\t/*\n\t * schedule() will not sleep if there is a pending signal that\n\t * can awaken the task.\n\t */\n\tset_special_state(TASK_TRACED);\n\n\t/*\n\t * We're committing to trapping.  TRACED should be visible before\n\t * TRAPPING is cleared; otherwise, the tracer might fail do_wait().\n\t * Also, transition to TRACED and updates to ->jobctl should be\n\t * atomic with respect to siglock and should be done after the arch\n\t * hook as siglock is released and regrabbed across it.\n\t *\n\t *     TRACER\t\t\t\t    TRACEE\n\t *\n\t *     ptrace_attach()\n\t * [L]   wait_on_bit(JOBCTL_TRAPPING)\t[S] set_special_state(TRACED)\n\t *     do_wait()\n\t *       set_current_state()                smp_wmb();\n\t *       ptrace_do_wait()\n\t *         wait_task_stopped()\n\t *           task_stopped_code()\n\t * [L]         task_is_traced()\t\t[S] task_clear_jobctl_trapping();\n\t */\n\tsmp_wmb();\n\n\tcurrent->ptrace_message = message;\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/*\n\t * If @why is CLD_STOPPED, we're trapping to participate in a group\n\t * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered\n\t * across siglock relocks since INTERRUPT was scheduled, PENDING\n\t * could be clear now.  We act as if SIGCONT is received after\n\t * TASK_TRACED is entered - ignore it.\n\t */\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t/* any trap clears pending STOP trap, STOP trap clears NOTIFY */\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t/* entering a trap, clear TRAPPING */\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (likely(current->ptrace)) {\n\t\t/*\n\t\t * Notify parents of the stop.\n\t\t *\n\t\t * While ptraced, there are two parents - the ptracer and\n\t\t * the real_parent of the group_leader.  The ptracer should\n\t\t * know about every stop while the real parent is only\n\t\t * interested in the completion of group stop.  The states\n\t\t * for the two don't interact with each other.  Notify\n\t\t * separately unless they're gonna be duplicates.\n\t\t */\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tcgroup_enter_frozen();\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t\tcgroup_leave_frozen(true);\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t *\n\t\t * If @gstop_done, the ptracer went away between group stop\n\t\t * completion and here.  During detach, it would have set\n\t\t * JOBCTL_STOP_PENDING on us and we'll re-enter\n\t\t * TASK_STOPPED in do_signal_stop() on return, so notifying\n\t\t * the real parent of the group stop completion is enough.\n\t\t */\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/* tasklist protects us from ptrace_freeze_traced() */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tread_code = false;\n\t\tif (clear_code)\n\t\t\texit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (read_code)\n\t\texit_code = current->exit_code;\n\tcurrent->last_siginfo = NULL;\n\tcurrent->ptrace_message = 0;\n\tcurrent->exit_code = 0;\n\n\t/* LISTENING can be set only during STOP traps, clear it */\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n\treturn exit_code;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int ptrace_stop(int exit_code, int why, int clear_code,\n\t\t\tunsigned long message, kernel_siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\tbool read_code = true;\n\n\tif (arch_ptrace_stop_needed()) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\n\t/*\n\t * schedule() will not sleep if there is a pending signal that\n\t * can awaken the task.\n\t */\n\tset_special_state(TASK_TRACED);\n\n\t/*\n\t * We're committing to trapping.  TRACED should be visible before\n\t * TRAPPING is cleared; otherwise, the tracer might fail do_wait().\n\t * Also, transition to TRACED and updates to ->jobctl should be\n\t * atomic with respect to siglock and should be done after the arch\n\t * hook as siglock is released and regrabbed across it.\n\t *\n\t *     TRACER\t\t\t\t    TRACEE\n\t *\n\t *     ptrace_attach()\n\t * [L]   wait_on_bit(JOBCTL_TRAPPING)\t[S] set_special_state(TRACED)\n\t *     do_wait()\n\t *       set_current_state()                smp_wmb();\n\t *       ptrace_do_wait()\n\t *         wait_task_stopped()\n\t *           task_stopped_code()\n\t * [L]         task_is_traced()\t\t[S] task_clear_jobctl_trapping();\n\t */\n\tsmp_wmb();\n\n\tcurrent->ptrace_message = message;\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/*\n\t * If @why is CLD_STOPPED, we're trapping to participate in a group\n\t * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered\n\t * across siglock relocks since INTERRUPT was scheduled, PENDING\n\t * could be clear now.  We act as if SIGCONT is received after\n\t * TASK_TRACED is entered - ignore it.\n\t */\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t/* any trap clears pending STOP trap, STOP trap clears NOTIFY */\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t/* entering a trap, clear TRAPPING */\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (likely(current->ptrace)) {\n\t\t/*\n\t\t * Notify parents of the stop.\n\t\t *\n\t\t * While ptraced, there are two parents - the ptracer and\n\t\t * the real_parent of the group_leader.  The ptracer should\n\t\t * know about every stop while the real parent is only\n\t\t * interested in the completion of group stop.  The states\n\t\t * for the two don't interact with each other.  Notify\n\t\t * separately unless they're gonna be duplicates.\n\t\t */\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tcgroup_enter_frozen();\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t\tcgroup_leave_frozen(true);\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t *\n\t\t * If @gstop_done, the ptracer went away between group stop\n\t\t * completion and here.  During detach, it would have set\n\t\t * JOBCTL_STOP_PENDING on us and we'll re-enter\n\t\t * TASK_STOPPED in do_signal_stop() on return, so notifying\n\t\t * the real parent of the group stop completion is enough.\n\t\t */\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/* tasklist protects us from ptrace_freeze_traced() */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tread_code = false;\n\t\tif (clear_code)\n\t\t\texit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (read_code)\n\t\texit_code = current->exit_code;\n\tcurrent->last_siginfo = NULL;\n\tcurrent->ptrace_message = 0;\n\tcurrent->exit_code = 0;\n\n\t/* LISTENING can be set only during STOP traps, clear it */\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n\treturn exit_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!signr"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_do_notify",
          "args": [
            "signr",
            "signr | (PTRACE_EVENT_STOP << 8)",
            "CLD_STOPPED",
            "0"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_do_notify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2340-2352",
          "snippet": "static int ptrace_do_notify(int signr, int exit_code, int why, unsigned long message)\n{\n\tkernel_siginfo_t info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = signr;\n\tinfo.si_code = exit_code;\n\tinfo.si_pid = task_pid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\t/* Let the debugger run.  */\n\treturn ptrace_stop(exit_code, why, 1, message, &info);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int ptrace_do_notify(int signr, int exit_code, int why, unsigned long message)\n{\n\tkernel_siginfo_t info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = signr;\n\tinfo.si_code = exit_code;\n\tinfo.si_pid = task_pid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\t/* Let the debugger run.  */\n\treturn ptrace_stop(exit_code, why, 1, message, &info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!signr"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void do_jobctl_trap(void)\n{\n\tstruct signal_struct *signal = current->signal;\n\tint signr = current->jobctl & JOBCTL_STOP_SIGMASK;\n\n\tif (current->ptrace & PT_SEIZED) {\n\t\tif (!signal->group_stop_count &&\n\t\t    !(signal->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsignr = SIGTRAP;\n\t\tWARN_ON_ONCE(!signr);\n\t\tptrace_do_notify(signr, signr | (PTRACE_EVENT_STOP << 8),\n\t\t\t\t CLD_STOPPED, 0);\n\t} else {\n\t\tWARN_ON_ONCE(!signr);\n\t\tptrace_stop(signr, CLD_STOPPED, 0, 0, NULL);\n\t}\n}"
  },
  {
    "function_name": "do_signal_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "2390-2492",
    "snippet": "static bool do_signal_stop(int signr)\n\t__releases(&current->sighand->siglock)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tif (!(current->jobctl & JOBCTL_STOP_PENDING)) {\n\t\tunsigned long gstop = JOBCTL_STOP_PENDING | JOBCTL_STOP_CONSUME;\n\t\tstruct task_struct *t;\n\n\t\t/* signr will be recorded in task->jobctl for retries */\n\t\tWARN_ON_ONCE(signr & ~JOBCTL_STOP_SIGMASK);\n\n\t\tif (!likely(current->jobctl & JOBCTL_STOP_DEQUEUED) ||\n\t\t    unlikely(sig->flags & SIGNAL_GROUP_EXIT) ||\n\t\t    unlikely(sig->group_exec_task))\n\t\t\treturn false;\n\t\t/*\n\t\t * There is no group stop already in progress.  We must\n\t\t * initiate one now.\n\t\t *\n\t\t * While ptraced, a task may be resumed while group stop is\n\t\t * still in effect and then receive a stop signal and\n\t\t * initiate another group stop.  This deviates from the\n\t\t * usual behavior as two consecutive stop signals can't\n\t\t * cause two group stops when !ptraced.  That is why we\n\t\t * also check !task_is_stopped(t) below.\n\t\t *\n\t\t * The condition can be distinguished by testing whether\n\t\t * SIGNAL_STOP_STOPPED is already set.  Don't generate\n\t\t * group_exit_code in such case.\n\t\t *\n\t\t * This is not necessary for SIGNAL_STOP_CONTINUED because\n\t\t * an intervening stop signal is required to cause two\n\t\t * continued events regardless of ptrace.\n\t\t */\n\t\tif (!(sig->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsig->group_exit_code = signr;\n\n\t\tsig->group_stop_count = 0;\n\n\t\tif (task_set_jobctl_pending(current, signr | gstop))\n\t\t\tsig->group_stop_count++;\n\n\t\tt = current;\n\t\twhile_each_thread(current, t) {\n\t\t\t/*\n\t\t\t * Setting state to TASK_STOPPED for a group\n\t\t\t * stop is always done with the siglock held,\n\t\t\t * so this check has no races.\n\t\t\t */\n\t\t\tif (!task_is_stopped(t) &&\n\t\t\t    task_set_jobctl_pending(t, signr | gstop)) {\n\t\t\t\tsig->group_stop_count++;\n\t\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\t\tsignal_wake_up(t, 0);\n\t\t\t\telse\n\t\t\t\t\tptrace_trap_notify(t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (likely(!current->ptrace)) {\n\t\tint notify = 0;\n\n\t\t/*\n\t\t * If there are no other threads in the group, or if there\n\t\t * is a group stop in progress and we are the last to stop,\n\t\t * report to the parent.\n\t\t */\n\t\tif (task_participate_group_stop(current))\n\t\t\tnotify = CLD_STOPPED;\n\n\t\tset_special_state(TASK_STOPPED);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\t\t/*\n\t\t * Notify the parent of the group stop completion.  Because\n\t\t * we're not holding either the siglock or tasklist_lock\n\t\t * here, ptracer may attach inbetween; however, this is for\n\t\t * group stop and should always be delivered to the real\n\t\t * parent of the group leader.  The new ptracer will get\n\t\t * its notification when this task transitions into\n\t\t * TASK_TRACED.\n\t\t */\n\t\tif (notify) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tdo_notify_parent_cldstop(current, false, notify);\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\n\t\t/* Now we don't run again until woken by SIGCONT or SIGKILL */\n\t\tcgroup_enter_frozen();\n\t\tfreezable_schedule();\n\t\treturn true;\n\t} else {\n\t\t/*\n\t\t * While ptraced, group stop is handled by STOP trap.\n\t\t * Schedule it and let the caller deal with it.\n\t\t */\n\t\ttask_set_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_set_jobctl_pending",
          "args": [
            "current",
            "JOBCTL_TRAP_STOP"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "task_set_jobctl_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "284-298",
          "snippet": "bool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezable_schedule",
          "args": [],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_enter_frozen",
          "args": [],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_enter_frozen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "107-120",
          "snippet": "void cgroup_enter_frozen(void)\n{\n\tstruct cgroup *cgrp;\n\n\tif (current->frozen)\n\t\treturn;\n\n\tspin_lock_irq(&css_set_lock);\n\tcurrent->frozen = true;\n\tcgrp = task_dfl_cgroup(current);\n\tcgroup_inc_frozen_cnt(cgrp);\n\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_enter_frozen(void)\n{\n\tstruct cgroup *cgrp;\n\n\tif (current->frozen)\n\t\treturn;\n\n\tspin_lock_irq(&css_set_lock);\n\tcurrent->frozen = true;\n\tcgrp = task_dfl_cgroup(current);\n\tcgroup_inc_frozen_cnt(cgrp);\n\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 2477
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_notify_parent_cldstop",
          "args": [
            "current",
            "false",
            "notify"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent_cldstop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2125-2181",
          "snippet": "static void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_special_state",
          "args": [
            "TASK_STOPPED"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_participate_group_stop",
          "args": [
            "current"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "task_participate_group_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "365-389",
          "snippet": "static bool task_participate_group_stop(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n\tif (!consume)\n\t\treturn false;\n\n\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))\n\t\tsig->group_stop_count--;\n\n\t/*\n\t * Tell the caller to notify completion iff we are entering into a\n\t * fresh group stop.  Read comment in do_signal_stop() for details.\n\t */\n\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool task_participate_group_stop(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n\tif (!consume)\n\t\treturn false;\n\n\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))\n\t\tsig->group_stop_count--;\n\n\t/*\n\t * Tell the caller to notify completion iff we are entering into a\n\t * fresh group stop.  Read comment in do_signal_stop() for details.\n\t */\n\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!current->ptrace"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_trap_notify",
          "args": [
            "t"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_trap_notify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "884-891",
          "snippet": "static void ptrace_trap_notify(struct task_struct *t)\n{\n\tWARN_ON_ONCE(!(t->ptrace & PT_SEIZED));\n\tassert_spin_locked(&t->sighand->siglock);\n\n\ttask_set_jobctl_pending(t, JOBCTL_TRAP_NOTIFY);\n\tptrace_signal_wake_up(t, t->jobctl & JOBCTL_LISTENING);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void ptrace_trap_notify(struct task_struct *t)\n{\n\tWARN_ON_ONCE(!(t->ptrace & PT_SEIZED));\n\tassert_spin_locked(&t->sighand->siglock);\n\n\ttask_set_jobctl_pending(t, JOBCTL_TRAP_NOTIFY);\n\tptrace_signal_wake_up(t, t->jobctl & JOBCTL_LISTENING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_wake_up",
          "args": [
            "t",
            "0"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "763-775",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(t->ptrace & PT_SEIZED)"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_is_stopped",
          "args": [
            "t"
          ],
          "line": 2440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "current",
            "t"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sig->group_exec_task"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sig->flags & SIGNAL_GROUP_EXIT"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "current->jobctl & JOBCTL_STOP_DEQUEUED"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "signr & ~JOBCTL_STOP_SIGMASK"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool do_signal_stop(int signr)\n\t__releases(&current->sighand->siglock)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tif (!(current->jobctl & JOBCTL_STOP_PENDING)) {\n\t\tunsigned long gstop = JOBCTL_STOP_PENDING | JOBCTL_STOP_CONSUME;\n\t\tstruct task_struct *t;\n\n\t\t/* signr will be recorded in task->jobctl for retries */\n\t\tWARN_ON_ONCE(signr & ~JOBCTL_STOP_SIGMASK);\n\n\t\tif (!likely(current->jobctl & JOBCTL_STOP_DEQUEUED) ||\n\t\t    unlikely(sig->flags & SIGNAL_GROUP_EXIT) ||\n\t\t    unlikely(sig->group_exec_task))\n\t\t\treturn false;\n\t\t/*\n\t\t * There is no group stop already in progress.  We must\n\t\t * initiate one now.\n\t\t *\n\t\t * While ptraced, a task may be resumed while group stop is\n\t\t * still in effect and then receive a stop signal and\n\t\t * initiate another group stop.  This deviates from the\n\t\t * usual behavior as two consecutive stop signals can't\n\t\t * cause two group stops when !ptraced.  That is why we\n\t\t * also check !task_is_stopped(t) below.\n\t\t *\n\t\t * The condition can be distinguished by testing whether\n\t\t * SIGNAL_STOP_STOPPED is already set.  Don't generate\n\t\t * group_exit_code in such case.\n\t\t *\n\t\t * This is not necessary for SIGNAL_STOP_CONTINUED because\n\t\t * an intervening stop signal is required to cause two\n\t\t * continued events regardless of ptrace.\n\t\t */\n\t\tif (!(sig->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsig->group_exit_code = signr;\n\n\t\tsig->group_stop_count = 0;\n\n\t\tif (task_set_jobctl_pending(current, signr | gstop))\n\t\t\tsig->group_stop_count++;\n\n\t\tt = current;\n\t\twhile_each_thread(current, t) {\n\t\t\t/*\n\t\t\t * Setting state to TASK_STOPPED for a group\n\t\t\t * stop is always done with the siglock held,\n\t\t\t * so this check has no races.\n\t\t\t */\n\t\t\tif (!task_is_stopped(t) &&\n\t\t\t    task_set_jobctl_pending(t, signr | gstop)) {\n\t\t\t\tsig->group_stop_count++;\n\t\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\t\tsignal_wake_up(t, 0);\n\t\t\t\telse\n\t\t\t\t\tptrace_trap_notify(t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (likely(!current->ptrace)) {\n\t\tint notify = 0;\n\n\t\t/*\n\t\t * If there are no other threads in the group, or if there\n\t\t * is a group stop in progress and we are the last to stop,\n\t\t * report to the parent.\n\t\t */\n\t\tif (task_participate_group_stop(current))\n\t\t\tnotify = CLD_STOPPED;\n\n\t\tset_special_state(TASK_STOPPED);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\t\t/*\n\t\t * Notify the parent of the group stop completion.  Because\n\t\t * we're not holding either the siglock or tasklist_lock\n\t\t * here, ptracer may attach inbetween; however, this is for\n\t\t * group stop and should always be delivered to the real\n\t\t * parent of the group leader.  The new ptracer will get\n\t\t * its notification when this task transitions into\n\t\t * TASK_TRACED.\n\t\t */\n\t\tif (notify) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tdo_notify_parent_cldstop(current, false, notify);\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\n\t\t/* Now we don't run again until woken by SIGCONT or SIGKILL */\n\t\tcgroup_enter_frozen();\n\t\tfreezable_schedule();\n\t\treturn true;\n\t} else {\n\t\t/*\n\t\t * While ptraced, group stop is handled by STOP trap.\n\t\t * Schedule it and let the caller deal with it.\n\t\t */\n\t\ttask_set_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "ptrace_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "2354-2366",
    "snippet": "int ptrace_notify(int exit_code, unsigned long message)\n{\n\tint signr;\n\n\tBUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);\n\tif (unlikely(task_work_pending(current)))\n\t\ttask_work_run();\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tsignr = ptrace_do_notify(SIGTRAP, exit_code, CLD_TRAPPED, message);\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn signr;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_do_notify",
          "args": [
            "SIGTRAP",
            "exit_code",
            "CLD_TRAPPED",
            "message"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_do_notify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2340-2352",
          "snippet": "static int ptrace_do_notify(int signr, int exit_code, int why, unsigned long message)\n{\n\tkernel_siginfo_t info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = signr;\n\tinfo.si_code = exit_code;\n\tinfo.si_pid = task_pid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\t/* Let the debugger run.  */\n\treturn ptrace_stop(exit_code, why, 1, message, &info);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int ptrace_do_notify(int signr, int exit_code, int why, unsigned long message)\n{\n\tkernel_siginfo_t info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = signr;\n\tinfo.si_code = exit_code;\n\tinfo.si_pid = task_pid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\t/* Let the debugger run.  */\n\treturn ptrace_stop(exit_code, why, 1, message, &info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_work_run",
          "args": [],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "task_work_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/task_work.c",
          "lines": "131-169",
          "snippet": "void task_work_run(void)\n{\n\tstruct task_struct *task = current;\n\tstruct callback_head *work, *head, *next;\n\n\tfor (;;) {\n\t\t/*\n\t\t * work->func() can do task_work_add(), do not set\n\t\t * work_exited unless the list is empty.\n\t\t */\n\t\tdo {\n\t\t\thead = NULL;\n\t\t\twork = READ_ONCE(task->task_works);\n\t\t\tif (!work) {\n\t\t\t\tif (task->flags & PF_EXITING)\n\t\t\t\t\thead = &work_exited;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (cmpxchg(&task->task_works, work, head) != work);\n\n\t\tif (!work)\n\t\t\tbreak;\n\t\t/*\n\t\t * Synchronize with task_work_cancel(). It can not remove\n\t\t * the first entry == work, cmpxchg(task_works) must fail.\n\t\t * But it can remove another entry from the ->next list.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tdo {\n\t\t\tnext = work->next;\n\t\t\twork->func(work);\n\t\t\twork = next;\n\t\t\tcond_resched();\n\t\t} while (work);\n\t}\n}",
          "includes": [
            "#include <linux/resume_user_mode.h>",
            "#include <linux/task_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct callback_head work_exited;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/resume_user_mode.h>\n#include <linux/task_work.h>\n#include <linux/spinlock.h>\n\nstatic struct callback_head work_exited;\n\nvoid task_work_run(void)\n{\n\tstruct task_struct *task = current;\n\tstruct callback_head *work, *head, *next;\n\n\tfor (;;) {\n\t\t/*\n\t\t * work->func() can do task_work_add(), do not set\n\t\t * work_exited unless the list is empty.\n\t\t */\n\t\tdo {\n\t\t\thead = NULL;\n\t\t\twork = READ_ONCE(task->task_works);\n\t\t\tif (!work) {\n\t\t\t\tif (task->flags & PF_EXITING)\n\t\t\t\t\thead = &work_exited;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (cmpxchg(&task->task_works, work, head) != work);\n\n\t\tif (!work)\n\t\t\tbreak;\n\t\t/*\n\t\t * Synchronize with task_work_cancel(). It can not remove\n\t\t * the first entry == work, cmpxchg(task_works) must fail.\n\t\t * But it can remove another entry from the ->next list.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tdo {\n\t\t\tnext = work->next;\n\t\t\twork->func(work);\n\t\t\twork = next;\n\t\t\tcond_resched();\n\t\t} while (work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "task_work_pending(current)"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_work_pending",
          "args": [
            "current"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(exit_code & (0x7f | ~0xffff)) != SIGTRAP"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint ptrace_notify(int exit_code, unsigned long message)\n{\n\tint signr;\n\n\tBUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);\n\tif (unlikely(task_work_pending(current)))\n\t\ttask_work_run();\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tsignr = ptrace_do_notify(SIGTRAP, exit_code, CLD_TRAPPED, message);\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn signr;\n}"
  },
  {
    "function_name": "ptrace_do_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "2340-2352",
    "snippet": "static int ptrace_do_notify(int signr, int exit_code, int why, unsigned long message)\n{\n\tkernel_siginfo_t info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = signr;\n\tinfo.si_code = exit_code;\n\tinfo.si_pid = task_pid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\t/* Let the debugger run.  */\n\treturn ptrace_stop(exit_code, why, 1, message, &info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrace_stop",
          "args": [
            "exit_code",
            "why",
            "1",
            "message",
            "&info"
          ],
          "line": 2351
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2195-2338",
          "snippet": "static int ptrace_stop(int exit_code, int why, int clear_code,\n\t\t\tunsigned long message, kernel_siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\tbool read_code = true;\n\n\tif (arch_ptrace_stop_needed()) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\n\t/*\n\t * schedule() will not sleep if there is a pending signal that\n\t * can awaken the task.\n\t */\n\tset_special_state(TASK_TRACED);\n\n\t/*\n\t * We're committing to trapping.  TRACED should be visible before\n\t * TRAPPING is cleared; otherwise, the tracer might fail do_wait().\n\t * Also, transition to TRACED and updates to ->jobctl should be\n\t * atomic with respect to siglock and should be done after the arch\n\t * hook as siglock is released and regrabbed across it.\n\t *\n\t *     TRACER\t\t\t\t    TRACEE\n\t *\n\t *     ptrace_attach()\n\t * [L]   wait_on_bit(JOBCTL_TRAPPING)\t[S] set_special_state(TRACED)\n\t *     do_wait()\n\t *       set_current_state()                smp_wmb();\n\t *       ptrace_do_wait()\n\t *         wait_task_stopped()\n\t *           task_stopped_code()\n\t * [L]         task_is_traced()\t\t[S] task_clear_jobctl_trapping();\n\t */\n\tsmp_wmb();\n\n\tcurrent->ptrace_message = message;\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/*\n\t * If @why is CLD_STOPPED, we're trapping to participate in a group\n\t * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered\n\t * across siglock relocks since INTERRUPT was scheduled, PENDING\n\t * could be clear now.  We act as if SIGCONT is received after\n\t * TASK_TRACED is entered - ignore it.\n\t */\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t/* any trap clears pending STOP trap, STOP trap clears NOTIFY */\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t/* entering a trap, clear TRAPPING */\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (likely(current->ptrace)) {\n\t\t/*\n\t\t * Notify parents of the stop.\n\t\t *\n\t\t * While ptraced, there are two parents - the ptracer and\n\t\t * the real_parent of the group_leader.  The ptracer should\n\t\t * know about every stop while the real parent is only\n\t\t * interested in the completion of group stop.  The states\n\t\t * for the two don't interact with each other.  Notify\n\t\t * separately unless they're gonna be duplicates.\n\t\t */\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tcgroup_enter_frozen();\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t\tcgroup_leave_frozen(true);\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t *\n\t\t * If @gstop_done, the ptracer went away between group stop\n\t\t * completion and here.  During detach, it would have set\n\t\t * JOBCTL_STOP_PENDING on us and we'll re-enter\n\t\t * TASK_STOPPED in do_signal_stop() on return, so notifying\n\t\t * the real parent of the group stop completion is enough.\n\t\t */\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/* tasklist protects us from ptrace_freeze_traced() */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tread_code = false;\n\t\tif (clear_code)\n\t\t\texit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (read_code)\n\t\texit_code = current->exit_code;\n\tcurrent->last_siginfo = NULL;\n\tcurrent->ptrace_message = 0;\n\tcurrent->exit_code = 0;\n\n\t/* LISTENING can be set only during STOP traps, clear it */\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n\treturn exit_code;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int ptrace_stop(int exit_code, int why, int clear_code,\n\t\t\tunsigned long message, kernel_siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\tbool read_code = true;\n\n\tif (arch_ptrace_stop_needed()) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\n\t/*\n\t * schedule() will not sleep if there is a pending signal that\n\t * can awaken the task.\n\t */\n\tset_special_state(TASK_TRACED);\n\n\t/*\n\t * We're committing to trapping.  TRACED should be visible before\n\t * TRAPPING is cleared; otherwise, the tracer might fail do_wait().\n\t * Also, transition to TRACED and updates to ->jobctl should be\n\t * atomic with respect to siglock and should be done after the arch\n\t * hook as siglock is released and regrabbed across it.\n\t *\n\t *     TRACER\t\t\t\t    TRACEE\n\t *\n\t *     ptrace_attach()\n\t * [L]   wait_on_bit(JOBCTL_TRAPPING)\t[S] set_special_state(TRACED)\n\t *     do_wait()\n\t *       set_current_state()                smp_wmb();\n\t *       ptrace_do_wait()\n\t *         wait_task_stopped()\n\t *           task_stopped_code()\n\t * [L]         task_is_traced()\t\t[S] task_clear_jobctl_trapping();\n\t */\n\tsmp_wmb();\n\n\tcurrent->ptrace_message = message;\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/*\n\t * If @why is CLD_STOPPED, we're trapping to participate in a group\n\t * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered\n\t * across siglock relocks since INTERRUPT was scheduled, PENDING\n\t * could be clear now.  We act as if SIGCONT is received after\n\t * TASK_TRACED is entered - ignore it.\n\t */\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t/* any trap clears pending STOP trap, STOP trap clears NOTIFY */\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t/* entering a trap, clear TRAPPING */\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (likely(current->ptrace)) {\n\t\t/*\n\t\t * Notify parents of the stop.\n\t\t *\n\t\t * While ptraced, there are two parents - the ptracer and\n\t\t * the real_parent of the group_leader.  The ptracer should\n\t\t * know about every stop while the real parent is only\n\t\t * interested in the completion of group stop.  The states\n\t\t * for the two don't interact with each other.  Notify\n\t\t * separately unless they're gonna be duplicates.\n\t\t */\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tcgroup_enter_frozen();\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t\tcgroup_leave_frozen(true);\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t *\n\t\t * If @gstop_done, the ptracer went away between group stop\n\t\t * completion and here.  During detach, it would have set\n\t\t * JOBCTL_STOP_PENDING on us and we'll re-enter\n\t\t * TASK_STOPPED in do_signal_stop() on return, so notifying\n\t\t * the real parent of the group stop completion is enough.\n\t\t */\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/* tasklist protects us from ptrace_freeze_traced() */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tread_code = false;\n\t\tif (clear_code)\n\t\t\texit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (read_code)\n\t\texit_code = current->exit_code;\n\tcurrent->last_siginfo = NULL;\n\tcurrent->ptrace_message = 0;\n\tcurrent->exit_code = 0;\n\n\t/* LISTENING can be set only during STOP traps, clear it */\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n\treturn exit_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "current_uid()"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "current"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int ptrace_do_notify(int signr, int exit_code, int why, unsigned long message)\n{\n\tkernel_siginfo_t info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = signr;\n\tinfo.si_code = exit_code;\n\tinfo.si_pid = task_pid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\t/* Let the debugger run.  */\n\treturn ptrace_stop(exit_code, why, 1, message, &info);\n}"
  },
  {
    "function_name": "ptrace_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "2195-2338",
    "snippet": "static int ptrace_stop(int exit_code, int why, int clear_code,\n\t\t\tunsigned long message, kernel_siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\tbool read_code = true;\n\n\tif (arch_ptrace_stop_needed()) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\n\t/*\n\t * schedule() will not sleep if there is a pending signal that\n\t * can awaken the task.\n\t */\n\tset_special_state(TASK_TRACED);\n\n\t/*\n\t * We're committing to trapping.  TRACED should be visible before\n\t * TRAPPING is cleared; otherwise, the tracer might fail do_wait().\n\t * Also, transition to TRACED and updates to ->jobctl should be\n\t * atomic with respect to siglock and should be done after the arch\n\t * hook as siglock is released and regrabbed across it.\n\t *\n\t *     TRACER\t\t\t\t    TRACEE\n\t *\n\t *     ptrace_attach()\n\t * [L]   wait_on_bit(JOBCTL_TRAPPING)\t[S] set_special_state(TRACED)\n\t *     do_wait()\n\t *       set_current_state()                smp_wmb();\n\t *       ptrace_do_wait()\n\t *         wait_task_stopped()\n\t *           task_stopped_code()\n\t * [L]         task_is_traced()\t\t[S] task_clear_jobctl_trapping();\n\t */\n\tsmp_wmb();\n\n\tcurrent->ptrace_message = message;\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/*\n\t * If @why is CLD_STOPPED, we're trapping to participate in a group\n\t * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered\n\t * across siglock relocks since INTERRUPT was scheduled, PENDING\n\t * could be clear now.  We act as if SIGCONT is received after\n\t * TASK_TRACED is entered - ignore it.\n\t */\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t/* any trap clears pending STOP trap, STOP trap clears NOTIFY */\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t/* entering a trap, clear TRAPPING */\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (likely(current->ptrace)) {\n\t\t/*\n\t\t * Notify parents of the stop.\n\t\t *\n\t\t * While ptraced, there are two parents - the ptracer and\n\t\t * the real_parent of the group_leader.  The ptracer should\n\t\t * know about every stop while the real parent is only\n\t\t * interested in the completion of group stop.  The states\n\t\t * for the two don't interact with each other.  Notify\n\t\t * separately unless they're gonna be duplicates.\n\t\t */\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tcgroup_enter_frozen();\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t\tcgroup_leave_frozen(true);\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t *\n\t\t * If @gstop_done, the ptracer went away between group stop\n\t\t * completion and here.  During detach, it would have set\n\t\t * JOBCTL_STOP_PENDING on us and we'll re-enter\n\t\t * TASK_STOPPED in do_signal_stop() on return, so notifying\n\t\t * the real parent of the group stop completion is enough.\n\t\t */\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/* tasklist protects us from ptrace_freeze_traced() */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tread_code = false;\n\t\tif (clear_code)\n\t\t\texit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (read_code)\n\t\texit_code = current->exit_code;\n\tcurrent->last_siginfo = NULL;\n\tcurrent->ptrace_message = 0;\n\tcurrent->exit_code = 0;\n\n\t/* LISTENING can be set only during STOP traps, clear it */\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n\treturn exit_code;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_sigpending_tsk",
          "args": [
            "current"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending_tsk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "154-170",
          "snippet": "static bool recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif ((t->jobctl & (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked) ||\n\t    cgroup_task_frozen(t)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn true;\n\t}\n\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn false;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif ((t->jobctl & (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked) ||\n\t    cgroup_task_frozen(t)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn true;\n\t}\n\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2321
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_notify_parent_cldstop",
          "args": [
            "current",
            "false",
            "why"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent_cldstop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "2125-2181",
          "snippet": "static void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_leave_frozen",
          "args": [
            "true"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_leave_frozen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "131-149",
          "snippet": "void cgroup_leave_frozen(bool always_leave)\n{\n\tstruct cgroup *cgrp;\n\n\tspin_lock_irq(&css_set_lock);\n\tcgrp = task_dfl_cgroup(current);\n\tif (always_leave || !test_bit(CGRP_FREEZE, &cgrp->flags)) {\n\t\tcgroup_dec_frozen_cnt(cgrp);\n\t\tcgroup_update_frozen(cgrp);\n\t\tWARN_ON_ONCE(!current->frozen);\n\t\tcurrent->frozen = false;\n\t} else if (!(current->jobctl & JOBCTL_TRAP_FREEZE)) {\n\t\tspin_lock(&current->sighand->siglock);\n\t\tcurrent->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tset_thread_flag(TIF_SIGPENDING);\n\t\tspin_unlock(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_leave_frozen(bool always_leave)\n{\n\tstruct cgroup *cgrp;\n\n\tspin_lock_irq(&css_set_lock);\n\tcgrp = task_dfl_cgroup(current);\n\tif (always_leave || !test_bit(CGRP_FREEZE, &cgrp->flags)) {\n\t\tcgroup_dec_frozen_cnt(cgrp);\n\t\tcgroup_update_frozen(cgrp);\n\t\tWARN_ON_ONCE(!current->frozen);\n\t\tcurrent->frozen = false;\n\t} else if (!(current->jobctl & JOBCTL_TRAP_FREEZE)) {\n\t\tspin_lock(&current->sighand->siglock);\n\t\tcurrent->jobctl |= JOBCTL_TRAP_FREEZE;\n\t\tset_thread_flag(TIF_SIGPENDING);\n\t\tspin_unlock(&current->sighand->siglock);\n\t}\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezable_schedule",
          "args": [],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable_no_resched",
          "args": [],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_enter_frozen",
          "args": [],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_enter_frozen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/freezer.c",
          "lines": "107-120",
          "snippet": "void cgroup_enter_frozen(void)\n{\n\tstruct cgroup *cgrp;\n\n\tif (current->frozen)\n\t\treturn;\n\n\tspin_lock_irq(&css_set_lock);\n\tcurrent->frozen = true;\n\tcgrp = task_dfl_cgroup(current);\n\tcgroup_inc_frozen_cnt(cgrp);\n\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include \"cgroup-internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include \"cgroup-internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/cgroup.h>\n\nvoid cgroup_enter_frozen(void)\n{\n\tstruct cgroup *cgrp;\n\n\tif (current->frozen)\n\t\treturn;\n\n\tspin_lock_irq(&css_set_lock);\n\tcurrent->frozen = true;\n\tcgrp = task_dfl_cgroup(current);\n\tcgroup_inc_frozen_cnt(cgrp);\n\tcgroup_update_frozen(cgrp);\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_reparented",
          "args": [
            "current"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "current->ptrace"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_clear_jobctl_trapping",
          "args": [
            "current"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "task_clear_jobctl_trapping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "312-319",
          "snippet": "void task_clear_jobctl_trapping(struct task_struct *task)\n{\n\tif (unlikely(task->jobctl & JOBCTL_TRAPPING)) {\n\t\ttask->jobctl &= ~JOBCTL_TRAPPING;\n\t\tsmp_mb();\t/* advised by wake_up_bit() */\n\t\twake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_trapping(struct task_struct *task)\n{\n\tif (unlikely(task->jobctl & JOBCTL_TRAPPING)) {\n\t\ttask->jobctl &= ~JOBCTL_TRAPPING;\n\t\tsmp_mb();\t/* advised by wake_up_bit() */\n\t\twake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_clear_jobctl_pending",
          "args": [
            "current",
            "JOBCTL_TRAP_NOTIFY"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "task_clear_jobctl_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "336-347",
          "snippet": "void task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_participate_group_stop",
          "args": [
            "current"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "task_participate_group_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "365-389",
          "snippet": "static bool task_participate_group_stop(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n\tif (!consume)\n\t\treturn false;\n\n\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))\n\t\tsig->group_stop_count--;\n\n\t/*\n\t * Tell the caller to notify completion iff we are entering into a\n\t * fresh group stop.  Read comment in do_signal_stop() for details.\n\t */\n\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool task_participate_group_stop(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n\tif (!consume)\n\t\treturn false;\n\n\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))\n\t\tsig->group_stop_count--;\n\n\t/*\n\t * Tell the caller to notify completion iff we are entering into a\n\t * fresh group stop.  Read comment in do_signal_stop() for details.\n\t */\n\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_special_state",
          "args": [
            "TASK_TRACED"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_ptrace_stop",
          "args": [],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_ptrace_stop_needed",
          "args": [],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int ptrace_stop(int exit_code, int why, int clear_code,\n\t\t\tunsigned long message, kernel_siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\tbool read_code = true;\n\n\tif (arch_ptrace_stop_needed()) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop();\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t}\n\n\t/*\n\t * schedule() will not sleep if there is a pending signal that\n\t * can awaken the task.\n\t */\n\tset_special_state(TASK_TRACED);\n\n\t/*\n\t * We're committing to trapping.  TRACED should be visible before\n\t * TRAPPING is cleared; otherwise, the tracer might fail do_wait().\n\t * Also, transition to TRACED and updates to ->jobctl should be\n\t * atomic with respect to siglock and should be done after the arch\n\t * hook as siglock is released and regrabbed across it.\n\t *\n\t *     TRACER\t\t\t\t    TRACEE\n\t *\n\t *     ptrace_attach()\n\t * [L]   wait_on_bit(JOBCTL_TRAPPING)\t[S] set_special_state(TRACED)\n\t *     do_wait()\n\t *       set_current_state()                smp_wmb();\n\t *       ptrace_do_wait()\n\t *         wait_task_stopped()\n\t *           task_stopped_code()\n\t * [L]         task_is_traced()\t\t[S] task_clear_jobctl_trapping();\n\t */\n\tsmp_wmb();\n\n\tcurrent->ptrace_message = message;\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/*\n\t * If @why is CLD_STOPPED, we're trapping to participate in a group\n\t * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered\n\t * across siglock relocks since INTERRUPT was scheduled, PENDING\n\t * could be clear now.  We act as if SIGCONT is received after\n\t * TASK_TRACED is entered - ignore it.\n\t */\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t/* any trap clears pending STOP trap, STOP trap clears NOTIFY */\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t/* entering a trap, clear TRAPPING */\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (likely(current->ptrace)) {\n\t\t/*\n\t\t * Notify parents of the stop.\n\t\t *\n\t\t * While ptraced, there are two parents - the ptracer and\n\t\t * the real_parent of the group_leader.  The ptracer should\n\t\t * know about every stop while the real parent is only\n\t\t * interested in the completion of group stop.  The states\n\t\t * for the two don't interact with each other.  Notify\n\t\t * separately unless they're gonna be duplicates.\n\t\t */\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tcgroup_enter_frozen();\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t\tcgroup_leave_frozen(true);\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t *\n\t\t * If @gstop_done, the ptracer went away between group stop\n\t\t * completion and here.  During detach, it would have set\n\t\t * JOBCTL_STOP_PENDING on us and we'll re-enter\n\t\t * TASK_STOPPED in do_signal_stop() on return, so notifying\n\t\t * the real parent of the group stop completion is enough.\n\t\t */\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/* tasklist protects us from ptrace_freeze_traced() */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tread_code = false;\n\t\tif (clear_code)\n\t\t\texit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (read_code)\n\t\texit_code = current->exit_code;\n\tcurrent->last_siginfo = NULL;\n\tcurrent->ptrace_message = 0;\n\tcurrent->exit_code = 0;\n\n\t/* LISTENING can be set only during STOP traps, clear it */\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n\treturn exit_code;\n}"
  },
  {
    "function_name": "do_notify_parent_cldstop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "2125-2181",
    "snippet": "static void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&sighand->siglock",
            "flags"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wake_up_parent",
          "args": [
            "tsk",
            "parent"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "1451-1455",
          "snippet": "void __wake_up_parent(struct task_struct *p, struct task_struct *parent)\n{\n\t__wake_up_sync_key(&parent->signal->wait_chldexit,\n\t\t\t   TASK_INTERRUPTIBLE, p);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __wake_up_parent(struct task_struct *p, struct task_struct *parent)\n{\n\t__wake_up_sync_key(&parent->signal->wait_chldexit,\n\t\t\t   TASK_INTERRUPTIBLE, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__group_send_sig_info",
          "args": [
            "SIGCHLD",
            "&info",
            "parent"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "__group_send_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1284-1288",
          "snippet": "int\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&sighand->siglock",
            "flags"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nsec_to_clock_t",
          "args": [
            "stime"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "nsec_to_clock_t",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "674-688",
          "snippet": "u64 nsec_to_clock_t(u64 x)\n{\n#if (NSEC_PER_SEC % USER_HZ) == 0\n\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);\n#elif (USER_HZ % 512) == 0\n\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t/*\n         * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,\n         * overflow after 64.99 years.\n         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...\n         */\n\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);\n#endif\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nu64 nsec_to_clock_t(u64 x)\n{\n#if (NSEC_PER_SEC % USER_HZ) == 0\n\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);\n#elif (USER_HZ % 512) == 0\n\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t/*\n         * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,\n         * overflow after 64.99 years.\n         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...\n         */\n\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "tsk",
            "&utime",
            "&stime"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "832-870",
          "snippet": "bool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "task_cred_xxx(parent, user_ns)",
            "task_uid(tsk)"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "tsk"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cred_xxx",
          "args": [
            "parent",
            "user_ns"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "tsk",
            "task_active_pid_ns(parent)"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "parent"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "507-510",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}"
  },
  {
    "function_name": "do_notify_parent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "2014-2110",
    "snippet": "bool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\t/* Wake up all pidfd waiters */\n\tdo_notify_pidfd(tsk);\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != READ_ONCE(tsk->parent->self_exec_id))\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\t/*\n\t * Send with __send_signal as si_pid and si_uid are in the\n\t * parent's namespaces.\n\t */\n\tif (valid_signal(sig) && sig)\n\t\t__send_signal(sig, &info, tsk->parent, PIDTYPE_TGID, false);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&psig->siglock",
            "flags"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wake_up_parent",
          "args": [
            "tsk",
            "tsk->parent"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_parent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/exit.c",
          "lines": "1451-1455",
          "snippet": "void __wake_up_parent(struct task_struct *p, struct task_struct *parent)\n{\n\t__wake_up_sync_key(&parent->signal->wait_chldexit,\n\t\t\t   TASK_INTERRUPTIBLE, p);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/task_work.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/kprobes.h>\n#include <linux/io_uring.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/task_work.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __wake_up_parent(struct task_struct *p, struct task_struct *parent)\n{\n\t__wake_up_sync_key(&parent->signal->wait_chldexit,\n\t\t\t   TASK_INTERRUPTIBLE, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__send_signal",
          "args": [
            "sig",
            "&info",
            "tsk->parent",
            "PIDTYPE_TGID",
            "false"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "__send_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1074-1189",
          "snippet": "static int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type, bool force)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, force))\n\t\tgoto ret;\n\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tresult = TRACE_SIGNAL_DELIVERED;\n\t/*\n\t * Skip useless siginfo allocation for SIGKILL and kernel threads.\n\t */\n\tif ((sig == SIGKILL) || (t->flags & PF_KTHREAD))\n\t\tgoto out_set;\n\n\t/*\n\t * Real-time signals must be queued if sent by sigqueue, or\n\t * some other real-time mechanism.  It is implementation\n\t * defined whether kill() does so.  We attempt to do so, on\n\t * the principle of least surprise, but since kill is not\n\t * allowed to fail with EAGAIN when low on memory we just\n\t * make sure at least one signal gets delivered and don't\n\t * pass on the info struct.\n\t */\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, 0);\n\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\trcu_read_lock();\n\t\t\tq->info.si_uid =\n\t\t\t\tfrom_kuid_munged(task_cred_xxx(t, user_ns),\n\t\t\t\t\t\t current_uid());\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tbreak;\n\t\t}\n\t} else if (!is_si_special(info) &&\n\t\t   sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t/*\n\t\t * Queue overflow, abort.  We may abort if the\n\t\t * signal was rt and sent by user using something\n\t\t * other than kill().\n\t\t */\n\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\tret = -EAGAIN;\n\t\tgoto ret;\n\t} else {\n\t\t/*\n\t\t * This is a silent loss of information.  We still\n\t\t * send the signal, but the *info bits are lost.\n\t\t */\n\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\n\t/* Let multiprocess signals appear after on-going forks */\n\tif (type > PIDTYPE_TGID) {\n\t\tstruct multiprocess_signals *delayed;\n\t\thlist_for_each_entry(delayed, &t->signal->multiprocess, node) {\n\t\t\tsigset_t *signal = &delayed->signal;\n\t\t\t/* Can't queue both a stop and a continue signal */\n\t\t\tif (sig == SIGCONT)\n\t\t\t\tsigdelsetmask(signal, SIG_KERNEL_STOP_MASK);\n\t\t\telse if (sig_kernel_stop(sig))\n\t\t\t\tsigdelset(signal, SIGCONT);\n\t\t\tsigaddset(signal, sig);\n\t\t}\n\t}\n\n\tcomplete_signal(sig, t, type);\nret:\n\ttrace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type, bool force)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, force))\n\t\tgoto ret;\n\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tresult = TRACE_SIGNAL_DELIVERED;\n\t/*\n\t * Skip useless siginfo allocation for SIGKILL and kernel threads.\n\t */\n\tif ((sig == SIGKILL) || (t->flags & PF_KTHREAD))\n\t\tgoto out_set;\n\n\t/*\n\t * Real-time signals must be queued if sent by sigqueue, or\n\t * some other real-time mechanism.  It is implementation\n\t * defined whether kill() does so.  We attempt to do so, on\n\t * the principle of least surprise, but since kill is not\n\t * allowed to fail with EAGAIN when low on memory we just\n\t * make sure at least one signal gets delivered and don't\n\t * pass on the info struct.\n\t */\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, 0);\n\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\trcu_read_lock();\n\t\t\tq->info.si_uid =\n\t\t\t\tfrom_kuid_munged(task_cred_xxx(t, user_ns),\n\t\t\t\t\t\t current_uid());\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tbreak;\n\t\t}\n\t} else if (!is_si_special(info) &&\n\t\t   sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t/*\n\t\t * Queue overflow, abort.  We may abort if the\n\t\t * signal was rt and sent by user using something\n\t\t * other than kill().\n\t\t */\n\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\tret = -EAGAIN;\n\t\tgoto ret;\n\t} else {\n\t\t/*\n\t\t * This is a silent loss of information.  We still\n\t\t * send the signal, but the *info bits are lost.\n\t\t */\n\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\n\t/* Let multiprocess signals appear after on-going forks */\n\tif (type > PIDTYPE_TGID) {\n\t\tstruct multiprocess_signals *delayed;\n\t\thlist_for_each_entry(delayed, &t->signal->multiprocess, node) {\n\t\t\tsigset_t *signal = &delayed->signal;\n\t\t\t/* Can't queue both a stop and a continue signal */\n\t\t\tif (sig == SIGCONT)\n\t\t\t\tsigdelsetmask(signal, SIG_KERNEL_STOP_MASK);\n\t\t\telse if (sig_kernel_stop(sig))\n\t\t\t\tsigdelset(signal, SIGCONT);\n\t\t\tsigaddset(signal, sig);\n\t\t}\n\t}\n\n\tcomplete_signal(sig, t, type);\nret:\n\ttrace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_signal",
          "args": [
            "sig"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&psig->siglock",
            "flags"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsec_to_clock_t",
          "args": [
            "stime + tsk->signal->stime"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "nsec_to_clock_t",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "674-688",
          "snippet": "u64 nsec_to_clock_t(u64 x)\n{\n#if (NSEC_PER_SEC % USER_HZ) == 0\n\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);\n#elif (USER_HZ % 512) == 0\n\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t/*\n         * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,\n         * overflow after 64.99 years.\n         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...\n         */\n\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);\n#endif\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nu64 nsec_to_clock_t(u64 x)\n{\n#if (NSEC_PER_SEC % USER_HZ) == 0\n\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);\n#elif (USER_HZ % 512) == 0\n\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t/*\n         * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,\n         * overflow after 64.99 years.\n         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...\n         */\n\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "tsk",
            "&utime",
            "&stime"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "832-870",
          "snippet": "bool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\tint ret;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn false;\n\t}\n\n\tdo {\n\t\tret = false;\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping or idle, nothing to add */\n\t\tif (vtime->state < VTIME_SYS)\n\t\t\tcontinue;\n\n\t\tret = true;\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user (including guest) or kernel space,\n\t\t * add pending nohz time to the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t\telse\n\t\t\t*utime += vtime->utime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "task_cred_xxx(tsk->parent, user_ns)",
            "task_uid(tsk)"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "tsk"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cred_xxx",
          "args": [
            "tsk->parent",
            "user_ns"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "tsk",
            "task_active_pid_ns(tsk->parent)"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "tsk->parent"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "507-510",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "tsk->parent->self_exec_id"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_notify_pidfd",
          "args": [
            "tsk"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_pidfd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1998-2005",
          "snippet": "static void do_notify_pidfd(struct task_struct *task)\n{\n\tstruct pid *pid;\n\n\tWARN_ON(task->exit_state == 0);\n\tpid = task_pid(task);\n\twake_up_all(&pid->wait_pidfd);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void do_notify_pidfd(struct task_struct *task)\n{\n\tstruct pid *pid;\n\n\tWARN_ON(task->exit_state == 0);\n\tpid = task_pid(task);\n\twake_up_all(&pid->wait_pidfd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk))"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "tsk"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "task_is_stopped_or_traced(tsk)"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_is_stopped_or_traced",
          "args": [
            "tsk"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sig == -1"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\t/* Wake up all pidfd waiters */\n\tdo_notify_pidfd(tsk);\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != READ_ONCE(tsk->parent->self_exec_id))\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\t/*\n\t * Send with __send_signal as si_pid and si_uid are in the\n\t * parent's namespaces.\n\t */\n\tif (valid_signal(sig) && sig)\n\t\t__send_signal(sig, &info, tsk->parent, PIDTYPE_TGID, false);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}"
  },
  {
    "function_name": "do_notify_pidfd",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1998-2005",
    "snippet": "static void do_notify_pidfd(struct task_struct *task)\n{\n\tstruct pid *pid;\n\n\tWARN_ON(task->exit_state == 0);\n\tpid = task_pid(task);\n\twake_up_all(&pid->wait_pidfd);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&pid->wait_pidfd"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/swait.c",
          "lines": "62-82",
          "snippet": "void swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid",
          "args": [
            "task"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "init_task_pid_links",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1710-1716",
          "snippet": "static inline void init_task_pid_links(struct task_struct *task)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type)\n\t\tINIT_HLIST_NODE(&task->pid_links[type]);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic inline void init_task_pid_links(struct task_struct *task)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type)\n\t\tINIT_HLIST_NODE(&task->pid_links[type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "task->exit_state == 0"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void do_notify_pidfd(struct task_struct *task)\n{\n\tstruct pid *pid;\n\n\tWARN_ON(task->exit_state == 0);\n\tpid = task_pid(task);\n\twake_up_all(&pid->wait_pidfd);\n}"
  },
  {
    "function_name": "send_sigqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1950-1996",
    "snippet": "int send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tint ret, result;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n\tret = -1;\n\trcu_read_lock();\n\tt = pid_task(pid, type);\n\tif (!t || !likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\n\tret = 1; /* the signal is ignored */\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, false))\n\t\tgoto out;\n\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\t/*\n\t\t * If an SI_TIMER entry is already queue just increment\n\t\t * the overrun count.\n\t\t */\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\n\tsignalfd_notify(t, sig);\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, type);\n\tresult = TRACE_SIGNAL_DELIVERED;\nout:\n\ttrace_signal_generate(sig, &q->info, t, type != PIDTYPE_PID, result);\n\tunlock_task_sighand(t, &flags);\nret:\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "t",
            "&flags"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_signal_generate",
          "args": [
            "sig",
            "&q->info",
            "t",
            "type != PIDTYPE_PID",
            "result"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete_signal",
          "args": [
            "sig",
            "t",
            "type"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "complete_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "993-1067",
          "snippet": "static void complete_signal(int sig, struct task_struct *p, enum pid_type type)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\n\t/*\n\t * Now find a thread we can wake up to take the signal off the queue.\n\t *\n\t * If the main thread wants the signal, it gets first crack.\n\t * Probably the least surprising to the average bear.\n\t */\n\tif (wants_signal(sig, p))\n\t\tt = p;\n\telse if ((type == PIDTYPE_PID) || thread_group_empty(p))\n\t\t/*\n\t\t * There is just one thread and it does not need to be woken.\n\t\t * It will dequeue unblocked signals before it runs again.\n\t\t */\n\t\treturn;\n\telse {\n\t\t/*\n\t\t * Otherwise try to find a suitable thread.\n\t\t */\n\t\tt = signal->curr_target;\n\t\twhile (!wants_signal(sig, t)) {\n\t\t\tt = next_thread(t);\n\t\t\tif (t == signal->curr_target)\n\t\t\t\t/*\n\t\t\t\t * No thread needs to be woken.\n\t\t\t\t * Any eligible threads will see\n\t\t\t\t * the signal in the queue soon.\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t}\n\t\tsignal->curr_target = t;\n\t}\n\n\t/*\n\t * Found a killable thread.  If the signal will be fatal,\n\t * then start taking the whole group down immediately.\n\t */\n\tif (sig_fatal(p, sig) &&\n\t    (signal->core_state || !(signal->flags & SIGNAL_GROUP_EXIT)) &&\n\t    !sigismember(&t->real_blocked, sig) &&\n\t    (sig == SIGKILL || !p->ptrace)) {\n\t\t/*\n\t\t * This signal will be fatal to the whole group.\n\t\t */\n\t\tif (!sig_kernel_coredump(sig)) {\n\t\t\t/*\n\t\t\t * Start a group exit and wake everybody up.\n\t\t\t * This way we don't have other threads\n\t\t\t * running and doing things after a slower\n\t\t\t * thread has the fatal signal pending.\n\t\t\t */\n\t\t\tsignal->flags = SIGNAL_GROUP_EXIT;\n\t\t\tsignal->group_exit_code = sig;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\t\tsignal_wake_up(t, 1);\n\t\t\t} while_each_thread(p, t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * The signal is already in the shared-pending queue.\n\t * Tell the chosen thread to wake up and dequeue it.\n\t */\n\tsignal_wake_up(t, sig == SIGKILL);\n\treturn;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void complete_signal(int sig, struct task_struct *p, enum pid_type type)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\n\t/*\n\t * Now find a thread we can wake up to take the signal off the queue.\n\t *\n\t * If the main thread wants the signal, it gets first crack.\n\t * Probably the least surprising to the average bear.\n\t */\n\tif (wants_signal(sig, p))\n\t\tt = p;\n\telse if ((type == PIDTYPE_PID) || thread_group_empty(p))\n\t\t/*\n\t\t * There is just one thread and it does not need to be woken.\n\t\t * It will dequeue unblocked signals before it runs again.\n\t\t */\n\t\treturn;\n\telse {\n\t\t/*\n\t\t * Otherwise try to find a suitable thread.\n\t\t */\n\t\tt = signal->curr_target;\n\t\twhile (!wants_signal(sig, t)) {\n\t\t\tt = next_thread(t);\n\t\t\tif (t == signal->curr_target)\n\t\t\t\t/*\n\t\t\t\t * No thread needs to be woken.\n\t\t\t\t * Any eligible threads will see\n\t\t\t\t * the signal in the queue soon.\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t}\n\t\tsignal->curr_target = t;\n\t}\n\n\t/*\n\t * Found a killable thread.  If the signal will be fatal,\n\t * then start taking the whole group down immediately.\n\t */\n\tif (sig_fatal(p, sig) &&\n\t    (signal->core_state || !(signal->flags & SIGNAL_GROUP_EXIT)) &&\n\t    !sigismember(&t->real_blocked, sig) &&\n\t    (sig == SIGKILL || !p->ptrace)) {\n\t\t/*\n\t\t * This signal will be fatal to the whole group.\n\t\t */\n\t\tif (!sig_kernel_coredump(sig)) {\n\t\t\t/*\n\t\t\t * Start a group exit and wake everybody up.\n\t\t\t * This way we don't have other threads\n\t\t\t * running and doing things after a slower\n\t\t\t * thread has the fatal signal pending.\n\t\t\t */\n\t\t\tsignal->flags = SIGNAL_GROUP_EXIT;\n\t\t\tsignal->group_exit_code = sig;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\t\tsignal_wake_up(t, 1);\n\t\t\t} while_each_thread(p, t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * The signal is already in the shared-pending queue.\n\t * Tell the chosen thread to wake up and dequeue it.\n\t */\n\tsignal_wake_up(t, sig == SIGKILL);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&pending->signal",
            "sig"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&q->list",
            "&pending->list"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signalfd_notify",
          "args": [
            "t",
            "sig"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "q->info.si_code != SI_TIMER"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!list_empty(&q->list)"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&q->list"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_signal",
          "args": [
            "sig",
            "t",
            "false"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "903-966",
          "snippet": "static bool prepare_signal(int sig, struct task_struct *p, bool force)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\tsigset_t flush;\n\n\tif (signal->flags & SIGNAL_GROUP_EXIT) {\n\t\tif (signal->core_state)\n\t\t\treturn sig == SIGKILL;\n\t\t/*\n\t\t * The process is in the middle of dying, nothing to do.\n\t\t */\n\t} else if (sig_kernel_stop(sig)) {\n\t\t/*\n\t\t * This is a stop signal.  Remove SIGCONT from all queues.\n\t\t */\n\t\tsiginitset(&flush, sigmask(SIGCONT));\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t)\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t} else if (sig == SIGCONT) {\n\t\tunsigned int why;\n\t\t/*\n\t\t * Remove all stop signals from all queues, wake all threads.\n\t\t */\n\t\tsiginitset(&flush, SIG_KERNEL_STOP_MASK);\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t) {\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t\t\ttask_clear_jobctl_pending(t, JOBCTL_STOP_PENDING);\n\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\twake_up_state(t, __TASK_STOPPED);\n\t\t\telse\n\t\t\t\tptrace_trap_notify(t);\n\t\t}\n\n\t\t/*\n\t\t * Notify the parent with CLD_CONTINUED if we were stopped.\n\t\t *\n\t\t * If we were in the middle of a group stop, we pretend it\n\t\t * was already finished, and then continued. Since SIGCHLD\n\t\t * doesn't queue we report only CLD_STOPPED, as if the next\n\t\t * CLD_CONTINUED was dropped.\n\t\t */\n\t\twhy = 0;\n\t\tif (signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\twhy |= SIGNAL_CLD_CONTINUED;\n\t\telse if (signal->group_stop_count)\n\t\t\twhy |= SIGNAL_CLD_STOPPED;\n\n\t\tif (why) {\n\t\t\t/*\n\t\t\t * The first thread which returns from do_signal_stop()\n\t\t\t * will take ->siglock, notice SIGNAL_CLD_MASK, and\n\t\t\t * notify its parent. See get_signal().\n\t\t\t */\n\t\t\tsignal_set_stop_flags(signal, why | SIGNAL_STOP_CONTINUED);\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tsignal->group_exit_code = 0;\n\t\t}\n\t}\n\n\treturn !sig_ignored(p, sig, force);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool prepare_signal(int sig, struct task_struct *p, bool force)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\tsigset_t flush;\n\n\tif (signal->flags & SIGNAL_GROUP_EXIT) {\n\t\tif (signal->core_state)\n\t\t\treturn sig == SIGKILL;\n\t\t/*\n\t\t * The process is in the middle of dying, nothing to do.\n\t\t */\n\t} else if (sig_kernel_stop(sig)) {\n\t\t/*\n\t\t * This is a stop signal.  Remove SIGCONT from all queues.\n\t\t */\n\t\tsiginitset(&flush, sigmask(SIGCONT));\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t)\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t} else if (sig == SIGCONT) {\n\t\tunsigned int why;\n\t\t/*\n\t\t * Remove all stop signals from all queues, wake all threads.\n\t\t */\n\t\tsiginitset(&flush, SIG_KERNEL_STOP_MASK);\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t) {\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t\t\ttask_clear_jobctl_pending(t, JOBCTL_STOP_PENDING);\n\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\twake_up_state(t, __TASK_STOPPED);\n\t\t\telse\n\t\t\t\tptrace_trap_notify(t);\n\t\t}\n\n\t\t/*\n\t\t * Notify the parent with CLD_CONTINUED if we were stopped.\n\t\t *\n\t\t * If we were in the middle of a group stop, we pretend it\n\t\t * was already finished, and then continued. Since SIGCHLD\n\t\t * doesn't queue we report only CLD_STOPPED, as if the next\n\t\t * CLD_CONTINUED was dropped.\n\t\t */\n\t\twhy = 0;\n\t\tif (signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\twhy |= SIGNAL_CLD_CONTINUED;\n\t\telse if (signal->group_stop_count)\n\t\t\twhy |= SIGNAL_CLD_STOPPED;\n\n\t\tif (why) {\n\t\t\t/*\n\t\t\t * The first thread which returns from do_signal_stop()\n\t\t\t * will take ->siglock, notice SIGNAL_CLD_MASK, and\n\t\t\t * notify its parent. See get_signal().\n\t\t\t */\n\t\t\tsignal_set_stop_flags(signal, why | SIGNAL_STOP_CONTINUED);\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tsignal->group_exit_code = 0;\n\t\t}\n\t}\n\n\treturn !sig_ignored(p, sig, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "lock_task_sighand(t, &flags)"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "t",
            "&flags"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1384-1414",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid",
            "type"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "448-457",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(q->flags & SIGQUEUE_PREALLOC)"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tint ret, result;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n\tret = -1;\n\trcu_read_lock();\n\tt = pid_task(pid, type);\n\tif (!t || !likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\n\tret = 1; /* the signal is ignored */\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, false))\n\t\tgoto out;\n\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\t/*\n\t\t * If an SI_TIMER entry is already queue just increment\n\t\t * the overrun count.\n\t\t */\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\n\tsignalfd_notify(t, sig);\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, type);\n\tresult = TRACE_SIGNAL_DELIVERED;\nout:\n\ttrace_signal_generate(sig, &q->info, t, type != PIDTYPE_PID, result);\n\tunlock_task_sighand(t, &flags);\nret:\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "sigqueue_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1925-1948",
    "snippet": "void sigqueue_free(struct sigqueue *q)\n{\n\tunsigned long flags;\n\tspinlock_t *lock = &current->sighand->siglock;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\t/*\n\t * We must hold ->siglock while testing q->list\n\t * to serialize with collect_signal() or with\n\t * __exit_signal()->flush_sigqueue().\n\t */\n\tspin_lock_irqsave(lock, flags);\n\tq->flags &= ~SIGQUEUE_PREALLOC;\n\t/*\n\t * If it is queued it will be freed when dequeued,\n\t * like the \"regular\" sigqueue.\n\t */\n\tif (!list_empty(&q->list))\n\t\tq = NULL;\n\tspin_unlock_irqrestore(lock, flags);\n\n\tif (q)\n\t\t__sigqueue_free(q);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sigqueue_free",
          "args": [
            "q"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "__sigqueue_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "450-459",
          "snippet": "static void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tif (q->ucounts) {\n\t\tdec_rlimit_put_ucounts(q->ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t\tq->ucounts = NULL;\n\t}\n\tkmem_cache_free(sigqueue_cachep, q);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sigqueue_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tif (q->ucounts) {\n\t\tdec_rlimit_put_ucounts(q->ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t\tq->ucounts = NULL;\n\t}\n\tkmem_cache_free(sigqueue_cachep, q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "lock",
            "flags"
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&q->list"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "lock",
            "flags"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(q->flags & SIGQUEUE_PREALLOC)"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid sigqueue_free(struct sigqueue *q)\n{\n\tunsigned long flags;\n\tspinlock_t *lock = &current->sighand->siglock;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\t/*\n\t * We must hold ->siglock while testing q->list\n\t * to serialize with collect_signal() or with\n\t * __exit_signal()->flush_sigqueue().\n\t */\n\tspin_lock_irqsave(lock, flags);\n\tq->flags &= ~SIGQUEUE_PREALLOC;\n\t/*\n\t * If it is queued it will be freed when dequeued,\n\t * like the \"regular\" sigqueue.\n\t */\n\tif (!list_empty(&q->list))\n\t\tq = NULL;\n\tspin_unlock_irqrestore(lock, flags);\n\n\tif (q)\n\t\t__sigqueue_free(q);\n}"
  },
  {
    "function_name": "sigqueue_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1920-1923",
    "snippet": "struct sigqueue *sigqueue_alloc(void)\n{\n\treturn __sigqueue_alloc(-1, current, GFP_KERNEL, 0, SIGQUEUE_PREALLOC);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sigqueue_alloc",
          "args": [
            "-1",
            "current",
            "GFP_KERNEL",
            "0",
            "SIGQUEUE_PREALLOC"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "__sigqueue_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "411-448",
          "snippet": "static struct sigqueue *\n__sigqueue_alloc(int sig, struct task_struct *t, gfp_t gfp_flags,\n\t\t int override_rlimit, const unsigned int sigqueue_flags)\n{\n\tstruct sigqueue *q = NULL;\n\tstruct ucounts *ucounts = NULL;\n\tlong sigpending;\n\n\t/*\n\t * Protect access to @t credentials. This can go away when all\n\t * callers hold rcu read lock.\n\t *\n\t * NOTE! A pending signal will hold on to the user refcount,\n\t * and we get/put the refcount only when the sigpending count\n\t * changes from/to zero.\n\t */\n\trcu_read_lock();\n\tucounts = task_ucounts(t);\n\tsigpending = inc_rlimit_get_ucounts(ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\trcu_read_unlock();\n\tif (!sigpending)\n\t\treturn NULL;\n\n\tif (override_rlimit || likely(sigpending <= task_rlimit(t, RLIMIT_SIGPENDING))) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, gfp_flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\n\tif (unlikely(q == NULL)) {\n\t\tdec_rlimit_put_ucounts(ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t} else {\n\t\tINIT_LIST_HEAD(&q->list);\n\t\tq->flags = sigqueue_flags;\n\t\tq->ucounts = ucounts;\n\t}\n\treturn q;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sigqueue_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic struct sigqueue *\n__sigqueue_alloc(int sig, struct task_struct *t, gfp_t gfp_flags,\n\t\t int override_rlimit, const unsigned int sigqueue_flags)\n{\n\tstruct sigqueue *q = NULL;\n\tstruct ucounts *ucounts = NULL;\n\tlong sigpending;\n\n\t/*\n\t * Protect access to @t credentials. This can go away when all\n\t * callers hold rcu read lock.\n\t *\n\t * NOTE! A pending signal will hold on to the user refcount,\n\t * and we get/put the refcount only when the sigpending count\n\t * changes from/to zero.\n\t */\n\trcu_read_lock();\n\tucounts = task_ucounts(t);\n\tsigpending = inc_rlimit_get_ucounts(ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\trcu_read_unlock();\n\tif (!sigpending)\n\t\treturn NULL;\n\n\tif (override_rlimit || likely(sigpending <= task_rlimit(t, RLIMIT_SIGPENDING))) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, gfp_flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\n\tif (unlikely(q == NULL)) {\n\t\tdec_rlimit_put_ucounts(ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t} else {\n\t\tINIT_LIST_HEAD(&q->list);\n\t\tq->flags = sigqueue_flags;\n\t\tq->ucounts = ucounts;\n\t}\n\treturn q;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sigqueue *sigqueue_alloc(void)\n{\n\treturn __sigqueue_alloc(-1, current, GFP_KERNEL, 0, SIGQUEUE_PREALLOC);\n}"
  },
  {
    "function_name": "kill_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1905-1908",
    "snippet": "int kill_pid(struct pid *pid, int sig, int priv)\n{\n\treturn kill_pid_info(sig, __si_special(priv), pid);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_pid_info",
          "args": [
            "sig",
            "__si_special(priv)",
            "pid"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "kill_pid_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1469-1489",
          "snippet": "int kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__si_special",
          "args": [
            "priv"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint kill_pid(struct pid *pid, int sig, int priv)\n{\n\treturn kill_pid_info(sig, __si_special(priv), pid);\n}"
  },
  {
    "function_name": "kill_pgrp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1893-1902",
    "snippet": "int kill_pgrp(struct pid *pid, int sig, int priv)\n{\n\tint ret;\n\n\tread_lock(&tasklist_lock);\n\tret = __kill_pgrp_info(sig, __si_special(priv), pid);\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kill_pgrp_info",
          "args": [
            "sig",
            "__si_special(priv)",
            "pid"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "__kill_pgrp_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1454-1467",
          "snippet": "int __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__si_special",
          "args": [
            "priv"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint kill_pgrp(struct pid *pid, int sig, int priv)\n{\n\tint ret;\n\n\tread_lock(&tasklist_lock);\n\tret = __kill_pgrp_info(sig, __si_special(priv), pid);\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "send_sig_fault_trapno",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1879-1891",
    "snippet": "int send_sig_fault_trapno(int sig, int code, void __user *addr, int trapno,\n\t\t\t  struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = code;\n\tinfo.si_addr  = addr;\n\tinfo.si_trapno = trapno;\n\treturn send_sig_info(info.si_signo, &info, t);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_sig_info",
          "args": [
            "info.si_signo",
            "&info",
            "t"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "send_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1627-1637",
          "snippet": "int send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint send_sig_fault_trapno(int sig, int code, void __user *addr, int trapno,\n\t\t\t  struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = code;\n\tinfo.si_addr  = addr;\n\tinfo.si_trapno = trapno;\n\treturn send_sig_info(info.si_signo, &info, t);\n}"
  },
  {
    "function_name": "force_sig_fault_trapno",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1863-1874",
    "snippet": "int force_sig_fault_trapno(int sig, int code, void __user *addr, int trapno)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = code;\n\tinfo.si_addr  = addr;\n\tinfo.si_trapno = trapno;\n\treturn force_sig_info(&info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "&info"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1355-1358",
          "snippet": "int force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault_trapno(int sig, int code, void __user *addr, int trapno)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = code;\n\tinfo.si_addr  = addr;\n\tinfo.si_trapno = trapno;\n\treturn force_sig_info(&info);\n}"
  },
  {
    "function_name": "force_sig_ptrace_errno_trap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1848-1858",
    "snippet": "int force_sig_ptrace_errno_trap(int errno, void __user *addr)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = errno;\n\tinfo.si_code  = TRAP_HWBKPT;\n\tinfo.si_addr  = addr;\n\treturn force_sig_info(&info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "&info"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1355-1358",
          "snippet": "int force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_ptrace_errno_trap(int errno, void __user *addr)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = errno;\n\tinfo.si_code  = TRAP_HWBKPT;\n\tinfo.si_addr  = addr;\n\treturn force_sig_info(&info);\n}"
  },
  {
    "function_name": "force_sig_seccomp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1830-1843",
    "snippet": "int force_sig_seccomp(int syscall, int reason, bool force_coredump)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSYS;\n\tinfo.si_code = SYS_SECCOMP;\n\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);\n\tinfo.si_errno = reason;\n\tinfo.si_arch = syscall_get_arch(current);\n\tinfo.si_syscall = syscall;\n\treturn force_sig_info_to_task(&info, current,\n\t\tforce_coredump ? HANDLER_EXIT : HANDLER_CURRENT);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info_to_task",
          "args": [
            "&info",
            "current",
            "force_coredump ? HANDLER_EXIT : HANDLER_CURRENT"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info_to_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1321-1353",
          "snippet": "static int\nforce_sig_info_to_task(struct kernel_siginfo *info, struct task_struct *t,\n\tenum sig_handler handler)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\tint sig = info->si_signo;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored || (handler != HANDLER_CURRENT)) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (handler == HANDLER_EXIT)\n\t\t\taction->sa.sa_flags |= SA_IMMUTABLE;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int\nforce_sig_info_to_task(struct kernel_siginfo *info, struct task_struct *t,\n\tenum sig_handler handler)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\tint sig = info->si_signo;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored || (handler != HANDLER_CURRENT)) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (handler == HANDLER_EXIT)\n\t\t\taction->sa.sa_flags |= SA_IMMUTABLE;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_arch",
          "args": [
            "current"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KSTK_EIP",
          "args": [
            "current"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_seccomp(int syscall, int reason, bool force_coredump)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSYS;\n\tinfo.si_code = SYS_SECCOMP;\n\tinfo.si_call_addr = (void __user *)KSTK_EIP(current);\n\tinfo.si_errno = reason;\n\tinfo.si_arch = syscall_get_arch(current);\n\tinfo.si_syscall = syscall;\n\treturn force_sig_info_to_task(&info, current,\n\t\tforce_coredump ? HANDLER_EXIT : HANDLER_CURRENT);\n}"
  },
  {
    "function_name": "force_sig_perf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1807-1820",
    "snippet": "int force_sig_perf(void __user *addr, u32 type, u64 sig_data)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo     = SIGTRAP;\n\tinfo.si_errno     = 0;\n\tinfo.si_code      = TRAP_PERF;\n\tinfo.si_addr      = addr;\n\tinfo.si_perf_data = sig_data;\n\tinfo.si_perf_type = type;\n\n\treturn force_sig_info(&info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "&info"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1355-1358",
          "snippet": "int force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_perf(void __user *addr, u32 type, u64 sig_data)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo     = SIGTRAP;\n\tinfo.si_errno     = 0;\n\tinfo.si_code      = TRAP_PERF;\n\tinfo.si_addr      = addr;\n\tinfo.si_perf_data = sig_data;\n\tinfo.si_perf_type = type;\n\n\treturn force_sig_info(&info);\n}"
  },
  {
    "function_name": "force_sig_pkuerr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1793-1804",
    "snippet": "int force_sig_pkuerr(void __user *addr, u32 pkey)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSEGV;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = SEGV_PKUERR;\n\tinfo.si_addr  = addr;\n\tinfo.si_pkey  = pkey;\n\treturn force_sig_info(&info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "&info"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1355-1358",
          "snippet": "int force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_pkuerr(void __user *addr, u32 pkey)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSEGV;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = SEGV_PKUERR;\n\tinfo.si_addr  = addr;\n\tinfo.si_pkey  = pkey;\n\treturn force_sig_info(&info);\n}"
  },
  {
    "function_name": "force_sig_bnderr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1778-1790",
    "snippet": "int force_sig_bnderr(void __user *addr, void __user *lower, void __user *upper)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSEGV;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = SEGV_BNDERR;\n\tinfo.si_addr  = addr;\n\tinfo.si_lower = lower;\n\tinfo.si_upper = upper;\n\treturn force_sig_info(&info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "&info"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1355-1358",
          "snippet": "int force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_bnderr(void __user *addr, void __user *lower, void __user *upper)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSEGV;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = SEGV_BNDERR;\n\tinfo.si_addr  = addr;\n\tinfo.si_lower = lower;\n\tinfo.si_upper = upper;\n\treturn force_sig_info(&info);\n}"
  },
  {
    "function_name": "send_sig_mceerr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1763-1775",
    "snippet": "int send_sig_mceerr(int code, void __user *addr, short lsb, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\n\tWARN_ON((code != BUS_MCEERR_AO) && (code != BUS_MCEERR_AR));\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGBUS;\n\tinfo.si_errno = 0;\n\tinfo.si_code = code;\n\tinfo.si_addr = addr;\n\tinfo.si_addr_lsb = lsb;\n\treturn send_sig_info(info.si_signo, &info, t);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_sig_info",
          "args": [
            "info.si_signo",
            "&info",
            "t"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "send_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1627-1637",
          "snippet": "int send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "(code != BUS_MCEERR_AO) && (code != BUS_MCEERR_AR)"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint send_sig_mceerr(int code, void __user *addr, short lsb, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\n\tWARN_ON((code != BUS_MCEERR_AO) && (code != BUS_MCEERR_AR));\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGBUS;\n\tinfo.si_errno = 0;\n\tinfo.si_code = code;\n\tinfo.si_addr = addr;\n\tinfo.si_addr_lsb = lsb;\n\treturn send_sig_info(info.si_signo, &info, t);\n}"
  },
  {
    "function_name": "force_sig_mceerr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1749-1761",
    "snippet": "int force_sig_mceerr(int code, void __user *addr, short lsb)\n{\n\tstruct kernel_siginfo info;\n\n\tWARN_ON((code != BUS_MCEERR_AO) && (code != BUS_MCEERR_AR));\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGBUS;\n\tinfo.si_errno = 0;\n\tinfo.si_code = code;\n\tinfo.si_addr = addr;\n\tinfo.si_addr_lsb = lsb;\n\treturn force_sig_info(&info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "&info"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1355-1358",
          "snippet": "int force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "(code != BUS_MCEERR_AO) && (code != BUS_MCEERR_AR)"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_mceerr(int code, void __user *addr, short lsb)\n{\n\tstruct kernel_siginfo info;\n\n\tWARN_ON((code != BUS_MCEERR_AO) && (code != BUS_MCEERR_AR));\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGBUS;\n\tinfo.si_errno = 0;\n\tinfo.si_code = code;\n\tinfo.si_addr = addr;\n\tinfo.si_addr_lsb = lsb;\n\treturn force_sig_info(&info);\n}"
  },
  {
    "function_name": "send_sig_fault",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1730-1747",
    "snippet": "int send_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = code;\n\tinfo.si_addr  = addr;\n#ifdef __ia64__\n\tinfo.si_imm = imm;\n\tinfo.si_flags = flags;\n\tinfo.si_isr = isr;\n#endif\n\treturn send_sig_info(info.si_signo, &info, t);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_sig_info",
          "args": [
            "info.si_signo",
            "&info",
            "t"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "send_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1627-1637",
          "snippet": "int send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint send_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = code;\n\tinfo.si_addr  = addr;\n#ifdef __ia64__\n\tinfo.si_imm = imm;\n\tinfo.si_flags = flags;\n\tinfo.si_isr = isr;\n#endif\n\treturn send_sig_info(info.si_signo, &info, t);\n}"
  },
  {
    "function_name": "force_sig_fault",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1723-1728",
    "snippet": "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr))\n{\n\treturn force_sig_fault_to_task(sig, code, addr\n\t\t\t\t       ___ARCH_SI_IA64(imm, flags, isr), current);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_fault_to_task",
          "args": [
            "sig",
            "code",
            "addr___ARCH_SI_IA64(imm, flags, isr)",
            "current"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_fault_to_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1704-1721",
          "snippet": "int force_sig_fault_to_task(int sig, int code, void __user *addr\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = code;\n\tinfo.si_addr  = addr;\n#ifdef __ia64__\n\tinfo.si_imm = imm;\n\tinfo.si_flags = flags;\n\tinfo.si_isr = isr;\n#endif\n\treturn force_sig_info_to_task(&info, t, HANDLER_CURRENT);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault_to_task(int sig, int code, void __user *addr\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = code;\n\tinfo.si_addr  = addr;\n#ifdef __ia64__\n\tinfo.si_imm = imm;\n\tinfo.si_flags = flags;\n\tinfo.si_isr = isr;\n#endif\n\treturn force_sig_info_to_task(&info, t, HANDLER_CURRENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "___ARCH_SI_IA64",
          "args": [
            "imm",
            "flags",
            "isr"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr))\n{\n\treturn force_sig_fault_to_task(sig, code, addr\n\t\t\t\t       ___ARCH_SI_IA64(imm, flags, isr), current);\n}"
  },
  {
    "function_name": "force_sig_fault_to_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1704-1721",
    "snippet": "int force_sig_fault_to_task(int sig, int code, void __user *addr\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = code;\n\tinfo.si_addr  = addr;\n#ifdef __ia64__\n\tinfo.si_imm = imm;\n\tinfo.si_flags = flags;\n\tinfo.si_isr = isr;\n#endif\n\treturn force_sig_info_to_task(&info, t, HANDLER_CURRENT);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info_to_task",
          "args": [
            "&info",
            "t",
            "HANDLER_CURRENT"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info_to_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1321-1353",
          "snippet": "static int\nforce_sig_info_to_task(struct kernel_siginfo *info, struct task_struct *t,\n\tenum sig_handler handler)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\tint sig = info->si_signo;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored || (handler != HANDLER_CURRENT)) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (handler == HANDLER_EXIT)\n\t\t\taction->sa.sa_flags |= SA_IMMUTABLE;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int\nforce_sig_info_to_task(struct kernel_siginfo *info, struct task_struct *t,\n\tenum sig_handler handler)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\tint sig = info->si_signo;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored || (handler != HANDLER_CURRENT)) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (handler == HANDLER_EXIT)\n\t\t\taction->sa.sa_flags |= SA_IMMUTABLE;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault_to_task(int sig, int code, void __user *addr\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = code;\n\tinfo.si_addr  = addr;\n#ifdef __ia64__\n\tinfo.si_imm = imm;\n\tinfo.si_flags = flags;\n\tinfo.si_isr = isr;\n#endif\n\treturn force_sig_info_to_task(&info, t, HANDLER_CURRENT);\n}"
  },
  {
    "function_name": "force_sigsegv",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1696-1702",
    "snippet": "void force_sigsegv(int sig)\n{\n\tif (sig == SIGSEGV)\n\t\tforce_fatal_sig(SIGSEGV);\n\telse\n\t\tforce_sig(SIGSEGV);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig",
          "args": [
            "SIGSEGV"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "force_sigsegv",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1696-1702",
          "snippet": "void force_sigsegv(int sig)\n{\n\tif (sig == SIGSEGV)\n\t\tforce_fatal_sig(SIGSEGV);\n\telse\n\t\tforce_sig(SIGSEGV);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "force_fatal_sig",
          "args": [
            "SIGSEGV"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "force_fatal_sig",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1664-1675",
          "snippet": "void force_fatal_sig(int sig)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_KERNEL;\n\tinfo.si_pid = 0;\n\tinfo.si_uid = 0;\n\tforce_sig_info_to_task(&info, current, HANDLER_SIG_DFL);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid force_fatal_sig(int sig)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_KERNEL;\n\tinfo.si_pid = 0;\n\tinfo.si_uid = 0;\n\tforce_sig_info_to_task(&info, current, HANDLER_SIG_DFL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid force_sigsegv(int sig)\n{\n\tif (sig == SIGSEGV)\n\t\tforce_fatal_sig(SIGSEGV);\n\telse\n\t\tforce_sig(SIGSEGV);\n}"
  },
  {
    "function_name": "force_exit_sig",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1677-1688",
    "snippet": "void force_exit_sig(int sig)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_KERNEL;\n\tinfo.si_pid = 0;\n\tinfo.si_uid = 0;\n\tforce_sig_info_to_task(&info, current, HANDLER_EXIT);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info_to_task",
          "args": [
            "&info",
            "current",
            "HANDLER_EXIT"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info_to_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1321-1353",
          "snippet": "static int\nforce_sig_info_to_task(struct kernel_siginfo *info, struct task_struct *t,\n\tenum sig_handler handler)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\tint sig = info->si_signo;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored || (handler != HANDLER_CURRENT)) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (handler == HANDLER_EXIT)\n\t\t\taction->sa.sa_flags |= SA_IMMUTABLE;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int\nforce_sig_info_to_task(struct kernel_siginfo *info, struct task_struct *t,\n\tenum sig_handler handler)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\tint sig = info->si_signo;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored || (handler != HANDLER_CURRENT)) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (handler == HANDLER_EXIT)\n\t\t\taction->sa.sa_flags |= SA_IMMUTABLE;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid force_exit_sig(int sig)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_KERNEL;\n\tinfo.si_pid = 0;\n\tinfo.si_uid = 0;\n\tforce_sig_info_to_task(&info, current, HANDLER_EXIT);\n}"
  },
  {
    "function_name": "force_fatal_sig",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1664-1675",
    "snippet": "void force_fatal_sig(int sig)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_KERNEL;\n\tinfo.si_pid = 0;\n\tinfo.si_uid = 0;\n\tforce_sig_info_to_task(&info, current, HANDLER_SIG_DFL);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info_to_task",
          "args": [
            "&info",
            "current",
            "HANDLER_SIG_DFL"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info_to_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1321-1353",
          "snippet": "static int\nforce_sig_info_to_task(struct kernel_siginfo *info, struct task_struct *t,\n\tenum sig_handler handler)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\tint sig = info->si_signo;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored || (handler != HANDLER_CURRENT)) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (handler == HANDLER_EXIT)\n\t\t\taction->sa.sa_flags |= SA_IMMUTABLE;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int\nforce_sig_info_to_task(struct kernel_siginfo *info, struct task_struct *t,\n\tenum sig_handler handler)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\tint sig = info->si_signo;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored || (handler != HANDLER_CURRENT)) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (handler == HANDLER_EXIT)\n\t\t\taction->sa.sa_flags |= SA_IMMUTABLE;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid force_fatal_sig(int sig)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_KERNEL;\n\tinfo.si_pid = 0;\n\tinfo.si_uid = 0;\n\tforce_sig_info_to_task(&info, current, HANDLER_SIG_DFL);\n}"
  },
  {
    "function_name": "force_sig",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1650-1661",
    "snippet": "void force_sig(int sig)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_KERNEL;\n\tinfo.si_pid = 0;\n\tinfo.si_uid = 0;\n\tforce_sig_info(&info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "&info"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1355-1358",
          "snippet": "int force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid force_sig(int sig)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_KERNEL;\n\tinfo.si_pid = 0;\n\tinfo.si_uid = 0;\n\tforce_sig_info(&info);\n}"
  },
  {
    "function_name": "send_sig",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1643-1647",
    "snippet": "int\nsend_sig(int sig, struct task_struct *p, int priv)\n{\n\treturn send_sig_info(sig, __si_special(priv), p);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_sig_info",
          "args": [
            "sig",
            "__si_special(priv)",
            "p"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "send_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1627-1637",
          "snippet": "int send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__si_special",
          "args": [
            "priv"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint\nsend_sig(int sig, struct task_struct *p, int priv)\n{\n\treturn send_sig_info(sig, __si_special(priv), p);\n}"
  },
  {
    "function_name": "send_sig_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1627-1637",
    "snippet": "int send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_send_sig_info",
          "args": [
            "sig",
            "info",
            "p",
            "PIDTYPE_PID"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "do_send_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1290-1302",
          "snippet": "int do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n\t\t\tenum pid_type type)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, type);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n\t\t\tenum pid_type type)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, type);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_signal",
          "args": [
            "sig"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}"
  },
  {
    "function_name": "kill_something_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1587-1621",
    "snippet": "static int kill_something_info(int sig, struct kernel_siginfo *info, pid_t pid)\n{\n\tint ret;\n\n\tif (pid > 0)\n\t\treturn kill_proc_info(sig, info, pid);\n\n\t/* -INT_MIN is undefined.  Exclude this case to avoid a UBSAN warning */\n\tif (pid == INT_MIN)\n\t\treturn -ESRCH;\n\n\tread_lock(&tasklist_lock);\n\tif (pid != -1) {\n\t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p,\n\t\t\t\t\t\t\t      PIDTYPE_MAX);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "group_send_sig_info",
          "args": [
            "sig",
            "info",
            "p",
            "PIDTYPE_MAX"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "group_send_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1434-1447",
          "snippet": "int group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "p",
            "current"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "p"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kill_pgrp_info",
          "args": [
            "sig",
            "info",
            "pid ? find_vpid(-pid) : task_pgrp(current)"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "__kill_pgrp_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1454-1467",
          "snippet": "int __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pgrp",
          "args": [
            "current"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vpid",
          "args": [
            "-pid"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "find_vpid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "315-318",
          "snippet": "struct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_proc_info",
          "args": [
            "sig",
            "info",
            "pid"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "kill_proc_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1491-1498",
          "snippet": "static int kill_proc_info(int sig, struct kernel_siginfo *info, pid_t pid)\n{\n\tint error;\n\trcu_read_lock();\n\terror = kill_pid_info(sig, info, find_vpid(pid));\n\trcu_read_unlock();\n\treturn error;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int kill_proc_info(int sig, struct kernel_siginfo *info, pid_t pid)\n{\n\tint error;\n\trcu_read_lock();\n\terror = kill_pid_info(sig, info, find_vpid(pid));\n\trcu_read_unlock();\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int kill_something_info(int sig, struct kernel_siginfo *info, pid_t pid)\n{\n\tint ret;\n\n\tif (pid > 0)\n\t\treturn kill_proc_info(sig, info, pid);\n\n\t/* -INT_MIN is undefined.  Exclude this case to avoid a UBSAN warning */\n\tif (pid == INT_MIN)\n\t\treturn -ESRCH;\n\n\tread_lock(&tasklist_lock);\n\tif (pid != -1) {\n\t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p,\n\t\t\t\t\t\t\t      PIDTYPE_MAX);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kill_pid_usb_asyncio",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1536-1577",
    "snippet": "int kill_pid_usb_asyncio(int sig, int errno, sigval_t addr,\n\t\t\t struct pid *pid, const struct cred *cred)\n{\n\tstruct kernel_siginfo info;\n\tstruct task_struct *p;\n\tunsigned long flags;\n\tint ret = -EINVAL;\n\n\tif (!valid_signal(sig))\n\t\treturn ret;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = errno;\n\tinfo.si_code = SI_ASYNCIO;\n\t*((sigval_t *)&info.si_pid) = addr;\n\n\trcu_read_lock();\n\tp = pid_task(pid, PIDTYPE_PID);\n\tif (!p) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\tif (!kill_as_cred_perm(cred, p)) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\tret = security_task_kill(p, &info, sig, cred);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (sig) {\n\t\tif (lock_task_sighand(p, &flags)) {\n\t\t\tret = __send_signal(sig, &info, p, PIDTYPE_TGID, false);\n\t\t\tunlock_task_sighand(p, &flags);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\nout_unlock:\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__send_signal",
          "args": [
            "sig",
            "&info",
            "p",
            "PIDTYPE_TGID",
            "false"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "__send_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1074-1189",
          "snippet": "static int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type, bool force)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, force))\n\t\tgoto ret;\n\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tresult = TRACE_SIGNAL_DELIVERED;\n\t/*\n\t * Skip useless siginfo allocation for SIGKILL and kernel threads.\n\t */\n\tif ((sig == SIGKILL) || (t->flags & PF_KTHREAD))\n\t\tgoto out_set;\n\n\t/*\n\t * Real-time signals must be queued if sent by sigqueue, or\n\t * some other real-time mechanism.  It is implementation\n\t * defined whether kill() does so.  We attempt to do so, on\n\t * the principle of least surprise, but since kill is not\n\t * allowed to fail with EAGAIN when low on memory we just\n\t * make sure at least one signal gets delivered and don't\n\t * pass on the info struct.\n\t */\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, 0);\n\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\trcu_read_lock();\n\t\t\tq->info.si_uid =\n\t\t\t\tfrom_kuid_munged(task_cred_xxx(t, user_ns),\n\t\t\t\t\t\t current_uid());\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tbreak;\n\t\t}\n\t} else if (!is_si_special(info) &&\n\t\t   sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t/*\n\t\t * Queue overflow, abort.  We may abort if the\n\t\t * signal was rt and sent by user using something\n\t\t * other than kill().\n\t\t */\n\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\tret = -EAGAIN;\n\t\tgoto ret;\n\t} else {\n\t\t/*\n\t\t * This is a silent loss of information.  We still\n\t\t * send the signal, but the *info bits are lost.\n\t\t */\n\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\n\t/* Let multiprocess signals appear after on-going forks */\n\tif (type > PIDTYPE_TGID) {\n\t\tstruct multiprocess_signals *delayed;\n\t\thlist_for_each_entry(delayed, &t->signal->multiprocess, node) {\n\t\t\tsigset_t *signal = &delayed->signal;\n\t\t\t/* Can't queue both a stop and a continue signal */\n\t\t\tif (sig == SIGCONT)\n\t\t\t\tsigdelsetmask(signal, SIG_KERNEL_STOP_MASK);\n\t\t\telse if (sig_kernel_stop(sig))\n\t\t\t\tsigdelset(signal, SIGCONT);\n\t\t\tsigaddset(signal, sig);\n\t\t}\n\t}\n\n\tcomplete_signal(sig, t, type);\nret:\n\ttrace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type, bool force)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, force))\n\t\tgoto ret;\n\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tresult = TRACE_SIGNAL_DELIVERED;\n\t/*\n\t * Skip useless siginfo allocation for SIGKILL and kernel threads.\n\t */\n\tif ((sig == SIGKILL) || (t->flags & PF_KTHREAD))\n\t\tgoto out_set;\n\n\t/*\n\t * Real-time signals must be queued if sent by sigqueue, or\n\t * some other real-time mechanism.  It is implementation\n\t * defined whether kill() does so.  We attempt to do so, on\n\t * the principle of least surprise, but since kill is not\n\t * allowed to fail with EAGAIN when low on memory we just\n\t * make sure at least one signal gets delivered and don't\n\t * pass on the info struct.\n\t */\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, 0);\n\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\trcu_read_lock();\n\t\t\tq->info.si_uid =\n\t\t\t\tfrom_kuid_munged(task_cred_xxx(t, user_ns),\n\t\t\t\t\t\t current_uid());\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tbreak;\n\t\t}\n\t} else if (!is_si_special(info) &&\n\t\t   sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t/*\n\t\t * Queue overflow, abort.  We may abort if the\n\t\t * signal was rt and sent by user using something\n\t\t * other than kill().\n\t\t */\n\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\tret = -EAGAIN;\n\t\tgoto ret;\n\t} else {\n\t\t/*\n\t\t * This is a silent loss of information.  We still\n\t\t * send the signal, but the *info bits are lost.\n\t\t */\n\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\n\t/* Let multiprocess signals appear after on-going forks */\n\tif (type > PIDTYPE_TGID) {\n\t\tstruct multiprocess_signals *delayed;\n\t\thlist_for_each_entry(delayed, &t->signal->multiprocess, node) {\n\t\t\tsigset_t *signal = &delayed->signal;\n\t\t\t/* Can't queue both a stop and a continue signal */\n\t\t\tif (sig == SIGCONT)\n\t\t\t\tsigdelsetmask(signal, SIG_KERNEL_STOP_MASK);\n\t\t\telse if (sig_kernel_stop(sig))\n\t\t\t\tsigdelset(signal, SIGCONT);\n\t\t\tsigaddset(signal, sig);\n\t\t}\n\t}\n\n\tcomplete_signal(sig, t, type);\nret:\n\ttrace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1384-1414",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_task_kill",
          "args": [
            "p",
            "&info",
            "sig",
            "cred"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_as_cred_perm",
          "args": [
            "cred",
            "p"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "kill_as_cred_perm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1500-1509",
          "snippet": "static inline bool kill_as_cred_perm(const struct cred *cred,\n\t\t\t\t     struct task_struct *target)\n{\n\tconst struct cred *pcred = __task_cred(target);\n\n\treturn uid_eq(cred->euid, pcred->suid) ||\n\t       uid_eq(cred->euid, pcred->uid) ||\n\t       uid_eq(cred->uid, pcred->suid) ||\n\t       uid_eq(cred->uid, pcred->uid);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool kill_as_cred_perm(const struct cred *cred,\n\t\t\t\t     struct task_struct *target)\n{\n\tconst struct cred *pcred = __task_cred(target);\n\n\treturn uid_eq(cred->euid, pcred->suid) ||\n\t       uid_eq(cred->euid, pcred->uid) ||\n\t       uid_eq(cred->uid, pcred->suid) ||\n\t       uid_eq(cred->uid, pcred->uid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid",
            "PIDTYPE_PID"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "448-457",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_signal",
          "args": [
            "sig"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint kill_pid_usb_asyncio(int sig, int errno, sigval_t addr,\n\t\t\t struct pid *pid, const struct cred *cred)\n{\n\tstruct kernel_siginfo info;\n\tstruct task_struct *p;\n\tunsigned long flags;\n\tint ret = -EINVAL;\n\n\tif (!valid_signal(sig))\n\t\treturn ret;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = errno;\n\tinfo.si_code = SI_ASYNCIO;\n\t*((sigval_t *)&info.si_pid) = addr;\n\n\trcu_read_lock();\n\tp = pid_task(pid, PIDTYPE_PID);\n\tif (!p) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\tif (!kill_as_cred_perm(cred, p)) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\tret = security_task_kill(p, &info, sig, cred);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (sig) {\n\t\tif (lock_task_sighand(p, &flags)) {\n\t\t\tret = __send_signal(sig, &info, p, PIDTYPE_TGID, false);\n\t\t\tunlock_task_sighand(p, &flags);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\nout_unlock:\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "kill_as_cred_perm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1500-1509",
    "snippet": "static inline bool kill_as_cred_perm(const struct cred *cred,\n\t\t\t\t     struct task_struct *target)\n{\n\tconst struct cred *pcred = __task_cred(target);\n\n\treturn uid_eq(cred->euid, pcred->suid) ||\n\t       uid_eq(cred->euid, pcred->uid) ||\n\t       uid_eq(cred->uid, pcred->suid) ||\n\t       uid_eq(cred->uid, pcred->uid);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->uid",
            "pcred->uid"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->uid",
            "pcred->suid"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->euid",
            "pcred->uid"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->euid",
            "pcred->suid"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "target"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool kill_as_cred_perm(const struct cred *cred,\n\t\t\t\t     struct task_struct *target)\n{\n\tconst struct cred *pcred = __task_cred(target);\n\n\treturn uid_eq(cred->euid, pcred->suid) ||\n\t       uid_eq(cred->euid, pcred->uid) ||\n\t       uid_eq(cred->uid, pcred->suid) ||\n\t       uid_eq(cred->uid, pcred->uid);\n}"
  },
  {
    "function_name": "kill_proc_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1491-1498",
    "snippet": "static int kill_proc_info(int sig, struct kernel_siginfo *info, pid_t pid)\n{\n\tint error;\n\trcu_read_lock();\n\terror = kill_pid_info(sig, info, find_vpid(pid));\n\trcu_read_unlock();\n\treturn error;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_pid_info",
          "args": [
            "sig",
            "info",
            "find_vpid(pid)"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "kill_pid_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1469-1489",
          "snippet": "int kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vpid",
          "args": [
            "pid"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "find_vpid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "315-318",
          "snippet": "struct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int kill_proc_info(int sig, struct kernel_siginfo *info, pid_t pid)\n{\n\tint error;\n\trcu_read_lock();\n\terror = kill_pid_info(sig, info, find_vpid(pid));\n\trcu_read_unlock();\n\treturn error;\n}"
  },
  {
    "function_name": "kill_pid_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1469-1489",
    "snippet": "int kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!p || error != -ESRCH"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "group_send_sig_info",
          "args": [
            "sig",
            "info",
            "p",
            "PIDTYPE_TGID"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "group_send_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1434-1447",
          "snippet": "int group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid",
            "PIDTYPE_PID"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "448-457",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}"
  },
  {
    "function_name": "__kill_pgrp_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1454-1467",
    "snippet": "int __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_each_pid_task",
          "args": [
            "pgrp",
            "PIDTYPE_PGID",
            "p"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group_send_sig_info",
          "args": [
            "sig",
            "info",
            "p",
            "PIDTYPE_PGID"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "group_send_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1434-1447",
          "snippet": "int group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_each_pid_task",
          "args": [
            "pgrp",
            "PIDTYPE_PGID",
            "p"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}"
  },
  {
    "function_name": "group_send_sig_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1434-1447",
    "snippet": "int group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_send_sig_info",
          "args": [
            "sig",
            "info",
            "p",
            "type"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "do_send_sig_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1290-1302",
          "snippet": "int do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n\t\t\tenum pid_type type)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, type);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n\t\t\tenum pid_type type)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, type);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_kill_permission",
          "args": [
            "sig",
            "info",
            "p"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "check_kill_permission",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "831-865",
          "snippet": "static int check_kill_permission(int sig, struct kernel_siginfo *info,\n\t\t\t\t struct task_struct *t)\n{\n\tstruct pid *sid;\n\tint error;\n\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\tif (!si_fromuser(info))\n\t\treturn 0;\n\n\terror = audit_signal_info(sig, t); /* Let audit system see the signal */\n\tif (error)\n\t\treturn error;\n\n\tif (!same_thread_group(current, t) &&\n\t    !kill_ok_by_cred(t)) {\n\t\tswitch (sig) {\n\t\tcase SIGCONT:\n\t\t\tsid = task_session(t);\n\t\t\t/*\n\t\t\t * We don't return the error if sid == NULL. The\n\t\t\t * task was unhashed, the caller must notice this.\n\t\t\t */\n\t\t\tif (!sid || sid == task_session(current))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn security_task_kill(t, info, sig, NULL);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int check_kill_permission(int sig, struct kernel_siginfo *info,\n\t\t\t\t struct task_struct *t)\n{\n\tstruct pid *sid;\n\tint error;\n\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\tif (!si_fromuser(info))\n\t\treturn 0;\n\n\terror = audit_signal_info(sig, t); /* Let audit system see the signal */\n\tif (error)\n\t\treturn error;\n\n\tif (!same_thread_group(current, t) &&\n\t    !kill_ok_by_cred(t)) {\n\t\tswitch (sig) {\n\t\tcase SIGCONT:\n\t\t\tsid = task_session(t);\n\t\t\t/*\n\t\t\t * We don't return the error if sid == NULL. The\n\t\t\t * task was unhashed, the caller must notice this.\n\t\t\t */\n\t\t\tif (!sid || sid == task_session(current))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn security_task_kill(t, info, sig, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lockdep_assert_task_sighand_held",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1417-1428",
    "snippet": "void lockdep_assert_task_sighand_held(struct task_struct *task)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tsighand = rcu_dereference(task->sighand);\n\tif (sighand)\n\t\tlockdep_assert_held(&sighand->siglock);\n\telse\n\t\tWARN_ON_ONCE(1);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&sighand->siglock"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "task->sighand"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid lockdep_assert_task_sighand_held(struct task_struct *task)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tsighand = rcu_dereference(task->sighand);\n\tif (sighand)\n\t\tlockdep_assert_held(&sighand->siglock);\n\telse\n\t\tWARN_ON_ONCE(1);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "__lock_task_sighand",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1384-1414",
    "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&sighand->siglock",
            "*flags"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "sighand == rcu_access_pointer(tsk->sighand)"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "tsk->sighand"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&sighand->siglock",
            "*flags"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sighand == NULL"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "tsk->sighand"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
  },
  {
    "function_name": "zap_other_threads",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1363-1382",
    "snippet": "int zap_other_threads(struct task_struct *p)\n{\n\tstruct task_struct *t = p;\n\tint count = 0;\n\n\tp->signal->group_stop_count = 0;\n\n\twhile_each_thread(p, t) {\n\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\tcount++;\n\n\t\t/* Don't bother with already dead threads */\n\t\tif (t->exit_state)\n\t\t\tcontinue;\n\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\tsignal_wake_up(t, 1);\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_wake_up",
          "args": [
            "t",
            "1"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "763-775",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&t->pending.signal",
            "SIGKILL"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_clear_jobctl_pending",
          "args": [
            "t",
            "JOBCTL_PENDING_MASK"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "task_clear_jobctl_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "336-347",
          "snippet": "void task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint zap_other_threads(struct task_struct *p)\n{\n\tstruct task_struct *t = p;\n\tint count = 0;\n\n\tp->signal->group_stop_count = 0;\n\n\twhile_each_thread(p, t) {\n\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\tcount++;\n\n\t\t/* Don't bother with already dead threads */\n\t\tif (t->exit_state)\n\t\t\tcontinue;\n\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\tsignal_wake_up(t, 1);\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "force_sig_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1355-1358",
    "snippet": "int force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info_to_task",
          "args": [
            "info",
            "current",
            "HANDLER_CURRENT"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info_to_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1321-1353",
          "snippet": "static int\nforce_sig_info_to_task(struct kernel_siginfo *info, struct task_struct *t,\n\tenum sig_handler handler)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\tint sig = info->si_signo;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored || (handler != HANDLER_CURRENT)) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (handler == HANDLER_EXIT)\n\t\t\taction->sa.sa_flags |= SA_IMMUTABLE;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int\nforce_sig_info_to_task(struct kernel_siginfo *info, struct task_struct *t,\n\tenum sig_handler handler)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\tint sig = info->si_signo;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored || (handler != HANDLER_CURRENT)) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (handler == HANDLER_EXIT)\n\t\t\taction->sa.sa_flags |= SA_IMMUTABLE;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_info(struct kernel_siginfo *info)\n{\n\treturn force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}"
  },
  {
    "function_name": "force_sig_info_to_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1321-1353",
    "snippet": "static int\nforce_sig_info_to_task(struct kernel_siginfo *info, struct task_struct *t,\n\tenum sig_handler handler)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\tint sig = info->si_signo;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored || (handler != HANDLER_CURRENT)) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (handler == HANDLER_EXIT)\n\t\t\taction->sa.sa_flags |= SA_IMMUTABLE;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&t->sighand->siglock",
            "flags"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_signal",
          "args": [
            "sig",
            "info",
            "t",
            "PIDTYPE_PID"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "send_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1215-1249",
          "snippet": "static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\t/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */\n\tbool force = false;\n\n\tif (info == SEND_SIG_NOINFO) {\n\t\t/* Force if sent from an ancestor pid namespace */\n\t\tforce = !task_pid_nr_ns(current, task_active_pid_ns(t));\n\t} else if (info == SEND_SIG_PRIV) {\n\t\t/* Don't ignore kernel generated signals */\n\t\tforce = true;\n\t} else if (has_si_pid_and_uid(info)) {\n\t\t/* SIGKILL and SIGSTOP is special or has ids */\n\t\tstruct user_namespace *t_user_ns;\n\n\t\trcu_read_lock();\n\t\tt_user_ns = task_cred_xxx(t, user_ns);\n\t\tif (current_user_ns() != t_user_ns) {\n\t\t\tkuid_t uid = make_kuid(current_user_ns(), info->si_uid);\n\t\t\tinfo->si_uid = from_kuid_munged(t_user_ns, uid);\n\t\t}\n\t\trcu_read_unlock();\n\n\t\t/* A kernel generated signal? */\n\t\tforce = (info->si_code == SI_KERNEL);\n\n\t\t/* From an ancestor pid namespace? */\n\t\tif (!task_pid_nr_ns(current, task_active_pid_ns(t))) {\n\t\t\tinfo->si_pid = 0;\n\t\t\tforce = true;\n\t\t}\n\t}\n\treturn __send_signal(sig, info, t, type, force);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\t/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */\n\tbool force = false;\n\n\tif (info == SEND_SIG_NOINFO) {\n\t\t/* Force if sent from an ancestor pid namespace */\n\t\tforce = !task_pid_nr_ns(current, task_active_pid_ns(t));\n\t} else if (info == SEND_SIG_PRIV) {\n\t\t/* Don't ignore kernel generated signals */\n\t\tforce = true;\n\t} else if (has_si_pid_and_uid(info)) {\n\t\t/* SIGKILL and SIGSTOP is special or has ids */\n\t\tstruct user_namespace *t_user_ns;\n\n\t\trcu_read_lock();\n\t\tt_user_ns = task_cred_xxx(t, user_ns);\n\t\tif (current_user_ns() != t_user_ns) {\n\t\t\tkuid_t uid = make_kuid(current_user_ns(), info->si_uid);\n\t\t\tinfo->si_uid = from_kuid_munged(t_user_ns, uid);\n\t\t}\n\t\trcu_read_unlock();\n\n\t\t/* A kernel generated signal? */\n\t\tforce = (info->si_code == SI_KERNEL);\n\n\t\t/* From an ancestor pid namespace? */\n\t\tif (!task_pid_nr_ns(current, task_active_pid_ns(t))) {\n\t\t\tinfo->si_pid = 0;\n\t\t\tforce = true;\n\t\t}\n\t}\n\treturn __send_signal(sig, info, t, type, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalc_sigpending_and_wake",
          "args": [
            "t"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending_and_wake",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "176-180",
          "snippet": "void recalc_sigpending_and_wake(struct task_struct *t)\n{\n\tif (recalc_sigpending_tsk(t))\n\t\tsignal_wake_up(t, 0);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending_and_wake(struct task_struct *t)\n{\n\tif (recalc_sigpending_tsk(t))\n\t\tsignal_wake_up(t, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&t->blocked",
            "sig"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&t->blocked",
            "sig"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&t->sighand->siglock",
            "flags"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int\nforce_sig_info_to_task(struct kernel_siginfo *info, struct task_struct *t,\n\tenum sig_handler handler)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\tint sig = info->si_signo;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored || (handler != HANDLER_CURRENT)) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (handler == HANDLER_EXIT)\n\t\t\taction->sa.sa_flags |= SA_IMMUTABLE;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_send_sig_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1290-1302",
    "snippet": "int do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n\t\t\tenum pid_type type)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, type);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_signal",
          "args": [
            "sig",
            "info",
            "p",
            "type"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "send_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1215-1249",
          "snippet": "static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\t/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */\n\tbool force = false;\n\n\tif (info == SEND_SIG_NOINFO) {\n\t\t/* Force if sent from an ancestor pid namespace */\n\t\tforce = !task_pid_nr_ns(current, task_active_pid_ns(t));\n\t} else if (info == SEND_SIG_PRIV) {\n\t\t/* Don't ignore kernel generated signals */\n\t\tforce = true;\n\t} else if (has_si_pid_and_uid(info)) {\n\t\t/* SIGKILL and SIGSTOP is special or has ids */\n\t\tstruct user_namespace *t_user_ns;\n\n\t\trcu_read_lock();\n\t\tt_user_ns = task_cred_xxx(t, user_ns);\n\t\tif (current_user_ns() != t_user_ns) {\n\t\t\tkuid_t uid = make_kuid(current_user_ns(), info->si_uid);\n\t\t\tinfo->si_uid = from_kuid_munged(t_user_ns, uid);\n\t\t}\n\t\trcu_read_unlock();\n\n\t\t/* A kernel generated signal? */\n\t\tforce = (info->si_code == SI_KERNEL);\n\n\t\t/* From an ancestor pid namespace? */\n\t\tif (!task_pid_nr_ns(current, task_active_pid_ns(t))) {\n\t\t\tinfo->si_pid = 0;\n\t\t\tforce = true;\n\t\t}\n\t}\n\treturn __send_signal(sig, info, t, type, force);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\t/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */\n\tbool force = false;\n\n\tif (info == SEND_SIG_NOINFO) {\n\t\t/* Force if sent from an ancestor pid namespace */\n\t\tforce = !task_pid_nr_ns(current, task_active_pid_ns(t));\n\t} else if (info == SEND_SIG_PRIV) {\n\t\t/* Don't ignore kernel generated signals */\n\t\tforce = true;\n\t} else if (has_si_pid_and_uid(info)) {\n\t\t/* SIGKILL and SIGSTOP is special or has ids */\n\t\tstruct user_namespace *t_user_ns;\n\n\t\trcu_read_lock();\n\t\tt_user_ns = task_cred_xxx(t, user_ns);\n\t\tif (current_user_ns() != t_user_ns) {\n\t\t\tkuid_t uid = make_kuid(current_user_ns(), info->si_uid);\n\t\t\tinfo->si_uid = from_kuid_munged(t_user_ns, uid);\n\t\t}\n\t\trcu_read_unlock();\n\n\t\t/* A kernel generated signal? */\n\t\tforce = (info->si_code == SI_KERNEL);\n\n\t\t/* From an ancestor pid namespace? */\n\t\tif (!task_pid_nr_ns(current, task_active_pid_ns(t))) {\n\t\t\tinfo->si_pid = 0;\n\t\t\tforce = true;\n\t\t}\n\t}\n\treturn __send_signal(sig, info, t, type, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1384-1414",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n\t\t\tenum pid_type type)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, type);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__group_send_sig_info",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1284-1288",
    "snippet": "int\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_signal",
          "args": [
            "sig",
            "info",
            "p",
            "PIDTYPE_TGID"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "send_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1215-1249",
          "snippet": "static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\t/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */\n\tbool force = false;\n\n\tif (info == SEND_SIG_NOINFO) {\n\t\t/* Force if sent from an ancestor pid namespace */\n\t\tforce = !task_pid_nr_ns(current, task_active_pid_ns(t));\n\t} else if (info == SEND_SIG_PRIV) {\n\t\t/* Don't ignore kernel generated signals */\n\t\tforce = true;\n\t} else if (has_si_pid_and_uid(info)) {\n\t\t/* SIGKILL and SIGSTOP is special or has ids */\n\t\tstruct user_namespace *t_user_ns;\n\n\t\trcu_read_lock();\n\t\tt_user_ns = task_cred_xxx(t, user_ns);\n\t\tif (current_user_ns() != t_user_ns) {\n\t\t\tkuid_t uid = make_kuid(current_user_ns(), info->si_uid);\n\t\t\tinfo->si_uid = from_kuid_munged(t_user_ns, uid);\n\t\t}\n\t\trcu_read_unlock();\n\n\t\t/* A kernel generated signal? */\n\t\tforce = (info->si_code == SI_KERNEL);\n\n\t\t/* From an ancestor pid namespace? */\n\t\tif (!task_pid_nr_ns(current, task_active_pid_ns(t))) {\n\t\t\tinfo->si_pid = 0;\n\t\t\tforce = true;\n\t\t}\n\t}\n\treturn __send_signal(sig, info, t, type, force);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\t/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */\n\tbool force = false;\n\n\tif (info == SEND_SIG_NOINFO) {\n\t\t/* Force if sent from an ancestor pid namespace */\n\t\tforce = !task_pid_nr_ns(current, task_active_pid_ns(t));\n\t} else if (info == SEND_SIG_PRIV) {\n\t\t/* Don't ignore kernel generated signals */\n\t\tforce = true;\n\t} else if (has_si_pid_and_uid(info)) {\n\t\t/* SIGKILL and SIGSTOP is special or has ids */\n\t\tstruct user_namespace *t_user_ns;\n\n\t\trcu_read_lock();\n\t\tt_user_ns = task_cred_xxx(t, user_ns);\n\t\tif (current_user_ns() != t_user_ns) {\n\t\t\tkuid_t uid = make_kuid(current_user_ns(), info->si_uid);\n\t\t\tinfo->si_uid = from_kuid_munged(t_user_ns, uid);\n\t\t}\n\t\trcu_read_unlock();\n\n\t\t/* A kernel generated signal? */\n\t\tforce = (info->si_code == SI_KERNEL);\n\n\t\t/* From an ancestor pid namespace? */\n\t\tif (!task_pid_nr_ns(current, task_active_pid_ns(t))) {\n\t\t\tinfo->si_pid = 0;\n\t\t\tforce = true;\n\t\t}\n\t}\n\treturn __send_signal(sig, info, t, type, force);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}"
  },
  {
    "function_name": "setup_print_fatal_signals",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1275-1280",
    "snippet": "static int __init setup_print_fatal_signals(char *str)\n{\n\tget_option (&str, &print_fatal_signals);\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int print_fatal_signals"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&print_fatal_signals"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint print_fatal_signals;\n\nstatic int __init setup_print_fatal_signals(char *str)\n{\n\tget_option (&str, &print_fatal_signals);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "print_fatal_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1251-1273",
    "snippet": "static void print_fatal_signal(int signr)\n{\n\tstruct pt_regs *regs = signal_pt_regs();\n\tpr_info(\"potentially unexpected fatal signal %d.\\n\", signr);\n\n#if defined(__i386__) && !defined(__arch_um__)\n\tpr_info(\"code at %08lx: \", regs->ip);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tunsigned char insn;\n\n\t\t\tif (get_user(insn, (unsigned char *)(regs->ip + i)))\n\t\t\t\tbreak;\n\t\t\tpr_cont(\"%02x \", insn);\n\t\t}\n\t}\n\tpr_cont(\"\\n\");\n#endif\n\tpreempt_disable();\n\tshow_regs(regs);\n\tpreempt_enable();\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_regs",
          "args": [
            "regs"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%02x \"",
            "insn"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "insn",
            "(unsigned char *)(regs->ip + i)"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "530-557",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"code at %08lx: \"",
            "regs->ip"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"potentially unexpected fatal signal %d.\\n\"",
            "signr"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pt_regs",
          "args": [],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void print_fatal_signal(int signr)\n{\n\tstruct pt_regs *regs = signal_pt_regs();\n\tpr_info(\"potentially unexpected fatal signal %d.\\n\", signr);\n\n#if defined(__i386__) && !defined(__arch_um__)\n\tpr_info(\"code at %08lx: \", regs->ip);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tunsigned char insn;\n\n\t\t\tif (get_user(insn, (unsigned char *)(regs->ip + i)))\n\t\t\t\tbreak;\n\t\t\tpr_cont(\"%02x \", insn);\n\t\t}\n\t}\n\tpr_cont(\"\\n\");\n#endif\n\tpreempt_disable();\n\tshow_regs(regs);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "send_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1215-1249",
    "snippet": "static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\t/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */\n\tbool force = false;\n\n\tif (info == SEND_SIG_NOINFO) {\n\t\t/* Force if sent from an ancestor pid namespace */\n\t\tforce = !task_pid_nr_ns(current, task_active_pid_ns(t));\n\t} else if (info == SEND_SIG_PRIV) {\n\t\t/* Don't ignore kernel generated signals */\n\t\tforce = true;\n\t} else if (has_si_pid_and_uid(info)) {\n\t\t/* SIGKILL and SIGSTOP is special or has ids */\n\t\tstruct user_namespace *t_user_ns;\n\n\t\trcu_read_lock();\n\t\tt_user_ns = task_cred_xxx(t, user_ns);\n\t\tif (current_user_ns() != t_user_ns) {\n\t\t\tkuid_t uid = make_kuid(current_user_ns(), info->si_uid);\n\t\t\tinfo->si_uid = from_kuid_munged(t_user_ns, uid);\n\t\t}\n\t\trcu_read_unlock();\n\n\t\t/* A kernel generated signal? */\n\t\tforce = (info->si_code == SI_KERNEL);\n\n\t\t/* From an ancestor pid namespace? */\n\t\tif (!task_pid_nr_ns(current, task_active_pid_ns(t))) {\n\t\t\tinfo->si_pid = 0;\n\t\t\tforce = true;\n\t\t}\n\t}\n\treturn __send_signal(sig, info, t, type, force);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__send_signal",
          "args": [
            "sig",
            "info",
            "t",
            "type",
            "force"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "__send_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1074-1189",
          "snippet": "static int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type, bool force)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, force))\n\t\tgoto ret;\n\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tresult = TRACE_SIGNAL_DELIVERED;\n\t/*\n\t * Skip useless siginfo allocation for SIGKILL and kernel threads.\n\t */\n\tif ((sig == SIGKILL) || (t->flags & PF_KTHREAD))\n\t\tgoto out_set;\n\n\t/*\n\t * Real-time signals must be queued if sent by sigqueue, or\n\t * some other real-time mechanism.  It is implementation\n\t * defined whether kill() does so.  We attempt to do so, on\n\t * the principle of least surprise, but since kill is not\n\t * allowed to fail with EAGAIN when low on memory we just\n\t * make sure at least one signal gets delivered and don't\n\t * pass on the info struct.\n\t */\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, 0);\n\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\trcu_read_lock();\n\t\t\tq->info.si_uid =\n\t\t\t\tfrom_kuid_munged(task_cred_xxx(t, user_ns),\n\t\t\t\t\t\t current_uid());\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tbreak;\n\t\t}\n\t} else if (!is_si_special(info) &&\n\t\t   sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t/*\n\t\t * Queue overflow, abort.  We may abort if the\n\t\t * signal was rt and sent by user using something\n\t\t * other than kill().\n\t\t */\n\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\tret = -EAGAIN;\n\t\tgoto ret;\n\t} else {\n\t\t/*\n\t\t * This is a silent loss of information.  We still\n\t\t * send the signal, but the *info bits are lost.\n\t\t */\n\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\n\t/* Let multiprocess signals appear after on-going forks */\n\tif (type > PIDTYPE_TGID) {\n\t\tstruct multiprocess_signals *delayed;\n\t\thlist_for_each_entry(delayed, &t->signal->multiprocess, node) {\n\t\t\tsigset_t *signal = &delayed->signal;\n\t\t\t/* Can't queue both a stop and a continue signal */\n\t\t\tif (sig == SIGCONT)\n\t\t\t\tsigdelsetmask(signal, SIG_KERNEL_STOP_MASK);\n\t\t\telse if (sig_kernel_stop(sig))\n\t\t\t\tsigdelset(signal, SIGCONT);\n\t\t\tsigaddset(signal, sig);\n\t\t}\n\t}\n\n\tcomplete_signal(sig, t, type);\nret:\n\ttrace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type, bool force)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, force))\n\t\tgoto ret;\n\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tresult = TRACE_SIGNAL_DELIVERED;\n\t/*\n\t * Skip useless siginfo allocation for SIGKILL and kernel threads.\n\t */\n\tif ((sig == SIGKILL) || (t->flags & PF_KTHREAD))\n\t\tgoto out_set;\n\n\t/*\n\t * Real-time signals must be queued if sent by sigqueue, or\n\t * some other real-time mechanism.  It is implementation\n\t * defined whether kill() does so.  We attempt to do so, on\n\t * the principle of least surprise, but since kill is not\n\t * allowed to fail with EAGAIN when low on memory we just\n\t * make sure at least one signal gets delivered and don't\n\t * pass on the info struct.\n\t */\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, 0);\n\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\trcu_read_lock();\n\t\t\tq->info.si_uid =\n\t\t\t\tfrom_kuid_munged(task_cred_xxx(t, user_ns),\n\t\t\t\t\t\t current_uid());\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tbreak;\n\t\t}\n\t} else if (!is_si_special(info) &&\n\t\t   sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t/*\n\t\t * Queue overflow, abort.  We may abort if the\n\t\t * signal was rt and sent by user using something\n\t\t * other than kill().\n\t\t */\n\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\tret = -EAGAIN;\n\t\tgoto ret;\n\t} else {\n\t\t/*\n\t\t * This is a silent loss of information.  We still\n\t\t * send the signal, but the *info bits are lost.\n\t\t */\n\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\n\t/* Let multiprocess signals appear after on-going forks */\n\tif (type > PIDTYPE_TGID) {\n\t\tstruct multiprocess_signals *delayed;\n\t\thlist_for_each_entry(delayed, &t->signal->multiprocess, node) {\n\t\t\tsigset_t *signal = &delayed->signal;\n\t\t\t/* Can't queue both a stop and a continue signal */\n\t\t\tif (sig == SIGCONT)\n\t\t\t\tsigdelsetmask(signal, SIG_KERNEL_STOP_MASK);\n\t\t\telse if (sig_kernel_stop(sig))\n\t\t\t\tsigdelset(signal, SIGCONT);\n\t\t\tsigaddset(signal, sig);\n\t\t}\n\t}\n\n\tcomplete_signal(sig, t, type);\nret:\n\ttrace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "current",
            "task_active_pid_ns(t)"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "t"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "507-510",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "t_user_ns",
            "uid"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "info->si_uid"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "make_kuid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "391-395",
          "snippet": "kuid_t make_kuid(struct user_namespace *ns, uid_t uid)\n{\n\t/* Map the uid to a global kernel uid */\n\treturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nkuid_t make_kuid(struct user_namespace *ns, uid_t uid)\n{\n\t/* Map the uid to a global kernel uid */\n\treturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cred_xxx",
          "args": [
            "t",
            "user_ns"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_si_pid_and_uid",
          "args": [
            "info"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "has_si_pid_and_uid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1191-1213",
          "snippet": "static inline bool has_si_pid_and_uid(struct kernel_siginfo *info)\n{\n\tbool ret = false;\n\tswitch (siginfo_layout(info->si_signo, info->si_code)) {\n\tcase SIL_KILL:\n\tcase SIL_CHLD:\n\tcase SIL_RT:\n\t\tret = true;\n\t\tbreak;\n\tcase SIL_TIMER:\n\tcase SIL_POLL:\n\tcase SIL_FAULT:\n\tcase SIL_FAULT_TRAPNO:\n\tcase SIL_FAULT_MCEERR:\n\tcase SIL_FAULT_BNDERR:\n\tcase SIL_FAULT_PKUERR:\n\tcase SIL_FAULT_PERF_EVENT:\n\tcase SIL_SYS:\n\t\tret = false;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool has_si_pid_and_uid(struct kernel_siginfo *info)\n{\n\tbool ret = false;\n\tswitch (siginfo_layout(info->si_signo, info->si_code)) {\n\tcase SIL_KILL:\n\tcase SIL_CHLD:\n\tcase SIL_RT:\n\t\tret = true;\n\t\tbreak;\n\tcase SIL_TIMER:\n\tcase SIL_POLL:\n\tcase SIL_FAULT:\n\tcase SIL_FAULT_TRAPNO:\n\tcase SIL_FAULT_MCEERR:\n\tcase SIL_FAULT_BNDERR:\n\tcase SIL_FAULT_PKUERR:\n\tcase SIL_FAULT_PERF_EVENT:\n\tcase SIL_SYS:\n\t\tret = false;\n\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "current",
            "task_active_pid_ns(t)"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\t/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */\n\tbool force = false;\n\n\tif (info == SEND_SIG_NOINFO) {\n\t\t/* Force if sent from an ancestor pid namespace */\n\t\tforce = !task_pid_nr_ns(current, task_active_pid_ns(t));\n\t} else if (info == SEND_SIG_PRIV) {\n\t\t/* Don't ignore kernel generated signals */\n\t\tforce = true;\n\t} else if (has_si_pid_and_uid(info)) {\n\t\t/* SIGKILL and SIGSTOP is special or has ids */\n\t\tstruct user_namespace *t_user_ns;\n\n\t\trcu_read_lock();\n\t\tt_user_ns = task_cred_xxx(t, user_ns);\n\t\tif (current_user_ns() != t_user_ns) {\n\t\t\tkuid_t uid = make_kuid(current_user_ns(), info->si_uid);\n\t\t\tinfo->si_uid = from_kuid_munged(t_user_ns, uid);\n\t\t}\n\t\trcu_read_unlock();\n\n\t\t/* A kernel generated signal? */\n\t\tforce = (info->si_code == SI_KERNEL);\n\n\t\t/* From an ancestor pid namespace? */\n\t\tif (!task_pid_nr_ns(current, task_active_pid_ns(t))) {\n\t\t\tinfo->si_pid = 0;\n\t\t\tforce = true;\n\t\t}\n\t}\n\treturn __send_signal(sig, info, t, type, force);\n}"
  },
  {
    "function_name": "has_si_pid_and_uid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1191-1213",
    "snippet": "static inline bool has_si_pid_and_uid(struct kernel_siginfo *info)\n{\n\tbool ret = false;\n\tswitch (siginfo_layout(info->si_signo, info->si_code)) {\n\tcase SIL_KILL:\n\tcase SIL_CHLD:\n\tcase SIL_RT:\n\t\tret = true;\n\t\tbreak;\n\tcase SIL_TIMER:\n\tcase SIL_POLL:\n\tcase SIL_FAULT:\n\tcase SIL_FAULT_TRAPNO:\n\tcase SIL_FAULT_MCEERR:\n\tcase SIL_FAULT_BNDERR:\n\tcase SIL_FAULT_PKUERR:\n\tcase SIL_FAULT_PERF_EVENT:\n\tcase SIL_SYS:\n\t\tret = false;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "siginfo_layout",
          "args": [
            "info->si_signo",
            "info->si_code"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "siginfo_layout",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3283-3321",
          "snippet": "enum siginfo_layout siginfo_layout(unsigned sig, int si_code)\n{\n\tenum siginfo_layout layout = SIL_KILL;\n\tif ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n\t\tif ((sig < ARRAY_SIZE(sig_sicodes)) &&\n\t\t    (si_code <= sig_sicodes[sig].limit)) {\n\t\t\tlayout = sig_sicodes[sig].layout;\n\t\t\t/* Handle the exceptions */\n\t\t\tif ((sig == SIGBUS) &&\n\t\t\t    (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n\t\t\t\tlayout = SIL_FAULT_MCEERR;\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n\t\t\t\tlayout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n\t\t\t\tlayout = SIL_FAULT_PKUERR;\n#endif\n\t\t\telse if ((sig == SIGTRAP) && (si_code == TRAP_PERF))\n\t\t\t\tlayout = SIL_FAULT_PERF_EVENT;\n\t\t\telse if (IS_ENABLED(CONFIG_SPARC) &&\n\t\t\t\t (sig == SIGILL) && (si_code == ILL_ILLTRP))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t\telse if (IS_ENABLED(CONFIG_ALPHA) &&\n\t\t\t\t ((sig == SIGFPE) ||\n\t\t\t\t  ((sig == SIGTRAP) && (si_code == TRAP_UNK))))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\tlayout = SIL_POLL;\n\t} else {\n\t\tif (si_code == SI_TIMER)\n\t\t\tlayout = SIL_TIMER;\n\t\telse if (si_code == SI_SIGIO)\n\t\t\tlayout = SIL_POLL;\n\t\telse if (si_code < 0)\n\t\t\tlayout = SIL_RT;\n\t}\n\treturn layout;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};\n\nenum siginfo_layout siginfo_layout(unsigned sig, int si_code)\n{\n\tenum siginfo_layout layout = SIL_KILL;\n\tif ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n\t\tif ((sig < ARRAY_SIZE(sig_sicodes)) &&\n\t\t    (si_code <= sig_sicodes[sig].limit)) {\n\t\t\tlayout = sig_sicodes[sig].layout;\n\t\t\t/* Handle the exceptions */\n\t\t\tif ((sig == SIGBUS) &&\n\t\t\t    (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n\t\t\t\tlayout = SIL_FAULT_MCEERR;\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n\t\t\t\tlayout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n\t\t\t\tlayout = SIL_FAULT_PKUERR;\n#endif\n\t\t\telse if ((sig == SIGTRAP) && (si_code == TRAP_PERF))\n\t\t\t\tlayout = SIL_FAULT_PERF_EVENT;\n\t\t\telse if (IS_ENABLED(CONFIG_SPARC) &&\n\t\t\t\t (sig == SIGILL) && (si_code == ILL_ILLTRP))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t\telse if (IS_ENABLED(CONFIG_ALPHA) &&\n\t\t\t\t ((sig == SIGFPE) ||\n\t\t\t\t  ((sig == SIGTRAP) && (si_code == TRAP_UNK))))\n\t\t\t\tlayout = SIL_FAULT_TRAPNO;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\tlayout = SIL_POLL;\n\t} else {\n\t\tif (si_code == SI_TIMER)\n\t\t\tlayout = SIL_TIMER;\n\t\telse if (si_code == SI_SIGIO)\n\t\t\tlayout = SIL_POLL;\n\t\telse if (si_code < 0)\n\t\t\tlayout = SIL_RT;\n\t}\n\treturn layout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool has_si_pid_and_uid(struct kernel_siginfo *info)\n{\n\tbool ret = false;\n\tswitch (siginfo_layout(info->si_signo, info->si_code)) {\n\tcase SIL_KILL:\n\tcase SIL_CHLD:\n\tcase SIL_RT:\n\t\tret = true;\n\t\tbreak;\n\tcase SIL_TIMER:\n\tcase SIL_POLL:\n\tcase SIL_FAULT:\n\tcase SIL_FAULT_TRAPNO:\n\tcase SIL_FAULT_MCEERR:\n\tcase SIL_FAULT_BNDERR:\n\tcase SIL_FAULT_PKUERR:\n\tcase SIL_FAULT_PERF_EVENT:\n\tcase SIL_SYS:\n\t\tret = false;\n\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__send_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1074-1189",
    "snippet": "static int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type, bool force)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, force))\n\t\tgoto ret;\n\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tresult = TRACE_SIGNAL_DELIVERED;\n\t/*\n\t * Skip useless siginfo allocation for SIGKILL and kernel threads.\n\t */\n\tif ((sig == SIGKILL) || (t->flags & PF_KTHREAD))\n\t\tgoto out_set;\n\n\t/*\n\t * Real-time signals must be queued if sent by sigqueue, or\n\t * some other real-time mechanism.  It is implementation\n\t * defined whether kill() does so.  We attempt to do so, on\n\t * the principle of least surprise, but since kill is not\n\t * allowed to fail with EAGAIN when low on memory we just\n\t * make sure at least one signal gets delivered and don't\n\t * pass on the info struct.\n\t */\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, 0);\n\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\trcu_read_lock();\n\t\t\tq->info.si_uid =\n\t\t\t\tfrom_kuid_munged(task_cred_xxx(t, user_ns),\n\t\t\t\t\t\t current_uid());\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tbreak;\n\t\t}\n\t} else if (!is_si_special(info) &&\n\t\t   sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t/*\n\t\t * Queue overflow, abort.  We may abort if the\n\t\t * signal was rt and sent by user using something\n\t\t * other than kill().\n\t\t */\n\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\tret = -EAGAIN;\n\t\tgoto ret;\n\t} else {\n\t\t/*\n\t\t * This is a silent loss of information.  We still\n\t\t * send the signal, but the *info bits are lost.\n\t\t */\n\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\n\t/* Let multiprocess signals appear after on-going forks */\n\tif (type > PIDTYPE_TGID) {\n\t\tstruct multiprocess_signals *delayed;\n\t\thlist_for_each_entry(delayed, &t->signal->multiprocess, node) {\n\t\t\tsigset_t *signal = &delayed->signal;\n\t\t\t/* Can't queue both a stop and a continue signal */\n\t\t\tif (sig == SIGCONT)\n\t\t\t\tsigdelsetmask(signal, SIG_KERNEL_STOP_MASK);\n\t\t\telse if (sig_kernel_stop(sig))\n\t\t\t\tsigdelset(signal, SIGCONT);\n\t\t\tsigaddset(signal, sig);\n\t\t}\n\t}\n\n\tcomplete_signal(sig, t, type);\nret:\n\ttrace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_signal_generate",
          "args": [
            "sig",
            "info",
            "t",
            "type != PIDTYPE_PID",
            "result"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete_signal",
          "args": [
            "sig",
            "t",
            "type"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "complete_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "993-1067",
          "snippet": "static void complete_signal(int sig, struct task_struct *p, enum pid_type type)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\n\t/*\n\t * Now find a thread we can wake up to take the signal off the queue.\n\t *\n\t * If the main thread wants the signal, it gets first crack.\n\t * Probably the least surprising to the average bear.\n\t */\n\tif (wants_signal(sig, p))\n\t\tt = p;\n\telse if ((type == PIDTYPE_PID) || thread_group_empty(p))\n\t\t/*\n\t\t * There is just one thread and it does not need to be woken.\n\t\t * It will dequeue unblocked signals before it runs again.\n\t\t */\n\t\treturn;\n\telse {\n\t\t/*\n\t\t * Otherwise try to find a suitable thread.\n\t\t */\n\t\tt = signal->curr_target;\n\t\twhile (!wants_signal(sig, t)) {\n\t\t\tt = next_thread(t);\n\t\t\tif (t == signal->curr_target)\n\t\t\t\t/*\n\t\t\t\t * No thread needs to be woken.\n\t\t\t\t * Any eligible threads will see\n\t\t\t\t * the signal in the queue soon.\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t}\n\t\tsignal->curr_target = t;\n\t}\n\n\t/*\n\t * Found a killable thread.  If the signal will be fatal,\n\t * then start taking the whole group down immediately.\n\t */\n\tif (sig_fatal(p, sig) &&\n\t    (signal->core_state || !(signal->flags & SIGNAL_GROUP_EXIT)) &&\n\t    !sigismember(&t->real_blocked, sig) &&\n\t    (sig == SIGKILL || !p->ptrace)) {\n\t\t/*\n\t\t * This signal will be fatal to the whole group.\n\t\t */\n\t\tif (!sig_kernel_coredump(sig)) {\n\t\t\t/*\n\t\t\t * Start a group exit and wake everybody up.\n\t\t\t * This way we don't have other threads\n\t\t\t * running and doing things after a slower\n\t\t\t * thread has the fatal signal pending.\n\t\t\t */\n\t\t\tsignal->flags = SIGNAL_GROUP_EXIT;\n\t\t\tsignal->group_exit_code = sig;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\t\tsignal_wake_up(t, 1);\n\t\t\t} while_each_thread(p, t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * The signal is already in the shared-pending queue.\n\t * Tell the chosen thread to wake up and dequeue it.\n\t */\n\tsignal_wake_up(t, sig == SIGKILL);\n\treturn;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void complete_signal(int sig, struct task_struct *p, enum pid_type type)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\n\t/*\n\t * Now find a thread we can wake up to take the signal off the queue.\n\t *\n\t * If the main thread wants the signal, it gets first crack.\n\t * Probably the least surprising to the average bear.\n\t */\n\tif (wants_signal(sig, p))\n\t\tt = p;\n\telse if ((type == PIDTYPE_PID) || thread_group_empty(p))\n\t\t/*\n\t\t * There is just one thread and it does not need to be woken.\n\t\t * It will dequeue unblocked signals before it runs again.\n\t\t */\n\t\treturn;\n\telse {\n\t\t/*\n\t\t * Otherwise try to find a suitable thread.\n\t\t */\n\t\tt = signal->curr_target;\n\t\twhile (!wants_signal(sig, t)) {\n\t\t\tt = next_thread(t);\n\t\t\tif (t == signal->curr_target)\n\t\t\t\t/*\n\t\t\t\t * No thread needs to be woken.\n\t\t\t\t * Any eligible threads will see\n\t\t\t\t * the signal in the queue soon.\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t}\n\t\tsignal->curr_target = t;\n\t}\n\n\t/*\n\t * Found a killable thread.  If the signal will be fatal,\n\t * then start taking the whole group down immediately.\n\t */\n\tif (sig_fatal(p, sig) &&\n\t    (signal->core_state || !(signal->flags & SIGNAL_GROUP_EXIT)) &&\n\t    !sigismember(&t->real_blocked, sig) &&\n\t    (sig == SIGKILL || !p->ptrace)) {\n\t\t/*\n\t\t * This signal will be fatal to the whole group.\n\t\t */\n\t\tif (!sig_kernel_coredump(sig)) {\n\t\t\t/*\n\t\t\t * Start a group exit and wake everybody up.\n\t\t\t * This way we don't have other threads\n\t\t\t * running and doing things after a slower\n\t\t\t * thread has the fatal signal pending.\n\t\t\t */\n\t\t\tsignal->flags = SIGNAL_GROUP_EXIT;\n\t\t\tsignal->group_exit_code = sig;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\t\tsignal_wake_up(t, 1);\n\t\t\t} while_each_thread(p, t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * The signal is already in the shared-pending queue.\n\t * Tell the chosen thread to wake up and dequeue it.\n\t */\n\tsignal_wake_up(t, sig == SIGKILL);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "signal",
            "sig"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "signal",
            "SIGCONT"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_kernel_stop",
          "args": [
            "sig"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelsetmask",
          "args": [
            "signal",
            "SIG_KERNEL_STOP_MASK"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "delayed",
            "&t->signal->multiprocess",
            "node"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&pending->signal",
            "sig"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signalfd_notify",
          "args": [
            "t",
            "sig"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_si_special",
          "args": [
            "info"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "is_si_special",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "801-804",
          "snippet": "static inline int is_si_special(const struct kernel_siginfo *info)\n{\n\treturn info <= SEND_SIG_PRIV;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline int is_si_special(const struct kernel_siginfo *info)\n{\n\treturn info <= SEND_SIG_PRIV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_siginfo",
          "args": [
            "&q->info",
            "info"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_from_user_any",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3804-3818",
          "snippet": "static int copy_siginfo_from_user_any(kernel_siginfo_t *kinfo,\n\t\tsiginfo_t __user *info)\n{\n#ifdef CONFIG_COMPAT\n\t/*\n\t * Avoid hooking up compat syscalls and instead handle necessary\n\t * conversions here. Note, this is a stop-gap measure and should not be\n\t * considered a generic solution.\n\t */\n\tif (in_compat_syscall())\n\t\treturn copy_siginfo_from_user32(\n\t\t\tkinfo, (struct compat_siginfo __user *)info);\n#endif\n\treturn copy_siginfo_from_user(kinfo, info);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int copy_siginfo_from_user_any(kernel_siginfo_t *kinfo,\n\t\tsiginfo_t __user *info)\n{\n#ifdef CONFIG_COMPAT\n\t/*\n\t * Avoid hooking up compat syscalls and instead handle necessary\n\t * conversions here. Note, this is a stop-gap measure and should not be\n\t * considered a generic solution.\n\t */\n\tif (in_compat_syscall())\n\t\treturn copy_siginfo_from_user32(\n\t\t\tkinfo, (struct compat_siginfo __user *)info);\n#endif\n\treturn copy_siginfo_from_user(kinfo, info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&q->info"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "task_cred_xxx(t, user_ns)",
            "current_uid()"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/user_namespace.c",
          "lines": "435-443",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cred_xxx",
          "args": [
            "t",
            "user_ns"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid_nr_ns",
          "args": [
            "current",
            "task_active_pid_ns(t)"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "t"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "507-510",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&q->info"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&q->list",
            "&pending->list"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sigqueue_alloc",
          "args": [
            "sig",
            "t",
            "GFP_ATOMIC",
            "override_rlimit",
            "0"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "__sigqueue_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "411-448",
          "snippet": "static struct sigqueue *\n__sigqueue_alloc(int sig, struct task_struct *t, gfp_t gfp_flags,\n\t\t int override_rlimit, const unsigned int sigqueue_flags)\n{\n\tstruct sigqueue *q = NULL;\n\tstruct ucounts *ucounts = NULL;\n\tlong sigpending;\n\n\t/*\n\t * Protect access to @t credentials. This can go away when all\n\t * callers hold rcu read lock.\n\t *\n\t * NOTE! A pending signal will hold on to the user refcount,\n\t * and we get/put the refcount only when the sigpending count\n\t * changes from/to zero.\n\t */\n\trcu_read_lock();\n\tucounts = task_ucounts(t);\n\tsigpending = inc_rlimit_get_ucounts(ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\trcu_read_unlock();\n\tif (!sigpending)\n\t\treturn NULL;\n\n\tif (override_rlimit || likely(sigpending <= task_rlimit(t, RLIMIT_SIGPENDING))) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, gfp_flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\n\tif (unlikely(q == NULL)) {\n\t\tdec_rlimit_put_ucounts(ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t} else {\n\t\tINIT_LIST_HEAD(&q->list);\n\t\tq->flags = sigqueue_flags;\n\t\tq->ucounts = ucounts;\n\t}\n\treturn q;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sigqueue_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic struct sigqueue *\n__sigqueue_alloc(int sig, struct task_struct *t, gfp_t gfp_flags,\n\t\t int override_rlimit, const unsigned int sigqueue_flags)\n{\n\tstruct sigqueue *q = NULL;\n\tstruct ucounts *ucounts = NULL;\n\tlong sigpending;\n\n\t/*\n\t * Protect access to @t credentials. This can go away when all\n\t * callers hold rcu read lock.\n\t *\n\t * NOTE! A pending signal will hold on to the user refcount,\n\t * and we get/put the refcount only when the sigpending count\n\t * changes from/to zero.\n\t */\n\trcu_read_lock();\n\tucounts = task_ucounts(t);\n\tsigpending = inc_rlimit_get_ucounts(ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\trcu_read_unlock();\n\tif (!sigpending)\n\t\treturn NULL;\n\n\tif (override_rlimit || likely(sigpending <= task_rlimit(t, RLIMIT_SIGPENDING))) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, gfp_flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\n\tif (unlikely(q == NULL)) {\n\t\tdec_rlimit_put_ucounts(ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t} else {\n\t\tINIT_LIST_HEAD(&q->list);\n\t\tq->flags = sigqueue_flags;\n\t\tq->ucounts = ucounts;\n\t}\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "legacy_queue",
          "args": [
            "pending",
            "sig"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "legacy_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1069-1072",
          "snippet": "static inline bool legacy_queue(struct sigpending *signals, int sig)\n{\n\treturn (sig < SIGRTMIN) && sigismember(&signals->signal, sig);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool legacy_queue(struct sigpending *signals, int sig)\n{\n\treturn (sig < SIGRTMIN) && sigismember(&signals->signal, sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_signal",
          "args": [
            "sig",
            "t",
            "force"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "903-966",
          "snippet": "static bool prepare_signal(int sig, struct task_struct *p, bool force)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\tsigset_t flush;\n\n\tif (signal->flags & SIGNAL_GROUP_EXIT) {\n\t\tif (signal->core_state)\n\t\t\treturn sig == SIGKILL;\n\t\t/*\n\t\t * The process is in the middle of dying, nothing to do.\n\t\t */\n\t} else if (sig_kernel_stop(sig)) {\n\t\t/*\n\t\t * This is a stop signal.  Remove SIGCONT from all queues.\n\t\t */\n\t\tsiginitset(&flush, sigmask(SIGCONT));\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t)\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t} else if (sig == SIGCONT) {\n\t\tunsigned int why;\n\t\t/*\n\t\t * Remove all stop signals from all queues, wake all threads.\n\t\t */\n\t\tsiginitset(&flush, SIG_KERNEL_STOP_MASK);\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t) {\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t\t\ttask_clear_jobctl_pending(t, JOBCTL_STOP_PENDING);\n\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\twake_up_state(t, __TASK_STOPPED);\n\t\t\telse\n\t\t\t\tptrace_trap_notify(t);\n\t\t}\n\n\t\t/*\n\t\t * Notify the parent with CLD_CONTINUED if we were stopped.\n\t\t *\n\t\t * If we were in the middle of a group stop, we pretend it\n\t\t * was already finished, and then continued. Since SIGCHLD\n\t\t * doesn't queue we report only CLD_STOPPED, as if the next\n\t\t * CLD_CONTINUED was dropped.\n\t\t */\n\t\twhy = 0;\n\t\tif (signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\twhy |= SIGNAL_CLD_CONTINUED;\n\t\telse if (signal->group_stop_count)\n\t\t\twhy |= SIGNAL_CLD_STOPPED;\n\n\t\tif (why) {\n\t\t\t/*\n\t\t\t * The first thread which returns from do_signal_stop()\n\t\t\t * will take ->siglock, notice SIGNAL_CLD_MASK, and\n\t\t\t * notify its parent. See get_signal().\n\t\t\t */\n\t\t\tsignal_set_stop_flags(signal, why | SIGNAL_STOP_CONTINUED);\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tsignal->group_exit_code = 0;\n\t\t}\n\t}\n\n\treturn !sig_ignored(p, sig, force);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool prepare_signal(int sig, struct task_struct *p, bool force)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\tsigset_t flush;\n\n\tif (signal->flags & SIGNAL_GROUP_EXIT) {\n\t\tif (signal->core_state)\n\t\t\treturn sig == SIGKILL;\n\t\t/*\n\t\t * The process is in the middle of dying, nothing to do.\n\t\t */\n\t} else if (sig_kernel_stop(sig)) {\n\t\t/*\n\t\t * This is a stop signal.  Remove SIGCONT from all queues.\n\t\t */\n\t\tsiginitset(&flush, sigmask(SIGCONT));\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t)\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t} else if (sig == SIGCONT) {\n\t\tunsigned int why;\n\t\t/*\n\t\t * Remove all stop signals from all queues, wake all threads.\n\t\t */\n\t\tsiginitset(&flush, SIG_KERNEL_STOP_MASK);\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t) {\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t\t\ttask_clear_jobctl_pending(t, JOBCTL_STOP_PENDING);\n\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\twake_up_state(t, __TASK_STOPPED);\n\t\t\telse\n\t\t\t\tptrace_trap_notify(t);\n\t\t}\n\n\t\t/*\n\t\t * Notify the parent with CLD_CONTINUED if we were stopped.\n\t\t *\n\t\t * If we were in the middle of a group stop, we pretend it\n\t\t * was already finished, and then continued. Since SIGCHLD\n\t\t * doesn't queue we report only CLD_STOPPED, as if the next\n\t\t * CLD_CONTINUED was dropped.\n\t\t */\n\t\twhy = 0;\n\t\tif (signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\twhy |= SIGNAL_CLD_CONTINUED;\n\t\telse if (signal->group_stop_count)\n\t\t\twhy |= SIGNAL_CLD_STOPPED;\n\n\t\tif (why) {\n\t\t\t/*\n\t\t\t * The first thread which returns from do_signal_stop()\n\t\t\t * will take ->siglock, notice SIGNAL_CLD_MASK, and\n\t\t\t * notify its parent. See get_signal().\n\t\t\t */\n\t\t\tsignal_set_stop_flags(signal, why | SIGNAL_STOP_CONTINUED);\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tsignal->group_exit_code = 0;\n\t\t}\n\t}\n\n\treturn !sig_ignored(p, sig, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&t->sighand->siglock"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type, bool force)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, force))\n\t\tgoto ret;\n\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tresult = TRACE_SIGNAL_DELIVERED;\n\t/*\n\t * Skip useless siginfo allocation for SIGKILL and kernel threads.\n\t */\n\tif ((sig == SIGKILL) || (t->flags & PF_KTHREAD))\n\t\tgoto out_set;\n\n\t/*\n\t * Real-time signals must be queued if sent by sigqueue, or\n\t * some other real-time mechanism.  It is implementation\n\t * defined whether kill() does so.  We attempt to do so, on\n\t * the principle of least surprise, but since kill is not\n\t * allowed to fail with EAGAIN when low on memory we just\n\t * make sure at least one signal gets delivered and don't\n\t * pass on the info struct.\n\t */\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, 0);\n\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\trcu_read_lock();\n\t\t\tq->info.si_uid =\n\t\t\t\tfrom_kuid_munged(task_cred_xxx(t, user_ns),\n\t\t\t\t\t\t current_uid());\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tbreak;\n\t\t}\n\t} else if (!is_si_special(info) &&\n\t\t   sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t/*\n\t\t * Queue overflow, abort.  We may abort if the\n\t\t * signal was rt and sent by user using something\n\t\t * other than kill().\n\t\t */\n\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\tret = -EAGAIN;\n\t\tgoto ret;\n\t} else {\n\t\t/*\n\t\t * This is a silent loss of information.  We still\n\t\t * send the signal, but the *info bits are lost.\n\t\t */\n\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\n\t/* Let multiprocess signals appear after on-going forks */\n\tif (type > PIDTYPE_TGID) {\n\t\tstruct multiprocess_signals *delayed;\n\t\thlist_for_each_entry(delayed, &t->signal->multiprocess, node) {\n\t\t\tsigset_t *signal = &delayed->signal;\n\t\t\t/* Can't queue both a stop and a continue signal */\n\t\t\tif (sig == SIGCONT)\n\t\t\t\tsigdelsetmask(signal, SIG_KERNEL_STOP_MASK);\n\t\t\telse if (sig_kernel_stop(sig))\n\t\t\t\tsigdelset(signal, SIGCONT);\n\t\t\tsigaddset(signal, sig);\n\t\t}\n\t}\n\n\tcomplete_signal(sig, t, type);\nret:\n\ttrace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);\n\treturn ret;\n}"
  },
  {
    "function_name": "legacy_queue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "1069-1072",
    "snippet": "static inline bool legacy_queue(struct sigpending *signals, int sig)\n{\n\treturn (sig < SIGRTMIN) && sigismember(&signals->signal, sig);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&signals->signal",
            "sig"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool legacy_queue(struct sigpending *signals, int sig)\n{\n\treturn (sig < SIGRTMIN) && sigismember(&signals->signal, sig);\n}"
  },
  {
    "function_name": "complete_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "993-1067",
    "snippet": "static void complete_signal(int sig, struct task_struct *p, enum pid_type type)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\n\t/*\n\t * Now find a thread we can wake up to take the signal off the queue.\n\t *\n\t * If the main thread wants the signal, it gets first crack.\n\t * Probably the least surprising to the average bear.\n\t */\n\tif (wants_signal(sig, p))\n\t\tt = p;\n\telse if ((type == PIDTYPE_PID) || thread_group_empty(p))\n\t\t/*\n\t\t * There is just one thread and it does not need to be woken.\n\t\t * It will dequeue unblocked signals before it runs again.\n\t\t */\n\t\treturn;\n\telse {\n\t\t/*\n\t\t * Otherwise try to find a suitable thread.\n\t\t */\n\t\tt = signal->curr_target;\n\t\twhile (!wants_signal(sig, t)) {\n\t\t\tt = next_thread(t);\n\t\t\tif (t == signal->curr_target)\n\t\t\t\t/*\n\t\t\t\t * No thread needs to be woken.\n\t\t\t\t * Any eligible threads will see\n\t\t\t\t * the signal in the queue soon.\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t}\n\t\tsignal->curr_target = t;\n\t}\n\n\t/*\n\t * Found a killable thread.  If the signal will be fatal,\n\t * then start taking the whole group down immediately.\n\t */\n\tif (sig_fatal(p, sig) &&\n\t    (signal->core_state || !(signal->flags & SIGNAL_GROUP_EXIT)) &&\n\t    !sigismember(&t->real_blocked, sig) &&\n\t    (sig == SIGKILL || !p->ptrace)) {\n\t\t/*\n\t\t * This signal will be fatal to the whole group.\n\t\t */\n\t\tif (!sig_kernel_coredump(sig)) {\n\t\t\t/*\n\t\t\t * Start a group exit and wake everybody up.\n\t\t\t * This way we don't have other threads\n\t\t\t * running and doing things after a slower\n\t\t\t * thread has the fatal signal pending.\n\t\t\t */\n\t\t\tsignal->flags = SIGNAL_GROUP_EXIT;\n\t\t\tsignal->group_exit_code = sig;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\t\tsignal_wake_up(t, 1);\n\t\t\t} while_each_thread(p, t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * The signal is already in the shared-pending queue.\n\t * Tell the chosen thread to wake up and dequeue it.\n\t */\n\tsignal_wake_up(t, sig == SIGKILL);\n\treturn;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_wake_up",
          "args": [
            "t",
            "sig == SIGKILL"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "763-775",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&t->pending.signal",
            "SIGKILL"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_clear_jobctl_pending",
          "args": [
            "t",
            "JOBCTL_PENDING_MASK"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "task_clear_jobctl_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "336-347",
          "snippet": "void task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sig_kernel_coredump",
          "args": [
            "sig"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&t->real_blocked",
            "sig"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_fatal",
          "args": [
            "p",
            "sig"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_thread",
          "args": [
            "t"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wants_signal",
          "args": [
            "sig",
            "t"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "wants_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "976-991",
          "snippet": "static inline bool wants_signal(int sig, struct task_struct *p)\n{\n\tif (sigismember(&p->blocked, sig))\n\t\treturn false;\n\n\tif (p->flags & PF_EXITING)\n\t\treturn false;\n\n\tif (sig == SIGKILL)\n\t\treturn true;\n\n\tif (task_is_stopped_or_traced(p))\n\t\treturn false;\n\n\treturn task_curr(p) || !task_sigpending(p);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool wants_signal(int sig, struct task_struct *p)\n{\n\tif (sigismember(&p->blocked, sig))\n\t\treturn false;\n\n\tif (p->flags & PF_EXITING)\n\t\treturn false;\n\n\tif (sig == SIGKILL)\n\t\treturn true;\n\n\tif (task_is_stopped_or_traced(p))\n\t\treturn false;\n\n\treturn task_curr(p) || !task_sigpending(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "p"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void complete_signal(int sig, struct task_struct *p, enum pid_type type)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\n\t/*\n\t * Now find a thread we can wake up to take the signal off the queue.\n\t *\n\t * If the main thread wants the signal, it gets first crack.\n\t * Probably the least surprising to the average bear.\n\t */\n\tif (wants_signal(sig, p))\n\t\tt = p;\n\telse if ((type == PIDTYPE_PID) || thread_group_empty(p))\n\t\t/*\n\t\t * There is just one thread and it does not need to be woken.\n\t\t * It will dequeue unblocked signals before it runs again.\n\t\t */\n\t\treturn;\n\telse {\n\t\t/*\n\t\t * Otherwise try to find a suitable thread.\n\t\t */\n\t\tt = signal->curr_target;\n\t\twhile (!wants_signal(sig, t)) {\n\t\t\tt = next_thread(t);\n\t\t\tif (t == signal->curr_target)\n\t\t\t\t/*\n\t\t\t\t * No thread needs to be woken.\n\t\t\t\t * Any eligible threads will see\n\t\t\t\t * the signal in the queue soon.\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t}\n\t\tsignal->curr_target = t;\n\t}\n\n\t/*\n\t * Found a killable thread.  If the signal will be fatal,\n\t * then start taking the whole group down immediately.\n\t */\n\tif (sig_fatal(p, sig) &&\n\t    (signal->core_state || !(signal->flags & SIGNAL_GROUP_EXIT)) &&\n\t    !sigismember(&t->real_blocked, sig) &&\n\t    (sig == SIGKILL || !p->ptrace)) {\n\t\t/*\n\t\t * This signal will be fatal to the whole group.\n\t\t */\n\t\tif (!sig_kernel_coredump(sig)) {\n\t\t\t/*\n\t\t\t * Start a group exit and wake everybody up.\n\t\t\t * This way we don't have other threads\n\t\t\t * running and doing things after a slower\n\t\t\t * thread has the fatal signal pending.\n\t\t\t */\n\t\t\tsignal->flags = SIGNAL_GROUP_EXIT;\n\t\t\tsignal->group_exit_code = sig;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\t\tsignal_wake_up(t, 1);\n\t\t\t} while_each_thread(p, t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * The signal is already in the shared-pending queue.\n\t * Tell the chosen thread to wake up and dequeue it.\n\t */\n\tsignal_wake_up(t, sig == SIGKILL);\n\treturn;\n}"
  },
  {
    "function_name": "wants_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "976-991",
    "snippet": "static inline bool wants_signal(int sig, struct task_struct *p)\n{\n\tif (sigismember(&p->blocked, sig))\n\t\treturn false;\n\n\tif (p->flags & PF_EXITING)\n\t\treturn false;\n\n\tif (sig == SIGKILL)\n\t\treturn true;\n\n\tif (task_is_stopped_or_traced(p))\n\t\treturn false;\n\n\treturn task_curr(p) || !task_sigpending(p);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_sigpending",
          "args": [
            "p"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_curr",
          "args": [
            "p"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "task_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2099-2102",
          "snippet": "inline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\ninline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_is_stopped_or_traced",
          "args": [
            "p"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&p->blocked",
            "sig"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool wants_signal(int sig, struct task_struct *p)\n{\n\tif (sigismember(&p->blocked, sig))\n\t\treturn false;\n\n\tif (p->flags & PF_EXITING)\n\t\treturn false;\n\n\tif (sig == SIGKILL)\n\t\treturn true;\n\n\tif (task_is_stopped_or_traced(p))\n\t\treturn false;\n\n\treturn task_curr(p) || !task_sigpending(p);\n}"
  },
  {
    "function_name": "prepare_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "903-966",
    "snippet": "static bool prepare_signal(int sig, struct task_struct *p, bool force)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\tsigset_t flush;\n\n\tif (signal->flags & SIGNAL_GROUP_EXIT) {\n\t\tif (signal->core_state)\n\t\t\treturn sig == SIGKILL;\n\t\t/*\n\t\t * The process is in the middle of dying, nothing to do.\n\t\t */\n\t} else if (sig_kernel_stop(sig)) {\n\t\t/*\n\t\t * This is a stop signal.  Remove SIGCONT from all queues.\n\t\t */\n\t\tsiginitset(&flush, sigmask(SIGCONT));\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t)\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t} else if (sig == SIGCONT) {\n\t\tunsigned int why;\n\t\t/*\n\t\t * Remove all stop signals from all queues, wake all threads.\n\t\t */\n\t\tsiginitset(&flush, SIG_KERNEL_STOP_MASK);\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t) {\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t\t\ttask_clear_jobctl_pending(t, JOBCTL_STOP_PENDING);\n\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\twake_up_state(t, __TASK_STOPPED);\n\t\t\telse\n\t\t\t\tptrace_trap_notify(t);\n\t\t}\n\n\t\t/*\n\t\t * Notify the parent with CLD_CONTINUED if we were stopped.\n\t\t *\n\t\t * If we were in the middle of a group stop, we pretend it\n\t\t * was already finished, and then continued. Since SIGCHLD\n\t\t * doesn't queue we report only CLD_STOPPED, as if the next\n\t\t * CLD_CONTINUED was dropped.\n\t\t */\n\t\twhy = 0;\n\t\tif (signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\twhy |= SIGNAL_CLD_CONTINUED;\n\t\telse if (signal->group_stop_count)\n\t\t\twhy |= SIGNAL_CLD_STOPPED;\n\n\t\tif (why) {\n\t\t\t/*\n\t\t\t * The first thread which returns from do_signal_stop()\n\t\t\t * will take ->siglock, notice SIGNAL_CLD_MASK, and\n\t\t\t * notify its parent. See get_signal().\n\t\t\t */\n\t\t\tsignal_set_stop_flags(signal, why | SIGNAL_STOP_CONTINUED);\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tsignal->group_exit_code = 0;\n\t\t}\n\t}\n\n\treturn !sig_ignored(p, sig, force);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sig_ignored",
          "args": [
            "p",
            "sig",
            "force"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "sig_ignored",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "101-120",
          "snippet": "static bool sig_ignored(struct task_struct *t, int sig, bool force)\n{\n\t/*\n\t * Blocked signals are never ignored, since the\n\t * signal handler may change by the time it is\n\t * unblocked.\n\t */\n\tif (sigismember(&t->blocked, sig) || sigismember(&t->real_blocked, sig))\n\t\treturn false;\n\n\t/*\n\t * Tracers may want to know about even ignored signal unless it\n\t * is SIGKILL which can't be reported anyway but can be ignored\n\t * by SIGNAL_UNKILLABLE task.\n\t */\n\tif (t->ptrace && sig != SIGKILL)\n\t\treturn false;\n\n\treturn sig_task_ignored(t, sig, force);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool sig_ignored(struct task_struct *t, int sig, bool force)\n{\n\t/*\n\t * Blocked signals are never ignored, since the\n\t * signal handler may change by the time it is\n\t * unblocked.\n\t */\n\tif (sigismember(&t->blocked, sig) || sigismember(&t->real_blocked, sig))\n\t\treturn false;\n\n\t/*\n\t * Tracers may want to know about even ignored signal unless it\n\t * is SIGKILL which can't be reported anyway but can be ignored\n\t * by SIGNAL_UNKILLABLE task.\n\t */\n\tif (t->ptrace && sig != SIGKILL)\n\t\treturn false;\n\n\treturn sig_task_ignored(t, sig, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_set_stop_flags",
          "args": [
            "signal",
            "why | SIGNAL_STOP_CONTINUED"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_trap_notify",
          "args": [
            "t"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_trap_notify",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "884-891",
          "snippet": "static void ptrace_trap_notify(struct task_struct *t)\n{\n\tWARN_ON_ONCE(!(t->ptrace & PT_SEIZED));\n\tassert_spin_locked(&t->sighand->siglock);\n\n\ttask_set_jobctl_pending(t, JOBCTL_TRAP_NOTIFY);\n\tptrace_signal_wake_up(t, t->jobctl & JOBCTL_LISTENING);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void ptrace_trap_notify(struct task_struct *t)\n{\n\tWARN_ON_ONCE(!(t->ptrace & PT_SEIZED));\n\tassert_spin_locked(&t->sighand->siglock);\n\n\ttask_set_jobctl_pending(t, JOBCTL_TRAP_NOTIFY);\n\tptrace_signal_wake_up(t, t->jobctl & JOBCTL_LISTENING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_state",
          "args": [
            "t",
            "__TASK_STOPPED"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "763-775",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(t->ptrace & PT_SEIZED)"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_clear_jobctl_pending",
          "args": [
            "t",
            "JOBCTL_STOP_PENDING"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "task_clear_jobctl_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "336-347",
          "snippet": "void task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_sigqueue_mask",
          "args": [
            "&flush",
            "&t->pending"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "flush_sigqueue_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "783-799",
          "snippet": "static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginitset",
          "args": [
            "&flush",
            "SIG_KERNEL_STOP_MASK"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginitset",
          "args": [
            "&flush",
            "sigmask(SIGCONT)"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGCONT"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_kernel_stop",
          "args": [
            "sig"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool prepare_signal(int sig, struct task_struct *p, bool force)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\tsigset_t flush;\n\n\tif (signal->flags & SIGNAL_GROUP_EXIT) {\n\t\tif (signal->core_state)\n\t\t\treturn sig == SIGKILL;\n\t\t/*\n\t\t * The process is in the middle of dying, nothing to do.\n\t\t */\n\t} else if (sig_kernel_stop(sig)) {\n\t\t/*\n\t\t * This is a stop signal.  Remove SIGCONT from all queues.\n\t\t */\n\t\tsiginitset(&flush, sigmask(SIGCONT));\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t)\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t} else if (sig == SIGCONT) {\n\t\tunsigned int why;\n\t\t/*\n\t\t * Remove all stop signals from all queues, wake all threads.\n\t\t */\n\t\tsiginitset(&flush, SIG_KERNEL_STOP_MASK);\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t) {\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t\t\ttask_clear_jobctl_pending(t, JOBCTL_STOP_PENDING);\n\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\twake_up_state(t, __TASK_STOPPED);\n\t\t\telse\n\t\t\t\tptrace_trap_notify(t);\n\t\t}\n\n\t\t/*\n\t\t * Notify the parent with CLD_CONTINUED if we were stopped.\n\t\t *\n\t\t * If we were in the middle of a group stop, we pretend it\n\t\t * was already finished, and then continued. Since SIGCHLD\n\t\t * doesn't queue we report only CLD_STOPPED, as if the next\n\t\t * CLD_CONTINUED was dropped.\n\t\t */\n\t\twhy = 0;\n\t\tif (signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\twhy |= SIGNAL_CLD_CONTINUED;\n\t\telse if (signal->group_stop_count)\n\t\t\twhy |= SIGNAL_CLD_STOPPED;\n\n\t\tif (why) {\n\t\t\t/*\n\t\t\t * The first thread which returns from do_signal_stop()\n\t\t\t * will take ->siglock, notice SIGNAL_CLD_MASK, and\n\t\t\t * notify its parent. See get_signal().\n\t\t\t */\n\t\t\tsignal_set_stop_flags(signal, why | SIGNAL_STOP_CONTINUED);\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tsignal->group_exit_code = 0;\n\t\t}\n\t}\n\n\treturn !sig_ignored(p, sig, force);\n}"
  },
  {
    "function_name": "ptrace_trap_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "884-891",
    "snippet": "static void ptrace_trap_notify(struct task_struct *t)\n{\n\tWARN_ON_ONCE(!(t->ptrace & PT_SEIZED));\n\tassert_spin_locked(&t->sighand->siglock);\n\n\ttask_set_jobctl_pending(t, JOBCTL_TRAP_NOTIFY);\n\tptrace_signal_wake_up(t, t->jobctl & JOBCTL_LISTENING);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrace_signal_wake_up",
          "args": [
            "t",
            "t->jobctl & JOBCTL_LISTENING"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_set_jobctl_pending",
          "args": [
            "t",
            "JOBCTL_TRAP_NOTIFY"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "task_set_jobctl_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "284-298",
          "snippet": "bool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&t->sighand->siglock"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(t->ptrace & PT_SEIZED)"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void ptrace_trap_notify(struct task_struct *t)\n{\n\tWARN_ON_ONCE(!(t->ptrace & PT_SEIZED));\n\tassert_spin_locked(&t->sighand->siglock);\n\n\ttask_set_jobctl_pending(t, JOBCTL_TRAP_NOTIFY);\n\tptrace_signal_wake_up(t, t->jobctl & JOBCTL_LISTENING);\n}"
  },
  {
    "function_name": "check_kill_permission",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "831-865",
    "snippet": "static int check_kill_permission(int sig, struct kernel_siginfo *info,\n\t\t\t\t struct task_struct *t)\n{\n\tstruct pid *sid;\n\tint error;\n\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\tif (!si_fromuser(info))\n\t\treturn 0;\n\n\terror = audit_signal_info(sig, t); /* Let audit system see the signal */\n\tif (error)\n\t\treturn error;\n\n\tif (!same_thread_group(current, t) &&\n\t    !kill_ok_by_cred(t)) {\n\t\tswitch (sig) {\n\t\tcase SIGCONT:\n\t\t\tsid = task_session(t);\n\t\t\t/*\n\t\t\t * We don't return the error if sid == NULL. The\n\t\t\t * task was unhashed, the caller must notice this.\n\t\t\t */\n\t\t\tif (!sid || sid == task_session(current))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn security_task_kill(t, info, sig, NULL);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_task_kill",
          "args": [
            "t",
            "info",
            "sig",
            "NULL"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_session",
          "args": [
            "current"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_session",
          "args": [
            "t"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_ok_by_cred",
          "args": [
            "t"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "kill_ok_by_cred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "815-825",
          "snippet": "static bool kill_ok_by_cred(struct task_struct *t)\n{\n\tconst struct cred *cred = current_cred();\n\tconst struct cred *tcred = __task_cred(t);\n\n\treturn uid_eq(cred->euid, tcred->suid) ||\n\t       uid_eq(cred->euid, tcred->uid) ||\n\t       uid_eq(cred->uid, tcred->suid) ||\n\t       uid_eq(cred->uid, tcred->uid) ||\n\t       ns_capable(tcred->user_ns, CAP_KILL);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool kill_ok_by_cred(struct task_struct *t)\n{\n\tconst struct cred *cred = current_cred();\n\tconst struct cred *tcred = __task_cred(t);\n\n\treturn uid_eq(cred->euid, tcred->suid) ||\n\t       uid_eq(cred->euid, tcred->uid) ||\n\t       uid_eq(cred->uid, tcred->suid) ||\n\t       uid_eq(cred->uid, tcred->uid) ||\n\t       ns_capable(tcred->user_ns, CAP_KILL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "current",
            "t"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_signal_info",
          "args": [
            "sig",
            "t"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "audit_signal_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "2358-2375",
          "snippet": "int audit_signal_info(int sig, struct task_struct *t)\n{\n\tkuid_t uid = current_uid(), auid;\n\n\tif (auditd_test_task(t) &&\n\t    (sig == SIGTERM || sig == SIGHUP ||\n\t     sig == SIGUSR1 || sig == SIGUSR2)) {\n\t\taudit_sig_pid = task_tgid_nr(current);\n\t\tauid = audit_get_loginuid(current);\n\t\tif (uid_valid(auid))\n\t\t\taudit_sig_uid = auid;\n\t\telse\n\t\t\taudit_sig_uid = uid;\n\t\tsecurity_current_getsecid_subj(&audit_sig_sid);\n\t}\n\n\treturn audit_signal_info_syscall(t);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static kuid_t\t\taudit_sig_uid = INVALID_UID;",
            "static pid_t\t\taudit_sig_pid = -1;",
            "static u32\t\taudit_sig_sid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic kuid_t\t\taudit_sig_uid = INVALID_UID;\nstatic pid_t\t\taudit_sig_pid = -1;\nstatic u32\t\taudit_sig_sid;\n\nint audit_signal_info(int sig, struct task_struct *t)\n{\n\tkuid_t uid = current_uid(), auid;\n\n\tif (auditd_test_task(t) &&\n\t    (sig == SIGTERM || sig == SIGHUP ||\n\t     sig == SIGUSR1 || sig == SIGUSR2)) {\n\t\taudit_sig_pid = task_tgid_nr(current);\n\t\tauid = audit_get_loginuid(current);\n\t\tif (uid_valid(auid))\n\t\t\taudit_sig_uid = auid;\n\t\telse\n\t\t\taudit_sig_uid = uid;\n\t\tsecurity_current_getsecid_subj(&audit_sig_sid);\n\t}\n\n\treturn audit_signal_info_syscall(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "si_fromuser",
          "args": [
            "info"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "si_fromuser",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "806-810",
          "snippet": "static inline bool si_fromuser(const struct kernel_siginfo *info)\n{\n\treturn info == SEND_SIG_NOINFO ||\n\t\t(!is_si_special(info) && SI_FROMUSER(info));\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool si_fromuser(const struct kernel_siginfo *info)\n{\n\treturn info == SEND_SIG_NOINFO ||\n\t\t(!is_si_special(info) && SI_FROMUSER(info));\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_signal",
          "args": [
            "sig"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int check_kill_permission(int sig, struct kernel_siginfo *info,\n\t\t\t\t struct task_struct *t)\n{\n\tstruct pid *sid;\n\tint error;\n\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\tif (!si_fromuser(info))\n\t\treturn 0;\n\n\terror = audit_signal_info(sig, t); /* Let audit system see the signal */\n\tif (error)\n\t\treturn error;\n\n\tif (!same_thread_group(current, t) &&\n\t    !kill_ok_by_cred(t)) {\n\t\tswitch (sig) {\n\t\tcase SIGCONT:\n\t\t\tsid = task_session(t);\n\t\t\t/*\n\t\t\t * We don't return the error if sid == NULL. The\n\t\t\t * task was unhashed, the caller must notice this.\n\t\t\t */\n\t\t\tif (!sid || sid == task_session(current))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn security_task_kill(t, info, sig, NULL);\n}"
  },
  {
    "function_name": "kill_ok_by_cred",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "815-825",
    "snippet": "static bool kill_ok_by_cred(struct task_struct *t)\n{\n\tconst struct cred *cred = current_cred();\n\tconst struct cred *tcred = __task_cred(t);\n\n\treturn uid_eq(cred->euid, tcred->suid) ||\n\t       uid_eq(cred->euid, tcred->uid) ||\n\t       uid_eq(cred->uid, tcred->suid) ||\n\t       uid_eq(cred->uid, tcred->uid) ||\n\t       ns_capable(tcred->user_ns, CAP_KILL);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "tcred->user_ns",
            "CAP_KILL"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_setid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "431-434",
          "snippet": "bool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_setid(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, CAP_OPT_INSETID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->uid",
            "tcred->uid"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->uid",
            "tcred->suid"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->euid",
            "tcred->uid"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->euid",
            "tcred->suid"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "t"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool kill_ok_by_cred(struct task_struct *t)\n{\n\tconst struct cred *cred = current_cred();\n\tconst struct cred *tcred = __task_cred(t);\n\n\treturn uid_eq(cred->euid, tcred->suid) ||\n\t       uid_eq(cred->euid, tcred->uid) ||\n\t       uid_eq(cred->uid, tcred->suid) ||\n\t       uid_eq(cred->uid, tcred->uid) ||\n\t       ns_capable(tcred->user_ns, CAP_KILL);\n}"
  },
  {
    "function_name": "si_fromuser",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "806-810",
    "snippet": "static inline bool si_fromuser(const struct kernel_siginfo *info)\n{\n\treturn info == SEND_SIG_NOINFO ||\n\t\t(!is_si_special(info) && SI_FROMUSER(info));\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SI_FROMUSER",
          "args": [
            "info"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_si_special",
          "args": [
            "info"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "is_si_special",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "801-804",
          "snippet": "static inline int is_si_special(const struct kernel_siginfo *info)\n{\n\treturn info <= SEND_SIG_PRIV;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline int is_si_special(const struct kernel_siginfo *info)\n{\n\treturn info <= SEND_SIG_PRIV;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool si_fromuser(const struct kernel_siginfo *info)\n{\n\treturn info == SEND_SIG_NOINFO ||\n\t\t(!is_si_special(info) && SI_FROMUSER(info));\n}"
  },
  {
    "function_name": "is_si_special",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "801-804",
    "snippet": "static inline int is_si_special(const struct kernel_siginfo *info)\n{\n\treturn info <= SEND_SIG_PRIV;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline int is_si_special(const struct kernel_siginfo *info)\n{\n\treturn info <= SEND_SIG_PRIV;\n}"
  },
  {
    "function_name": "flush_sigqueue_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "783-799",
    "snippet": "static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sigqueue_free",
          "args": [
            "q"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "__sigqueue_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "450-459",
          "snippet": "static void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tif (q->ucounts) {\n\t\tdec_rlimit_put_ucounts(q->ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t\tq->ucounts = NULL;\n\t}\n\tkmem_cache_free(sigqueue_cachep, q);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sigqueue_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tif (q->ucounts) {\n\t\tdec_rlimit_put_ucounts(q->ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t\tq->ucounts = NULL;\n\t}\n\tkmem_cache_free(sigqueue_cachep, q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&q->list"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "mask",
            "q->info.si_signo"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "q",
            "n",
            "&s->list",
            "list"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigandnsets",
          "args": [
            "&s->signal",
            "&s->signal",
            "mask"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigisemptyset",
          "args": [
            "&m"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigandsets",
          "args": [
            "&m",
            "mask",
            "&s->signal"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "signal_wake_up_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "763-775",
    "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kick_process",
          "args": [
            "t"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "kick_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "3319-3328",
          "snippet": "void kick_process(struct task_struct *p)\n{\n\tint cpu;\n\n\tpreempt_disable();\n\tcpu = task_cpu(p);\n\tif ((cpu != smp_processor_id()) && task_curr(p))\n\t\tsmp_send_reschedule(cpu);\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid kick_process(struct task_struct *p)\n{\n\tint cpu;\n\n\tpreempt_disable();\n\tcpu = task_cpu(p);\n\tif ((cpu != smp_processor_id()) && task_curr(p))\n\t\tsmp_send_reschedule(cpu);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_state",
          "args": [
            "t",
            "state | TASK_INTERRUPTIBLE"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "763-775",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "t",
            "TIF_SIGPENDING"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
  },
  {
    "function_name": "dequeue_synchronous_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "710-750",
    "snippet": "static int dequeue_synchronous_signal(kernel_siginfo_t *info)\n{\n\tstruct task_struct *tsk = current;\n\tstruct sigpending *pending = &tsk->pending;\n\tstruct sigqueue *q, *sync = NULL;\n\n\t/*\n\t * Might a synchronous signal be in the queue?\n\t */\n\tif (!((pending->signal.sig[0] & ~tsk->blocked.sig[0]) & SYNCHRONOUS_MASK))\n\t\treturn 0;\n\n\t/*\n\t * Return the first synchronous signal in the queue.\n\t */\n\tlist_for_each_entry(q, &pending->list, list) {\n\t\t/* Synchronous signals have a positive si_code */\n\t\tif ((q->info.si_code > SI_USER) &&\n\t\t    (sigmask(q->info.si_signo) & SYNCHRONOUS_MASK)) {\n\t\t\tsync = q;\n\t\t\tgoto next;\n\t\t}\n\t}\n\treturn 0;\nnext:\n\t/*\n\t * Check if there is another siginfo for the same signal.\n\t */\n\tlist_for_each_entry_continue(q, &pending->list, list) {\n\t\tif (q->info.si_signo == sync->info.si_signo)\n\t\t\tgoto still_pending;\n\t}\n\n\tsigdelset(&pending->signal, sync->info.si_signo);\n\trecalc_sigpending();\nstill_pending:\n\tlist_del_init(&sync->list);\n\tcopy_siginfo(info, &sync->info);\n\t__sigqueue_free(sync);\n\treturn info->si_signo;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define SYNCHRONOUS_MASK \\\n\t(sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \\\n\t sigmask(SIGTRAP) | sigmask(SIGFPE) | sigmask(SIGSYS))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sigqueue_free",
          "args": [
            "sync"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "__sigqueue_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "450-459",
          "snippet": "static void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tif (q->ucounts) {\n\t\tdec_rlimit_put_ucounts(q->ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t\tq->ucounts = NULL;\n\t}\n\tkmem_cache_free(sigqueue_cachep, q);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sigqueue_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tif (q->ucounts) {\n\t\tdec_rlimit_put_ucounts(q->ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t\tq->ucounts = NULL;\n\t}\n\tkmem_cache_free(sigqueue_cachep, q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_siginfo",
          "args": [
            "info",
            "&sync->info"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_from_user_any",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3804-3818",
          "snippet": "static int copy_siginfo_from_user_any(kernel_siginfo_t *kinfo,\n\t\tsiginfo_t __user *info)\n{\n#ifdef CONFIG_COMPAT\n\t/*\n\t * Avoid hooking up compat syscalls and instead handle necessary\n\t * conversions here. Note, this is a stop-gap measure and should not be\n\t * considered a generic solution.\n\t */\n\tif (in_compat_syscall())\n\t\treturn copy_siginfo_from_user32(\n\t\t\tkinfo, (struct compat_siginfo __user *)info);\n#endif\n\treturn copy_siginfo_from_user(kinfo, info);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int copy_siginfo_from_user_any(kernel_siginfo_t *kinfo,\n\t\tsiginfo_t __user *info)\n{\n#ifdef CONFIG_COMPAT\n\t/*\n\t * Avoid hooking up compat syscalls and instead handle necessary\n\t * conversions here. Note, this is a stop-gap measure and should not be\n\t * considered a generic solution.\n\t */\n\tif (in_compat_syscall())\n\t\treturn copy_siginfo_from_user32(\n\t\t\tkinfo, (struct compat_siginfo __user *)info);\n#endif\n\treturn copy_siginfo_from_user(kinfo, info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&sync->list"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "182-187",
          "snippet": "void recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&pending->signal",
            "sync->info.si_signo"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "q",
            "&pending->list",
            "list"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "q->info.si_signo"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "q",
            "&pending->list",
            "list"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\n#define SYNCHRONOUS_MASK \\\n\t(sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \\\n\t sigmask(SIGTRAP) | sigmask(SIGFPE) | sigmask(SIGSYS))\n\nstatic int dequeue_synchronous_signal(kernel_siginfo_t *info)\n{\n\tstruct task_struct *tsk = current;\n\tstruct sigpending *pending = &tsk->pending;\n\tstruct sigqueue *q, *sync = NULL;\n\n\t/*\n\t * Might a synchronous signal be in the queue?\n\t */\n\tif (!((pending->signal.sig[0] & ~tsk->blocked.sig[0]) & SYNCHRONOUS_MASK))\n\t\treturn 0;\n\n\t/*\n\t * Return the first synchronous signal in the queue.\n\t */\n\tlist_for_each_entry(q, &pending->list, list) {\n\t\t/* Synchronous signals have a positive si_code */\n\t\tif ((q->info.si_code > SI_USER) &&\n\t\t    (sigmask(q->info.si_signo) & SYNCHRONOUS_MASK)) {\n\t\t\tsync = q;\n\t\t\tgoto next;\n\t\t}\n\t}\n\treturn 0;\nnext:\n\t/*\n\t * Check if there is another siginfo for the same signal.\n\t */\n\tlist_for_each_entry_continue(q, &pending->list, list) {\n\t\tif (q->info.si_signo == sync->info.si_signo)\n\t\t\tgoto still_pending;\n\t}\n\n\tsigdelset(&pending->signal, sync->info.si_signo);\n\trecalc_sigpending();\nstill_pending:\n\tlist_del_init(&sync->list);\n\tcopy_siginfo(info, &sync->info);\n\t__sigqueue_free(sync);\n\treturn info->si_signo;\n}"
  },
  {
    "function_name": "dequeue_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "629-707",
    "snippet": "int dequeue_signal(struct task_struct *tsk, sigset_t *mask,\n\t\t   kernel_siginfo_t *info, enum pid_type *type)\n{\n\tbool resched_timer = false;\n\tint signr;\n\n\t/* We only dequeue private signals from ourselves, we don't let\n\t * signalfd steal them\n\t */\n\t*type = PIDTYPE_PID;\n\tsignr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);\n\tif (!signr) {\n\t\t*type = PIDTYPE_TGID;\n\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,\n\t\t\t\t\t mask, info, &resched_timer);\n#ifdef CONFIG_POSIX_TIMERS\n\t\t/*\n\t\t * itimer signal ?\n\t\t *\n\t\t * itimers are process shared and we restart periodic\n\t\t * itimers in the signal delivery path to prevent DoS\n\t\t * attacks in the high resolution timer case. This is\n\t\t * compliant with the old way of self-restarting\n\t\t * itimers, as the SIGALRM is a legacy signal and only\n\t\t * queued once. Changing the restart behaviour to\n\t\t * restart the timer in the signal dequeue path is\n\t\t * reducing the timer noise on heavy loaded !highres\n\t\t * systems too.\n\t\t */\n\t\tif (unlikely(signr == SIGALRM)) {\n\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;\n\n\t\t\tif (!hrtimer_is_queued(tmr) &&\n\t\t\t    tsk->signal->it_real_incr != 0) {\n\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),\n\t\t\t\t\t\ttsk->signal->it_real_incr);\n\t\t\t\thrtimer_restart(tmr);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\trecalc_sigpending();\n\tif (!signr)\n\t\treturn 0;\n\n\tif (unlikely(sig_kernel_stop(signr))) {\n\t\t/*\n\t\t * Set a marker that we have dequeued a stop signal.  Our\n\t\t * caller might release the siglock and then the pending\n\t\t * stop signal it is about to process is no longer in the\n\t\t * pending bitmasks, but must still be cleared by a SIGCONT\n\t\t * (and overruled by a SIGKILL).  So those cases clear this\n\t\t * shared flag after we've set it.  Note that this flag may\n\t\t * remain set after the signal we return is ignored or\n\t\t * handled.  That doesn't matter because its only purpose\n\t\t * is to alert stop-signal processing code when another\n\t\t * processor has come along and cleared the flag.\n\t\t */\n\t\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\t}\n#ifdef CONFIG_POSIX_TIMERS\n\tif (resched_timer) {\n\t\t/*\n\t\t * Release the siglock to ensure proper locking order\n\t\t * of timer locks outside of siglocks.  Note, we leave\n\t\t * irqs disabled here, since the posix-timers code is\n\t\t * about to disable them again anyway.\n\t\t */\n\t\tspin_unlock(&tsk->sighand->siglock);\n\t\tposixtimer_rearm(info);\n\t\tspin_lock(&tsk->sighand->siglock);\n\n\t\t/* Don't expose the si_sys_private value to userspace */\n\t\tinfo->si_sys_private = 0;\n\t}\n#endif\n\treturn signr;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posixtimer_rearm",
          "args": [
            "info"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "posixtimer_rearm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "313-334",
          "snippet": "void posixtimer_rearm(struct kernel_siginfo *info)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\n\ttimr = lock_timer(info->si_tid, &flags);\n\tif (!timr)\n\t\treturn;\n\n\tif (timr->it_interval && timr->it_requeue_pending == info->si_sys_private) {\n\t\ttimr->kclock->timer_rearm(timr);\n\n\t\ttimr->it_active = 1;\n\t\ttimr->it_overrun_last = timr->it_overrun;\n\t\ttimr->it_overrun = -1LL;\n\t\t++timr->it_requeue_pending;\n\n\t\tinfo->si_overrun = timer_overrun_to_int(timr, info->si_overrun);\n\t}\n\n\tunlock_timer(timr, flags);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nvoid posixtimer_rearm(struct kernel_siginfo *info)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\n\ttimr = lock_timer(info->si_tid, &flags);\n\tif (!timr)\n\t\treturn;\n\n\tif (timr->it_interval && timr->it_requeue_pending == info->si_sys_private) {\n\t\ttimr->kclock->timer_rearm(timr);\n\n\t\ttimr->it_active = 1;\n\t\ttimr->it_overrun_last = timr->it_overrun;\n\t\ttimr->it_overrun = -1LL;\n\t\t++timr->it_requeue_pending;\n\n\t\tinfo->si_overrun = timer_overrun_to_int(timr, info->si_overrun);\n\t}\n\n\tunlock_timer(timr, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sig_kernel_stop(signr)"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_kernel_stop",
          "args": [
            "signr"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "182-187",
          "snippet": "void recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_restart",
          "args": [
            "tmr"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "perf_mux_hrtimer_restart",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "1175-1194",
          "snippet": "static int perf_mux_hrtimer_restart(struct perf_cpu_context *cpuctx)\n{\n\tstruct hrtimer *timer = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tunsigned long flags;\n\n\t/* not for SW PMU */\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn 0;\n\n\traw_spin_lock_irqsave(&cpuctx->hrtimer_lock, flags);\n\tif (!cpuctx->hrtimer_active) {\n\t\tcpuctx->hrtimer_active = 1;\n\t\thrtimer_forward_now(timer, cpuctx->hrtimer_interval);\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED_HARD);\n\t}\n\traw_spin_unlock_irqrestore(&cpuctx->hrtimer_lock, flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool perf_rotate_context(struct perf_cpu_context *cpuctx);",
            "static void update_context_time(struct perf_event_context *ctx);",
            "static __must_check struct",
            "static void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);",
            "static bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);",
            "static void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic bool perf_rotate_context(struct perf_cpu_context *cpuctx);\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic __must_check struct;\nstatic void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);\nstatic bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);\nstatic void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);\n\nstatic int perf_mux_hrtimer_restart(struct perf_cpu_context *cpuctx)\n{\n\tstruct hrtimer *timer = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tunsigned long flags;\n\n\t/* not for SW PMU */\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn 0;\n\n\traw_spin_lock_irqsave(&cpuctx->hrtimer_lock, flags);\n\tif (!cpuctx->hrtimer_active) {\n\t\tcpuctx->hrtimer_active = 1;\n\t\thrtimer_forward_now(timer, cpuctx->hrtimer_interval);\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED_HARD);\n\t}\n\traw_spin_unlock_irqrestore(&cpuctx->hrtimer_lock, flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_forward",
          "args": [
            "tmr",
            "tmr->base->get_time()",
            "tsk->signal->it_real_incr"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_forward",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1037-1069",
          "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmr->base->get_time",
          "args": [],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_is_queued",
          "args": [
            "tmr"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "signr == SIGALRM"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dequeue_signal",
          "args": [
            "&tsk->signal->shared_pending",
            "mask",
            "info",
            "&resched_timer"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "__dequeue_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "613-621",
          "snippet": "static int __dequeue_signal(struct sigpending *pending, sigset_t *mask,\n\t\t\tkernel_siginfo_t *info, bool *resched_timer)\n{\n\tint sig = next_signal(pending, mask);\n\n\tif (sig)\n\t\tcollect_signal(sig, pending, info, resched_timer);\n\treturn sig;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int __dequeue_signal(struct sigpending *pending, sigset_t *mask,\n\t\t\tkernel_siginfo_t *info, bool *resched_timer)\n{\n\tint sig = next_signal(pending, mask);\n\n\tif (sig)\n\t\tcollect_signal(sig, pending, info, resched_timer);\n\treturn sig;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint dequeue_signal(struct task_struct *tsk, sigset_t *mask,\n\t\t   kernel_siginfo_t *info, enum pid_type *type)\n{\n\tbool resched_timer = false;\n\tint signr;\n\n\t/* We only dequeue private signals from ourselves, we don't let\n\t * signalfd steal them\n\t */\n\t*type = PIDTYPE_PID;\n\tsignr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);\n\tif (!signr) {\n\t\t*type = PIDTYPE_TGID;\n\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,\n\t\t\t\t\t mask, info, &resched_timer);\n#ifdef CONFIG_POSIX_TIMERS\n\t\t/*\n\t\t * itimer signal ?\n\t\t *\n\t\t * itimers are process shared and we restart periodic\n\t\t * itimers in the signal delivery path to prevent DoS\n\t\t * attacks in the high resolution timer case. This is\n\t\t * compliant with the old way of self-restarting\n\t\t * itimers, as the SIGALRM is a legacy signal and only\n\t\t * queued once. Changing the restart behaviour to\n\t\t * restart the timer in the signal dequeue path is\n\t\t * reducing the timer noise on heavy loaded !highres\n\t\t * systems too.\n\t\t */\n\t\tif (unlikely(signr == SIGALRM)) {\n\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;\n\n\t\t\tif (!hrtimer_is_queued(tmr) &&\n\t\t\t    tsk->signal->it_real_incr != 0) {\n\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),\n\t\t\t\t\t\ttsk->signal->it_real_incr);\n\t\t\t\thrtimer_restart(tmr);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\trecalc_sigpending();\n\tif (!signr)\n\t\treturn 0;\n\n\tif (unlikely(sig_kernel_stop(signr))) {\n\t\t/*\n\t\t * Set a marker that we have dequeued a stop signal.  Our\n\t\t * caller might release the siglock and then the pending\n\t\t * stop signal it is about to process is no longer in the\n\t\t * pending bitmasks, but must still be cleared by a SIGCONT\n\t\t * (and overruled by a SIGKILL).  So those cases clear this\n\t\t * shared flag after we've set it.  Note that this flag may\n\t\t * remain set after the signal we return is ignored or\n\t\t * handled.  That doesn't matter because its only purpose\n\t\t * is to alert stop-signal processing code when another\n\t\t * processor has come along and cleared the flag.\n\t\t */\n\t\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\t}\n#ifdef CONFIG_POSIX_TIMERS\n\tif (resched_timer) {\n\t\t/*\n\t\t * Release the siglock to ensure proper locking order\n\t\t * of timer locks outside of siglocks.  Note, we leave\n\t\t * irqs disabled here, since the posix-timers code is\n\t\t * about to disable them again anyway.\n\t\t */\n\t\tspin_unlock(&tsk->sighand->siglock);\n\t\tposixtimer_rearm(info);\n\t\tspin_lock(&tsk->sighand->siglock);\n\n\t\t/* Don't expose the si_sys_private value to userspace */\n\t\tinfo->si_sys_private = 0;\n\t}\n#endif\n\treturn signr;\n}"
  },
  {
    "function_name": "__dequeue_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "613-621",
    "snippet": "static int __dequeue_signal(struct sigpending *pending, sigset_t *mask,\n\t\t\tkernel_siginfo_t *info, bool *resched_timer)\n{\n\tint sig = next_signal(pending, mask);\n\n\tif (sig)\n\t\tcollect_signal(sig, pending, info, resched_timer);\n\treturn sig;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "collect_signal",
          "args": [
            "sig",
            "pending",
            "info",
            "resched_timer"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "collect_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "568-611",
          "snippet": "static void collect_signal(int sig, struct sigpending *list, kernel_siginfo_t *info,\n\t\t\t   bool *resched_timer)\n{\n\tstruct sigqueue *q, *first = NULL;\n\n\t/*\n\t * Collect the siginfo appropriate to this signal.  Check if\n\t * there is another siginfo for the same signal.\n\t*/\n\tlist_for_each_entry(q, &list->list, list) {\n\t\tif (q->info.si_signo == sig) {\n\t\t\tif (first)\n\t\t\t\tgoto still_pending;\n\t\t\tfirst = q;\n\t\t}\n\t}\n\n\tsigdelset(&list->signal, sig);\n\n\tif (first) {\nstill_pending:\n\t\tlist_del_init(&first->list);\n\t\tcopy_siginfo(info, &first->info);\n\n\t\t*resched_timer =\n\t\t\t(first->flags & SIGQUEUE_PREALLOC) &&\n\t\t\t(info->si_code == SI_TIMER) &&\n\t\t\t(info->si_sys_private);\n\n\t\t__sigqueue_free(first);\n\t} else {\n\t\t/*\n\t\t * Ok, it wasn't in the queue.  This must be\n\t\t * a fast-pathed signal or we must have been\n\t\t * out of queue space.  So zero out the info.\n\t\t */\n\t\tclear_siginfo(info);\n\t\tinfo->si_signo = sig;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = 0;\n\t\tinfo->si_uid = 0;\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void collect_signal(int sig, struct sigpending *list, kernel_siginfo_t *info,\n\t\t\t   bool *resched_timer)\n{\n\tstruct sigqueue *q, *first = NULL;\n\n\t/*\n\t * Collect the siginfo appropriate to this signal.  Check if\n\t * there is another siginfo for the same signal.\n\t*/\n\tlist_for_each_entry(q, &list->list, list) {\n\t\tif (q->info.si_signo == sig) {\n\t\t\tif (first)\n\t\t\t\tgoto still_pending;\n\t\t\tfirst = q;\n\t\t}\n\t}\n\n\tsigdelset(&list->signal, sig);\n\n\tif (first) {\nstill_pending:\n\t\tlist_del_init(&first->list);\n\t\tcopy_siginfo(info, &first->info);\n\n\t\t*resched_timer =\n\t\t\t(first->flags & SIGQUEUE_PREALLOC) &&\n\t\t\t(info->si_code == SI_TIMER) &&\n\t\t\t(info->si_sys_private);\n\n\t\t__sigqueue_free(first);\n\t} else {\n\t\t/*\n\t\t * Ok, it wasn't in the queue.  This must be\n\t\t * a fast-pathed signal or we must have been\n\t\t * out of queue space.  So zero out the info.\n\t\t */\n\t\tclear_siginfo(info);\n\t\tinfo->si_signo = sig;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = 0;\n\t\tinfo->si_uid = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_signal",
          "args": [
            "pending",
            "mask"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "next_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "207-251",
          "snippet": "int next_signal(struct sigpending *pending, sigset_t *mask)\n{\n\tunsigned long i, *s, *m, x;\n\tint sig = 0;\n\n\ts = pending->signal.sig;\n\tm = mask->sig;\n\n\t/*\n\t * Handle the first word specially: it contains the\n\t * synchronous signals that need to be dequeued first.\n\t */\n\tx = *s &~ *m;\n\tif (x) {\n\t\tif (x & SYNCHRONOUS_MASK)\n\t\t\tx &= SYNCHRONOUS_MASK;\n\t\tsig = ffz(~x) + 1;\n\t\treturn sig;\n\t}\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = 1; i < _NSIG_WORDS; ++i) {\n\t\t\tx = *++s &~ *++m;\n\t\t\tif (!x)\n\t\t\t\tcontinue;\n\t\t\tsig = ffz(~x) + i*_NSIG_BPW + 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tx = s[1] &~ m[1];\n\t\tif (!x)\n\t\t\tbreak;\n\t\tsig = ffz(~x) + _NSIG_BPW + 1;\n\t\tbreak;\n\n\tcase 1:\n\t\t/* Nothing to do */\n\t\tbreak;\n\t}\n\n\treturn sig;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define SYNCHRONOUS_MASK \\\n\t(sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \\\n\t sigmask(SIGTRAP) | sigmask(SIGFPE) | sigmask(SIGSYS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\n#define SYNCHRONOUS_MASK \\\n\t(sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \\\n\t sigmask(SIGTRAP) | sigmask(SIGFPE) | sigmask(SIGSYS))\n\nint next_signal(struct sigpending *pending, sigset_t *mask)\n{\n\tunsigned long i, *s, *m, x;\n\tint sig = 0;\n\n\ts = pending->signal.sig;\n\tm = mask->sig;\n\n\t/*\n\t * Handle the first word specially: it contains the\n\t * synchronous signals that need to be dequeued first.\n\t */\n\tx = *s &~ *m;\n\tif (x) {\n\t\tif (x & SYNCHRONOUS_MASK)\n\t\t\tx &= SYNCHRONOUS_MASK;\n\t\tsig = ffz(~x) + 1;\n\t\treturn sig;\n\t}\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = 1; i < _NSIG_WORDS; ++i) {\n\t\t\tx = *++s &~ *++m;\n\t\t\tif (!x)\n\t\t\t\tcontinue;\n\t\t\tsig = ffz(~x) + i*_NSIG_BPW + 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tx = s[1] &~ m[1];\n\t\tif (!x)\n\t\t\tbreak;\n\t\tsig = ffz(~x) + _NSIG_BPW + 1;\n\t\tbreak;\n\n\tcase 1:\n\t\t/* Nothing to do */\n\t\tbreak;\n\t}\n\n\treturn sig;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int __dequeue_signal(struct sigpending *pending, sigset_t *mask,\n\t\t\tkernel_siginfo_t *info, bool *resched_timer)\n{\n\tint sig = next_signal(pending, mask);\n\n\tif (sig)\n\t\tcollect_signal(sig, pending, info, resched_timer);\n\treturn sig;\n}"
  },
  {
    "function_name": "collect_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "568-611",
    "snippet": "static void collect_signal(int sig, struct sigpending *list, kernel_siginfo_t *info,\n\t\t\t   bool *resched_timer)\n{\n\tstruct sigqueue *q, *first = NULL;\n\n\t/*\n\t * Collect the siginfo appropriate to this signal.  Check if\n\t * there is another siginfo for the same signal.\n\t*/\n\tlist_for_each_entry(q, &list->list, list) {\n\t\tif (q->info.si_signo == sig) {\n\t\t\tif (first)\n\t\t\t\tgoto still_pending;\n\t\t\tfirst = q;\n\t\t}\n\t}\n\n\tsigdelset(&list->signal, sig);\n\n\tif (first) {\nstill_pending:\n\t\tlist_del_init(&first->list);\n\t\tcopy_siginfo(info, &first->info);\n\n\t\t*resched_timer =\n\t\t\t(first->flags & SIGQUEUE_PREALLOC) &&\n\t\t\t(info->si_code == SI_TIMER) &&\n\t\t\t(info->si_sys_private);\n\n\t\t__sigqueue_free(first);\n\t} else {\n\t\t/*\n\t\t * Ok, it wasn't in the queue.  This must be\n\t\t * a fast-pathed signal or we must have been\n\t\t * out of queue space.  So zero out the info.\n\t\t */\n\t\tclear_siginfo(info);\n\t\tinfo->si_signo = sig;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = 0;\n\t\tinfo->si_uid = 0;\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "info"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sigqueue_free",
          "args": [
            "first"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "__sigqueue_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "450-459",
          "snippet": "static void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tif (q->ucounts) {\n\t\tdec_rlimit_put_ucounts(q->ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t\tq->ucounts = NULL;\n\t}\n\tkmem_cache_free(sigqueue_cachep, q);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sigqueue_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tif (q->ucounts) {\n\t\tdec_rlimit_put_ucounts(q->ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t\tq->ucounts = NULL;\n\t}\n\tkmem_cache_free(sigqueue_cachep, q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_siginfo",
          "args": [
            "info",
            "&first->info"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_from_user_any",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "3804-3818",
          "snippet": "static int copy_siginfo_from_user_any(kernel_siginfo_t *kinfo,\n\t\tsiginfo_t __user *info)\n{\n#ifdef CONFIG_COMPAT\n\t/*\n\t * Avoid hooking up compat syscalls and instead handle necessary\n\t * conversions here. Note, this is a stop-gap measure and should not be\n\t * considered a generic solution.\n\t */\n\tif (in_compat_syscall())\n\t\treturn copy_siginfo_from_user32(\n\t\t\tkinfo, (struct compat_siginfo __user *)info);\n#endif\n\treturn copy_siginfo_from_user(kinfo, info);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int copy_siginfo_from_user_any(kernel_siginfo_t *kinfo,\n\t\tsiginfo_t __user *info)\n{\n#ifdef CONFIG_COMPAT\n\t/*\n\t * Avoid hooking up compat syscalls and instead handle necessary\n\t * conversions here. Note, this is a stop-gap measure and should not be\n\t * considered a generic solution.\n\t */\n\tif (in_compat_syscall())\n\t\treturn copy_siginfo_from_user32(\n\t\t\tkinfo, (struct compat_siginfo __user *)info);\n#endif\n\treturn copy_siginfo_from_user(kinfo, info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&first->list"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&list->signal",
            "sig"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "q",
            "&list->list",
            "list"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void collect_signal(int sig, struct sigpending *list, kernel_siginfo_t *info,\n\t\t\t   bool *resched_timer)\n{\n\tstruct sigqueue *q, *first = NULL;\n\n\t/*\n\t * Collect the siginfo appropriate to this signal.  Check if\n\t * there is another siginfo for the same signal.\n\t*/\n\tlist_for_each_entry(q, &list->list, list) {\n\t\tif (q->info.si_signo == sig) {\n\t\t\tif (first)\n\t\t\t\tgoto still_pending;\n\t\t\tfirst = q;\n\t\t}\n\t}\n\n\tsigdelset(&list->signal, sig);\n\n\tif (first) {\nstill_pending:\n\t\tlist_del_init(&first->list);\n\t\tcopy_siginfo(info, &first->info);\n\n\t\t*resched_timer =\n\t\t\t(first->flags & SIGQUEUE_PREALLOC) &&\n\t\t\t(info->si_code == SI_TIMER) &&\n\t\t\t(info->si_sys_private);\n\n\t\t__sigqueue_free(first);\n\t} else {\n\t\t/*\n\t\t * Ok, it wasn't in the queue.  This must be\n\t\t * a fast-pathed signal or we must have been\n\t\t * out of queue space.  So zero out the info.\n\t\t */\n\t\tclear_siginfo(info);\n\t\tinfo->si_signo = sig;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = 0;\n\t\tinfo->si_uid = 0;\n\t}\n}"
  },
  {
    "function_name": "unhandled_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "555-566",
    "snippet": "bool unhandled_signal(struct task_struct *tsk, int sig)\n{\n\tvoid __user *handler = tsk->sighand->action[sig-1].sa.sa_handler;\n\tif (is_global_init(tsk))\n\t\treturn true;\n\n\tif (handler != SIG_IGN && handler != SIG_DFL)\n\t\treturn false;\n\n\t/* if ptraced, let the tracer determine */\n\treturn !tsk->ptrace;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_global_init",
          "args": [
            "tsk"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool unhandled_signal(struct task_struct *tsk, int sig)\n{\n\tvoid __user *handler = tsk->sighand->action[sig-1].sa.sa_handler;\n\tif (is_global_init(tsk))\n\t\treturn true;\n\n\tif (handler != SIG_IGN && handler != SIG_DFL)\n\t\treturn false;\n\n\t/* if ptraced, let the tracer determine */\n\treturn !tsk->ptrace;\n}"
  },
  {
    "function_name": "flush_signal_handlers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "538-553",
    "snippet": "void\nflush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\tka->sa.sa_flags = 0;\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tka->sa.sa_restorer = NULL;\n#endif\n\t\tsigemptyset(&ka->sa.sa_mask);\n\t\tka++;\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&ka->sa.sa_mask"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid\nflush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\tka->sa.sa_flags = 0;\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tka->sa.sa_restorer = NULL;\n#endif\n\t\tsigemptyset(&ka->sa.sa_mask);\n\t\tka++;\n\t}\n}"
  },
  {
    "function_name": "ignore_signals",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "524-532",
    "snippet": "void ignore_signals(struct task_struct *t)\n{\n\tint i;\n\n\tfor (i = 0; i < _NSIG; ++i)\n\t\tt->sighand->action[i].sa.sa_handler = SIG_IGN;\n\n\tflush_signals(t);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_signals",
          "args": [
            "t"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "flush_signals",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "476-485",
          "snippet": "void flush_signals(struct task_struct *t)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\tflush_sigqueue(&t->pending);\n\tflush_sigqueue(&t->signal->shared_pending);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid flush_signals(struct task_struct *t)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\tflush_sigqueue(&t->pending);\n\tflush_sigqueue(&t->signal->shared_pending);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid ignore_signals(struct task_struct *t)\n{\n\tint i;\n\n\tfor (i = 0; i < _NSIG; ++i)\n\t\tt->sighand->action[i].sa.sa_handler = SIG_IGN;\n\n\tflush_signals(t);\n}"
  },
  {
    "function_name": "flush_itimer_signals",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "512-521",
    "snippet": "void flush_itimer_signals(void)\n{\n\tstruct task_struct *tsk = current;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\t__flush_itimer_signals(&tsk->pending);\n\t__flush_itimer_signals(&tsk->signal->shared_pending);\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&tsk->sighand->siglock",
            "flags"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__flush_itimer_signals",
          "args": [
            "&tsk->signal->shared_pending"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "__flush_itimer_signals",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "489-510",
          "snippet": "static void __flush_itimer_signals(struct sigpending *pending)\n{\n\tsigset_t signal, retain;\n\tstruct sigqueue *q, *n;\n\n\tsignal = pending->signal;\n\tsigemptyset(&retain);\n\n\tlist_for_each_entry_safe(q, n, &pending->list, list) {\n\t\tint sig = q->info.si_signo;\n\n\t\tif (likely(q->info.si_code != SI_TIMER)) {\n\t\t\tsigaddset(&retain, sig);\n\t\t} else {\n\t\t\tsigdelset(&signal, sig);\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n\n\tsigorsets(&pending->signal, &signal, &retain);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void __flush_itimer_signals(struct sigpending *pending)\n{\n\tsigset_t signal, retain;\n\tstruct sigqueue *q, *n;\n\n\tsignal = pending->signal;\n\tsigemptyset(&retain);\n\n\tlist_for_each_entry_safe(q, n, &pending->list, list) {\n\t\tint sig = q->info.si_signo;\n\n\t\tif (likely(q->info.si_code != SI_TIMER)) {\n\t\t\tsigaddset(&retain, sig);\n\t\t} else {\n\t\t\tsigdelset(&signal, sig);\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n\n\tsigorsets(&pending->signal, &signal, &retain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&tsk->sighand->siglock",
            "flags"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid flush_itimer_signals(void)\n{\n\tstruct task_struct *tsk = current;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\t__flush_itimer_signals(&tsk->pending);\n\t__flush_itimer_signals(&tsk->signal->shared_pending);\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n}"
  },
  {
    "function_name": "__flush_itimer_signals",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "489-510",
    "snippet": "static void __flush_itimer_signals(struct sigpending *pending)\n{\n\tsigset_t signal, retain;\n\tstruct sigqueue *q, *n;\n\n\tsignal = pending->signal;\n\tsigemptyset(&retain);\n\n\tlist_for_each_entry_safe(q, n, &pending->list, list) {\n\t\tint sig = q->info.si_signo;\n\n\t\tif (likely(q->info.si_code != SI_TIMER)) {\n\t\t\tsigaddset(&retain, sig);\n\t\t} else {\n\t\t\tsigdelset(&signal, sig);\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n\n\tsigorsets(&pending->signal, &signal, &retain);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigorsets",
          "args": [
            "&pending->signal",
            "&signal",
            "&retain"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sigqueue_free",
          "args": [
            "q"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "__sigqueue_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "450-459",
          "snippet": "static void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tif (q->ucounts) {\n\t\tdec_rlimit_put_ucounts(q->ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t\tq->ucounts = NULL;\n\t}\n\tkmem_cache_free(sigqueue_cachep, q);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sigqueue_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tif (q->ucounts) {\n\t\tdec_rlimit_put_ucounts(q->ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t\tq->ucounts = NULL;\n\t}\n\tkmem_cache_free(sigqueue_cachep, q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&q->list"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&signal",
            "sig"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&retain",
            "sig"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "q->info.si_code != SI_TIMER"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "q",
            "n",
            "&pending->list",
            "list"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&retain"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void __flush_itimer_signals(struct sigpending *pending)\n{\n\tsigset_t signal, retain;\n\tstruct sigqueue *q, *n;\n\n\tsignal = pending->signal;\n\tsigemptyset(&retain);\n\n\tlist_for_each_entry_safe(q, n, &pending->list, list) {\n\t\tint sig = q->info.si_signo;\n\n\t\tif (likely(q->info.si_code != SI_TIMER)) {\n\t\t\tsigaddset(&retain, sig);\n\t\t} else {\n\t\t\tsigdelset(&signal, sig);\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n\n\tsigorsets(&pending->signal, &signal, &retain);\n}"
  },
  {
    "function_name": "flush_signals",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "476-485",
    "snippet": "void flush_signals(struct task_struct *t)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\tflush_sigqueue(&t->pending);\n\tflush_sigqueue(&t->signal->shared_pending);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&t->sighand->siglock",
            "flags"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_sigqueue",
          "args": [
            "&t->signal->shared_pending"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "flush_sigqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "461-471",
          "snippet": "void flush_sigqueue(struct sigpending *queue)\n{\n\tstruct sigqueue *q;\n\n\tsigemptyset(&queue->signal);\n\twhile (!list_empty(&queue->list)) {\n\t\tq = list_entry(queue->list.next, struct sigqueue , list);\n\t\tlist_del_init(&q->list);\n\t\t__sigqueue_free(q);\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid flush_sigqueue(struct sigpending *queue)\n{\n\tstruct sigqueue *q;\n\n\tsigemptyset(&queue->signal);\n\twhile (!list_empty(&queue->list)) {\n\t\tq = list_entry(queue->list.next, struct sigqueue , list);\n\t\tlist_del_init(&q->list);\n\t\t__sigqueue_free(q);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "t",
            "TIF_SIGPENDING"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&t->sighand->siglock",
            "flags"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid flush_signals(struct task_struct *t)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\tflush_sigqueue(&t->pending);\n\tflush_sigqueue(&t->signal->shared_pending);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n}"
  },
  {
    "function_name": "flush_sigqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "461-471",
    "snippet": "void flush_sigqueue(struct sigpending *queue)\n{\n\tstruct sigqueue *q;\n\n\tsigemptyset(&queue->signal);\n\twhile (!list_empty(&queue->list)) {\n\t\tq = list_entry(queue->list.next, struct sigqueue , list);\n\t\tlist_del_init(&q->list);\n\t\t__sigqueue_free(q);\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sigqueue_free",
          "args": [
            "q"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "__sigqueue_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "450-459",
          "snippet": "static void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tif (q->ucounts) {\n\t\tdec_rlimit_put_ucounts(q->ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t\tq->ucounts = NULL;\n\t}\n\tkmem_cache_free(sigqueue_cachep, q);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sigqueue_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tif (q->ucounts) {\n\t\tdec_rlimit_put_ucounts(q->ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t\tq->ucounts = NULL;\n\t}\n\tkmem_cache_free(sigqueue_cachep, q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&q->list"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "queue->list.next",
            "structsigqueue",
            "list"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&queue->list"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&queue->signal"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid flush_sigqueue(struct sigpending *queue)\n{\n\tstruct sigqueue *q;\n\n\tsigemptyset(&queue->signal);\n\twhile (!list_empty(&queue->list)) {\n\t\tq = list_entry(queue->list.next, struct sigqueue , list);\n\t\tlist_del_init(&q->list);\n\t\t__sigqueue_free(q);\n\t}\n}"
  },
  {
    "function_name": "__sigqueue_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "450-459",
    "snippet": "static void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tif (q->ucounts) {\n\t\tdec_rlimit_put_ucounts(q->ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t\tq->ucounts = NULL;\n\t}\n\tkmem_cache_free(sigqueue_cachep, q);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *sigqueue_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "sigqueue_cachep",
            "q"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_rlimit_put_ucounts",
          "args": [
            "q->ucounts",
            "UCOUNT_RLIMIT_SIGPENDING"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "dec_rlimit_put_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "307-310",
          "snippet": "void dec_rlimit_put_ucounts(struct ucounts *ucounts, enum ucount_type type)\n{\n\tdo_dec_rlimit_put_ucounts(ucounts, NULL, type);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nvoid dec_rlimit_put_ucounts(struct ucounts *ucounts, enum ucount_type type)\n{\n\tdo_dec_rlimit_put_ucounts(ucounts, NULL, type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tif (q->ucounts) {\n\t\tdec_rlimit_put_ucounts(q->ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t\tq->ucounts = NULL;\n\t}\n\tkmem_cache_free(sigqueue_cachep, q);\n}"
  },
  {
    "function_name": "__sigqueue_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "411-448",
    "snippet": "static struct sigqueue *\n__sigqueue_alloc(int sig, struct task_struct *t, gfp_t gfp_flags,\n\t\t int override_rlimit, const unsigned int sigqueue_flags)\n{\n\tstruct sigqueue *q = NULL;\n\tstruct ucounts *ucounts = NULL;\n\tlong sigpending;\n\n\t/*\n\t * Protect access to @t credentials. This can go away when all\n\t * callers hold rcu read lock.\n\t *\n\t * NOTE! A pending signal will hold on to the user refcount,\n\t * and we get/put the refcount only when the sigpending count\n\t * changes from/to zero.\n\t */\n\trcu_read_lock();\n\tucounts = task_ucounts(t);\n\tsigpending = inc_rlimit_get_ucounts(ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\trcu_read_unlock();\n\tif (!sigpending)\n\t\treturn NULL;\n\n\tif (override_rlimit || likely(sigpending <= task_rlimit(t, RLIMIT_SIGPENDING))) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, gfp_flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\n\tif (unlikely(q == NULL)) {\n\t\tdec_rlimit_put_ucounts(ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t} else {\n\t\tINIT_LIST_HEAD(&q->list);\n\t\tq->flags = sigqueue_flags;\n\t\tq->ucounts = ucounts;\n\t}\n\treturn q;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *sigqueue_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&q->list"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_rlimit_put_ucounts",
          "args": [
            "ucounts",
            "UCOUNT_RLIMIT_SIGPENDING"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "dec_rlimit_put_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "307-310",
          "snippet": "void dec_rlimit_put_ucounts(struct ucounts *ucounts, enum ucount_type type)\n{\n\tdo_dec_rlimit_put_ucounts(ucounts, NULL, type);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nvoid dec_rlimit_put_ucounts(struct ucounts *ucounts, enum ucount_type type)\n{\n\tdo_dec_rlimit_put_ucounts(ucounts, NULL, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "q == NULL"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_dropped_signal",
          "args": [
            "sig"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "print_dropped_signal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "253-265",
          "snippet": "static inline void print_dropped_signal(int sig)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!print_fatal_signals)\n\t\treturn;\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tpr_info(\"%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\\n\",\n\t\t\t\tcurrent->comm, current->pid, sig);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int print_fatal_signals"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint print_fatal_signals;\n\nstatic inline void print_dropped_signal(int sig)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!print_fatal_signals)\n\t\treturn;\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tpr_info(\"%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\\n\",\n\t\t\t\tcurrent->comm, current->pid, sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "sigqueue_cachep",
            "gfp_flags"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "sigpending <= task_rlimit(t, RLIMIT_SIGPENDING)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rlimit",
          "args": [
            "t",
            "RLIMIT_SIGPENDING"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_rlimit_get_ucounts",
          "args": [
            "ucounts",
            "UCOUNT_RLIMIT_SIGPENDING"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "inc_rlimit_get_ucounts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/ucount.c",
          "lines": "312-342",
          "snippet": "long inc_rlimit_get_ucounts(struct ucounts *ucounts, enum ucount_type type)\n{\n\t/* Caller must hold a reference to ucounts */\n\tstruct ucounts *iter;\n\tlong max = LONG_MAX;\n\tlong dec, ret = 0;\n\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong new = atomic_long_add_return(1, &iter->ucount[type]);\n\t\tif (new < 0 || new > max)\n\t\t\tgoto unwind;\n\t\tif (iter == ucounts)\n\t\t\tret = new;\n\t\tmax = READ_ONCE(iter->ns->ucount_max[type]);\n\t\t/*\n\t\t * Grab an extra ucount reference for the caller when\n\t\t * the rlimit count was previously 0.\n\t\t */\n\t\tif (new != 1)\n\t\t\tcontinue;\n\t\tif (!get_ucounts(iter))\n\t\t\tgoto dec_unwind;\n\t}\n\treturn ret;\ndec_unwind:\n\tdec = atomic_long_sub_return(1, &iter->ucount[type]);\n\tWARN_ON_ONCE(dec < 0);\nunwind:\n\tdo_dec_rlimit_put_ucounts(ucounts, iter, type);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nlong inc_rlimit_get_ucounts(struct ucounts *ucounts, enum ucount_type type)\n{\n\t/* Caller must hold a reference to ucounts */\n\tstruct ucounts *iter;\n\tlong max = LONG_MAX;\n\tlong dec, ret = 0;\n\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tlong new = atomic_long_add_return(1, &iter->ucount[type]);\n\t\tif (new < 0 || new > max)\n\t\t\tgoto unwind;\n\t\tif (iter == ucounts)\n\t\t\tret = new;\n\t\tmax = READ_ONCE(iter->ns->ucount_max[type]);\n\t\t/*\n\t\t * Grab an extra ucount reference for the caller when\n\t\t * the rlimit count was previously 0.\n\t\t */\n\t\tif (new != 1)\n\t\t\tcontinue;\n\t\tif (!get_ucounts(iter))\n\t\t\tgoto dec_unwind;\n\t}\n\treturn ret;\ndec_unwind:\n\tdec = atomic_long_sub_return(1, &iter->ucount[type]);\n\tWARN_ON_ONCE(dec < 0);\nunwind:\n\tdo_dec_rlimit_put_ucounts(ucounts, iter, type);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_ucounts",
          "args": [
            "t"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic struct sigqueue *\n__sigqueue_alloc(int sig, struct task_struct *t, gfp_t gfp_flags,\n\t\t int override_rlimit, const unsigned int sigqueue_flags)\n{\n\tstruct sigqueue *q = NULL;\n\tstruct ucounts *ucounts = NULL;\n\tlong sigpending;\n\n\t/*\n\t * Protect access to @t credentials. This can go away when all\n\t * callers hold rcu read lock.\n\t *\n\t * NOTE! A pending signal will hold on to the user refcount,\n\t * and we get/put the refcount only when the sigpending count\n\t * changes from/to zero.\n\t */\n\trcu_read_lock();\n\tucounts = task_ucounts(t);\n\tsigpending = inc_rlimit_get_ucounts(ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\trcu_read_unlock();\n\tif (!sigpending)\n\t\treturn NULL;\n\n\tif (override_rlimit || likely(sigpending <= task_rlimit(t, RLIMIT_SIGPENDING))) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, gfp_flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\n\tif (unlikely(q == NULL)) {\n\t\tdec_rlimit_put_ucounts(ucounts, UCOUNT_RLIMIT_SIGPENDING);\n\t} else {\n\t\tINIT_LIST_HEAD(&q->list);\n\t\tq->flags = sigqueue_flags;\n\t\tq->ucounts = ucounts;\n\t}\n\treturn q;\n}"
  },
  {
    "function_name": "task_join_group_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "391-404",
    "snippet": "void task_join_group_stop(struct task_struct *task)\n{\n\tunsigned long mask = current->jobctl & JOBCTL_STOP_SIGMASK;\n\tstruct signal_struct *sig = current->signal;\n\n\tif (sig->group_stop_count) {\n\t\tsig->group_stop_count++;\n\t\tmask |= JOBCTL_STOP_CONSUME;\n\t} else if (!(sig->flags & SIGNAL_STOP_STOPPED))\n\t\treturn;\n\n\t/* Have the new thread join an on-going signal group stop */\n\ttask_set_jobctl_pending(task, mask | JOBCTL_STOP_PENDING);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_set_jobctl_pending",
          "args": [
            "task",
            "mask | JOBCTL_STOP_PENDING"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "task_set_jobctl_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "284-298",
          "snippet": "bool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_join_group_stop(struct task_struct *task)\n{\n\tunsigned long mask = current->jobctl & JOBCTL_STOP_SIGMASK;\n\tstruct signal_struct *sig = current->signal;\n\n\tif (sig->group_stop_count) {\n\t\tsig->group_stop_count++;\n\t\tmask |= JOBCTL_STOP_CONSUME;\n\t} else if (!(sig->flags & SIGNAL_STOP_STOPPED))\n\t\treturn;\n\n\t/* Have the new thread join an on-going signal group stop */\n\ttask_set_jobctl_pending(task, mask | JOBCTL_STOP_PENDING);\n}"
  },
  {
    "function_name": "task_participate_group_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "365-389",
    "snippet": "static bool task_participate_group_stop(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n\tif (!consume)\n\t\treturn false;\n\n\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))\n\t\tsig->group_stop_count--;\n\n\t/*\n\t * Tell the caller to notify completion iff we are entering into a\n\t * fresh group stop.  Read comment in do_signal_stop() for details.\n\t */\n\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_set_stop_flags",
          "args": [
            "sig",
            "SIGNAL_STOP_STOPPED"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "sig->group_stop_count == 0"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_clear_jobctl_pending",
          "args": [
            "task",
            "JOBCTL_STOP_PENDING"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "task_clear_jobctl_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "336-347",
          "snippet": "void task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(task->jobctl & JOBCTL_STOP_PENDING)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool task_participate_group_stop(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n\tif (!consume)\n\t\treturn false;\n\n\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))\n\t\tsig->group_stop_count--;\n\n\t/*\n\t * Tell the caller to notify completion iff we are entering into a\n\t * fresh group stop.  Read comment in do_signal_stop() for details.\n\t */\n\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "task_clear_jobctl_pending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "336-347",
    "snippet": "void task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_clear_jobctl_trapping",
          "args": [
            "task"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "task_clear_jobctl_trapping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "312-319",
          "snippet": "void task_clear_jobctl_trapping(struct task_struct *task)\n{\n\tif (unlikely(task->jobctl & JOBCTL_TRAPPING)) {\n\t\ttask->jobctl &= ~JOBCTL_TRAPPING;\n\t\tsmp_mb();\t/* advised by wake_up_bit() */\n\t\twake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_trapping(struct task_struct *task)\n{\n\tif (unlikely(task->jobctl & JOBCTL_TRAPPING)) {\n\t\ttask->jobctl &= ~JOBCTL_TRAPPING;\n\t\tsmp_mb();\t/* advised by wake_up_bit() */\n\t\twake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mask & ~JOBCTL_PENDING_MASK"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}"
  },
  {
    "function_name": "task_clear_jobctl_trapping",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "312-319",
    "snippet": "void task_clear_jobctl_trapping(struct task_struct *task)\n{\n\tif (unlikely(task->jobctl & JOBCTL_TRAPPING)) {\n\t\ttask->jobctl &= ~JOBCTL_TRAPPING;\n\t\tsmp_mb();\t/* advised by wake_up_bit() */\n\t\twake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&task->jobctl",
            "JOBCTL_TRAPPING_BIT"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait_bit.c",
          "lines": "147-150",
          "snippet": "void wake_up_bit(void *word, int bit)\n{\n\t__wake_up_bit(bit_waitqueue(word, bit), word, bit);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid wake_up_bit(void *word, int bit)\n{\n\t__wake_up_bit(bit_waitqueue(word, bit), word, bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "task->jobctl & JOBCTL_TRAPPING"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_trapping(struct task_struct *task)\n{\n\tif (unlikely(task->jobctl & JOBCTL_TRAPPING)) {\n\t\ttask->jobctl &= ~JOBCTL_TRAPPING;\n\t\tsmp_mb();\t/* advised by wake_up_bit() */\n\t\twake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);\n\t}\n}"
  },
  {
    "function_name": "task_set_jobctl_pending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "284-298",
    "snippet": "bool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fatal_signal_pending(task) || (task->flags & PF_EXITING)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "task"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING)"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}"
  },
  {
    "function_name": "print_dropped_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "253-265",
    "snippet": "static inline void print_dropped_signal(int sig)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!print_fatal_signals)\n\t\treturn;\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tpr_info(\"%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\\n\",\n\t\t\t\tcurrent->comm, current->pid, sig);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int print_fatal_signals"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\\n\"",
            "current->comm",
            "current->pid",
            "sig"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&ratelimit_state"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint print_fatal_signals;\n\nstatic inline void print_dropped_signal(int sig)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!print_fatal_signals)\n\t\treturn;\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tpr_info(\"%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\\n\",\n\t\t\t\tcurrent->comm, current->pid, sig);\n}"
  },
  {
    "function_name": "next_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "207-251",
    "snippet": "int next_signal(struct sigpending *pending, sigset_t *mask)\n{\n\tunsigned long i, *s, *m, x;\n\tint sig = 0;\n\n\ts = pending->signal.sig;\n\tm = mask->sig;\n\n\t/*\n\t * Handle the first word specially: it contains the\n\t * synchronous signals that need to be dequeued first.\n\t */\n\tx = *s &~ *m;\n\tif (x) {\n\t\tif (x & SYNCHRONOUS_MASK)\n\t\t\tx &= SYNCHRONOUS_MASK;\n\t\tsig = ffz(~x) + 1;\n\t\treturn sig;\n\t}\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = 1; i < _NSIG_WORDS; ++i) {\n\t\t\tx = *++s &~ *++m;\n\t\t\tif (!x)\n\t\t\t\tcontinue;\n\t\t\tsig = ffz(~x) + i*_NSIG_BPW + 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tx = s[1] &~ m[1];\n\t\tif (!x)\n\t\t\tbreak;\n\t\tsig = ffz(~x) + _NSIG_BPW + 1;\n\t\tbreak;\n\n\tcase 1:\n\t\t/* Nothing to do */\n\t\tbreak;\n\t}\n\n\treturn sig;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define SYNCHRONOUS_MASK \\\n\t(sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \\\n\t sigmask(SIGTRAP) | sigmask(SIGFPE) | sigmask(SIGSYS))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffz",
          "args": [
            "~x"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffz",
          "args": [
            "~x"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffz",
          "args": [
            "~x"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\n#define SYNCHRONOUS_MASK \\\n\t(sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \\\n\t sigmask(SIGTRAP) | sigmask(SIGFPE) | sigmask(SIGSYS))\n\nint next_signal(struct sigpending *pending, sigset_t *mask)\n{\n\tunsigned long i, *s, *m, x;\n\tint sig = 0;\n\n\ts = pending->signal.sig;\n\tm = mask->sig;\n\n\t/*\n\t * Handle the first word specially: it contains the\n\t * synchronous signals that need to be dequeued first.\n\t */\n\tx = *s &~ *m;\n\tif (x) {\n\t\tif (x & SYNCHRONOUS_MASK)\n\t\t\tx &= SYNCHRONOUS_MASK;\n\t\tsig = ffz(~x) + 1;\n\t\treturn sig;\n\t}\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = 1; i < _NSIG_WORDS; ++i) {\n\t\t\tx = *++s &~ *++m;\n\t\t\tif (!x)\n\t\t\t\tcontinue;\n\t\t\tsig = ffz(~x) + i*_NSIG_BPW + 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tx = s[1] &~ m[1];\n\t\tif (!x)\n\t\t\tbreak;\n\t\tsig = ffz(~x) + _NSIG_BPW + 1;\n\t\tbreak;\n\n\tcase 1:\n\t\t/* Nothing to do */\n\t\tbreak;\n\t}\n\n\treturn sig;\n}"
  },
  {
    "function_name": "calculate_sigpending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "190-199",
    "snippet": "void calculate_sigpending(void)\n{\n\t/* Have any signals or users of TIF_SIGPENDING been delayed\n\t * until after fork?\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tset_tsk_thread_flag(current, TIF_SIGPENDING);\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "182-187",
          "snippet": "void recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "current",
            "TIF_SIGPENDING"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid calculate_sigpending(void)\n{\n\t/* Have any signals or users of TIF_SIGPENDING been delayed\n\t * until after fork?\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tset_tsk_thread_flag(current, TIF_SIGPENDING);\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
  },
  {
    "function_name": "recalc_sigpending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "182-187",
    "snippet": "void recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_thread_flag",
          "args": [
            "TIF_SIGPENDING"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "current"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "freezing_slow_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/freezer.c",
          "lines": "37-52",
          "snippet": "bool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool pm_freezing;",
            "bool pm_nosig_freezing;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nbool pm_freezing;\nbool pm_nosig_freezing;\n\nbool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalc_sigpending_tsk",
          "args": [
            "current"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending_tsk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "154-170",
          "snippet": "static bool recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif ((t->jobctl & (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked) ||\n\t    cgroup_task_frozen(t)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn true;\n\t}\n\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn false;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif ((t->jobctl & (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked) ||\n\t    cgroup_task_frozen(t)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn true;\n\t}\n\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}"
  },
  {
    "function_name": "recalc_sigpending_and_wake",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "176-180",
    "snippet": "void recalc_sigpending_and_wake(struct task_struct *t)\n{\n\tif (recalc_sigpending_tsk(t))\n\t\tsignal_wake_up(t, 0);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_wake_up",
          "args": [
            "t",
            "0"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "763-775",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalc_sigpending_tsk",
          "args": [
            "t"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending_tsk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "154-170",
          "snippet": "static bool recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif ((t->jobctl & (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked) ||\n\t    cgroup_task_frozen(t)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn true;\n\t}\n\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn false;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif ((t->jobctl & (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked) ||\n\t    cgroup_task_frozen(t)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn true;\n\t}\n\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending_and_wake(struct task_struct *t)\n{\n\tif (recalc_sigpending_tsk(t))\n\t\tsignal_wake_up(t, 0);\n}"
  },
  {
    "function_name": "recalc_sigpending_tsk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "154-170",
    "snippet": "static bool recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif ((t->jobctl & (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked) ||\n\t    cgroup_task_frozen(t)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn true;\n\t}\n\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn false;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "t",
            "TIF_SIGPENDING"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_task_frozen",
          "args": [
            "t"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PENDING",
          "args": [
            "&t->signal->shared_pending",
            "&t->blocked"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PENDING",
          "args": [
            "&t->pending",
            "&t->blocked"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif ((t->jobctl & (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked) ||\n\t    cgroup_task_frozen(t)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn true;\n\t}\n\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn false;\n}"
  },
  {
    "function_name": "has_pending_signals",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "126-150",
    "snippet": "static inline bool has_pending_signals(sigset_t *signal, sigset_t *blocked)\n{\n\tunsigned long ready;\n\tlong i;\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = _NSIG_WORDS, ready = 0; --i >= 0 ;)\n\t\t\tready |= signal->sig[i] &~ blocked->sig[i];\n\t\tbreak;\n\n\tcase 4: ready  = signal->sig[3] &~ blocked->sig[3];\n\t\tready |= signal->sig[2] &~ blocked->sig[2];\n\t\tready |= signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 2: ready  = signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 1: ready  = signal->sig[0] &~ blocked->sig[0];\n\t}\n\treturn ready !=\t0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool has_pending_signals(sigset_t *signal, sigset_t *blocked)\n{\n\tunsigned long ready;\n\tlong i;\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = _NSIG_WORDS, ready = 0; --i >= 0 ;)\n\t\t\tready |= signal->sig[i] &~ blocked->sig[i];\n\t\tbreak;\n\n\tcase 4: ready  = signal->sig[3] &~ blocked->sig[3];\n\t\tready |= signal->sig[2] &~ blocked->sig[2];\n\t\tready |= signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 2: ready  = signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 1: ready  = signal->sig[0] &~ blocked->sig[0];\n\t}\n\treturn ready !=\t0;\n}"
  },
  {
    "function_name": "sig_ignored",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "101-120",
    "snippet": "static bool sig_ignored(struct task_struct *t, int sig, bool force)\n{\n\t/*\n\t * Blocked signals are never ignored, since the\n\t * signal handler may change by the time it is\n\t * unblocked.\n\t */\n\tif (sigismember(&t->blocked, sig) || sigismember(&t->real_blocked, sig))\n\t\treturn false;\n\n\t/*\n\t * Tracers may want to know about even ignored signal unless it\n\t * is SIGKILL which can't be reported anyway but can be ignored\n\t * by SIGNAL_UNKILLABLE task.\n\t */\n\tif (t->ptrace && sig != SIGKILL)\n\t\treturn false;\n\n\treturn sig_task_ignored(t, sig, force);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sig_task_ignored",
          "args": [
            "t",
            "sig",
            "force"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "sig_task_ignored",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "79-99",
          "snippet": "static bool sig_task_ignored(struct task_struct *t, int sig, bool force)\n{\n\tvoid __user *handler;\n\n\thandler = sig_handler(t, sig);\n\n\t/* SIGKILL and SIGSTOP may not be sent to the global init */\n\tif (unlikely(is_global_init(t) && sig_kernel_only(sig)))\n\t\treturn true;\n\n\tif (unlikely(t->signal->flags & SIGNAL_UNKILLABLE) &&\n\t    handler == SIG_DFL && !(force && sig_kernel_only(sig)))\n\t\treturn true;\n\n\t/* Only allow kernel generated signals to this kthread */\n\tif (unlikely((t->flags & PF_KTHREAD) &&\n\t\t     (handler == SIG_KTHREAD_KERNEL) && !force))\n\t\treturn true;\n\n\treturn sig_handler_ignored(handler, sig);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool sig_task_ignored(struct task_struct *t, int sig, bool force)\n{\n\tvoid __user *handler;\n\n\thandler = sig_handler(t, sig);\n\n\t/* SIGKILL and SIGSTOP may not be sent to the global init */\n\tif (unlikely(is_global_init(t) && sig_kernel_only(sig)))\n\t\treturn true;\n\n\tif (unlikely(t->signal->flags & SIGNAL_UNKILLABLE) &&\n\t    handler == SIG_DFL && !(force && sig_kernel_only(sig)))\n\t\treturn true;\n\n\t/* Only allow kernel generated signals to this kthread */\n\tif (unlikely((t->flags & PF_KTHREAD) &&\n\t\t     (handler == SIG_KTHREAD_KERNEL) && !force))\n\t\treturn true;\n\n\treturn sig_handler_ignored(handler, sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&t->real_blocked",
            "sig"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&t->blocked",
            "sig"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool sig_ignored(struct task_struct *t, int sig, bool force)\n{\n\t/*\n\t * Blocked signals are never ignored, since the\n\t * signal handler may change by the time it is\n\t * unblocked.\n\t */\n\tif (sigismember(&t->blocked, sig) || sigismember(&t->real_blocked, sig))\n\t\treturn false;\n\n\t/*\n\t * Tracers may want to know about even ignored signal unless it\n\t * is SIGKILL which can't be reported anyway but can be ignored\n\t * by SIGNAL_UNKILLABLE task.\n\t */\n\tif (t->ptrace && sig != SIGKILL)\n\t\treturn false;\n\n\treturn sig_task_ignored(t, sig, force);\n}"
  },
  {
    "function_name": "sig_task_ignored",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "79-99",
    "snippet": "static bool sig_task_ignored(struct task_struct *t, int sig, bool force)\n{\n\tvoid __user *handler;\n\n\thandler = sig_handler(t, sig);\n\n\t/* SIGKILL and SIGSTOP may not be sent to the global init */\n\tif (unlikely(is_global_init(t) && sig_kernel_only(sig)))\n\t\treturn true;\n\n\tif (unlikely(t->signal->flags & SIGNAL_UNKILLABLE) &&\n\t    handler == SIG_DFL && !(force && sig_kernel_only(sig)))\n\t\treturn true;\n\n\t/* Only allow kernel generated signals to this kthread */\n\tif (unlikely((t->flags & PF_KTHREAD) &&\n\t\t     (handler == SIG_KTHREAD_KERNEL) && !force))\n\t\treturn true;\n\n\treturn sig_handler_ignored(handler, sig);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sig_handler_ignored",
          "args": [
            "handler",
            "sig"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "sig_handler_ignored",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "72-77",
          "snippet": "static inline bool sig_handler_ignored(void __user *handler, int sig)\n{\n\t/* Is it explicitly or implicitly ignored? */\n\treturn handler == SIG_IGN ||\n\t       (handler == SIG_DFL && sig_kernel_ignore(sig));\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool sig_handler_ignored(void __user *handler, int sig)\n{\n\t/* Is it explicitly or implicitly ignored? */\n\treturn handler == SIG_IGN ||\n\t       (handler == SIG_DFL && sig_kernel_ignore(sig));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(t->flags & PF_KTHREAD) &&\n\t\t     (handler == SIG_KTHREAD_KERNEL) && !force"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_kernel_only",
          "args": [
            "sig"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "t->signal->flags & SIGNAL_UNKILLABLE"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_global_init(t) && sig_kernel_only(sig)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_kernel_only",
          "args": [
            "sig"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_global_init",
          "args": [
            "t"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool sig_task_ignored(struct task_struct *t, int sig, bool force)\n{\n\tvoid __user *handler;\n\n\thandler = sig_handler(t, sig);\n\n\t/* SIGKILL and SIGSTOP may not be sent to the global init */\n\tif (unlikely(is_global_init(t) && sig_kernel_only(sig)))\n\t\treturn true;\n\n\tif (unlikely(t->signal->flags & SIGNAL_UNKILLABLE) &&\n\t    handler == SIG_DFL && !(force && sig_kernel_only(sig)))\n\t\treturn true;\n\n\t/* Only allow kernel generated signals to this kthread */\n\tif (unlikely((t->flags & PF_KTHREAD) &&\n\t\t     (handler == SIG_KTHREAD_KERNEL) && !force))\n\t\treturn true;\n\n\treturn sig_handler_ignored(handler, sig);\n}"
  },
  {
    "function_name": "sig_handler_ignored",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "72-77",
    "snippet": "static inline bool sig_handler_ignored(void __user *handler, int sig)\n{\n\t/* Is it explicitly or implicitly ignored? */\n\treturn handler == SIG_IGN ||\n\t       (handler == SIG_DFL && sig_kernel_ignore(sig));\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sig_kernel_ignore",
          "args": [
            "sig"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool sig_handler_ignored(void __user *handler, int sig)\n{\n\t/* Is it explicitly or implicitly ignored? */\n\treturn handler == SIG_IGN ||\n\t       (handler == SIG_DFL && sig_kernel_ignore(sig));\n}"
  },
  {
    "function_name": "sig_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "67-70",
    "snippet": "static void __user *sig_handler(struct task_struct *t, int sig)\n{\n\treturn t->sighand->action[sig - 1].sa.sa_handler;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void __user *sig_handler(struct task_struct *t, int sig)\n{\n\treturn t->sighand->action[sig - 1].sa.sa_handler;\n}"
  },
  {
    "function_name": "restart_syscall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3003-3007",
    "snippet": "SYSCALL_DEFINE0(restart_syscall)\n{\n\tstruct restart_block *restart = &current->restart_block;\n\treturn restart->fn(restart);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE0(restart_syscall)\n{\n\tstruct restart_block *restart = &current->restart_block;\n\treturn restart->fn(restart);\n}"
  },
  {
    "function_name": "rt_sigprocmask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3146-3174",
    "snippet": "SYSCALL_DEFINE4(rt_sigprocmask, int, how, sigset_t __user *, nset,\n\t\tsigset_t __user *, oset, size_t, sigsetsize)\n{\n\tsigset_t old_set, new_set;\n\tint error;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\told_set = current->blocked;\n\n\tif (nset) {\n\t\tif (copy_from_user(&new_set, nset, sizeof(sigset_t)))\n\t\t\treturn -EFAULT;\n\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\n\t\terror = sigprocmask(how, &new_set, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (oset) {\n\t\tif (copy_to_user(oset, &old_set, sizeof(sigset_t)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(rt_sigprocmask, int, how, sigset_t __user *, nset,\n\t\tsigset_t __user *, oset, size_t, sigsetsize)\n{\n\tsigset_t old_set, new_set;\n\tint error;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\told_set = current->blocked;\n\n\tif (nset) {\n\t\tif (copy_from_user(&new_set, nset, sizeof(sigset_t)))\n\t\t\treturn -EFAULT;\n\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\n\t\terror = sigprocmask(how, &new_set, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (oset) {\n\t\tif (copy_to_user(oset, &old_set, sizeof(sigset_t)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rt_sigprocmask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3177-3198",
    "snippet": "SYSCALL_DEFINE4(rt_sigprocmask, int, how, compat_sigset_t __user *, nset,\n\t\tcompat_sigset_t __user *, oset, compat_size_t, sigsetsize)\n{\n\tsigset_t old_set = current->blocked;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (nset) {\n\t\tsigset_t new_set;\n\t\tint error;\n\t\tif (get_compat_sigset(&new_set, nset))\n\t\t\treturn -EFAULT;\n\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\n\t\terror = sigprocmask(how, &new_set, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn oset ? put_compat_sigset(oset, &old_set, sizeof(*oset)) : 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(rt_sigprocmask, int, how, compat_sigset_t __user *, nset,\n\t\tcompat_sigset_t __user *, oset, compat_size_t, sigsetsize)\n{\n\tsigset_t old_set = current->blocked;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (nset) {\n\t\tsigset_t new_set;\n\t\tint error;\n\t\tif (get_compat_sigset(&new_set, nset))\n\t\t\treturn -EFAULT;\n\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\n\t\terror = sigprocmask(how, &new_set, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn oset ? put_compat_sigset(oset, &old_set, sizeof(*oset)) : 0;\n}"
  },
  {
    "function_name": "rt_sigpending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3218-3231",
    "snippet": "SYSCALL_DEFINE2(rt_sigpending, sigset_t __user *, uset, size_t, sigsetsize)\n{\n\tsigset_t set;\n\n\tif (sigsetsize > sizeof(*uset))\n\t\treturn -EINVAL;\n\n\tdo_sigpending(&set);\n\n\tif (copy_to_user(uset, &set, sigsetsize))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(rt_sigpending, sigset_t __user *, uset, size_t, sigsetsize)\n{\n\tsigset_t set;\n\n\tif (sigsetsize > sizeof(*uset))\n\t\treturn -EINVAL;\n\n\tdo_sigpending(&set);\n\n\tif (copy_to_user(uset, &set, sigsetsize))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rt_sigpending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3234-3245",
    "snippet": "SYSCALL_DEFINE2(rt_sigpending, compat_sigset_t __user *, uset,\n\t\tcompat_size_t, sigsetsize)\n{\n\tsigset_t set;\n\n\tif (sigsetsize > sizeof(*uset))\n\t\treturn -EINVAL;\n\n\tdo_sigpending(&set);\n\n\treturn put_compat_sigset(uset, &set, sigsetsize);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(rt_sigpending, compat_sigset_t __user *, uset,\n\t\tcompat_size_t, sigsetsize)\n{\n\tsigset_t set;\n\n\tif (sigsetsize > sizeof(*uset))\n\t\treturn -EINVAL;\n\n\tdo_sigpending(&set);\n\n\treturn put_compat_sigset(uset, &set, sigsetsize);\n}"
  },
  {
    "function_name": "rt_sigtimedwait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3630-3660",
    "snippet": "SYSCALL_DEFINE4(rt_sigtimedwait, const sigset_t __user *, uthese,\n\t\tsiginfo_t __user *, uinfo,\n\t\tconst struct __kernel_timespec __user *, uts,\n\t\tsize_t, sigsetsize)\n{\n\tsigset_t these;\n\tstruct timespec64 ts;\n\tkernel_siginfo_t info;\n\tint ret;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&these, uthese, sizeof(these)))\n\t\treturn -EFAULT;\n\n\tif (uts) {\n\t\tif (get_timespec64(&ts, uts))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigtimedwait(&these, &info, uts ? &ts : NULL);\n\n\tif (ret > 0 && uinfo) {\n\t\tif (copy_siginfo_to_user(uinfo, &info))\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(rt_sigtimedwait, const sigset_t __user *, uthese,\n\t\tsiginfo_t __user *, uinfo,\n\t\tconst struct __kernel_timespec __user *, uts,\n\t\tsize_t, sigsetsize)\n{\n\tsigset_t these;\n\tstruct timespec64 ts;\n\tkernel_siginfo_t info;\n\tint ret;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&these, uthese, sizeof(these)))\n\t\treturn -EFAULT;\n\n\tif (uts) {\n\t\tif (get_timespec64(&ts, uts))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigtimedwait(&these, &info, uts ? &ts : NULL);\n\n\tif (ret > 0 && uinfo) {\n\t\tif (copy_siginfo_to_user(uinfo, &info))\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rt_sigtimedwait_time32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3663-3692",
    "snippet": "SYSCALL_DEFINE4(rt_sigtimedwait_time32, const sigset_t __user *, uthese,\n\t\tsiginfo_t __user *, uinfo,\n\t\tconst struct old_timespec32 __user *, uts,\n\t\tsize_t, sigsetsize)\n{\n\tsigset_t these;\n\tstruct timespec64 ts;\n\tkernel_siginfo_t info;\n\tint ret;\n\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&these, uthese, sizeof(these)))\n\t\treturn -EFAULT;\n\n\tif (uts) {\n\t\tif (get_old_timespec32(&ts, uts))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigtimedwait(&these, &info, uts ? &ts : NULL);\n\n\tif (ret > 0 && uinfo) {\n\t\tif (copy_siginfo_to_user(uinfo, &info))\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(rt_sigtimedwait_time32, const sigset_t __user *, uthese,\n\t\tsiginfo_t __user *, uinfo,\n\t\tconst struct old_timespec32 __user *, uts,\n\t\tsize_t, sigsetsize)\n{\n\tsigset_t these;\n\tstruct timespec64 ts;\n\tkernel_siginfo_t info;\n\tint ret;\n\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&these, uthese, sizeof(these)))\n\t\treturn -EFAULT;\n\n\tif (uts) {\n\t\tif (get_old_timespec32(&ts, uts))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigtimedwait(&these, &info, uts ? &ts : NULL);\n\n\tif (ret > 0 && uinfo) {\n\t\tif (copy_siginfo_to_user(uinfo, &info))\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rt_sigtimedwait_time64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3696-3724",
    "snippet": "SYSCALL_DEFINE4(rt_sigtimedwait_time64, compat_sigset_t __user *, uthese,\n\t\tstruct compat_siginfo __user *, uinfo,\n\t\tstruct __kernel_timespec __user *, uts, compat_size_t, sigsetsize)\n{\n\tsigset_t s;\n\tstruct timespec64 t;\n\tkernel_siginfo_t info;\n\tlong ret;\n\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (get_compat_sigset(&s, uthese))\n\t\treturn -EFAULT;\n\n\tif (uts) {\n\t\tif (get_timespec64(&t, uts))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigtimedwait(&s, &info, uts ? &t : NULL);\n\n\tif (ret > 0 && uinfo) {\n\t\tif (copy_siginfo_to_user32(uinfo, &info))\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(rt_sigtimedwait_time64, compat_sigset_t __user *, uthese,\n\t\tstruct compat_siginfo __user *, uinfo,\n\t\tstruct __kernel_timespec __user *, uts, compat_size_t, sigsetsize)\n{\n\tsigset_t s;\n\tstruct timespec64 t;\n\tkernel_siginfo_t info;\n\tlong ret;\n\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (get_compat_sigset(&s, uthese))\n\t\treturn -EFAULT;\n\n\tif (uts) {\n\t\tif (get_timespec64(&t, uts))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigtimedwait(&s, &info, uts ? &t : NULL);\n\n\tif (ret > 0 && uinfo) {\n\t\tif (copy_siginfo_to_user32(uinfo, &info))\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rt_sigtimedwait_time32",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3727-3755",
    "snippet": "SYSCALL_DEFINE4(rt_sigtimedwait_time32, compat_sigset_t __user *, uthese,\n\t\tstruct compat_siginfo __user *, uinfo,\n\t\tstruct old_timespec32 __user *, uts, compat_size_t, sigsetsize)\n{\n\tsigset_t s;\n\tstruct timespec64 t;\n\tkernel_siginfo_t info;\n\tlong ret;\n\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (get_compat_sigset(&s, uthese))\n\t\treturn -EFAULT;\n\n\tif (uts) {\n\t\tif (get_old_timespec32(&t, uts))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigtimedwait(&s, &info, uts ? &t : NULL);\n\n\tif (ret > 0 && uinfo) {\n\t\tif (copy_siginfo_to_user32(uinfo, &info))\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(rt_sigtimedwait_time32, compat_sigset_t __user *, uthese,\n\t\tstruct compat_siginfo __user *, uinfo,\n\t\tstruct old_timespec32 __user *, uts, compat_size_t, sigsetsize)\n{\n\tsigset_t s;\n\tstruct timespec64 t;\n\tkernel_siginfo_t info;\n\tlong ret;\n\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (get_compat_sigset(&s, uthese))\n\t\treturn -EFAULT;\n\n\tif (uts) {\n\t\tif (get_old_timespec32(&t, uts))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigtimedwait(&s, &info, uts ? &t : NULL);\n\n\tif (ret > 0 && uinfo) {\n\t\tif (copy_siginfo_to_user32(uinfo, &info))\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kill",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3774-3781",
    "snippet": "SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)\n{\n\tstruct kernel_siginfo info;\n\n\tprepare_kill_siginfo(sig, &info);\n\n\treturn kill_something_info(sig, &info, pid);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(kill, pid_t, pid, int, sig)\n{\n\tstruct kernel_siginfo info;\n\n\tprepare_kill_siginfo(sig, &info);\n\n\treturn kill_something_info(sig, &info, pid);\n}"
  },
  {
    "function_name": "pidfd_send_signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3849-3899",
    "snippet": "SYSCALL_DEFINE4(pidfd_send_signal, int, pidfd, int, sig,\n\t\tsiginfo_t __user *, info, unsigned int, flags)\n{\n\tint ret;\n\tstruct fd f;\n\tstruct pid *pid;\n\tkernel_siginfo_t kinfo;\n\n\t/* Enforce flags be set to 0 until we add an extension. */\n\tif (flags)\n\t\treturn -EINVAL;\n\n\tf = fdget(pidfd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\t/* Is this a pidfd? */\n\tpid = pidfd_to_pid(f.file);\n\tif (IS_ERR(pid)) {\n\t\tret = PTR_ERR(pid);\n\t\tgoto err;\n\t}\n\n\tret = -EINVAL;\n\tif (!access_pidfd_pidns(pid))\n\t\tgoto err;\n\n\tif (info) {\n\t\tret = copy_siginfo_from_user_any(&kinfo, info);\n\t\tif (unlikely(ret))\n\t\t\tgoto err;\n\n\t\tret = -EINVAL;\n\t\tif (unlikely(sig != kinfo.si_signo))\n\t\t\tgoto err;\n\n\t\t/* Only allow sending arbitrary signals to yourself. */\n\t\tret = -EPERM;\n\t\tif ((task_pid(current) != pid) &&\n\t\t    (kinfo.si_code >= 0 || kinfo.si_code == SI_TKILL))\n\t\t\tgoto err;\n\t} else {\n\t\tprepare_kill_siginfo(sig, &kinfo);\n\t}\n\n\tret = kill_pid_info(sig, &kinfo, pid);\n\nerr:\n\tfdput(f);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(pidfd_send_signal, int, pidfd, int, sig,\n\t\tsiginfo_t __user *, info, unsigned int, flags)\n{\n\tint ret;\n\tstruct fd f;\n\tstruct pid *pid;\n\tkernel_siginfo_t kinfo;\n\n\t/* Enforce flags be set to 0 until we add an extension. */\n\tif (flags)\n\t\treturn -EINVAL;\n\n\tf = fdget(pidfd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\t/* Is this a pidfd? */\n\tpid = pidfd_to_pid(f.file);\n\tif (IS_ERR(pid)) {\n\t\tret = PTR_ERR(pid);\n\t\tgoto err;\n\t}\n\n\tret = -EINVAL;\n\tif (!access_pidfd_pidns(pid))\n\t\tgoto err;\n\n\tif (info) {\n\t\tret = copy_siginfo_from_user_any(&kinfo, info);\n\t\tif (unlikely(ret))\n\t\t\tgoto err;\n\n\t\tret = -EINVAL;\n\t\tif (unlikely(sig != kinfo.si_signo))\n\t\t\tgoto err;\n\n\t\t/* Only allow sending arbitrary signals to yourself. */\n\t\tret = -EPERM;\n\t\tif ((task_pid(current) != pid) &&\n\t\t    (kinfo.si_code >= 0 || kinfo.si_code == SI_TKILL))\n\t\t\tgoto err;\n\t} else {\n\t\tprepare_kill_siginfo(sig, &kinfo);\n\t}\n\n\tret = kill_pid_info(sig, &kinfo, pid);\n\nerr:\n\tfdput(f);\n\treturn ret;\n}"
  },
  {
    "function_name": "tgkill",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3955-3962",
    "snippet": "SYSCALL_DEFINE3(tgkill, pid_t, tgid, pid_t, pid, int, sig)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\treturn do_tkill(tgid, pid, sig);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(tgkill, pid_t, tgid, pid_t, pid, int, sig)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\treturn do_tkill(tgid, pid, sig);\n}"
  },
  {
    "function_name": "tkill",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3971-3978",
    "snippet": "SYSCALL_DEFINE2(tkill, pid_t, pid, int, sig)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0)\n\t\treturn -EINVAL;\n\n\treturn do_tkill(0, pid, sig);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(tkill, pid_t, pid, int, sig)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0)\n\t\treturn -EINVAL;\n\n\treturn do_tkill(0, pid, sig);\n}"
  },
  {
    "function_name": "rt_sigqueueinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "3999-4007",
    "snippet": "SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tkernel_siginfo_t info;\n\tint ret = __copy_siginfo_from_user(sig, &info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_sigqueueinfo(pid, sig, &info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tkernel_siginfo_t info;\n\tint ret = __copy_siginfo_from_user(sig, &info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_sigqueueinfo(pid, sig, &info);\n}"
  },
  {
    "function_name": "rt_sigqueueinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4010-4020",
    "snippet": "SYSCALL_DEFINE3(rt_sigqueueinfo,\n\t\t\tcompat_pid_t, pid,\n\t\t\tint, sig,\n\t\t\tstruct compat_siginfo __user *, uinfo)\n{\n\tkernel_siginfo_t info;\n\tint ret = __copy_siginfo_from_user32(sig, &info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_sigqueueinfo(pid, sig, &info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(rt_sigqueueinfo,\n\t\t\tcompat_pid_t, pid,\n\t\t\tint, sig,\n\t\t\tstruct compat_siginfo __user *, uinfo)\n{\n\tkernel_siginfo_t info;\n\tint ret = __copy_siginfo_from_user32(sig, &info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_sigqueueinfo(pid, sig, &info);\n}"
  },
  {
    "function_name": "rt_tgsigqueueinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4039-4047",
    "snippet": "SYSCALL_DEFINE4(rt_tgsigqueueinfo, pid_t, tgid, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tkernel_siginfo_t info;\n\tint ret = __copy_siginfo_from_user(sig, &info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_tgsigqueueinfo(tgid, pid, sig, &info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(rt_tgsigqueueinfo, pid_t, tgid, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tkernel_siginfo_t info;\n\tint ret = __copy_siginfo_from_user(sig, &info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_tgsigqueueinfo(tgid, pid, sig, &info);\n}"
  },
  {
    "function_name": "rt_tgsigqueueinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4050-4061",
    "snippet": "SYSCALL_DEFINE4(rt_tgsigqueueinfo,\n\t\t\tcompat_pid_t, tgid,\n\t\t\tcompat_pid_t, pid,\n\t\t\tint, sig,\n\t\t\tstruct compat_siginfo __user *, uinfo)\n{\n\tkernel_siginfo_t info;\n\tint ret = __copy_siginfo_from_user32(sig, &info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_tgsigqueueinfo(tgid, pid, sig, &info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(rt_tgsigqueueinfo,\n\t\t\tcompat_pid_t, tgid,\n\t\t\tcompat_pid_t, pid,\n\t\t\tint, sig,\n\t\t\tstruct compat_siginfo __user *, uinfo)\n{\n\tkernel_siginfo_t info;\n\tint ret = __copy_siginfo_from_user32(sig, &info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_tgsigqueueinfo(tgid, pid, sig, &info);\n}"
  },
  {
    "function_name": "sigaltstack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4230-4242",
    "snippet": "SYSCALL_DEFINE2(sigaltstack,const stack_t __user *,uss, stack_t __user *,uoss)\n{\n\tstack_t new, old;\n\tint err;\n\tif (uss && copy_from_user(&new, uss, sizeof(stack_t)))\n\t\treturn -EFAULT;\n\terr = do_sigaltstack(uss ? &new : NULL, uoss ? &old : NULL,\n\t\t\t      current_user_stack_pointer(),\n\t\t\t      MINSIGSTKSZ);\n\tif (!err && uoss && copy_to_user(uoss, &old, sizeof(stack_t)))\n\t\terr = -EFAULT;\n\treturn err;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(sigaltstack,const stack_t __user *,uss, stack_t __user *,uoss)\n{\n\tstack_t new, old;\n\tint err;\n\tif (uss && copy_from_user(&new, uss, sizeof(stack_t)))\n\t\treturn -EFAULT;\n\terr = do_sigaltstack(uss ? &new : NULL, uoss ? &old : NULL,\n\t\t\t      current_user_stack_pointer(),\n\t\t\t      MINSIGSTKSZ);\n\tif (!err && uoss && copy_to_user(uoss, &old, sizeof(stack_t)))\n\t\terr = -EFAULT;\n\treturn err;\n}"
  },
  {
    "function_name": "sigaltstack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4294-4299",
    "snippet": "SYSCALL_DEFINE2(sigaltstack,\n\t\t\tconst compat_stack_t __user *, uss_ptr,\n\t\t\tcompat_stack_t __user *, uoss_ptr)\n{\n\treturn do_compat_sigaltstack(uss_ptr, uoss_ptr);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(sigaltstack,\n\t\t\tconst compat_stack_t __user *, uss_ptr,\n\t\t\tcompat_stack_t __user *, uoss_ptr)\n{\n\treturn do_compat_sigaltstack(uss_ptr, uoss_ptr);\n}"
  },
  {
    "function_name": "sigpending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4326-4339",
    "snippet": "SYSCALL_DEFINE1(sigpending, old_sigset_t __user *, uset)\n{\n\tsigset_t set;\n\n\tif (sizeof(old_sigset_t) > sizeof(*uset))\n\t\treturn -EINVAL;\n\n\tdo_sigpending(&set);\n\n\tif (copy_to_user(uset, &set, sizeof(old_sigset_t)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE1(sigpending, old_sigset_t __user *, uset)\n{\n\tsigset_t set;\n\n\tif (sizeof(old_sigset_t) > sizeof(*uset))\n\t\treturn -EINVAL;\n\n\tdo_sigpending(&set);\n\n\tif (copy_to_user(uset, &set, sizeof(old_sigset_t)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sigpending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4342-4349",
    "snippet": "SYSCALL_DEFINE1(sigpending, compat_old_sigset_t __user *, set32)\n{\n\tsigset_t set;\n\n\tdo_sigpending(&set);\n\n\treturn put_user(set.sig[0], set32);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE1(sigpending, compat_old_sigset_t __user *, set32)\n{\n\tsigset_t set;\n\n\tdo_sigpending(&set);\n\n\treturn put_user(set.sig[0], set32);\n}"
  },
  {
    "function_name": "sigprocmask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4365-4402",
    "snippet": "SYSCALL_DEFINE3(sigprocmask, int, how, old_sigset_t __user *, nset,\n\t\told_sigset_t __user *, oset)\n{\n\told_sigset_t old_set, new_set;\n\tsigset_t new_blocked;\n\n\told_set = current->blocked.sig[0];\n\n\tif (nset) {\n\t\tif (copy_from_user(&new_set, nset, sizeof(*nset)))\n\t\t\treturn -EFAULT;\n\n\t\tnew_blocked = current->blocked;\n\n\t\tswitch (how) {\n\t\tcase SIG_BLOCK:\n\t\t\tsigaddsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_UNBLOCK:\n\t\t\tsigdelsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_SETMASK:\n\t\t\tnew_blocked.sig[0] = new_set;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tset_current_blocked(&new_blocked);\n\t}\n\n\tif (oset) {\n\t\tif (copy_to_user(oset, &old_set, sizeof(*oset)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(sigprocmask, int, how, old_sigset_t __user *, nset,\n\t\told_sigset_t __user *, oset)\n{\n\told_sigset_t old_set, new_set;\n\tsigset_t new_blocked;\n\n\told_set = current->blocked.sig[0];\n\n\tif (nset) {\n\t\tif (copy_from_user(&new_set, nset, sizeof(*nset)))\n\t\t\treturn -EFAULT;\n\n\t\tnew_blocked = current->blocked;\n\n\t\tswitch (how) {\n\t\tcase SIG_BLOCK:\n\t\t\tsigaddsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_UNBLOCK:\n\t\t\tsigdelsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_SETMASK:\n\t\t\tnew_blocked.sig[0] = new_set;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tset_current_blocked(&new_blocked);\n\t}\n\n\tif (oset) {\n\t\tif (copy_to_user(oset, &old_set, sizeof(*oset)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rt_sigaction",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4413-4436",
    "snippet": "SYSCALL_DEFINE4(rt_sigaction, int, sig,\n\t\tconst struct sigaction __user *, act,\n\t\tstruct sigaction __user *, oact,\n\t\tsize_t, sigsetsize)\n{\n\tstruct k_sigaction new_sa, old_sa;\n\tint ret;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (act && copy_from_user(&new_sa.sa, act, sizeof(new_sa.sa)))\n\t\treturn -EFAULT;\n\n\tret = do_sigaction(sig, act ? &new_sa : NULL, oact ? &old_sa : NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (oact && copy_to_user(oact, &old_sa.sa, sizeof(old_sa.sa)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(rt_sigaction, int, sig,\n\t\tconst struct sigaction __user *, act,\n\t\tstruct sigaction __user *, oact,\n\t\tsize_t, sigsetsize)\n{\n\tstruct k_sigaction new_sa, old_sa;\n\tint ret;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (act && copy_from_user(&new_sa.sa, act, sizeof(new_sa.sa)))\n\t\treturn -EFAULT;\n\n\tret = do_sigaction(sig, act ? &new_sa : NULL, oact ? &old_sa : NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (oact && copy_to_user(oact, &old_sa.sa, sizeof(old_sa.sa)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rt_sigaction",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4438-4480",
    "snippet": "SYSCALL_DEFINE4(rt_sigaction, int, sig,\n\t\tconst struct compat_sigaction __user *, act,\n\t\tstruct compat_sigaction __user *, oact,\n\t\tcompat_size_t, sigsetsize)\n{\n\tstruct k_sigaction new_ka, old_ka;\n#ifdef __ARCH_HAS_SA_RESTORER\n\tcompat_uptr_t restorer;\n#endif\n\tint ret;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\treturn -EINVAL;\n\n\tif (act) {\n\t\tcompat_uptr_t handler;\n\t\tret = get_user(handler, &act->sa_handler);\n\t\tnew_ka.sa.sa_handler = compat_ptr(handler);\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tret |= get_user(restorer, &act->sa_restorer);\n\t\tnew_ka.sa.sa_restorer = compat_ptr(restorer);\n#endif\n\t\tret |= get_compat_sigset(&new_ka.sa.sa_mask, &act->sa_mask);\n\t\tret |= get_user(new_ka.sa.sa_flags, &act->sa_flags);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\tif (!ret && oact) {\n\t\tret = put_user(ptr_to_compat(old_ka.sa.sa_handler), \n\t\t\t       &oact->sa_handler);\n\t\tret |= put_compat_sigset(&oact->sa_mask, &old_ka.sa.sa_mask,\n\t\t\t\t\t sizeof(oact->sa_mask));\n\t\tret |= put_user(old_ka.sa.sa_flags, &oact->sa_flags);\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tret |= put_user(ptr_to_compat(old_ka.sa.sa_restorer),\n\t\t\t\t&oact->sa_restorer);\n#endif\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(rt_sigaction, int, sig,\n\t\tconst struct compat_sigaction __user *, act,\n\t\tstruct compat_sigaction __user *, oact,\n\t\tcompat_size_t, sigsetsize)\n{\n\tstruct k_sigaction new_ka, old_ka;\n#ifdef __ARCH_HAS_SA_RESTORER\n\tcompat_uptr_t restorer;\n#endif\n\tint ret;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\treturn -EINVAL;\n\n\tif (act) {\n\t\tcompat_uptr_t handler;\n\t\tret = get_user(handler, &act->sa_handler);\n\t\tnew_ka.sa.sa_handler = compat_ptr(handler);\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tret |= get_user(restorer, &act->sa_restorer);\n\t\tnew_ka.sa.sa_restorer = compat_ptr(restorer);\n#endif\n\t\tret |= get_compat_sigset(&new_ka.sa.sa_mask, &act->sa_mask);\n\t\tret |= get_user(new_ka.sa.sa_flags, &act->sa_flags);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\tif (!ret && oact) {\n\t\tret = put_user(ptr_to_compat(old_ka.sa.sa_handler), \n\t\t\t       &oact->sa_handler);\n\t\tret |= put_compat_sigset(&oact->sa_mask, &old_ka.sa.sa_mask,\n\t\t\t\t\t sizeof(oact->sa_mask));\n\t\tret |= put_user(old_ka.sa.sa_flags, &oact->sa_flags);\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tret |= put_user(ptr_to_compat(old_ka.sa.sa_restorer),\n\t\t\t\t&oact->sa_restorer);\n#endif\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "sigaction",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4485-4518",
    "snippet": "SYSCALL_DEFINE3(sigaction, int, sig,\n\t\tconst struct old_sigaction __user *, act,\n\t        struct old_sigaction __user *, oact)\n{\n\tstruct k_sigaction new_ka, old_ka;\n\tint ret;\n\n\tif (act) {\n\t\told_sigset_t mask;\n\t\tif (!access_ok(act, sizeof(*act)) ||\n\t\t    __get_user(new_ka.sa.sa_handler, &act->sa_handler) ||\n\t\t    __get_user(new_ka.sa.sa_restorer, &act->sa_restorer) ||\n\t\t    __get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\n\t\t    __get_user(mask, &act->sa_mask))\n\t\t\treturn -EFAULT;\n#ifdef __ARCH_HAS_KA_RESTORER\n\t\tnew_ka.ka_restorer = NULL;\n#endif\n\t\tsiginitset(&new_ka.sa.sa_mask, mask);\n\t}\n\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\n\tif (!ret && oact) {\n\t\tif (!access_ok(oact, sizeof(*oact)) ||\n\t\t    __put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||\n\t\t    __put_user(old_ka.sa.sa_restorer, &oact->sa_restorer) ||\n\t\t    __put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\n\t\t    __put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(sigaction, int, sig,\n\t\tconst struct old_sigaction __user *, act,\n\t        struct old_sigaction __user *, oact)\n{\n\tstruct k_sigaction new_ka, old_ka;\n\tint ret;\n\n\tif (act) {\n\t\told_sigset_t mask;\n\t\tif (!access_ok(act, sizeof(*act)) ||\n\t\t    __get_user(new_ka.sa.sa_handler, &act->sa_handler) ||\n\t\t    __get_user(new_ka.sa.sa_restorer, &act->sa_restorer) ||\n\t\t    __get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\n\t\t    __get_user(mask, &act->sa_mask))\n\t\t\treturn -EFAULT;\n#ifdef __ARCH_HAS_KA_RESTORER\n\t\tnew_ka.ka_restorer = NULL;\n#endif\n\t\tsiginitset(&new_ka.sa.sa_mask, mask);\n\t}\n\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\n\tif (!ret && oact) {\n\t\tif (!access_ok(oact, sizeof(*oact)) ||\n\t\t    __put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||\n\t\t    __put_user(old_ka.sa.sa_restorer, &oact->sa_restorer) ||\n\t\t    __put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\n\t\t    __put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "sigaction",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4521-4559",
    "snippet": "SYSCALL_DEFINE3(sigaction, int, sig,\n\t\tconst struct compat_old_sigaction __user *, act,\n\t        struct compat_old_sigaction __user *, oact)\n{\n\tstruct k_sigaction new_ka, old_ka;\n\tint ret;\n\tcompat_old_sigset_t mask;\n\tcompat_uptr_t handler, restorer;\n\n\tif (act) {\n\t\tif (!access_ok(act, sizeof(*act)) ||\n\t\t    __get_user(handler, &act->sa_handler) ||\n\t\t    __get_user(restorer, &act->sa_restorer) ||\n\t\t    __get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\n\t\t    __get_user(mask, &act->sa_mask))\n\t\t\treturn -EFAULT;\n\n#ifdef __ARCH_HAS_KA_RESTORER\n\t\tnew_ka.ka_restorer = NULL;\n#endif\n\t\tnew_ka.sa.sa_handler = compat_ptr(handler);\n\t\tnew_ka.sa.sa_restorer = compat_ptr(restorer);\n\t\tsiginitset(&new_ka.sa.sa_mask, mask);\n\t}\n\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\n\tif (!ret && oact) {\n\t\tif (!access_ok(oact, sizeof(*oact)) ||\n\t\t    __put_user(ptr_to_compat(old_ka.sa.sa_handler),\n\t\t\t       &oact->sa_handler) ||\n\t\t    __put_user(ptr_to_compat(old_ka.sa.sa_restorer),\n\t\t\t       &oact->sa_restorer) ||\n\t\t    __put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\n\t\t    __put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\n\t\t\treturn -EFAULT;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(sigaction, int, sig,\n\t\tconst struct compat_old_sigaction __user *, act,\n\t        struct compat_old_sigaction __user *, oact)\n{\n\tstruct k_sigaction new_ka, old_ka;\n\tint ret;\n\tcompat_old_sigset_t mask;\n\tcompat_uptr_t handler, restorer;\n\n\tif (act) {\n\t\tif (!access_ok(act, sizeof(*act)) ||\n\t\t    __get_user(handler, &act->sa_handler) ||\n\t\t    __get_user(restorer, &act->sa_restorer) ||\n\t\t    __get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\n\t\t    __get_user(mask, &act->sa_mask))\n\t\t\treturn -EFAULT;\n\n#ifdef __ARCH_HAS_KA_RESTORER\n\t\tnew_ka.ka_restorer = NULL;\n#endif\n\t\tnew_ka.sa.sa_handler = compat_ptr(handler);\n\t\tnew_ka.sa.sa_restorer = compat_ptr(restorer);\n\t\tsiginitset(&new_ka.sa.sa_mask, mask);\n\t}\n\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\n\tif (!ret && oact) {\n\t\tif (!access_ok(oact, sizeof(*oact)) ||\n\t\t    __put_user(ptr_to_compat(old_ka.sa.sa_handler),\n\t\t\t       &oact->sa_handler) ||\n\t\t    __put_user(ptr_to_compat(old_ka.sa.sa_restorer),\n\t\t\t       &oact->sa_restorer) ||\n\t\t    __put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\n\t\t    __put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\n\t\t\treturn -EFAULT;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "sgetmask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4567-4571",
    "snippet": "SYSCALL_DEFINE0(sgetmask)\n{\n\t/* SMP safe */\n\treturn current->blocked.sig[0];\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE0(sgetmask)\n{\n\t/* SMP safe */\n\treturn current->blocked.sig[0];\n}"
  },
  {
    "function_name": "ssetmask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4573-4582",
    "snippet": "SYSCALL_DEFINE1(ssetmask, int, newmask)\n{\n\tint old = current->blocked.sig[0];\n\tsigset_t newset;\n\n\tsiginitset(&newset, newmask);\n\tset_current_blocked(&newset);\n\n\treturn old;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE1(ssetmask, int, newmask)\n{\n\tint old = current->blocked.sig[0];\n\tsigset_t newset;\n\n\tsiginitset(&newset, newmask);\n\tset_current_blocked(&newset);\n\n\treturn old;\n}"
  },
  {
    "function_name": "signal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4589-4601",
    "snippet": "SYSCALL_DEFINE2(signal, int, sig, __sighandler_t, handler)\n{\n\tstruct k_sigaction new_sa, old_sa;\n\tint ret;\n\n\tnew_sa.sa.sa_handler = handler;\n\tnew_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK;\n\tsigemptyset(&new_sa.sa.sa_mask);\n\n\tret = do_sigaction(sig, &new_sa, &old_sa);\n\n\treturn ret ? ret : (unsigned long)old_sa.sa.sa_handler;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(signal, int, sig, __sighandler_t, handler)\n{\n\tstruct k_sigaction new_sa, old_sa;\n\tint ret;\n\n\tnew_sa.sa.sa_handler = handler;\n\tnew_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK;\n\tsigemptyset(&new_sa.sa.sa_mask);\n\n\tret = do_sigaction(sig, &new_sa, &old_sa);\n\n\treturn ret ? ret : (unsigned long)old_sa.sa.sa_handler;\n}"
  },
  {
    "function_name": "pause",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4606-4613",
    "snippet": "SYSCALL_DEFINE0(pause)\n{\n\twhile (!signal_pending(current)) {\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule();\n\t}\n\treturn -ERESTARTNOHAND;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE0(pause)\n{\n\twhile (!signal_pending(current)) {\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule();\n\t}\n\treturn -ERESTARTNOHAND;\n}"
  },
  {
    "function_name": "rt_sigsuspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4636-4647",
    "snippet": "SYSCALL_DEFINE2(rt_sigsuspend, sigset_t __user *, unewset, size_t, sigsetsize)\n{\n\tsigset_t newset;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&newset, unewset, sizeof(newset)))\n\t\treturn -EFAULT;\n\treturn sigsuspend(&newset);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(rt_sigsuspend, sigset_t __user *, unewset, size_t, sigsetsize)\n{\n\tsigset_t newset;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&newset, unewset, sizeof(newset)))\n\t\treturn -EFAULT;\n\treturn sigsuspend(&newset);\n}"
  },
  {
    "function_name": "rt_sigsuspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4650-4661",
    "snippet": "SYSCALL_DEFINE2(rt_sigsuspend, compat_sigset_t __user *, unewset, compat_size_t, sigsetsize)\n{\n\tsigset_t newset;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (get_compat_sigset(&newset, unewset))\n\t\treturn -EFAULT;\n\treturn sigsuspend(&newset);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(rt_sigsuspend, compat_sigset_t __user *, unewset, compat_size_t, sigsetsize)\n{\n\tsigset_t newset;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (get_compat_sigset(&newset, unewset))\n\t\treturn -EFAULT;\n\treturn sigsuspend(&newset);\n}"
  },
  {
    "function_name": "sigsuspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4665-4670",
    "snippet": "SYSCALL_DEFINE1(sigsuspend, old_sigset_t, mask)\n{\n\tsigset_t blocked;\n\tsiginitset(&blocked, mask);\n\treturn sigsuspend(&blocked);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE1(sigsuspend, old_sigset_t, mask)\n{\n\tsigset_t blocked;\n\tsiginitset(&blocked, mask);\n\treturn sigsuspend(&blocked);\n}"
  },
  {
    "function_name": "sigsuspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
    "lines": "4673-4678",
    "snippet": "SYSCALL_DEFINE3(sigsuspend, int, unused1, int, unused2, old_sigset_t, mask)\n{\n\tsigset_t blocked;\n\tsiginitset(&blocked, mask);\n\treturn sigsuspend(&blocked);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include <asm/syscall.h>\t/* for syscall_get_* */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/audit.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/task_work.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(sigsuspend, int, unused1, int, unused2, old_sigset_t, mask)\n{\n\tsigset_t blocked;\n\tsiginitset(&blocked, mask);\n\treturn sigsuspend(&blocked);\n}"
  }
]